1
00:00:00,000 --> 00:00:03,567
在接下来的三部分里，我们稍微改变一下讨论内容

2
00:00:00,000 --> 00:00:03,567
In the next three segments we will change
gears a little bit and talk about the

3
00:00:03,567 --> 00:00:07,224
来讨论一下PRG的定义。这个定义真的是一种很好的理解PRG的方式

4
00:00:03,567 --> 00:00:07,224
definition of a PRG. This definition is a
really good way to think of a PRG. And we

5
00:00:07,224 --> 00:00:10,784
will see many applications for this
definition. So consider a PRG with

6
00:00:07,224 --> 00:00:10,784
并且我们能看到这个定义的很多应用。那么令PRG有

7
00:00:10,784 --> 00:00:15,943
keyspace K that ouputs N bit strings. Our
goal is to define, what does it mean for

8
00:00:10,784 --> 00:00:15,943
秘钥空间K，输出N比特序列。我们的目标是定义

9
00:00:15,943 --> 00:00:20,592
the output of the generator to be
indistinguishable from random? In other

10
00:00:15,943 --> 00:00:20,592
无法与随机序列区分生成器的输出是什么？

11
00:00:20,592 --> 00:00:25,687
words, we're gonna define a distribution
that basically is defined by choosing a

12
00:00:20,592 --> 00:00:25,687
换句话说，我们要定义一个分布

13
00:00:25,687 --> 00:00:30,781
random key in the keyspace. Remember that
a arrow with R above it means choosing

14
00:00:25,687 --> 00:00:30,781
从秘钥空间里随机选取秘钥。记住上面那个带R的箭头意味着

15
00:00:30,781 --> 00:00:35,813
uniformly from the set script K. And then
we output, basically, the output of the

16
00:00:30,781 --> 00:00:35,813
从集合K中随机地选取，然后我们用这个生成器的输出。

17
00:00:35,813 --> 00:00:40,710
generator. And what we'd like to say. Is
that this distribution. This distribution

18
00:00:35,813 --> 00:00:40,710
并且我们所说的就是这个分布

19
00:00:40,710 --> 00:00:44,757
of pseudo random strings is
indistinguishable from a truly uniform

20
00:00:40,710 --> 00:00:44,757
这个伪随机序列分布和真正的均匀分布没有区别

21
00:00:44,757 --> 00:00:49,927
换句话说，如果我们仅选择一个真正均匀的0，1

22
00:00:44,757 --> 00:00:49,927
distribution. In other words, if we just
choose a truly uniform string in 01 to the

23
00:00:49,927 --> 00:00:55,096
N位序列并且输出这个序列，我们说这两个分布

24
00:00:49,927 --> 00:00:55,096
N and simply output this string, we'd like
to say that these two distributions are

25
00:00:55,096 --> 00:01:00,139
没有区别。如果大家现在想想，这真的

26
00:00:55,096 --> 00:01:00,139
indistinguishable from one another. Now if
you think about it, this sounds really

27
00:01:00,139 --> 00:01:05,246
很令人吃惊，因为如果我们画一个圈表示所有n位01序列，

28
00:01:00,139 --> 00:01:05,246
surprising because if we draw a circle
here of all possible strings in 01 to the

29
00:01:05,246 --> 00:01:10,541
那么均匀分布能够等概输出这些序列

30
00:01:05,246 --> 00:01:10,541
N, then the uniform distribution basically
can ouput any of these strings with equal

31
00:01:10,541 --> 00:01:15,161
这就是均匀分布的定义。然而

32
00:01:10,541 --> 00:01:15,161
probability. That's the definition of the
uniform distribution. However a

33
00:01:15,161 --> 00:01:20,661
这个生成器G生成的伪随机分布，由于种子空间

34
00:01:15,161 --> 00:01:20,661
pseudo-random distribution generated by
this generator G. Because the seed space

35
00:01:20,661 --> 00:01:25,673
很小，可能输出的集合是非常小的

36
00:01:20,661 --> 00:01:25,673
is so small, the set of possible outputs
is really, really small, it's tiny inside

37
00:01:25,673 --> 00:01:30,623
是N位01序列集合中很小的子集。这就是这个生成器能输出的全部。然而

38
00:01:25,673 --> 00:01:30,623
of, 01 to the N. And this is really all
that the generator can output. And yet,

39
00:01:30,623 --> 00:01:35,698
我们讨论，敌手看到生成器的输出的

40
00:01:30,623 --> 00:01:35,698
what we're arguing is that an adversary
who looks at the output of the generator

41
00:01:35,698 --> 00:01:40,836
小集合的元素，无法区分它和均匀分布输出的

42
00:01:35,698 --> 00:01:40,836
in this tiny set can't distinguish it from
the output of the uniform distribution

43
00:01:40,836 --> 00:01:45,703
整个集合的元素，我想这就是我们真正想要的性质

44
00:01:40,836 --> 00:01:45,703
over the entire set. I think that's the
property that we're actually shooting for.

45
00:01:45,703 --> 00:01:50,026
因此要理解怎么定义这个无法和随机区分的概念

46
00:01:45,703 --> 00:01:50,026
So to understand how to define this
concept of indistinguishability from

47
00:01:50,026 --> 00:01:54,350
我们需要统计测试的概念。因此让我来定义一下

48
00:01:50,026 --> 00:01:54,350
random, we need the concept of a
statistical test. So, let me define what a

49
00:01:54,350 --> 00:01:59,030
N位01序列的统计测试是什么。我会用字母A来表示这些统计测试

50
00:01:54,350 --> 00:01:59,030
statistical test on 01 to the N is. I'm
gonna define these statistical tests by

51
00:01:59,030 --> 00:02:03,924
统计测试是一个算法，用

52
00:01:59,030 --> 00:02:03,924
the letter A. And the statistical test is
basically an algorithm that takes its

53
00:02:03,924 --> 00:02:08,486
N比特序列的输入，输出0或1。现在我告诉大家

54
00:02:03,924 --> 00:02:08,486
inputs and N bit string, and simply
outputs zero or one. Now I'll tell you

55
00:02:08,486 --> 00:02:13,110
0，我们认为它是统计测试说

56
00:02:08,486 --> 00:02:13,110
that zero, we're gonna think of it as
though the statistical test said, the

57
00:02:13,110 --> 00:02:18,150
你的输入不是随机的。1，我们把它想成统计测试说

58
00:02:13,110 --> 00:02:18,150
input you gave me is not random. And one,
we're going to think of it as saying that

59
00:02:18,150 --> 00:02:23,196
你的输入是随机的。好，统计测试所做的是

60
00:02:18,150 --> 00:02:23,196
the imput you gave me actually is random.
Okay, so all this statistical test does is

61
00:02:23,196 --> 00:02:27,939
用给它的输入n比特序列x

62
00:02:23,196 --> 00:02:27,939
it basically takes the input x that was
given to it, the n bit string that was

63
00:02:27,939 --> 00:02:32,803
来判断它看起来是不是随机的。让我们

64
00:02:27,939 --> 00:02:32,803
given to it, and decides whether it looks
random or it doesn't look random. Let's

65
00:02:32,803 --> 00:02:37,849
看几个例子，第一个例子会用一个事实

66
00:02:32,803 --> 00:02:37,849
look at a couple of examples. So the first
example basically will use the fact that

67
00:02:37,849 --> 00:02:42,835
一个随机序列中，0的个数大致等于1的个数

68
00:02:37,849 --> 00:02:42,835
for a random string, the number of zeros
is roughly equal to the number of ones in

69
00:02:42,835 --> 00:02:47,248
换句话说，统计测试输出1。当

70
00:02:42,835 --> 00:02:47,248
that string. In other words, the
statistical test is going to say one. If

71
00:02:47,248 --> 00:02:54,514
且仅当序列X中0的个数减去1的个数

72
00:02:47,248 --> 00:02:54,514
and only if basically the number of zeros
in the given string X minus the number of

73
00:02:54,514 --> 00:02:59,837
个数不会差太多，换句话说

74
00:02:54,514 --> 00:02:59,837
1's in the given string X. These numbers
are not too far apart. In other words, the

75
00:02:59,837 --> 00:03:05,225
0的个数和1的个数的差别

76
00:02:59,837 --> 00:03:05,225
difference between the number of 0's and
the number of 1's. Let's just say is less

77
00:03:05,225 --> 00:03:10,614
是小于10倍根号n的。好，如果差别小于10倍的根号n

78
00:03:05,225 --> 00:03:10,614
than ten times square root of n. Okay If
the difference is less than ten times, the

79
00:03:10,614 --> 00:03:15,082
统计测试认为X序列看起来是随机的。如果

80
00:03:10,614 --> 00:03:15,082
statistical test will say hey the string X looks random. If the

81
00:03:15,082 --> 00:03:20,602
差别碰巧比10倍的根号n大得多

82
00:03:15,082 --> 00:03:20,602
difference happens to be much bigger than
ten times square root of n, that starts to

83
00:03:20,602 --> 00:03:25,991
那就看起来很可疑，测试认为你给的序列不是

84
00:03:20,602 --> 00:03:25,991
look suspicious and the test,
hey the string you gave me does not

85
00:03:25,991 --> 00:03:31,403
随机的，这是一个统计测试。让我们看另一个相似的例子

86
00:03:25,991 --> 00:03:31,403
look random. A statistical test. Let's
look at another similar example. We'll say

87
00:03:31,403 --> 00:03:36,785
在这里，统计测试说1，当且仅当

88
00:03:31,403 --> 00:03:36,785
here, the statistical test will say one.
If and only if say the number of times

89
00:03:36,785 --> 00:03:41,838
X序列中出现连续两个0的次数，但是我们想一想

90
00:03:36,785 --> 00:03:41,838
that we have two consecutive zeros. Inside
of X. But let's think about this for a

91
00:03:41,838 --> 00:03:46,766
数一数，n比特序列中，数一下

92
00:03:41,838 --> 00:03:46,766
second. This basically again counts. In
this string of, n bits. It counts a number

93
00:03:46,766 --> 00:03:51,734
00出现的次数。连续的两个0

94
00:03:46,766 --> 00:03:51,734
of times that we see the pattern zero,
zero. Two consecutive zeros. Well for a

95
00:03:51,734 --> 00:03:56,804
对一个随机序列，我们期望看到00的概率是四分之一

96
00:03:51,734 --> 00:03:56,804
random string. We will expect to see 0,0
as probability one fourth. And there for

97
00:03:56,804 --> 00:04:03,535
对于一个随机序列，我们期望四分之N个00。是的，四分之N的

98
00:03:56,804 --> 00:04:03,535
in a random string. We'll expect about N
over four 0,0's. Yeah, N over four blocks

99
00:04:03,535 --> 00:04:08,133
00。那么，统计测试会做的是，它会说，如果

100
00:04:03,535 --> 00:04:08,133
a 0,0. And so, what the statistical test
will do is it will say, well, if the

101
00:04:08,133 --> 00:04:12,604
00的个数近似等于四分之N，换句话说

102
00:04:08,133 --> 00:04:12,604
number of zero zeros is roughly N over
four. In other words, the difference

103
00:04:12,604 --> 00:04:17,254
00的个数和四分之N的差别小于10倍的根号n

104
00:04:12,604 --> 00:04:17,254
between the number and N over four,
is, say, less than ten square root of n,

105
00:04:17,254 --> 00:04:22,005
我们就说X看起来是随机的。如果差别比四分之N大得多

106
00:04:17,254 --> 00:04:22,005
then we will say that X looks random. And
if the gap is much bigger than N over

107
00:04:22,005 --> 00:04:26,309
我们就说这个序列不是随机的。然后

108
00:04:22,005 --> 00:04:26,309
four, we'll say, hey, this string doesn't
really look random. And then the

109
00:04:26,309 --> 00:04:31,097
统计测试就会输出0，对吧？这就是两个统计测试的例子

110
00:04:26,309 --> 00:04:31,097
statistical test will output zero, okay?
So here are two examples of statistical

111
00:04:31,097 --> 00:04:35,703
对于随机序列，测试会以极大概率输出1

112
00:04:31,097 --> 00:04:35,703
tests that basically, for random strings,
they will output one with very high

113
00:04:35,703 --> 00:04:40,067
但是对于一些序列，你懂得，那些不随机的序列，比如

114
00:04:35,703 --> 00:04:40,067
probability. But for strings that, you
know, don't look random, for example,

115
00:04:40,067 --> 00:04:44,856
全0序列。对于全0序列，这些测试

116
00:04:40,067 --> 00:04:44,856
think of the all zero string. So the all
zero string, neither one of these tests

117
00:04:44,856 --> 00:04:49,986
没有一个会输出1。并且事实上，全0序列看起来也不随机

118
00:04:44,856 --> 00:04:49,986
will output, one. And in fact, the all
zero string does not look random. Let's

119
00:04:49,986 --> 00:04:55,098
让我们再看一个统计测试的例子

120
00:04:49,986 --> 00:04:55,098
look at one more example of the
statistical test just to kinda show you

121
00:04:55,098 --> 00:05:00,993
来给大家展示统计测试能想做什么就做什么

122
00:04:55,098 --> 00:05:00,993
the, basically statistical test can pretty
much do whatever they want. So here's the

123
00:05:00,993 --> 00:05:06,745
这是第三个例子。我们说统计测试输出1，当且仅当

124
00:05:00,993 --> 00:05:06,745
third example. Let's say that statistical
test output one if an only if I say the

125
00:05:06,745 --> 00:05:12,497
最大的块，我们称之为x序列中0的最大游程

126
00:05:06,745 --> 00:05:12,497
biggest blocks what we'll call this the
Maximum Run of zero inside of the string

127
00:05:12,497 --> 00:05:17,950
是x序列中最长的0序列

128
00:05:12,497 --> 00:05:17,950
x, this is basically the longest sequence
of zero inside of the string x. In a

129
00:05:17,950 --> 00:05:23,336
在随机序列中，你希望最长0序列近似等于

130
00:05:17,950 --> 00:05:23,336
random string you expect the longest
sequence of zeros to be roughly of length

131
00:05:23,336 --> 00:05:28,449
log N（以2为底）。我们说如果最长0游程碰巧小于

132
00:05:23,336 --> 00:05:28,449
log N. So we'll say if the longest
sequence of zero happens to be less than

133
00:05:28,449 --> 00:05:32,814
10倍log N，测试就认为X序列是随机的。但是如果

134
00:05:28,449 --> 00:05:32,814
ten times log N Then this test will say
that X was random. But if, all of a

135
00:05:32,814 --> 00:05:37,160
突然我们看到一个0的游程比10倍log N大得多

136
00:05:32,814 --> 00:05:37,160
sudden, we see a run of zeros that, say,
is much bigger than ten log N, then the

137
00:05:37,160 --> 00:05:41,733
测试就认为X序列是不随机的，对吧？这是另一个

138
00:05:37,160 --> 00:05:41,733
statistical test will say, the string is
not random, okay? So this is another crazy

139
00:05:41,733 --> 00:05:46,192
测试做的疯狂例子。顺便说一下，大家注意到，如果你

140
00:05:41,733 --> 00:05:46,192
thing that the statistical test will do.
By the way, you notice that if you give

141
00:05:46,192 --> 00:05:50,444
给定这个测试一个全1序列，就是11111。测试也会

142
00:05:46,192 --> 00:05:50,444
this test, the all one string. So one,
one, one, one, one. This test will also

143
00:05:50,444 --> 00:05:55,370
输出1。换句话说测试认为全1序列是随机的

144
00:05:50,444 --> 00:05:55,370
output one. In other words this test will
think that the all one string is random.

145
00:05:55,370 --> 00:05:59,735
即便它不是，即使全1序列不是随机的

146
00:05:55,370 --> 00:05:59,735
Even though it's not. Yeah, even though
one string is not particularly random.

147
00:05:59,735 --> 00:06:04,068
好，统计测试不一定是对的。它们只是做它们想做的事

148
00:05:59,735 --> 00:06:04,068
Okay, so statistical tests don't have to
get things right. They can do whatever

149
00:06:04,068 --> 00:06:08,149
它们能测试，能判断输出是是不是随机的。你知道

150
00:06:04,068 --> 00:06:08,149
they like. They can test, they can decide
to output random or not. You know, zero or

151
00:06:08,149 --> 00:06:11,776
不管是0或1，类似的，这有很多其他统计测试

152
00:06:08,149 --> 00:06:11,776
one, however they like. And similarly,
there are many, many, many, many other

153
00:06:11,776 --> 00:06:15,857
一个人能做数百个统计测试来

154
00:06:11,776 --> 00:06:15,857
statistical tests. There are literally
hundreds of statistical tests that one can

155
00:06:15,857 --> 00:06:19,737
我能告诉大家在以前，你定义

156
00:06:15,857 --> 00:06:19,737
think of. And I can tell you that in the
old days, basically, the way you would

157
00:06:19,737 --> 00:06:23,663
某物看起来随机的方法，你会说有跟多统计测试

158
00:06:19,737 --> 00:06:23,663
define. That something looks random. As
you would say, hey, here's a battery of

159
00:06:23,663 --> 00:06:27,754
statistical tests. And all of them said
that this string looks random. Therefore,

160
00:06:23,663 --> 00:06:27,754
所有测试说这个序列像是随机的。因此

161
00:06:27,754 --> 00:06:31,896
we say that this generator that generated
the string is good generator. In other

162
00:06:27,754 --> 00:06:31,896
我们认为生成这个序列的生成器很不错

163
00:06:31,896 --> 00:06:36,091
words, this definition, then, uses a fixed
set of statistical tests, is actually not

164
00:06:31,896 --> 00:06:36,091
换句话说，这个用很多统计测试的定义

165
00:06:36,091 --> 00:06:40,364
a good definition for security, but more
generally, for crytpo. But before we talk

166
00:06:36,091 --> 00:06:40,364
对更一般的密码学来说，实际上在安全方面不是一个好定义。但是在我们谈论

167
00:06:40,364 --> 00:06:45,290
about actually defining security, the next
thing we talk about is how do we evaluate

168
00:06:40,364 --> 00:06:45,290
安全定义之前，我们还需要讨论我们如何评估

169
00:06:45,290 --> 00:06:50,040
whether a statistical test is good or not?
So to do that, we define the concept of

170
00:06:45,290 --> 00:06:50,040
一个统计测试是好是坏？为此，我们定义

171
00:06:50,040 --> 00:06:54,321
advantage. And so let me define the
advantage. So here we have a generator

172
00:06:50,040 --> 00:06:54,321
优势的概念。那么我来定义优势的意思。我们有一个

173
00:06:54,321 --> 00:06:59,188
that outputs N bit strings. And we have a
statistical tests on N bit strings. And we

174
00:06:54,321 --> 00:06:59,188
输出N比特序列的生成器，我们对这N比特序列做个统计测试。

175
00:06:59,188 --> 00:07:04,578
define the advantage of this generator,
as denoted by advantage sub PRG,

176
00:06:59,188 --> 00:07:04,578
然后我们定义这个生成器的优势，记为优势子PRG

177
00:07:04,578 --> 00:07:10,313
the advantage of the statistical test A
relative to the generator g. I'll define

178
00:07:04,578 --> 00:07:10,313
统计测试A相对于生成器g的优势

179
00:07:10,313 --> 00:07:16,121
it as follows, basically the difference
between two quantities. The first quantity

180
00:07:10,313 --> 00:07:16,121
我会像下面这样定义它，定义为两个量之间的差距。第一个量

181
00:07:16,121 --> 00:07:21,679
is basically, we ask how likely is this
statistical test to output one. When we

182
00:07:16,121 --> 00:07:21,679
是统计测试输出1的概率。

183
00:07:21,679 --> 00:07:27,007
give it a pseudo random string just like
here K is chosen uniformly from the C

184
00:07:21,679 --> 00:07:27,007
当我们输入一个为随机序列，就比如从C空间里均匀选取的K

185
00:07:27,007 --> 00:07:32,403
space we ask how likely is the statistical
test to output one when we give it a

186
00:07:27,007 --> 00:07:32,403
我们考虑统计测试输出1的概率，当我们

187
00:07:32,403 --> 00:07:37,799
pseudo random output generated by the
generator verses now we ask how likely is

188
00:07:32,403 --> 00:07:37,799
输入有生成器产生的伪随机序列

189
00:07:37,799 --> 00:07:43,532
the statistical test to output one when we
give it a truly random string. So here are

190
00:07:37,799 --> 00:07:43,532
同时我们要看当我们输入真随机序列是统计测试输出1的概率

191
00:07:43,532 --> 00:07:48,174
is truly random in zero random one to the
n. Okay, and yeah. We look at the

192
00:07:43,532 --> 00:07:48,174
那么这里是n位真随机的01序列，好，我们来看

193
00:07:48,174 --> 00:07:52,447
difference between these two quantities.
Now you realize because these are

194
00:07:48,174 --> 00:07:52,447
这两个量之间的差。现在大家看到

195
00:07:52,447 --> 00:07:56,720
differences of probabilities this
advantage is always going to lie in the

196
00:07:52,447 --> 00:07:56,720
因为是概率的差，优势总是体现在

197
00:07:56,720 --> 00:08:00,733
interval zero, one. So let's think a
little bit about what this advantage

198
00:07:56,720 --> 00:08:00,733
[0,1]区间里。那么大家稍微想想这个优势意味着什么

199
00:08:00,733 --> 00:08:05,138
actually means. So first of all if the
advantage happens to be close to one. Well

200
00:08:00,733 --> 00:08:05,138
首先，如果优势接近1

201
00:08:05,138 --> 00:08:09,580
what does that mean. That means that
somehow, the statistical test A behaves

202
00:08:05,138 --> 00:08:09,580
什么意思呢？意思就是统计测试A

203
00:08:09,580 --> 00:08:14,620
differently when we gave it pseudo-random
inputs, when we gave it the output of the

204
00:08:09,580 --> 00:08:14,620
会有不同的结果，如果我们输入伪随机序列

205
00:08:14,620 --> 00:08:19,175
generator, for when we gave it truly
random inputs, right? It somehow behaved

206
00:08:14,620 --> 00:08:19,175
和生成器产生的真随机序列，对吧？

207
00:08:19,175 --> 00:08:23,790
differently. In one case, it output one
with a certain probability. And in the

208
00:08:19,175 --> 00:08:23,790
它表现的不用。在一种情况下，它以一定概率输出1

209
00:08:23,790 --> 00:08:28,344
other case, it output one with a very
different probability, okay? So somehow,

210
00:08:23,790 --> 00:08:28,344
另一种情况下，它会以完全不同的概率输出1，对吧？

211
00:08:28,344 --> 00:08:32,778
it was able to behave differently. And
what they really means is that the

212
00:08:28,344 --> 00:08:32,778
它就能表现地不同。这些真正想表达的是

213
00:08:32,778 --> 00:08:37,211
statistical test could basically
distinguish the output of the generator

214
00:08:32,778 --> 00:08:37,211
这个统计测试能将这个生成器的输出

215
00:08:37,211 --> 00:08:42,877
from random. Okay, so in some sense we'll
say that this statistical test broke the

216
00:08:37,211 --> 00:08:42,877
和随机序列区分开。好，在某种意义上，我们认为这个统计测试

217
00:08:42,877 --> 00:08:47,053
generator G because it was able to
distinguish the output from random.

218
00:08:42,877 --> 00:08:47,053
破解了生成器G，因为它能够区分输出序列和随机序列

219
00:08:47,053 --> 00:08:51,975
However if the advantage is close to zero
Well what does that mean. That means that

220
00:08:47,053 --> 00:08:51,975
然而这个优势和0很接近，什么意思？

221
00:08:51,975 --> 00:08:56,451
basically the statistical tests behaves
pretty much the same on pseudo random

222
00:08:51,975 --> 00:08:56,451
这意味着统计测试在伪随机输入

223
00:08:56,451 --> 00:09:01,222
inputs. As it does on truly random inputs.
And basically there we would say that A

224
00:08:56,451 --> 00:09:01,222
和真随机输入两种情况下表现一致。我们基本上可以说A

225
00:09:01,222 --> 00:09:05,773
could not distinguish the generator from
random. Okay, so this sum gives you a

226
00:09:01,222 --> 00:09:05,773
不能区分生成器的输出和真随机的输出。好，这个总结可以给大家

227
00:09:05,773 --> 00:09:10,289
little bit of intuition about why this
concept of advantage is important. It

228
00:09:05,773 --> 00:09:10,289
一点直观感受，为什么优势这一概念如此重要

229
00:09:10,289 --> 00:09:15,222
basically tells us whether A was able to
break the generator, namely distinguish it

230
00:09:10,289 --> 00:09:15,222
它告诉我们A是否能够破解这个生成器，即区分随机性

231
00:09:15,222 --> 00:09:19,917
from random, or not able to break it. So
let's look, first of all, at a very silly

232
00:09:15,222 --> 00:09:19,917
否则就不能破解它。那么我们首先再看一个很傻的例子

233
00:09:19,917 --> 00:09:24,671
example. Suppose we have a statistical
test A that simply ignores its inputs and

234
00:09:19,917 --> 00:09:24,671
设想我们有一个统计测试A，不管输入什么

235
00:09:24,671 --> 00:09:29,496
always outputs zero. Okay. Always output
zero. What do you think of the advantage

236
00:09:24,671 --> 00:09:29,496
总是输出0。好总是输出0.大家认为

237
00:09:29,496 --> 00:09:33,742
of this statistical test relative to a
generator G? So, I hope everybody

238
00:09:29,496 --> 00:09:33,742
这个相对于生成器G的统计测试的优势是什么？那么我希望大家

239
00:09:33,742 --> 00:09:37,932
say the advantage is zero, let
me just explain, why that's the case,

240
00:09:33,742 --> 00:09:37,932
都能认为优势是0，让我来解释一下为什么是这种情况

241
00:09:37,932 --> 00:09:41,791
well, if the statistical test, always outputs, zero, that

242
00:09:37,932 --> 00:09:41,791
如果在统计测试中总是输出0

243
00:09:41,791 --> 00:09:45,982
means, pseudo random inputs, it will never
output one, so, the probability that

244
00:09:41,791 --> 00:09:45,982
这意味着，输入伪随机序列是，不会输出1，所以

245
00:09:45,982 --> 00:09:50,282
outputs one, is zero. Similarly, when we
give a truly random input, it still will

246
00:09:45,982 --> 00:09:50,282
输出1的概率是零。相似的，当我们输入真随机序列时，它仍然

247
00:09:50,282 --> 00:09:54,527
never output one, and, so, the probability
that outputs one, is zero,

248
00:09:50,282 --> 00:09:54,527
不会输出1，并且输出1的概率还是0

249
00:09:54,527 --> 00:09:58,772
and, so, zero minus zero is zero, so, its
advantage is zero, so, basically, and, a

250
00:09:54,527 --> 00:09:58,772
所以0减0等于0，它的优势也就是0。那么

251
00:09:58,772 --> 00:10:03,128
statistical test that ignores its, its
input, does not able to distinguish, truly

252
00:09:58,772 --> 00:10:03,128
这个不看输入的统计测试明显不能区分

253
00:10:03,128 --> 00:10:07,441
random inputs, from, a pseudo random
input, obviously. Okay, now let's look at

254
00:10:03,128 --> 00:10:07,441
真随机和伪随机序列。好，我们来看

255
00:10:07,441 --> 00:10:12,861
a more interesting example. So suppose we
have a generator G that satisfies a funny

256
00:10:07,441 --> 00:10:12,861
一个更有趣的例子。假设我们有一个生成器G满足一个有趣的

257
00:10:12,861 --> 00:10:17,671
property. It so happens that for
two-thirds of the keys The first bit

258
00:10:12,861 --> 00:10:17,671
性质：有三分之二的秘钥

259
00:10:17,671 --> 00:10:22,892
of the output of the generator happens to
be one, okay? So if I choose a random key

260
00:10:17,671 --> 00:10:22,892
生成器输出的第一位碰巧是1，对吧？所以如果我选一个随机秘钥

261
00:10:22,892 --> 00:10:28,176
with probability two-thirds, the generator
will output one as its first bit, okay? So

262
00:10:22,892 --> 00:10:28,176
生成器会以三分之二的概率，第一位输出1，对吧？

263
00:10:28,176 --> 00:10:33,333
that's the property of the generator that
we're looking at. Now, let's look at the

264
00:10:28,176 --> 00:10:33,333
那么这就是我们看到的这个生成器的性质。现在我们来看

265
00:10:33,333 --> 00:10:37,790
following statistical test. The
statistical test basically says, if the

266
00:10:33,333 --> 00:10:37,790
下面的统计测试。这个测试是这样的

267
00:10:37,790 --> 00:10:42,883
most signifigant bit of the string you
gave me is one, I'm gonna say one, meaning

268
00:10:37,790 --> 00:10:42,883
如果这个序列的最高位是1，就输出1

269
00:10:42,883 --> 00:10:48,167
I think it's random. If the most signigant
bit of the stream you gave me is not one,

270
00:10:42,883 --> 00:10:48,167
我会认为它是随机的。如果输入的最高位不是1

271
00:10:48,167 --> 00:10:53,969
zero, I'm gonna say zero. Okay
so now my question to you is what is the

272
00:10:48,167 --> 00:10:53,969
是0，就输出0。好那么问题来了

273
00:10:53,969 --> 00:10:59,625
advantage of this statistical test on the
generator G? Okay, so remember I just

274
00:10:53,969 --> 00:10:59,625
对于生成器G的统计测试的优势是什么？

275
00:10:59,625 --> 00:11:04,552
wrote down the definition here again. And
I'll let you think about this for a

276
00:10:59,625 --> 00:11:04,552
我再在这里写一遍定义，并且大家可以想一想

277
00:11:04,552 --> 00:11:09,933
second. So let me explain. Suppose we give
the statistical tests pseudo random

278
00:11:04,552 --> 00:11:09,933
那么我来解释一下，假设我们对这个统计测试输入伪随机序列

279
00:11:09,933 --> 00:11:14,568
inputs. By definition of G, we know that
with probability two-thirds, the first

280
00:11:09,933 --> 00:11:14,568
根据G的定义，我们知道有三分之二的概率

281
00:11:14,568 --> 00:11:19,625
bits in the inputs will start with the bit
one. But if it starts with a bit one, then

282
00:11:14,568 --> 00:11:19,625
输入的第一位是1.但如果以1开始

283
00:11:19,625 --> 00:11:24,320
the statistical test will output one. In
other words, the probability that this

284
00:11:19,625 --> 00:11:24,320
那统计测试就会输出1.换句话说

285
00:11:24,320 --> 00:11:29,196
statistical test outputs one is exactly
two-thirds. Now let's look at the case of

286
00:11:24,320 --> 00:11:29,196
统计测试输出1的概率严格为三分之二。我们来看一下

287
00:11:29,196 --> 00:11:33,831
a random string. If I give you a random
string, how likely is it that the most

288
00:11:29,196 --> 00:11:33,831
随机序列的情况。如果我输入一个随机序列，

289
00:11:33,831 --> 00:11:38,346
signifigant bits of the random string is
one? Well, for a random string, that

290
00:11:33,831 --> 00:11:38,346
最高位是1的概率是多少？好，对于这个随机序列

291
00:11:38,346 --> 00:11:43,342
happens exactly half the time, and so in
this case the statistical test will output

292
00:11:38,346 --> 00:11:43,342
概率是约为一半，并且这种情况下统计测试会输出

293
00:11:43,342 --> 00:11:47,918
one, with probability one-half. And so the
overall advantage is one-sixth, and

294
00:11:43,342 --> 00:11:47,918
1，概率是二分之一。所以总的优势是六分之一

295
00:11:47,918 --> 00:11:52,553
one-sixth is actually a non-negligible
number, that's actually a fairly large

296
00:11:47,918 --> 00:11:52,553
六分之一实际上是一个不可忽略的数字，是一个相当大的

297
00:11:52,553 --> 00:11:57,490
number, which basically means that this a
was able to distinguish the output. We'll

298
00:11:52,553 --> 00:11:57,490
数，这意味着生成器能够区分输出了。

299
00:11:57,490 --> 00:12:03,314
say that a breaks the generator G with
advantage 1/6. Okay, which basically

300
00:11:57,490 --> 00:12:03,314
我们可以认为A以六分之一的优势破解了生成器G。好，

301
00:12:03,314 --> 00:12:08,292
means that this generator is no good, is
broken. Okay, so now that we understand

302
00:12:03,314 --> 00:12:08,292
这说明这个生成器不好，被破解了。那么我们现在理解了

303
00:12:08,292 --> 00:12:13,521
what statistical tests are, we can go
ahead and define, what is a secure

304
00:12:08,292 --> 00:12:13,521
统计测试是什么了，我们来更进一步定义，什么是

305
00:12:13,521 --> 00:12:19,191
pseudo-random generator. So, basically, we
say that, as generator G is secure, if

306
00:12:13,521 --> 00:12:19,191
一个安全伪随机生成器。那么我们说生成器G是安全的

307
00:12:19,191 --> 00:12:24,935
essentially no efficient, statistical
tests can distinguish its output from

308
00:12:19,191 --> 00:12:24,935
如果本质上没有有效的统计测试能区分G输出和

309
00:12:24,935 --> 00:12:30,311
random. More precisely, what we'll say is
that, basically for all efficient

310
00:12:24,935 --> 00:12:30,311
和随机序列。更精确地说，所有有效的

311
00:12:30,311 --> 00:12:36,423
statistical tests, a... Statistical tests,
a... It so happens that if I look at the

312
00:12:30,311 --> 00:12:36,423
统计测试，A..统计测试，A..如果我看

313
00:12:36,423 --> 00:12:42,496
advantage. Of the statistical test E
relative to G. This advantage basically is

314
00:12:36,423 --> 00:12:42,496
统计测试E对于生成器G的优势。这个优势是

315
00:12:42,496 --> 00:12:47,246
negligible. So, in other words,
it's very close to zero, and as a result,

316
00:12:42,496 --> 00:12:47,246
可以忽略的。换句话说，它非常接近于0，作为结果来说

317
00:12:47,246 --> 00:12:52,103
this, statistical test was not able to
distinguish the output from random, and

318
00:12:47,246 --> 00:12:52,103
这个统计测试不能区分生成器的输出序列和随机序列

319
00:12:52,103 --> 00:12:56,961
that has to be true for all statistical
tests. So, this is a very, very pretty and

320
00:12:52,103 --> 00:12:56,961
这对于所有统计测试都是对的。因此这是一个非常非常完美

321
00:12:56,961 --> 00:13:01,211
elegant definition, that says that a
generator is secure, not only if a

322
00:12:56,961 --> 00:13:01,211
优雅的定义，它说明了生成器是安全的，不仅

323
00:13:01,211 --> 00:13:06,129
particular battery of statistical tests
says that the output looks random, but, in

324
00:13:01,211 --> 00:13:06,129
一些特定的统计测试认为它的输出是随机的

325
00:13:06,129 --> 00:13:10,929
fact, all efficient statistical tests will
say the output looks random. Okay? One

326
00:13:06,129 --> 00:13:10,929
事实上所有有效的统计测试都认为输出是随机的，对吧？

327
00:13:10,929 --> 00:13:15,992
thing I'd like to point out is, that the
restriction to efficient statistical tests

328
00:13:10,929 --> 00:13:15,992
我想指出的一点是，有效统计测试的限制

329
00:13:15,992 --> 00:13:20,934
is actually necessary. If we ask that all
statistical tests, regardless of whether

330
00:13:15,992 --> 00:13:20,934
是必须的。如果我们考虑的所有的统计测试，不管

331
00:13:20,934 --> 00:13:25,836
they're efficient or not, not be able to
distinguish the output from random. Then

332
00:13:20,934 --> 00:13:25,836
是否是有效的，它们就不能够区分生成器的输出序列和随机序列了。

333
00:13:25,836 --> 00:13:30,469
in fact, that can not be satisfied. So in
other words if we took out the

334
00:13:25,836 --> 00:13:30,469
事实上，这是无法被满足的。换句话说，如果我们

335
00:13:30,469 --> 00:13:34,826
requirements that the test be efficient.
Then this definition would be

336
00:13:30,469 --> 00:13:34,826
去掉测试是有效的要求，那么这个定义

337
00:13:34,826 --> 00:13:39,484
unsatisfiable. And I'll leave this as a
simple puzzle for you to think about. But

338
00:13:34,826 --> 00:13:39,484
无法被满足。我把这点留给大家当做一个小问题思考一下

339
00:13:39,484 --> 00:13:43,851
basically the fact is that restricting
this definition into only efficient

340
00:13:39,484 --> 00:13:43,851
但是实际上限制定义在有效的

341
00:13:43,851 --> 00:13:48,625
statistical tests is actually necessary
for this to be satisfiable. So now that we

342
00:13:43,851 --> 00:13:48,625
统计测试范围内是必要的，这样定义才能被满足

343
00:13:48,625 --> 00:13:53,341
have a definition, the next question is
can we actually construct a generator and

344
00:13:48,625 --> 00:13:53,341
现在我们有了这个定义，下一个问题就是我们能否构造一个生成器

345
00:13:53,341 --> 00:13:57,533
then prove that it is in fact a secure
PRG. In other words, prove that no

346
00:13:53,341 --> 00:13:57,533
并且证明它实际上是安全的PRG。换句话说，就是证明

347
00:13:57,533 --> 00:14:02,366
efficient statistical test can distinguish
its output from random. And it turns out

348
00:13:57,533 --> 00:14:02,366
没有有效的统计测试能区分生成器的输出序列和随机序列。

349
00:14:02,366 --> 00:14:07,022
that the answer is we actually can't. In
fact, it's not known. If there are any

350
00:14:02,366 --> 00:14:07,022
结果答案就是我们不能，实际上不知道是否

351
00:14:07,022 --> 00:14:12,627
probably secure PRG's. Then I will just
say very briefly the reason is that if you

352
00:14:07,022 --> 00:14:12,627
有任何可能的安全PRG。我来说一个简单的理由

353
00:14:12,627 --> 00:14:18,301
could prove that a particular generator is
secure that would actually imply that P

354
00:14:12,627 --> 00:14:18,301
如果你能证明一个特定的生成器是安全的，那意味着

355
00:14:18,301 --> 00:14:23,455
is not equal to NP. And I don't want to
dwell on this. Because I don't want to

356
00:14:18,301 --> 00:14:23,455
P不等于NP。我不想在这个地方纠结。因为我不想

357
00:14:23,455 --> 00:14:28,706
assume that you guys know what P and NP
are. But I'll tell you as a simple fact

358
00:14:23,455 --> 00:14:28,706
假定大家都知道P和NP是什么。但我会简单告诉大家

359
00:14:28,706 --> 00:14:33,420
that in fact in P is equal to NP. Then
it's very easy to show that there are no

360
00:14:28,706 --> 00:14:33,420
事实是P是等于NP的。显而易见没有

361
00:14:33,420 --> 00:14:37,858
secure PRGs. And so if you could prove to
me that a particular PRG is secure, that

362
00:14:33,420 --> 00:14:37,858
安全的PRG。如果大家能够证明给我看看一个特定的PRG是安全的

363
00:14:37,858 --> 00:14:41,913
would imply that P is not equal to
NP. Again, I will leave this to

364
00:14:37,858 --> 00:14:41,913
那意味着P不等于NP。我会把这个

365
00:14:41,913 --> 00:14:45,858
you as a simple puzzle to think about.
But, even though we can't actually

366
00:14:41,913 --> 00:14:45,858
再当做一个问题留给大家思考。但是尽管我们实际上不能

367
00:14:45,858 --> 00:14:50,297
rigorously prove that a particular PRG is
secure, we still have lots and lots and

368
00:14:45,858 --> 00:14:50,297
严格证明一个特定的PRG是安全的，我们任然有很多

369
00:14:50,297 --> 00:14:54,406
lots of heuristic candidates, and we even
saw some of those in the previous

370
00:14:50,297 --> 00:14:54,406
候选方案，我们之前甚至看到过一些

371
00:14:54,406 --> 00:14:59,289
segments. Okay now that we understand what
is a secure PRG. I want to talk a little

372
00:14:54,406 --> 00:14:59,289
好，现在我们理解了什么是一个安全的PRG。我想稍微讨论一下

373
00:14:59,289 --> 00:15:03,558
bit about some applications and
implications of this definition. And so

374
00:14:59,289 --> 00:15:03,558
这个定义的一些应用以及含义。那么

375
00:15:03,558 --> 00:15:08,308
the first thing I want to show you is that
in fact a secure PRG is necessarily

376
00:15:03,558 --> 00:15:08,308
我想给大家看的第一件事实际上是一个安全的PRG

377
00:15:08,308 --> 00:15:12,884
unpredictable. In a previous segment, we
talked about what it means for a generator

378
00:15:08,308 --> 00:15:12,884
是不可预测的。在前面一节，我们讨论了一个生成器

379
00:15:12,884 --> 00:15:17,114
to be unpredictable. And we said that,
basically, what that means is that, given

380
00:15:12,884 --> 00:15:17,114
不可预测是什么意思。我们说，这个意思是

381
00:15:17,114 --> 00:15:21,508
a prefix of the output generator, it's
impossible to predict the next bit of the

382
00:15:17,114 --> 00:15:21,508
给定生成器输出的前一部分，我们不能预测下一位输出

383
00:15:21,508 --> 00:15:25,902
output. Okay, so we'd like to show that if
a generator is secure, then necessarily,

384
00:15:21,508 --> 00:15:25,902
好，我们想要表明一个生成器是否安全，必须

385
00:15:25,902 --> 00:15:30,176
it means it's unpredictable. And so the
only way we're gonna do that is using the

386
00:15:25,902 --> 00:15:30,176
意味着它是不可预测的。唯一的方式就是使用

387
00:15:30,176 --> 00:15:34,254
contrapositive. That is, we're gonna say
that if you give me a generator that is

388
00:15:30,176 --> 00:15:34,254
逆否命题。也就是说，如果你给出一个可预测的生成器

389
00:15:34,254 --> 00:15:37,971
predictable, then necessarily, it's
insecure. In other words, necessarily, I

390
00:15:34,254 --> 00:15:37,971
那么它是不安全的。换句话说

391
00:15:37,971 --> 00:15:42,050
can distinguish it from random. And so
let's see, this is actually a very simple

392
00:15:37,971 --> 00:15:42,050
我能区分生成器的输出和随机序列的输出。我们来看看，这是一个简单的

393
00:15:42,050 --> 00:15:46,077
fact. And so let's see how we would do
that. So suppose you give me a predictor.

394
00:15:42,050 --> 00:15:46,077
事实。我们看看我们怎么用这个事实。假定你给出一个预测

395
00:15:46,077 --> 00:15:50,000
In other words, suppose you give me an
efficient algorithm, such that, in fact,

396
00:15:46,077 --> 00:15:50,000
换句话说，假定你给出一个有效的算法，像这样，事实上

397
00:15:50,000 --> 00:15:54,234
if I give this algorithm the output of the
generator, but I give it only the first

398
00:15:50,000 --> 00:15:54,234
如果我把生成器的输出作为算法的输入，但我只输入

399
00:15:54,234 --> 00:15:58,599
I-bits of the outputs. It's able to
predict the next bit of the output. In

400
00:15:54,234 --> 00:15:58,599
输出序列的前I比特。它能够预测下一比特的输出。

401
00:15:58,599 --> 00:16:03,664
other words given the first I-bit it's
able to predict the I plus first bit. And

402
00:15:58,599 --> 00:16:03,664
换句话说，给定的前I比特能够预测I+1位

403
00:16:03,664 --> 00:16:08,827
it does that with a certain probability.
So let's say if we choose a random k. From

404
00:16:03,664 --> 00:16:08,827
该算法能够以一定概率实现。因此我们说如果我们从秘钥空间选择一个随机的k

405
00:16:08,827 --> 00:16:13,367
the keyspace. Then, clearly, a done predictor would be able to predict the

406
00:16:08,827 --> 00:16:13,367
然后预测机就能够

407
00:16:13,367 --> 00:16:18,138
next bit with probability one-half, simply
just guess the bits. You'll be right with

408
00:16:13,367 --> 00:16:18,138
以一半的概率预测下一位。简单地猜下这些比特，你能

409
00:16:18,138 --> 00:16:22,391
probability one-half. However, this
algorithm A is able to predict the next

410
00:16:18,138 --> 00:16:22,391
有一半的概率正确。然而算法A也能够

411
00:16:22,391 --> 00:16:27,053
bit with probability half with epsilon. So
it's bound to the way. From a half. And,

412
00:16:22,391 --> 00:16:27,053
一以二分之一加epsilon的概率预测下一位。因此它是被这样界定的。

413
00:16:27,053 --> 00:16:31,726
in fact, we require that this by true for
some non negligible epsilon. So, for

414
00:16:27,053 --> 00:16:31,726
实际上，我们要求这对某些不能忽略的epsilon成立

415
00:16:31,726 --> 00:16:36,338
example, epsilon =1/1000 would already be a
dangerous predictor, because it can

416
00:16:31,726 --> 00:16:36,338
比如，epsilon=1/1000，这会是一个危险的预测机，因为它能

417
00:16:36,338 --> 00:16:40,949
predict the next bits, given a prefix,
with non negligible advantage. Okay, so

418
00:16:36,338 --> 00:16:40,949
在给定前缀时，以不可忽略的优势预测下一位

419
00:16:40,949 --> 00:16:45,533
suppose we have such an algorithm. Let's
see that we can use this algorithm to

420
00:16:40,949 --> 00:16:45,533
假定我们有这样一个算法，我们来看我们能用这个算法

421
00:16:45,533 --> 00:16:50,010
break our generator. In other words to
show that a generator is distinguishable

422
00:16:45,533 --> 00:16:50,010
来破解我们的生成器。换句话说，是为了表明一个生成器是和

423
00:16:50,010 --> 00:16:54,146
from random and therefore, is insecure. So
what we'll do is we'll define a

424
00:16:50,010 --> 00:16:54,146
随机序列可以区分的，因此是不安全的。那么我们要做的是定义

425
00:16:54,146 --> 00:16:59,463
statistical test. So, let's define the
statistical test B as follows. Basically,

426
00:16:54,146 --> 00:16:59,463
一个统计测试。我们按如下方式定义统计测试B

427
00:16:59,463 --> 00:17:04,979
B, given a string, x, what it will do, is
it will simply run algorithm A on the

428
00:16:59,463 --> 00:17:04,979
B，给定序列x，接下来要做的是

429
00:17:04,979 --> 00:17:10,711
first I-bit of the string x that it was
given. And, statistical test b is simply

430
00:17:04,979 --> 00:17:10,711
对给定的x序列前i比特使用算法A。统计测试B简单地

431
00:17:10,711 --> 00:17:16,662
gonna ask, was a successful in predicting
the I-plus first bit of the string? If it

432
00:17:10,711 --> 00:17:16,662
问一下，是否成功地预测了第i+1位？

433
00:17:16,662 --> 00:17:22,579
was successful, then it's gonna output
one. And if it wasn't successful, then

434
00:17:16,662 --> 00:17:22,579
如果是成功的，它就会输出1.如果不成功

435
00:17:22,579 --> 00:17:28,154
it's gonna output zero. Okay. This our
statistical task. Let's put it in a box So

436
00:17:22,579 --> 00:17:28,154
就会输出0。好，这就是我们的统计任务。我们把它一个盒子中

437
00:17:28,154 --> 00:17:33,407
we can take it wherever we like. And we
can run the statistical test on any N bit

438
00:17:28,154 --> 00:17:33,407
我们能随意的使用。并且我们能用任意N比特

439
00:17:33,407 --> 00:17:38,466
string that's given to us as inputs. So
now, let's look at what happens. Suppose

440
00:17:33,407 --> 00:17:38,466
序列作为输入运行统计测试。现在我们来看看发生了什么。假定

441
00:17:38,466 --> 00:17:43,524
we give the statistical test, a truly
random string. So a truly random string R.

442
00:17:38,466 --> 00:17:43,524
我们在统计测试中输入真随机序列，R

443
00:17:43,524 --> 00:17:48,583
And we ask, what is the probability that
the statistical test outputs one? Well,

444
00:17:43,524 --> 00:17:48,583
我们想知道会有多大概率输出1？

445
00:17:51,112 --> 00:17:53,642
for a truly random string, the I+1
bit is totally independent of the first

446
00:17:51,112 --> 00:17:53,642
对于一个真随机序列，第i+1是独立于

447
00:17:53,642 --> 00:17:58,765
I-bits. So whatever this algorithm is
gonna output is completely independent of

448
00:17:53,642 --> 00:17:58,765
前I比特的。所以算法A的输出也是完全独立于

449
00:17:58,765 --> 00:18:04,231
what's, I+1 bit of the string R is.
And so whatever A outputs the probability

450
00:17:58,765 --> 00:18:04,231
序列R的i+1位的，所以不管A输出什么，概率

451
00:18:07,162 --> 00:18:10,092
is going to be equal to some random bit X I+1. Random independent bit X I+1, that

452
00:18:07,162 --> 00:18:10,092
都是等于随机的第i+1位，与第i+1位独立

453
00:18:10,092 --> 00:18:14,754
probability is exactly 1/2. In other
words, algorithm a simply has no

454
00:18:10,092 --> 00:18:14,754
概率为1/2.换句话说，算法A不提供第i+1位的任何信息

455
00:18:14,754 --> 00:18:19,620
information about what the bit X I+1 is, and so necessarily, the probability is

456
00:18:14,754 --> 00:18:19,620
第I+1位的任何信息。并且

457
00:18:19,620 --> 00:18:24,254
able to predict X I+1 is exactly one half. On the other hand, let's look at

458
00:18:19,620 --> 00:18:24,254
能够预测第I+1位是什么的概率为1/2.另一方面，我们来看

459
00:18:24,254 --> 00:18:28,946
what happens when we give our statistical
tests a pseudo-random sequence, okay. So

460
00:18:24,254 --> 00:18:28,946
当我们在统计测试输入伪随机序列会发生什么

461
00:18:28,946 --> 00:18:33,521
now we're going to run the statistical
test on the output of the generator, and

462
00:18:28,946 --> 00:18:33,521
好，我们对生成器的输出进行统计测试

463
00:18:33,521 --> 00:18:37,866
we ask how likely is it to output one.
Well, by definition of A, we know that

464
00:18:33,521 --> 00:18:37,866
我们想知道输出1的可能多大。根据定义A，我们知道

465
00:18:37,866 --> 00:18:42,326
when we give it the first I bits of the
output of the generator, it's able to

466
00:18:37,866 --> 00:18:42,326
当我们把生成器的前I位作为输入时，它能

467
00:18:42,326 --> 00:18:46,851
predict the next bit with probability 1/2 + epislon. So in this case our

468
00:18:42,326 --> 00:18:46,851
以1/2+epislon的概率预测。因此这种情况下

469
00:18:46,851 --> 00:18:51,657
statistical test B will output one with
probability greater than 1/2 + epsilon

470
00:18:46,851 --> 00:18:51,657
统计测试B会以大于1/2+epislon的概率输出1

471
00:18:51,657 --> 00:18:57,700
And basically what this means, is if we look at the advantage of our

472
00:18:51,657 --> 00:18:57,700
这就意味着如果我们看

473
00:18:57,700 --> 00:19:04,207
statistical tests over the generator G
it's basically, the difference between

474
00:18:57,700 --> 00:19:04,207
统计测试对于生成器G的优势，就是

475
00:19:04,207 --> 00:19:09,648
this quantity and that quantity. There's a
difference between the two. You can see

476
00:19:04,207 --> 00:19:09,648
两个量间的差别。你能够看出来两者的差

477
00:19:09,648 --> 00:19:14,514
that it's clearly greater than an epsilon.
So what this means is that if algorithm A

478
00:19:09,648 --> 00:19:14,514
是大于epsilon的。这意味着如果算法A

479
00:19:14,514 --> 00:19:18,917
is able to predict the next bits with
advantage epsilon, then algorithm B is

480
00:19:14,514 --> 00:19:18,917
能够以epsilon的优势预测下一位，那么算法B

481
00:19:18,917 --> 00:19:23,533
able to distinguish the output of the
generator with advantage epsilon. Okay? So

482
00:19:18,917 --> 00:19:23,533
能够以epsilon的优势区分生成器的输出，对吧？

483
00:19:23,533 --> 00:19:28,696
if A is a good predictor, B is a good
statistical test that break the generator.

484
00:19:23,533 --> 00:19:28,696
那么如果A是一个好的预测机，B是一个破解了生成器的好统计测试

485
00:19:28,696 --> 00:19:33,859
And as we said, the counter-positive of
that is that if G is a secure generator,

486
00:19:28,696 --> 00:19:33,859
就如我们说的，这个逆否命题是如果生成器G安全

487
00:19:33,859 --> 00:19:38,960
then there are no good statistical tests.
And as a result, there are no predictors.

488
00:19:33,859 --> 00:19:38,960
那么就没有好的统计测试，同样，也没有好的预测机

489
00:19:38,960 --> 00:19:43,756
Okay? Which means that the generator is,
as we said, unpredictable. Okay, so, so

490
00:19:38,960 --> 00:19:43,756
对吧？意思就是我们所说的生成器是不可预测的。好，目前为止

491
00:19:43,756 --> 00:19:48,361
far, what we've seen is that if the
generator is secure, necessarily, it's

492
00:19:43,756 --> 00:19:48,361
我们看到的是如果生成器是安全的

493
00:19:48,361 --> 00:19:53,030
impossible to predict the I+1 bit,
given first I bits.

494
00:19:48,361 --> 00:19:53,030
就不可能在给定前I比特时预测第I+1比特。

495
00:19:53,030 --> 00:19:57,890
Now there's a very elegant and remarkable
theorem Yao back in 1982. They

496
00:19:53,030 --> 00:19:57,890
1982年，姚期智给出了一个优雅非凡的定理

497
00:19:57,890 --> 00:20:02,623
chose it, in fact the converse is also
true. In other words, if I give you a

498
00:19:57,890 --> 00:20:02,623
人们认同了这个定理。实际上逆命题也是成立的。换句话说，如果我给出

499
00:20:02,623 --> 00:20:07,675
generator that's unpredictable, so you
cannot predict the I+1 bits from the

500
00:20:02,623 --> 00:20:07,675
一个不可预测的生成器，那么你就不能根据前I位预测第I+1位

501
00:20:07,675 --> 00:20:12,453
first I bits, and that's true for all I.
That generator, in fact, is secure. Okay,

502
00:20:07,675 --> 00:20:12,453
I取任何值都成立。事实上这个生成器是安全的。好

503
00:20:12,453 --> 00:20:17,021
so let me state the theorem a little bit
more precicely. So here we have our

504
00:20:12,453 --> 00:20:17,021
我来吧这个定理阐述的更清楚点。我们使

505
00:20:17,021 --> 00:20:21,949
generator that outputs n bit outputs. The
theorem says the following, basically for

506
00:20:17,021 --> 00:20:21,949
生成器输出n比特，定理告诉我们

507
00:20:21,949 --> 00:20:26,517
all bit positions, it's impossible to
predict I+1 bit of the output

508
00:20:21,949 --> 00:20:26,517
对所有比特位，都不可能根据前I位预测第I+1位输出

509
00:20:26,517 --> 00:20:30,905
given the first I bit. And that's true for
all I. In other words, again, the

510
00:20:26,517 --> 00:20:30,905
这对于所有I均成立。换句话说

511
00:20:30,905 --> 00:20:35,181
generator is unpredictable for all bit
positions. Then, that, in fact, implies

512
00:20:30,905 --> 00:20:35,181
生成器对于任何比特位都无法预测。事实上这就意味着

513
00:20:35,181 --> 00:20:38,969
that the generator is a secure PRG.
I want paraphrase this in English,

514
00:20:35,181 --> 00:20:38,969
生成器是一个安全的PRG。我想用英语解释这个

515
00:20:39,123 --> 00:20:43,321
and so the way to kinda interpret this
result is to say that it's basically these

516
00:20:39,123 --> 00:20:43,321
并且组织下语言，这个结果就是这些

517
00:20:43,321 --> 00:20:47,570
next bit predictors. These predictors that
try to predict the I+1 bit given the

518
00:20:43,321 --> 00:20:47,570
下一位预测机能够在给定前I位是预测第I+1位

519
00:20:47,570 --> 00:20:51,410
first I bits. If they're not able to
distinguish G from random, then, in fact,

520
00:20:47,570 --> 00:20:51,410
如果他们不能区分G的输出和随机序列的输出，那么事实上

521
00:20:51,410 --> 00:20:55,125
no statistical test is going to
distinguish G from random. So kind of next

522
00:20:51,410 --> 00:20:55,125
就没有统计测试能区分了。这些

523
00:20:55,125 --> 00:20:58,804
bit predictors are in some sense
universal, predictors, when it comes to

524
00:20:55,125 --> 00:20:58,804
下一位预测机某种意义上是指普遍的预测机。当说到

525
00:20:58,804 --> 00:21:02,334
distinguishing things from random. This
theorem, by the way, it's not too

526
00:20:58,804 --> 00:21:02,334
区分随机性时，顺便说下，这个定理，不难

527
00:21:02,334 --> 00:21:06,113
difficult to prove, but there's a very
elegant idea behind its proof. I'm not

528
00:21:02,334 --> 00:21:06,113
证明，但是在这个证明背后有一个非常优雅的想法。

529
00:21:06,113 --> 00:21:10,090
gonna do the proof here, but I encourage
you to think about this as a puzzle, try

530
00:21:06,113 --> 00:21:10,090
在这里我不做证明，但是我鼓励大家把它当做一个问题思考

531
00:21:10,090 --> 00:21:14,017
to kind of try to prove this theorem
yourself. Let me show you kind of one cute

532
00:21:10,090 --> 00:21:14,017
尝试自己证明它。我来给大家展示一个定理稍微

533
00:21:14,017 --> 00:21:19,101
implication of this theorem. So let me ask
you the following question. Suppose I give

534
00:21:14,017 --> 00:21:19,101
有趣的影响。我要问大家下面几个问题，假定我给出

535
00:21:19,101 --> 00:21:24,417
you a generator and I tell you that given
the last bit of the output. It's easy to

536
00:21:19,101 --> 00:21:24,417
一个生成器，并且我告诉大家给定的输出的最后一位

537
00:21:24,417 --> 00:21:28,963
predict the first bit of the outputs,
okay? So given the last end bits, you can

538
00:21:24,417 --> 00:21:28,963
很容易就能预测输出的第一位，对吧？那么给定最后一位，你可以

539
00:21:28,963 --> 00:21:33,627
compute the first end bits. That's kind of
the opposite of predictability, right?

540
00:21:28,963 --> 00:21:33,627
第一位，这和预测正好相反，对吧？

541
00:21:33,627 --> 00:21:38,469
Predictability mean given the first
bit, you can produce the next bits. Here,

542
00:21:33,627 --> 00:21:38,469
可预测性指的是给定第一位，你能得到下一位。这里

543
00:21:38,469 --> 00:21:43,133
given the last bits, you can produce the
first ones. And my question to you, does

544
00:21:38,469 --> 00:21:43,133
给定最后一位，你能得到第一位。那么我的问题是

545
00:21:43,133 --> 00:21:47,266
that mean that the generator is
predictable? Can you somehow, from this

546
00:21:43,133 --> 00:21:47,266
这意味着生成器是可预测的吗？能否根据这个

547
00:21:47,266 --> 00:21:52,310
fact, still build a predictor for this
generator? This is kind of a simple

548
00:21:47,266 --> 00:21:52,310
事实为生成器构造一个预测机呢？这是一个

549
00:21:52,310 --> 00:21:56,898
application of Yao theorem let me explain to
you the answer is actually yes let me

550
00:21:52,310 --> 00:21:56,898
姚期智定理的简单应用。我来给大家解释一下这个问题的答案是yes

551
00:21:56,898 --> 00:22:02,074
explain why how do we build this generator
well, actually we're not going to build it

552
00:21:56,898 --> 00:22:02,074
我解释一下怎样构造这个生成器，实际上我们不需要构造它

553
00:22:02,074 --> 00:22:06,661
I'm going to show you that the generator
exists. Well because an over two bits

554
00:22:02,074 --> 00:22:06,661
我会证明给大家这个生成器是存在的，就是因为超过两字节

555
00:22:06,661 --> 00:22:11,661
first an over two bits doesn't necessarily
mean that the generator here let me write

556
00:22:06,661 --> 00:22:11,661
首先超过两字节并不意味着生成器，我这样写

557
00:22:11,661 --> 00:22:16,613
them this way what it means is that g is
not secure. Because just as we did before

558
00:22:11,661 --> 00:22:16,613
即G不安全。因为如之前所说

559
00:22:16,613 --> 00:22:22,043
it's very easy to build a statistical test
that will distinguish the output of G from

560
00:22:16,613 --> 00:22:22,043
容易构造一个统计测试来区分G的输出和

561
00:22:22,043 --> 00:22:27,156
uniform. So G is not secure. But if G Is not
secure, by Yao's Theorem, that means that

562
00:22:22,043 --> 00:22:27,156
均匀分布序列。但如果G不安全，根据姚定理，那就是指

563
00:22:27,156 --> 00:22:32,396
G is predectible. So in other words, there
exists some I for which given the first I

564
00:22:27,156 --> 00:22:32,396
G是可预测的。因此换句话说，存在某个I，给定输出前I位

565
00:22:32,396 --> 00:22:37,257
bits of the output, you can build the I+1 bits of the output. Okay, so

566
00:22:32,396 --> 00:22:37,257
你能构造第I+1位的输出。好

567
00:22:37,257 --> 00:22:42,371
even though I can't quite point to you a
predicter, we know that a predicter must

568
00:22:37,257 --> 00:22:42,371
即使我不能为大家构造预测算法，但我们知道预测算法一定存在

569
00:22:42,371 --> 00:22:46,529
exist. So that's a one cute simple
application of Yao theorem. Now before we

570
00:22:42,371 --> 00:22:46,529
那么这就是姚定理的一个简单应用。现在在我们

571
00:22:46,693 --> 00:22:50,856
end the segment I want to kind of,
generalize a little bit of what we did.

572
00:22:46,693 --> 00:22:50,856
结束这个部分之前，我想对我们所做的进行一个推广

573
00:22:50,856 --> 00:22:54,964
And introduce a little bit of important
notation that's going to be useful

574
00:22:50,856 --> 00:22:54,964
那就引入一些一直都很有用的重要符号

575
00:22:54,964 --> 00:22:58,516
actually throughout. So, we're gonna
generalize the concept of

576
00:22:54,964 --> 00:22:58,516
我们来推广

577
00:22:58,516 --> 00:23:02,889
indistinguishability from uniform, to
indistinguishability of two general

578
00:22:58,516 --> 00:23:02,889
与均匀分布不可区分的概念，到两个一般分布间的不可区分

579
00:23:02,889 --> 00:23:07,143
distributions. So, suppose I give you p1
and p2, and we ask, can these two

580
00:23:02,889 --> 00:23:07,143
设想我给出p1和p2，那么我们想知道这两个

581
00:23:07,143 --> 00:23:11,636
distributions be distinguished? And so
we'll say that the distributions are

582
00:23:07,143 --> 00:23:11,636
分布可区分吗？我们说这些分布

583
00:23:11,636 --> 00:23:16,602
computationally indistinguishable, and
we'll denote this by p1, a squiggly p. P2.

584
00:23:11,636 --> 00:23:16,602
计算上不可区分的，我们记为p1，约等于p,p2

585
00:23:16,602 --> 00:23:22,908
This means that, in polynomial time, P1
cannot be distinguished from P2. And we'll

586
00:23:16,602 --> 00:23:22,908
这意味着，在多项式时间里，p1和p2无法区分

587
00:23:22,908 --> 00:23:28,582
say that they're indistinguishable,
basically, just as before

588
00:23:22,908 --> 00:23:28,582
我们说他们是不可区分的，与之前一样

589
00:23:28,582 --> 00:23:35,759
if basically for all, efficient, statistical
tests, statistical tests. A it so happens

590
00:23:28,582 --> 00:23:35,759
对所有有效的统计测试A

591
00:23:35,759 --> 00:23:44,160
that if I sample from the distribution P1.
And I give the output to A. Versus if I

592
00:23:35,759 --> 00:23:44,160
如果我从分布p1里取样，并且把输出给A。作为对比

593
00:23:44,160 --> 00:23:51,208
sample from the distribution P2, and I
give the sample to A. Then basically A

594
00:23:44,160 --> 00:23:51,208
若果我从p2中取样，也交给A。那么基本上A对

595
00:23:51,208 --> 00:23:55,414
behaves the same in both cases. In
another-wards the difference between these

596
00:23:51,208 --> 00:23:55,414
两种情况表现一致。换句话说，这

597
00:23:55,414 --> 00:23:59,893
two probabilities is negligible. And this
has to be true for all statistical tests.

598
00:23:55,414 --> 00:23:59,893
两概率的差是可以忽略的。这对所有统计测试都成立

599
00:23:59,893 --> 00:24:04,577
For all efficient statistical tests. Okay?
So if this is the case then we say that,

600
00:23:59,893 --> 00:24:04,577
对所有的统计测试，对吧？如果是这种情况，我们说

601
00:24:04,577 --> 00:24:09,530
well A couldn't distinguish it's advantage
in distinguishing two distributions is

602
00:24:04,577 --> 00:24:09,530
A不能区分两个分布时，这两个分布的优势

603
00:24:09,530 --> 00:24:14,240
negligible and if that's true for all
efficient statistical tests then we say

604
00:24:09,530 --> 00:24:14,240
是可以忽略的。如果这对所有有效的统计测试都成立

605
00:24:14,240 --> 00:24:18,649
that the distributions are basically
computationaly indistinguishable,

606
00:24:14,240 --> 00:24:18,649
我们就说这些分布在计算上无法区分

607
00:24:18,649 --> 00:24:23,481
because an efficient algorithm cannot
distinguish them. And just to show you how

608
00:24:18,649 --> 00:24:23,481
因为一个有效的算法都不能区分它们。我是为了告诉大家

609
00:24:23,481 --> 00:24:28,372
useful this notation is, basically using
this notation the definition of security

610
00:24:23,481 --> 00:24:28,372
这个符号很有用，我们可以用它表示安全PRG的定义

611
00:24:28,372 --> 00:24:32,810
for PRG just says. That if I give you a
pseudo-random distribution. In other

612
00:24:28,372 --> 00:24:32,810
如果我给出一个伪随机分布，换句话说

613
00:24:32,810 --> 00:24:37,159
words, I choose K at random, and that
outputs a G of K. That distribution is

614
00:24:32,810 --> 00:24:37,159
随机地选取K，然后输出相应的G。这个分布

615
00:24:37,159 --> 00:24:41,978
computationally indistinguishable from the
uniform distribution. So you can see this,

616
00:24:37,159 --> 00:24:41,978
和均匀分布在计算上是不可区分的。因此大家也看到了

617
00:24:41,978 --> 00:24:46,269
this very simple notation captures the
whole definition of pseudo-random

618
00:24:41,978 --> 00:24:46,269
这个非常简单的符号表达了伪随机生成器的整个定义

619
00:24:46,269 --> 00:24:50,795
generators. Okay, so we're gonna make use
of this notation. In the next segment,

620
00:24:46,269 --> 00:24:50,795
好，我们后面会用到这个符号。在下一节中

621
00:24:50,795 --> 00:24:54,439
when we define, what does it mean for a
cipher to be secure.

622
00:24:50,795 --> 00:24:54,439
当我们定义密码时，它就代表安全

