1
00:00:00,000 --> 00:00:03,837
In this segment, we're gonna construct
authenticated encryption systems. Since we

2
00:00:00,000 --> 00:00:03,837
在这一部分，我们将要来创建认证加密系统。

3
00:00:03,837 --> 00:00:08,250
already have CPA secured encryption, and
we have secure MACs, the natural question

4
00:00:03,837 --> 00:00:08,250
由于我们已经有了CPA安全的加密和安全的MAC，随之而来的问题就是

5
00:00:08,250 --> 00:00:12,824
is whether we can combine the two somehow,
in order to get authenticated encryption.

6
00:00:08,250 --> 00:00:12,824
我们是否可以通过某种方式来将两者结合起来从而得到认证加密系统

7
00:00:12,824 --> 00:00:15,721
And if, that's exactly what we're gonna do
in this segment. Authenticated encryption

8
00:00:12,824 --> 00:00:15,721
事实上，这正是我们本节将要做的。认证加密

9
00:00:15,721 --> 00:00:20,447
was introduced in the year 2000, in two
independent papers that I point to at the

10
00:00:15,721 --> 00:00:20,447
于2000年在两篇独立的文章里被提出，本章的最后我会讲到

11
00:00:20,447 --> 00:00:25,915
end of this module. But before then, many
crytpolibraries provided an API that

12
00:00:20,447 --> 00:00:25,915
在这之前，许多密码学库都提供了

13
00:00:25,915 --> 00:00:31,215
separately supported CPA secure
encryption, and MAC-ing. So there was one

14
00:00:25,915 --> 00:00:31,215
一个分开支持CPA安全加密和MAC的API。因此存在一个

15
00:00:31,215 --> 00:00:36,175
function for implementing CPA secure
encryption. For example, CBC with a random

16
00:00:31,215 --> 00:00:36,175
执行CPA安全加密的函数。例如，带随机IV的CBC

17
00:00:36,175 --> 00:00:41,136
IV. And another function for implementing
a MAC. And then every developer that

18
00:00:36,175 --> 00:00:41,136
还有另一个执行MAC的函数。之后每一个想要执行加密的开发者

19
00:00:41,136 --> 00:00:45,646
wanted to implement encryption, had to,
himself, call separately the CPA secure

20
00:00:41,136 --> 00:00:45,646
都必须分别调用CPA安全加密体系和

21
00:00:45,646 --> 00:00:50,552
encryption scheme and the MAC scheme. In
particular, every developer had to invent

22
00:00:45,646 --> 00:00:50,552
MAC体系。特别的，每一个开发者都必须发明

23
00:00:50,552 --> 00:00:55,697
his own way of combining encryption and
MAC-ing to provide some sort of

24
00:00:50,552 --> 00:00:55,697
他们自己结合加密和MAC体系的方式，从而提供一种

25
00:00:55,697 --> 00:00:59,376
authenticated encryption. But since the
goals of combining encryption and MAC-ing

26
00:00:55,697 --> 00:00:59,376
认证加密系统。但是认证加密还没有被定义导致将CPA加密和MAC体系

27
00:00:59,376 --> 00:01:03,690
wasn't well understood since authenticated
encryption hasn't yet been defined, it

28
00:00:59,376 --> 00:01:03,690
结合的目标不是很明确，因而

29
00:01:03,690 --> 00:01:08,497
wasn't really clear which combinations of
encryption and MAC-ing are correct and

30
00:01:03,690 --> 00:01:08,497
我们很难区分哪种结合是正确的，哪种是错误的

31
00:01:08,497 --> 00:01:13,243
which aren't. And so, every project as I
said had to invent its own combination.

32
00:01:08,497 --> 00:01:13,243
并且像我说的每个项目都要开发它自己的结合方式

33
00:01:13,243 --> 00:01:17,202
And in fact, not all combinations were
correct. And I can tell you that the most

34
00:01:13,243 --> 00:01:17,202
事实上并不是所有的结合方式都是正确的。并且我可以告诉你

35
00:01:17,202 --> 00:01:22,556
common mistake in software projects were
basically incorrectly combining the

36
00:01:17,202 --> 00:01:22,556
软件开发的大部分普遍错误基本上就是错误地

37
00:01:22,556 --> 00:01:27,025
encryption and integrity mechanisms. So
hopefully, by the end of this module, you

38
00:01:22,556 --> 00:01:27,025
将加密和诚信机制结合起来。所以希望在本章的最后，大家可以

39
00:01:27,025 --> 00:01:31,260
will know how to combine them correctly,
and you won't be making these mistakes

40
00:01:27,025 --> 00:01:31,260
明白如何正确地结合它们，而且自己不会犯这种错误

41
00:01:31,260 --> 00:01:35,174
yourself. So let's look at some
combinations of CPA secure encryption and

42
00:01:31,260 --> 00:01:35,174
那么让我们来看一些CPA安全加密和MAC结合实例

43
00:01:35,174 --> 00:01:39,303
MAC, that were introduced by different
projects. So here are three examples. So,

44
00:01:35,174 --> 00:01:39,303
这些是出自不同的项目提出。这有三个例子。

45
00:01:39,303 --> 00:01:43,816
first of all, in all three examples,
there's a separate key for encryption, and

46
00:01:39,303 --> 00:01:43,816
首先，在这三个例子中，有一个单独的密钥来加密，还有

47
00:01:43,816 --> 00:01:47,774
a separate key for MACing. These two
keys are independent of one another, and

48
00:01:43,816 --> 00:01:47,774
一个单独的密钥来MAC。这两的密钥相互是独立的

49
00:01:47,774 --> 00:01:52,224
both are generated at session setup time.
And we're gonna see how to generate these

50
00:01:47,774 --> 00:01:52,224
并且都是在会话建立阶段生成的。我们将会在之后的课程学习

51
00:01:52,224 --> 00:01:57,071
two keys later on in the course. So the
first example is the SSL protocol. So the

52
00:01:52,224 --> 00:01:57,071
如何生成这两个密钥。那么，第一个例子呢是SSL协议。

53
00:01:57,071 --> 00:02:02,681
way SSL combines encryption and MAC in the
hope of achieving authenticated encryption

54
00:01:57,071 --> 00:02:02,681
以下是为了实现认证加密,SSL将加密和MAC结合起来的方式

55
00:02:02,681 --> 00:02:07,656
is the following. Basically you take the
plain text, m, and then you compute a MAC

56
00:02:02,681 --> 00:02:07,656
取明文m，然后计算明文m的MAC

57
00:02:07,656 --> 00:02:13,415
on the plain text, m. So you use your MAC
key, kI, to compute tag for this message

58
00:02:07,656 --> 00:02:13,415
因此你用你的MAC的密钥k1来计算这个明文的标签

59
00:02:13,415 --> 00:02:17,787
m. And then you can concatenate the tag to
the message and then you encrypt the

60
00:02:13,415 --> 00:02:17,787
然后你可以将标签和明文联系起来，然后加密

61
00:02:17,787 --> 00:02:22,580
concatenation of the message and the tag
and what comes out is the actual final cipher text.

62
00:02:17,787 --> 00:02:22,580
明文和标签的联接，随后就会得出最终的密文

63
00:02:22,580 --> 00:02:26,710
So that's option number one. The
second option is what IPsec does. So

64
00:02:22,580 --> 00:02:26,710
这是方案一。方案二就是IPsec的原理。

65
00:02:26,710 --> 00:02:31,160
here, you take the message. The first
thing you do is you encrypt the message.

66
00:02:26,710 --> 00:02:31,160
现在，取明文，首先要做的就是加密明文

67
00:02:31,160 --> 00:02:35,692
And then, you compute a tag on the
resulting cipher text. So you notice the

68
00:02:31,160 --> 00:02:35,692
然后，计算在结果密文上的标签。然后大家可以注意到

69
00:02:35,692 --> 00:02:40,238
tag itself is computed on the resulting
cipher text. A third option is what the

70
00:02:35,692 --> 00:02:40,238
这个明文是基于密文结果。第三个方案是

71
00:02:40,238 --> 00:02:45,429
SSH protocol does. So here, the SSH takes
the message, and encrypts it using a CPA

72
00:02:40,238 --> 00:02:45,429
SSH协议。那么这里，SSH取明文，用CPA安全加密体系进行加密

73
00:02:45,429 --> 00:02:50,944
secure encryption scheme. And then, to it,
it concatenates a tag of the message. The

74
00:02:45,429 --> 00:02:50,944
之后，将明文和标签联系起来。

75
00:02:50,944 --> 00:02:55,567
difference between IPsec and SSH, is that
in IPsec, the tag is computed over the

76
00:02:50,944 --> 00:02:55,567
IPsec和SSH的不同在于，在IPsec中，标签的计算在密文之上，

77
00:02:55,567 --> 00:02:59,988
cipher text, whereas, in SSH, the tag is
computed over the message. And so these

78
00:02:55,567 --> 00:02:59,988
然而，在SSH里，标签的计算基于明文。

79
00:02:59,988 --> 00:03:04,536
are three completely different ways of
combining encryption and MAC. And the

80
00:02:59,988 --> 00:03:04,536
那么这就是结合加密和MAC的三种完全不同的方式

81
00:03:04,536 --> 00:03:09,090
question is, which one of these is secure?
So, I will let you think about this for a

82
00:03:04,536 --> 00:03:09,090
那么问题来了，呢一种方式是安全的？我想让大家先思考一下

83
00:03:09,090 --> 00:03:12,105
second, and then when we continue we'll do
the analysis together.

84
00:03:09,090 --> 00:03:12,105
然后我们一起来分析

85
00:03:13,197 --> 00:03:17,164
Okay. So let's start with the SSH method. So
in the SSH method you notice that the tag

86
00:03:13,197 --> 00:03:17,164
让我们先从SSH方式开始。在SSH方式中大家注意到

87
00:03:17,164 --> 00:03:21,629
is computed on the message and then
concatenated in the clear to the cipher text.

88
00:03:17,164 --> 00:03:21,629
标签的计算基于明文，然后将标签附在密文后面。

89
00:03:21,629 --> 00:03:26,407
Now this is actually quite a problem
because MACs themselves are not designed

90
00:03:21,629 --> 00:03:26,407
事实上这存在这很大的问题，因为MAC并不是

91
00:03:26,407 --> 00:03:30,784
to provide confidentiality. MACs are only
designed for integrity. And in fact, there's

92
00:03:26,407 --> 00:03:30,784
为了提供保密性而设计的。它只是为了完整性而设计的。并且事实上

93
00:03:30,784 --> 00:03:36,008
nothing wrong with a MAC that as part of
the tag outputs a few bits of the plain

94
00:03:30,784 --> 00:03:36,008
MAC作为标签的一部分输出明文中的几位是没有任何问题的

95
00:03:36,008 --> 00:03:41,458
text. Outputs a few bits of the message M.
That would be a perfectly fine tag. And yet if

96
00:03:36,008 --> 00:03:41,458
输出明文m中的几位。可以说这是一个很好的标签

97
00:03:41,458 --> 00:03:46,667
we did that, that would completely break
CPA security here, because some bits of

98
00:03:41,458 --> 00:03:46,667
但是如果我们这么做了，将会完全破坏CPA的安全性，因为明文中的

99
00:03:46,667 --> 00:03:51,815
the message are leaked in the cipher text.
And so the SSH approach, even though the

100
00:03:46,667 --> 00:03:51,815
的某几位会在密文中泄露。因此即使SSH的

101
00:03:51,815 --> 00:03:56,595
specifics of SSH are fine and the
protocol itself is not compromised by

102
00:03:51,815 --> 00:03:56,595
特性很好并且协议本身没有因这种特定

103
00:03:56,595 --> 00:04:00,818
this specific combination, generally it's
advisable not to use this approach. Simply

104
00:03:56,595 --> 00:04:00,818
的结合而妥协，还是不建议使用这种SSH方式

105
00:04:00,818 --> 00:04:05,928
because the output of the MAC signing algorithm might leak bits of the message. So

106
00:04:00,818 --> 00:04:05,928
因为MAC这种签名算法可能会泄露明文中的几位。

107
00:04:05,928 --> 00:04:11,481
now let's look at SSL and IPsec. As it
turns out, the recommended method actually

108
00:04:05,928 --> 00:04:11,481
因此让我们看一下SSL和IPsec方式。事实证明，被推荐的方式

109
00:04:11,481 --> 00:04:16,556
is the IPsec method. Because it turns out
no matter what CPA secure system and MAC

110
00:04:11,481 --> 00:04:16,556
事实上是IPsec方式。因为结果表明，无论你使用CPA安全系统还是MAC密钥

111
00:04:16,556 --> 00:04:21,134
key you use the combination is always
gonna provide authenticated encryption.

112
00:04:16,556 --> 00:04:21,134
结合的结果总是能提供一个认证加密

113
00:04:21,134 --> 00:04:26,070
Now let me very, very briefly explain why.
Basically what happens is once we encrypt

114
00:04:21,134 --> 00:04:26,070
现在让我非常简明扼要的解释一下原因。基本上，一旦我们加密明文

115
00:04:26,070 --> 00:04:31,005
the message well the message contents now
is hidden inside the cipher text and now

116
00:04:26,070 --> 00:04:31,005
那么明文的内容就藏在了密文中

117
00:04:31,005 --> 00:04:35,761
when we compute a tag of the cipher text
basically we're locking, this tag locks

118
00:04:31,005 --> 00:04:35,761
现在当我们计算密文中的标签时这个标签给密文上了锁

119
00:04:35,761 --> 00:04:40,815
the cipher text and makes sure no one can
produce a different cipher text that would

120
00:04:35,761 --> 00:04:40,815
并且保证没有人能够再去产生一个看起来正当的与之不同的密文

121
00:04:40,815 --> 00:04:45,314
look valid. And as a result this approach
ensures that any modifications to the

122
00:04:40,815 --> 00:04:45,314
因此，这个方法确保任何对密文的修改

123
00:04:45,314 --> 00:04:49,555
cipher text will be detected by the
decrypter simply because the MAC isn't

124
00:04:45,314 --> 00:04:49,555
将会被解密者轻易地发现，因为MAC

125
00:04:49,555 --> 00:04:54,026
gonna verify. As it turns out, for the SSL
approach, there actually are kind of

126
00:04:49,555 --> 00:04:54,026
无法验证。结果表明，对于SSL方式来说，事实上存在

127
00:04:54,026 --> 00:04:59,348
pathological examples, where you combine
CPA secure encryption system with a secure

128
00:04:54,026 --> 00:04:59,348
病态的事例，当你将CPA安全加密系统和安全MAC结合时

129
00:04:59,348 --> 00:05:03,542
MAC. And the result is vulnerable to a
chosen cipher text attack, so that it does

130
00:04:59,348 --> 00:05:03,542
结果对于选择密文攻击是脆弱的，因此

131
00:05:03,542 --> 00:05:07,978
not actually provide authenticated
encryption. And basically, the reason that

132
00:05:03,542 --> 00:05:07,978
它事实上并没有提供认证加密。基本上，这个可能发生的原因是

133
00:05:07,978 --> 00:05:12,824
could happen, is that there's some sort of
a bad interaction between the encryption

134
00:05:07,978 --> 00:05:12,824
在加密体系和MAC算法之间存在某种

135
00:05:12,824 --> 00:05:17,319
scheme and the MAC algorithm. Such that,
in fact, there will be a chosen cipher

136
00:05:12,824 --> 00:05:17,319
不好的联系。事实上，会有一个选择密文攻击

137
00:05:17,319 --> 00:05:21,752
text attack. So if you're designing a new
project the recommendation now is to

138
00:05:17,319 --> 00:05:21,752
如果你设计了一个新的项目，现在总是推荐先加密

139
00:05:21,752 --> 00:05:26,162
always use encrypt then MAC because that
is secure no matter which CPA secure

140
00:05:21,752 --> 00:05:26,162
然后计算MAC，因为无论你组合了什么样的CPA安全加密和MAC算法

141
00:05:26,162 --> 00:05:30,607
encryption and secure MAC algorithm you're
combining. Now, just to set the

142
00:05:26,162 --> 00:05:30,607
得到的总和总是安全的。现在看个术语

143
00:05:30,607 --> 00:05:37,995
terminology, the SSL method is sometimes
called MAC-then-encrypt. And the

144
00:05:30,607 --> 00:05:37,995
这个SSL方法有时叫做“先MAC后加密”

145
00:05:37,995 --> 00:05:45,039
IPsec method is called encrypt-then-MAC.
The SSH method even though you're

146
00:05:37,995 --> 00:05:45,039
IPsec方法叫做“先加密后MAC”。尽管我们不应该使用SSH方法

147
00:05:45,039 --> 00:05:51,898
not supposed to use it, is called encrypt-and-MAC. Okay, so I'll often refer to

148
00:05:45,039 --> 00:05:51,898
但它也被叫做“先加密后MAC”。所以我会经常提到

149
00:05:51,898 --> 00:05:57,002
encrypt-then-MAC, and MAC-then-encrypt to
differentiate SSL and IPsec. Okay, so

150
00:05:51,898 --> 00:05:57,002
“先加密后MAC”和“先MAC后加密”来区分SSL和IPsec

151
00:05:57,002 --> 00:06:02,112
just to repeat what I've just said. The IPsec
method encrypt-then-MAC always

152
00:05:57,002 --> 00:06:02,112
重复一下我刚才所讲，IPsec方法“先加密后MAC”

153
00:06:02,112 --> 00:06:07,160
provides authenticated encryption. If you start
from a CPA secure cipher and a secure MAC

154
00:06:02,112 --> 00:06:07,160
总是提供认证加密。如果你从一个CPA安全密码和一个安全MAC出发

155
00:06:07,160 --> 00:06:11,110
you will always get authenticated
encryption. As I said, MAC-then-encrypt in

156
00:06:07,160 --> 00:06:11,110
你将总是得到认证加密。就像我所说的，事实上

157
00:06:11,110 --> 00:06:15,737
fact, there are pathological cases where
the result is vulnerable to CCA attacks and

158
00:06:11,110 --> 00:06:15,737
先MAC后加密有一些病态的情况，结果对CCA攻击是脆弱的

159
00:06:15,737 --> 00:06:20,308
therefore does not provide authenticated
encryption. However, the story's a little

160
00:06:15,737 --> 00:06:20,308
因此它并不提供认证加密。然而，实际上

161
00:06:20,308 --> 00:06:24,653
bit more interesting than that, in that,
it turns out, if you're actually using

162
00:06:20,308 --> 00:06:24,653
比这要有趣。如果你使用随机计数器模式

163
00:06:24,653 --> 00:06:29,224
randomized counter mode or randomized CBC,
then it turns out, for those particular

164
00:06:24,653 --> 00:06:29,224
或随机CBC，那么对那些CPA安全的加密机制

165
00:06:29,224 --> 00:06:33,625
CPA secure encryption schemes, MAC-then-encrypt
actually does provide authenticated

166
00:06:29,224 --> 00:06:33,625
先MAC后加密确实提供了认证加密

167
00:06:33,625 --> 00:06:38,028
encryption and therefore it is secure. In
fact, there's even a more interesting

168
00:06:33,625 --> 00:06:38,028
因此是安全的。事实上，更有趣的是

169
00:06:38,028 --> 00:06:42,334
twist here in that if you're using
randomized counter mode. Then, it's enough

170
00:06:38,028 --> 00:06:42,334
如果你使用了随机计数器模式

171
00:06:42,334 --> 00:06:46,804
that your MAC algorithm just be one time
secure. It doesn't have to be a fully

172
00:06:42,334 --> 00:06:46,804
那么你的MAC算法只要是一次性安全的就够了，不需要是完全安全的MAC

173
00:06:46,804 --> 00:06:51,561
secure MAC. It just has to be secure when
a key is used to encrypt a single message,

174
00:06:46,804 --> 00:06:51,561
只需要当密钥只用于加密单个信息时是安全的即可

175
00:06:51,561 --> 00:06:56,088
okay? And when we talked about message
integrity, we saw that there are actually

176
00:06:51,561 --> 00:06:56,088
我们讨论信息完整性时，看到过有一些

177
00:06:56,088 --> 00:07:00,575
much faster MACs that are one time secure
than MACs that are fully secure. As a

178
00:06:56,088 --> 00:07:00,575
快得多的MAC算法，它们是一次性安全的，而非完全安全的MAC

179
00:07:00,575 --> 00:07:04,454
result, if you're using randomized counter
mode MAC-then-encrypt could actually

180
00:07:00,575 --> 00:07:04,454
因此如果你使用随机计数器模式，先MAC后加密

181
00:07:04,454 --> 00:07:08,187
result in a more efficient encryption
mechanism. However, I'm going to repeat

182
00:07:04,454 --> 00:07:08,187
实际上可以构造一个更有效率的加密机制。但我还要重复一遍

183
00:07:08,187 --> 00:07:12,213
this again. The recommendation is to use
encrypt-then-MAC and we're going to see a

184
00:07:08,187 --> 00:07:12,213
推荐使用先加密后MAC

185
00:07:12,213 --> 00:07:16,093
number of attacks on systems that didn't
use encrypt-then-MAC. And so just to make

186
00:07:12,213 --> 00:07:16,093
我们将看到许多针对未使用先加密后MAC的系统的攻击

187
00:07:16,093 --> 00:07:20,120
sure things are secure without you having
to think too hard about this. Again, I am

188
00:07:16,093 --> 00:07:20,120
为了确保安全，同时不必思考太多

189
00:07:20,120 --> 00:07:24,118
going to recommend that you always use
encrypt-then-MAC. Now, once the concept of

190
00:07:20,120 --> 00:07:24,118
我推荐大家始终使用先加密后MAC

191
00:07:24,118 --> 00:07:27,759
authenticated encryption became more
popular, a number of standardized

192
00:07:24,118 --> 00:07:27,759
现在一旦认证加密的观念变得更流行

193
00:07:27,759 --> 00:07:31,609
approaches for combining encryption and
MAC turned up. And those were even

194
00:07:27,759 --> 00:07:31,609
很多组合加密和MAC的标准方法便涌现出来

195
00:07:31,609 --> 00:07:35,978
standardized by the National Institute of
Standards. So I'm just gonna mention three

196
00:07:31,609 --> 00:07:35,978
还有些是国家标准局（NIST）的标准方法。我们将讨论其中三个标准

197
00:07:35,978 --> 00:07:41,031
of these standards. Two of these were
standardized by NIST. And these are

198
00:07:35,978 --> 00:07:41,031
其中两个是由NIST标准化的

199
00:07:41,031 --> 00:07:46,138
called Galois counter mode and CBC counter
mode. And so let me explain what they do.

200
00:07:41,031 --> 00:07:46,138
分别叫做Galois计数器模式（GCM）和CBC计数器模式（CCM）我来解释一下它们的工作过程

201
00:07:46,138 --> 00:07:51,245
Galois counter mode basically uses counter
mode encryption, so a randomized counter

202
00:07:46,138 --> 00:07:51,245
Galois计数器模式使用了计数器模式加密

203
00:07:51,245 --> 00:07:56,164
mode with a Carter-Wegman MAC, so a very
fact Carter-Wegman MAC. And the way the

204
00:07:51,245 --> 00:07:56,164
即使用Carter-Wegman MAC的随机计数器模式，一个非常快速的Carter-Wegman MAC

205
00:07:56,164 --> 00:08:01,146
Carter-Wegman MAC works in GCM is it's
basically a hash function of the message

206
00:07:56,164 --> 00:08:01,146
GCM的Carter-Wegman MAC如下工作：它是待求MAC的信息的一个哈希函数

207
00:08:01,146 --> 00:08:06,311
that's being MACed. And then the result is
encrypted using a PRF. Now this hash

208
00:08:01,146 --> 00:08:06,311
然后用一个PRF加密哈希的结果

209
00:08:06,311 --> 00:08:11,562
function in GCM is already quite fast to
the point where the bulk of the running

210
00:08:06,311 --> 00:08:11,562
现在GCM里的这个哈希函数已经很快了

211
00:08:11,562 --> 00:08:15,845
time of GCM is dominated by the counter
mode encryption and it's even made more so

212
00:08:11,562 --> 00:08:15,845
GCM的运行时间受制于计数器模式

213
00:08:15,845 --> 00:08:22,371
in that Intel introduces a special
instruction PCLMULQDQ specifically

214
00:08:15,845 --> 00:08:22,371
为了更快，Intel引入了一个特殊指令PCLMULQDQ

215
00:08:22,371 --> 00:08:27,432
designed for the purpose of making the
hash function in GCM run as fast as possible.

216
00:08:22,371 --> 00:08:27,432
特别为此设计，目标是让GCM的这个哈希函数跑的尽可能的快

217
00:08:27,432 --> 00:08:32,950
Now CCM counter mode is another
NIST standard. It uses a CBC MAC and

218
00:08:27,432 --> 00:08:32,950
现在CCM计数器模式是另一个NIST标准，它使用CBC MAC

219
00:08:32,950 --> 00:08:37,276
then counter mode encryption. So this
mechanism, you know, this uses MAC, then

220
00:08:32,950 --> 00:08:37,276
然后用计数器模式加密。这个机制使用MAC

221
00:08:37,276 --> 00:08:40,906
encrypt, like SSL does. So this is
actually not the recommended way of doing

222
00:08:37,276 --> 00:08:40,906
然后加密，就像SSL那样。这并不是推荐的方法

223
00:08:40,906 --> 00:08:44,023
things, but because counter mode
encryption is used. This is actually a

224
00:08:40,906 --> 00:08:44,023
但因为使用的是计数器模式，这实际上

225
00:08:44,023 --> 00:08:47,945
perfectly fine encryption mechanism. One
thing that I'd like to point out about

226
00:08:44,023 --> 00:08:47,945
是一个很好的加密机制。关于CCM我要指出一点

227
00:08:47,945 --> 00:08:53,799
CCM, is that everything is based on AES.
You notice, it's using AES for the CBC

228
00:08:47,945 --> 00:08:53,799
一切都是基于AES的。大家注意，它的CBC-MAC使用了AES

229
00:08:53,799 --> 00:08:58,778
MAC, and it's using AES for the counter
mode encryption. And as a result, CCM can

230
00:08:53,799 --> 00:08:58,778
它的计数器模式也是使用的AES

231
00:08:58,778 --> 00:09:03,084
be implemented with relatively little
code. Cause all you need is an AES engine

232
00:08:58,778 --> 00:09:03,084
因此CCM可以用相对少的代码实现，因为需要的仅为AES引擎

233
00:09:03,084 --> 00:09:08,343
and nothing else. And because of this, CCM
actually was adopted by the Wi-Fi

234
00:09:03,084 --> 00:09:08,343
其他都不需要，因为这点，CCM被Wi-Fi所采用

235
00:09:08,343 --> 00:09:13,963
alliance, and in fact, you're probably
using CCM on a daily basis if you're using

236
00:09:08,343 --> 00:09:13,963
事实上，你很有可能每天都在使用CCM

237
00:09:13,963 --> 00:09:19,093
encrypted Wi-Fi 802.11i then you're
basically using CCM to encrypt traffic

238
00:09:13,963 --> 00:09:19,093
如果你使用加密的Wi-Fi 802.11i，那么你就在使用CCM来加密

239
00:09:19,093 --> 00:09:23,450
between your laptop and the access point.
There's another mode called a EAX that

240
00:09:19,093 --> 00:09:23,450
你的笔记本和接入点之间的通信。还有一个模式叫做EAX

241
00:09:23,450 --> 00:09:28,922
uses counter mode encryption, and then
CMAC. So, again you notice encrypt-then-MAC

242
00:09:23,450 --> 00:09:28,922
使用的计数器模式加密，然后是CMAC，大家注意，这次是先加密后MAC

243
00:09:28,922 --> 00:09:31,906
and that's another fine mode to
use. We'll do a comparison of all these

244
00:09:28,922 --> 00:09:31,906
这是另一个很好的模式。我们待会来对这些模式做个比较

245
00:09:31,906 --> 00:09:36,806
modes in just a minute. Now I wanted to
mention that first of all, all these modes are

246
00:09:31,906 --> 00:09:36,806
现在我想提一下，首先，所有的这些模式都是基于新鲜值的

247
00:09:36,806 --> 00:09:41,190
nonce-based. In other words, they don't
use any randomness but they do take as

248
00:09:36,806 --> 00:09:41,190
换句话说它们不使用任何随机性，但它们取新鲜值为输入

249
00:09:41,190 --> 00:09:46,360
input a nonce and the nonce has to be
unique per key. In other words, as you

250
00:09:41,190 --> 00:09:46,360
而且每个密钥的新鲜值是唯一的，换句话说

251
00:09:46,360 --> 00:09:50,600
remember, the pair (key, nonce)
should never ever, ever repeat. But the

252
00:09:46,360 --> 00:09:50,600
大家记得，有序对（密钥，新鲜值）永远不该重复使用

253
00:09:50,600 --> 00:09:53,851
nonce itself need not be random, so
it's perfectly fine to use a counter, for

254
00:09:50,600 --> 00:09:53,851
但新鲜值本身不一定是随机的，所以完全可以使用一个计数器

255
00:09:53,851 --> 00:09:57,520
example, as a nonce. And the other
important point is that, in fact, all

256
00:09:53,851 --> 00:09:57,520
比如新鲜值。另一个重要的地方是，事实上

257
00:09:57,520 --> 00:10:01,384
these modes are what's called
authenticated encryption with associated

258
00:09:57,520 --> 00:10:01,384
所有的这些模式被称为带相关数据的认证加密（AEAD）

259
00:10:01,384 --> 00:10:04,936
data. This is an extension of
authenticated encryption, that comes

260
00:10:01,384 --> 00:10:04,936
这是一个认证加密的扩展

261
00:10:04,936 --> 00:10:10,884
up very often in networking protocols. So
the idea between AEAD is that, in fact,

262
00:10:04,936 --> 00:10:10,884
这在网络协议中经常出现，AEAD的想法是

263
00:10:10,884 --> 00:10:15,223
the message that's provided to the encryption
mode is not intended to be fully

264
00:10:10,884 --> 00:10:15,223
提供给加密模式的信息不被完全

265
00:10:15,223 --> 00:10:19,924
encrypted.Only part of the message is
intended to be encrypted, but all of the

266
00:10:15,223 --> 00:10:19,924
加密 只有部分信息是被加密的

267
00:10:19,924 --> 00:10:24,157
message is intended to be authenticated. A
good example of this is a network packet.

268
00:10:19,924 --> 00:10:24,157
但所有信息是被认证的 这里有一个好例子是网络数据包只有部分信息是被加密的

269
00:10:24,157 --> 00:10:29,408
Think of like a IP packet where there's a
header and then there's a payload. And

270
00:10:24,157 --> 00:10:29,408
考虑一个IP包 有报文头 然后是封装数据

271
00:10:29,408 --> 00:10:33,157
typically the header is not gonna be
encrypted. For example, the header might

272
00:10:29,408 --> 00:10:33,157
一般来说 报文头不会被加密 例如报文头可能包含

273
00:10:33,157 --> 00:10:36,905
contain the destination of the packet, but
then the header had better not be

274
00:10:33,157 --> 00:10:36,905
数据包的目标地址 那么报文头最好不要被加密

275
00:10:36,905 --> 00:10:40,950
encrypted otherwise routers along the way
wouldn't know where to route the packet.

276
00:10:36,905 --> 00:10:40,950
免得图中的路由器不知道如何路由

277
00:10:40,950 --> 00:10:45,225
And so, typically the header is sent in
the clear, but the payload, of course, is

278
00:10:40,950 --> 00:10:45,225
一般来说 报文头以明文形式发送 但当然

279
00:10:45,225 --> 00:10:49,500
always encrypted, but what you'd like to
do is have the header be authenticated.

280
00:10:45,225 --> 00:10:49,500
封装数据总是被加密的 不过你还是希望报文头被认证

281
00:10:49,500 --> 00:10:55,907
Not encrypted but authenticated. So this is
exactly what these AEAD modes do. They

282
00:10:49,500 --> 00:10:55,907
不用加密 但需认证 那么这就是这些AED模式的工作

283
00:10:55,907 --> 00:11:00,033
will authenticate the header and then
encrypt the payload. But the header and

284
00:10:55,907 --> 00:11:00,033
他们会认证报文头 然后加密封装数据

285
00:11:00,033 --> 00:11:04,177
the payload are bound together in the
authentication so they can't

286
00:11:00,033 --> 00:11:04,177
但在认证中 报文头和封装数据是被绑定在一起的

287
00:11:04,177 --> 00:11:07,803
actually be separated. So this is not
difficult to do. What happens is in these

288
00:11:04,177 --> 00:11:07,803
这样它们不能分开 这不能做到

289
00:11:07,803 --> 00:11:14,170
three modes GCM, CCM, and EAX, basically
the MAC is applied to the entire data. But

290
00:11:07,803 --> 00:11:14,170
在这三种模式GCM CCM和EAX中 MAC应用到整个报头文数据上

291
00:11:14,170 --> 00:11:18,852
the encryption is only applied to the part
of the data that needs to be encrypted.

292
00:11:14,170 --> 00:11:18,852
不过加密只被应用到部分需要加密的数据上

293
00:11:18,852 --> 00:11:22,983
So I wanted to show you what an API
to these authenticated encryption with

294
00:11:18,852 --> 00:11:22,983
所以我想为大家展示一个带相关数据的认证加密的API

295
00:11:22,983 --> 00:11:28,716
associated data encryption schemes look
like. So here's what it looks like in OpenSSL.

296
00:11:22,983 --> 00:11:28,716
长什么样 它在OpenSSL中长这样

297
00:11:28,716 --> 00:11:33,609
For example, this is, an API
for GCM. So what you do is you call the

298
00:11:28,716 --> 00:11:33,609
例如 这是一个GCM的API 你可以调用init函数

299
00:11:33,609 --> 00:11:37,404
init function to initialize the encryption
mode, and you notice you give it a key and

300
00:11:33,609 --> 00:11:37,404
来初始化这个加密模式 然后注意到它一个密钥和新鲜值

301
00:11:37,404 --> 00:11:40,609
the nonce. The nonce again,
doesn't have to be random, but it has to

302
00:11:37,404 --> 00:11:40,609
这个新鲜值也不必是随机的 但它必须是唯一的

303
00:11:40,609 --> 00:11:44,402
be unique. And after initialization, you
would call this encrypt function, where

304
00:11:40,609 --> 00:11:44,402
初始化后 调用这个加密函数

305
00:11:44,402 --> 00:11:48,169
you see that you give it the associated
data that's gonna be authenticated, but

306
00:11:44,402 --> 00:11:48,169
给它需要认证 但不需要加密的相关数据

307
00:11:48,169 --> 00:11:51,794
not encrypted. You give it the data, and
it's gonna be both authenticated and

308
00:11:48,169 --> 00:11:51,794
然后给它需要认证和加密的数据

309
00:11:51,794 --> 00:11:55,752
encrypted. And it gives you back the full
cipher text, which is an encryption of the

310
00:11:51,794 --> 00:11:55,752
函数就会返回整个数据加密后的密文

311
00:11:55,752 --> 00:11:59,582
data, but of course does not include the
AEAD, because the AEAD is gonna be sent in

312
00:11:55,752 --> 00:11:59,582
不过当然 不包括AED 因为AED需要以明文形式发送

313
00:11:59,582 --> 00:12:04,535
the clear. So now that we understand
this mode of encrypt-then-MAC, we can go

314
00:11:59,582 --> 00:12:04,535
那么我们现在理解了这个“先加密后MAC”的机制

315
00:12:04,535 --> 00:12:09,951
back to the definition of MAC security and
I can explain to you something that might

316
00:12:04,535 --> 00:12:09,951
我们可以回到MAC的安全性定义 我可以为大家解释

317
00:12:09,951 --> 00:12:13,970
have been a little obscure when we looked
at that definition. So if you remember,

318
00:12:09,951 --> 00:12:13,970
定义里一些看起来略难懂的地方 如果大家还记得

319
00:12:13,970 --> 00:12:18,570
one of the requirements that followed from
our definition of secure MACs meant that

320
00:12:13,970 --> 00:12:18,570
安全MAC定义的要求之一是 如果大家还记得

321
00:12:18,570 --> 00:12:25,689
given a message-MAC pair on a message M,
the attacker cannot produce another tag on

322
00:12:18,570 --> 00:12:25,689
给定信息M的信息 MAC对 攻击者不能产生

323
00:12:25,689 --> 00:12:30,386
the same message M. In other words, even
though the attacker already has a tag for

324
00:12:25,689 --> 00:12:30,386
同样的信息M的另一个标签 换句话说 即使攻击者已经有了信息M的一个标签

325
00:12:30,386 --> 00:12:34,771
the message M, he shouldn't be able to
produce a new tag for the same message M.

326
00:12:30,386 --> 00:12:34,771
他也不能产生同样信息M的一个新标签

327
00:12:34,771 --> 00:12:39,382
And it's really not clear, why does that
matter? Who cares, if the adversary already

328
00:12:34,771 --> 00:12:39,382
还不太清楚为什么这点很要紧 谁在乎这点呢 如果攻击者已经

329
00:12:39,382 --> 00:12:44,038
has a tag on the message M, who cares if
he can produce another tag? Well, it turns

330
00:12:39,382 --> 00:12:44,038
有了信息M的一个标签 谁在乎他是否能产生另一个标签？

331
00:12:44,038 --> 00:12:48,828
out if the MAC didn't have this property.
In other words, given a message-MAC pair

332
00:12:44,038 --> 00:12:48,828
实际上如果MAC没有这一性质 换句话说 给定一对信息和MAC

333
00:12:48,828 --> 00:12:53,618
you can produce another MAC on
the same message, then that MAC would

334
00:12:48,828 --> 00:12:53,618
你能产生同样信息的另一个MAC 那么这个MAC会造成一个不安全的“先加密后MAC”

335
00:12:53,618 --> 00:12:58,694
result in an insecure encrypt-then-MAC mode.
And so if we want our encrypt-then-MAC to

336
00:12:53,618 --> 00:12:58,694
的模式 如果我们想让我们的“先加密后MAC”

337
00:12:58,694 --> 00:13:03,961
have cipher text integrity, it's crucial
that our MAC security would imply this strong

338
00:12:58,694 --> 00:13:03,961
具有密文完整性 很重要的一点是 我们的MAC的安全性

339
00:13:03,961 --> 00:13:08,910
notion of security, which, of course, it
does because we defined it correctly.

340
00:13:03,961 --> 00:13:08,910
蕴含着这个安全观点 当然这是因为我们定义的正确

341
00:13:08,910 --> 00:13:13,613
So let's see what would go wrong, if, in
fact, it was easy to produce this type of

342
00:13:08,910 --> 00:13:13,613
那么我们看会出错的 事实上容易产生这种伪造

343
00:13:13,613 --> 00:13:18,081
forgery. So what I'll do is I'll show you
a chosen cipher text attack on the

344
00:13:13,613 --> 00:13:18,081
我会告诉大家一种在“先加密后MAC”系统上的选择密文攻击

345
00:13:18,081 --> 00:13:22,784
resulting encrypt-then-MAC system. And
since the system has a chosen cipher text

346
00:13:18,081 --> 00:13:22,784
由于这个系统有一种选择密文攻击

347
00:13:22,784 --> 00:13:27,193
attack on it, it necessarily means that it
doesn't provide authenticated

348
00:13:22,784 --> 00:13:27,193
这就意味着它不提供认证加密

349
00:13:27,193 --> 00:13:31,458
encryption. So let's see. So the
adversary's gonnna start by sending two

350
00:13:27,193 --> 00:13:31,458
我们来看看 一开始 攻击者发送两个信息

351
00:13:31,458 --> 00:13:35,861
messages, M0 and M1. And he's gonna
receive, as usual, the encryption of one

352
00:13:31,458 --> 00:13:35,861
M0和M1 通常他会收到

353
00:13:35,861 --> 00:13:39,522
of them, either the encryption of M0 or
the encryption of M1. And since we're

354
00:13:35,861 --> 00:13:39,522
M0或M1的加密结果 由于我们使用“先加密后MAC”

355
00:13:39,522 --> 00:13:44,907
using encrypt-then-MAC, the adversary
receives the cipher text we'll call it C0

356
00:13:39,522 --> 00:13:44,907
攻击者收到的密文我们记为C0

357
00:13:44,907 --> 00:13:49,883
and a MAC on the cipher text C0.
Well now we said that given the MAC on

358
00:13:44,907 --> 00:13:49,883
C0上有一MAC 我们说过 给定信息的MAC

359
00:13:49,883 --> 00:13:53,827
a message the adversary can produce
another MAC on the same message. So what

360
00:13:49,883 --> 00:13:53,827
攻击者可以产生同样信息的另一个MAC

361
00:13:53,827 --> 00:13:57,994
he's gonna do is he's gonna produce
another MAC on the message C0. Now he has

362
00:13:53,827 --> 00:13:57,994
这样他将产生信息C0的另一个MAC

363
00:13:57,994 --> 00:14:03,532
a new cipher text (C0,T'), which is a
perfectly valid cipher text. T' is a

364
00:13:57,994 --> 00:14:03,532
现在他有了一个新的密文（C0，T') 是一个完全有效的密文

365
00:14:03,532 --> 00:14:09,558
valid MAC of C0. Therefore, the adversary
now can submit a chosen cipher text query

366
00:14:03,532 --> 00:14:09,558
T'是C0的一个有效MAC 所以 攻击者可以提交

367
00:14:09,558 --> 00:14:14,492
on C' and this is a valid chosen
cipher text query because it's different

368
00:14:09,558 --> 00:14:14,492
C'和一个选择密文的询问 这是一个有效的选择密文的询问

369
00:14:14,492 --> 00:14:19,288
from C. It's a new cipher text. The poor
challenger now is forced to decrypt this

370
00:14:14,492 --> 00:14:19,288
因为它和C不同 它是一个新的密文 可怜的挑战者

371
00:14:19,288 --> 00:14:23,278
cipher text C' so he's going to send
back the decryption of C'. It's a

372
00:14:19,288 --> 00:14:23,278
被迫去解密这个密文C' 然后发送C'的解密

373
00:14:23,278 --> 00:14:29,093
valid cipher text therefore the decryption
of C prime is the message Mb but now the

374
00:14:23,278 --> 00:14:29,093
它是一个有效的密文 所以C'的解密是信息Mb

375
00:14:29,093 --> 00:14:32,318
attacker just learned the value of B
because he can test whether Mb is equal to

376
00:14:29,093 --> 00:14:32,318
但现在攻击者就学得了b的值 因为他可以测试

377
00:14:32,318 --> 00:14:37,371
M0 or MB is equal to M1. As a result he
can just output B and he gets advantage

378
00:14:32,318 --> 00:14:37,371
Mb等于M0还是M1 因此他能输出b

379
00:14:37,371 --> 00:14:43,468
one in defeating the scheme. And so
again if our MAC security did not imply

380
00:14:37,371 --> 00:14:43,468
以优势1赢得这个机制 如果我们的MAC的安全性不蕴含这里的性质

381
00:14:43,468 --> 00:14:48,471
this property here. Then, there would be a
chosen cipher text attack on encrypt-then-MAC.

382
00:14:43,468 --> 00:14:48,471
那么在这个“先加密后MAC”的系统上有一个选择密文攻击

383
00:14:48,471 --> 00:14:53,181
And therefore, it would not be secure. So the
fact that we define MAC security correctly

384
00:14:48,471 --> 00:14:53,181
因此 它将是不安全的 所以我们正确定义了MAC的安全性

385
00:14:53,181 --> 00:14:57,241
means that encrypt-then-MAC really does
provide authenticated encryption. And

386
00:14:53,181 --> 00:14:57,241
意味着“先加密后MAC”的确提供了认证加密

387
00:14:57,241 --> 00:15:01,728
throughout all the MACs that we discussed
actually do satisfy this strong notion of

388
00:14:57,241 --> 00:15:01,728
我们讨论过的所有MAC都满足这一很强的不可伪造的观点

389
00:15:01,728 --> 00:15:06,146
unforgeability. So, interestingly, this is
not the end of the story. So, as we said

390
00:15:01,728 --> 00:15:06,146
有趣的是 故事还没有结束

391
00:15:06,146 --> 00:15:10,385
before the concept of authenticated
encryption was introduced everyone was

392
00:15:06,146 --> 00:15:10,385
我们在引入认证加密的概念之前曾经说过

393
00:15:10,385 --> 00:15:15,295
just combining MACs and encryption in
various ways in the hope of achieving

394
00:15:10,385 --> 00:15:15,295
人们以不同的方式组合MAC和加密 以获得认证加密

395
00:15:15,295 --> 00:15:19,201
some authenticated encryption. After
the notion of authenticated encryption

396
00:15:15,295 --> 00:15:19,201
在认证加密的观点被严格地形式化后

397
00:15:19,201 --> 00:15:23,553
became formalized and rigorous, people
kind of started scratching their heads and said,

398
00:15:19,201 --> 00:15:23,553
人们开始搔脑袋 说

399
00:15:23,553 --> 00:15:28,130
hey, wait a minute. Maybe we can achieve
authenticated encryption more efficiently

400
00:15:23,553 --> 00:15:28,130
嘿 等一下 或许我们可以获取到

401
00:15:28,130 --> 00:15:32,722
than by combining a MAC and an encryption
scheme. In fact, if you think about how

402
00:15:28,130 --> 00:15:32,722
更加有效的获得认证加密。事实上

403
00:15:32,722 --> 00:15:37,366
this combination of MAC and encryption
works, let's say we combine counter mode

404
00:15:32,722 --> 00:15:37,366
如果考虑MAC和加密的组合是如何工作的，比如说组合计数器模式和CMAC

405
00:15:37,366 --> 00:15:42,134
with CMAC, then for every block of
plaintext, you first of all have to use

406
00:15:37,366 --> 00:15:42,134
那么对每个明文分组，首先必须使用

407
00:15:42,134 --> 00:15:46,419
your block cipher for counter mode, and
then you have to use to your block cipher

408
00:15:42,134 --> 00:15:46,419
你的分组密码以计数器模式，然后必须再次使用分组密码

409
00:15:46,419 --> 00:15:51,357
again, for the CBC-MAC. This means that if
you're combining CPA secure encryption with a

410
00:15:46,419 --> 00:15:51,357
运行CBC-MAC。这意味着如果你把CPA安全的加密

411
00:15:51,357 --> 00:15:55,943
MAC, for every block of plaintext, you
have to evaluate your block cipher twice,

412
00:15:51,357 --> 00:15:55,943
和一个MAC组合起来，对每个明文分组，你必须计算你的分组密码两次

413
00:15:55,943 --> 00:16:00,535
once for the MAC and once for the
encryption scheme. So the natural question

414
00:15:55,943 --> 00:16:00,535
一次计算MAC，一次计算加密机制

415
00:16:00,535 --> 00:16:05,396
was, can we construct an authenticated
encryption scheme directly from a PRP,

416
00:16:00,535 --> 00:16:05,396
自然问题就来了，我们能否由一个PRP直接构建一个认证加密机制

417
00:16:05,396 --> 00:16:10,345
such that we would have to only evaluate
the PRP once per block? And it turns out

418
00:16:05,396 --> 00:16:10,345
这样一来我们可以对每个分组，只计算PRP一次

419
00:16:10,345 --> 00:16:14,117
the answer is yes, and there's this
beautiful construction called OCB, that

420
00:16:10,345 --> 00:16:14,117
实际上答案是肯定的，有这个漂亮的构造叫做OCB

421
00:16:14,117 --> 00:16:18,343
pretty much does everything you want, and
is much faster than constructions that are

422
00:16:14,117 --> 00:16:18,343
它能做你想要的一切，而且比从加密和MAC分别构造的机

423
00:16:18,343 --> 00:16:22,467
separately built from an encryption and a
MAC. So I wrote down, kind of a schematic

424
00:16:18,343 --> 00:16:22,467
快很多。那么我写下了OCB的机制

425
00:16:22,467 --> 00:16:26,290
of OCB. I don't want to explain it in
detail. I'll just kind of explain it at a

426
00:16:22,467 --> 00:16:26,290
我不想解释太多细节。我从高层次来解释一下

427
00:16:26,290 --> 00:16:30,025
high level. So here we have our input
plain text, here at the top. And you

428
00:16:26,290 --> 00:16:30,025
这里有我们的输入明文，在这上面

429
00:16:30,025 --> 00:16:34,540
notice that, first of all, OCB is
parallelizable, completely parallelizable.

430
00:16:30,025 --> 00:16:34,540
大家注意，首先，OCB是可并行的，完全可并行的

431
00:16:34,540 --> 00:16:39,700
So every block can be encrypted separately of
every other block. The other thing to

432
00:16:34,540 --> 00:16:39,700
所以每个分组可以被单独加密

433
00:16:39,700 --> 00:16:44,338
notice is that as I promised, you only
evaluate your block cipher once per plain

434
00:16:39,700 --> 00:16:44,338
另一件事是，如我所保证的，对每个明文分组，你只需计算一次分组密码

435
00:16:44,338 --> 00:16:49,318
text block. And then you evaluate it one
more time at the end to build your

436
00:16:44,338 --> 00:16:49,318
然后在最后再计算一次分组密码，以构建

437
00:16:49,318 --> 00:16:53,887
authentication tag and then the overhead
of OCB beyond just a block cipher is

438
00:16:49,318 --> 00:16:53,887
认证标签，那么除去分组密码部分，OCB的开销是最小的

439
00:16:53,887 --> 00:16:58,749
minimal. All you have to do is evaluate a
certain very simple function P. The

440
00:16:53,887 --> 00:16:58,749
你只需计算一个非常简单的函数P

441
00:16:58,749 --> 00:17:02,844
nonce goes into the P you notice, the
key goes into this P and then there is a

442
00:16:58,749 --> 00:17:02,844
新鲜值交给了P，密钥也给了P

443
00:17:02,844 --> 00:17:08,238
block counter that goes into this P. So
you just evaluate this function P, twice

444
00:17:02,844 --> 00:17:08,238
然后还有一个分组计数器交给了P。所以你只需计算这个函数P

445
00:17:08,238 --> 00:17:12,748
for every block and you XOR the result
before and after encryption using the

446
00:17:08,238 --> 00:17:12,748
每个分组两次，然后与之前的结果异或

447
00:17:12,748 --> 00:17:17,553
block cipher and that's it. That's all you
have to do and then you get a very fast

448
00:17:12,748 --> 00:17:17,553
使用分组密码加密之后，就结束了。你获得了

449
00:17:17,553 --> 00:17:22,241
and efficient authenticated encryption
scheme built from a block cipher. So OCB

450
00:17:17,553 --> 00:17:22,241
一个快速有效的，由分组密码构建的认证加密机制

451
00:17:22,241 --> 00:17:26,065
actually has a nice security theorem
associated with it and I am going to point

452
00:17:22,241 --> 00:17:26,065
所以OCB有一个附带的很好的安全性定理

453
00:17:26,065 --> 00:17:29,567
to a paper on OCB when we get to end of
this module where I list some further

454
00:17:26,065 --> 00:17:29,567
在本章末，我要指出一篇关于OCB的论文

455
00:17:29,567 --> 00:17:34,457
reading papers that you can take a look
at. So you might be wondering if OCB is so

456
00:17:29,567 --> 00:17:34,457
届时我会列出一些大家可进一步阅读的论文。大家可能想知道

457
00:17:34,457 --> 00:17:40,168
much better than everything you've seen so
far, all these three standards CCM, GCM and

458
00:17:34,457 --> 00:17:40,168
如果OCB比目前看到过的其他机制都好，包括CCM,GCM

459
00:17:40,168 --> 00:17:46,037
EAX why isn't OCB being used or why isn't
OCB the standard? And the answer is a

460
00:17:40,168 --> 00:17:46,037
以及EAX，为什么OCB没怎么被使用？为什么OCB不是标准？

461
00:17:46,037 --> 00:17:50,729
little sad. The primary answer that
OCB is not being used is actually because

462
00:17:46,037 --> 00:17:50,729
这是个令人悲伤的答案。OCB没被应用的主要原因

463
00:17:50,729 --> 00:17:54,567
of various patents. And I'll just leave it
at that. So to conclude this section I

464
00:17:50,729 --> 00:17:54,567
是因为各种各样的专利。我这里就不提了。

465
00:17:54,567 --> 00:17:58,216
wanted to show you some performance
numbers. So here on the right I listed

466
00:17:54,567 --> 00:17:58,216
总结一下本书，我想给大家一些性能参数

467
00:17:58,216 --> 00:18:02,368
performance numbers for modes that you
shouldn't be using. So this is for

468
00:17:58,216 --> 00:18:02,368
右边我列了这些大家不该用的模式的性能参数

469
00:18:02,368 --> 00:18:07,879
randomized counter mode, and this is for
randomized CBC. And you can see also the

470
00:18:02,368 --> 00:18:07,879
这是随机计数器模式，这是随机CBC

471
00:18:07,879 --> 00:18:12,460
performance of CBC MAC is basically the
same as the performance of CBC encryption.

472
00:18:07,879 --> 00:18:12,460
大家还可以看到CBC-MAC的性能和CBC加密的性能基本一样

473
00:18:12,460 --> 00:18:16,221
Okay. Now here are the authenticated
encryption modes, so these are the ones

474
00:18:12,460 --> 00:18:16,221
现在这里是认证加密模式

475
00:18:16,221 --> 00:18:20,083
that you're supposed to using, these
you're not supposed to be using on their

476
00:18:16,221 --> 00:18:20,083
所以这些是大家应当使用的模式了，右边的大家不要用

477
00:18:20,083 --> 00:18:23,795
own, right. These two, you should never
ever use these two because they only

478
00:18:20,083 --> 00:18:23,795
这两个，大家永远不应该使用这两个

479
00:18:23,795 --> 00:18:27,858
provide CPA security, they don't
actually provide security against active

480
00:18:23,795 --> 00:18:27,858
因为它们只提供CPA安全它们不提供对抗主动攻击的安全性

481
00:18:27,858 --> 00:18:31,669
attacks. You're only supposed to use
authenticated encryption for encryption.

482
00:18:27,858 --> 00:18:31,669
大家只应该使用认证加密来进行加密

483
00:18:31,669 --> 00:18:35,509
And so I listed performance numbers
for the three standards. And let me remind

484
00:18:31,669 --> 00:18:35,509
所以我列了这三个标准的性能参数

485
00:18:35,509 --> 00:18:40,109
you that GCM basically uses a very fast
hash. And then it uses counter mode for

486
00:18:35,509 --> 00:18:40,109
让我提醒大家，GCM使用了非常快速的哈希函数。然后它在加密中使用了计数器模式

487
00:18:40,109 --> 00:18:43,770
actual encryption. And you can see that
the overhead of GCM over counter mode is

488
00:18:40,109 --> 00:18:43,770
你可以看到，计数器模式的GCM的开销

489
00:18:43,770 --> 00:18:49,554
relatively small. CCM and EAX both use a
block cipher based encryption and a

490
00:18:43,770 --> 00:18:49,554
相对是很小的。CCM和EAX都使用了一个基于分组密码的加密

491
00:18:49,554 --> 00:18:54,627
block cipher based MAC. And as a result
they're about twice as slow as counter

492
00:18:49,554 --> 00:18:54,627
和一个基于分组密码的MAC。因此它们的运行时间大约是计数器模式的两倍

493
00:18:54,627 --> 00:18:59,196
modes. You see that OCB is actually the
fastest of these, primarily because it

494
00:18:54,627 --> 00:18:59,196
大家看到，OCB是这些当中最快的

495
00:18:59,196 --> 00:19:03,820
only use the block cipher once per message
block. So based on these performance

496
00:18:59,196 --> 00:19:03,820
主要是因为它对每个明文只使用一次分组密码

497
00:19:03,820 --> 00:19:08,328
numbers, you would think that GCM is
exactly the right mode to always use. But

498
00:19:03,820 --> 00:19:08,328
根据这些性能参数，大家会认为GCM正是应该一直使用的正确模式

499
00:19:08,328 --> 00:19:12,659
it turns out if you're on the space
constrained hardware, GCM is not ideal.

500
00:19:08,328 --> 00:19:12,659
但实际上，如果你在空间有限的硬件设备上，GCM并不理想

501
00:19:12,659 --> 00:19:16,709
Primarily because its implementation
requires larger code than the other two

502
00:19:12,659 --> 00:19:16,709
主要是因为它的实现需要比其他两个模式更多的代码

503
00:19:16,709 --> 00:19:21,323
modes. However, as I said, Intel
specifically added instructions to speed

504
00:19:16,709 --> 00:19:21,323
但是，如我所说，Intel特地加了指令

505
00:19:21,323 --> 00:19:26,064
up GCM mode. And as a result, implementing
GCM on an Intel architecture takes

506
00:19:21,323 --> 00:19:26,064
来加速GCM模式。因此在Intel体系结构上实现GCM

507
00:19:26,064 --> 00:19:30,315
very little code. But on other hardware
platforms, say in smart cards or other

508
00:19:26,064 --> 00:19:30,315
只需要很少的代码。但在其他硬件平台上，比如说智能卡或其他受限的硬件环境

509
00:19:30,315 --> 00:19:34,745
constrained environments, the code size
for implementing GCM would be considerably

510
00:19:30,315 --> 00:19:34,745
实现GCM的代码大小会比其他两个模式

511
00:19:34,745 --> 00:19:39,387
larger than for the other two modes. But
if code size is not a constraint then GCM

512
00:19:34,745 --> 00:19:39,387
大得多。但如果代码大小不受限制的话

513
00:19:39,387 --> 00:19:43,928
is the right mode to use. So to summarize
this segment I want to say it one more

514
00:19:39,387 --> 00:19:43,928
那么GCM是正确的选择。总结一下本节，我想再说一次

515
00:19:43,928 --> 00:19:48,267
time that when you want to encrypt
messages you have to use an authenticated

516
00:19:43,928 --> 00:19:48,267
当你想加密信息时，你必须使用认证加密模式

517
00:19:48,267 --> 00:19:52,716
encryption mode and the recommended way to
do it is to use one of the standards,

518
00:19:48,267 --> 00:19:52,716
推荐的方法是使用这些标准中的一个

519
00:19:52,716 --> 00:19:57,037
namely one of these three modes for
providing authenticated encryption.

520
00:19:52,716 --> 00:19:57,037
这三个标准中的一个，以提供认证加密

521
00:19:57,037 --> 00:19:59,846
Don't implement the encryption scheme yourself.
In other words don't implement

522
00:19:57,037 --> 00:19:59,846
不要自己实现加密机制。换句话说

523
00:19:59,846 --> 00:20:05,842
encrypt-then-MAC yourself. Just use one of these
three standards. Many crypto libraries

524
00:19:59,846 --> 00:20:05,842
不要自己先加密后MAC，就使用三个标准中的一个

525
00:20:05,842 --> 00:20:10,513
now provide standard API's for these three
modes and these are the one's you should

526
00:20:05,842 --> 00:20:10,513
现在许多密码学库提供了这三种模式的标准API

527
00:20:10,513 --> 00:20:14,347
be using and nothing else. In the next
segment we're going to see what else can

528
00:20:10,513 --> 00:20:14,347
你应该使用这些，而不是别的。下一节，我们要看

529
00:20:14,347 --> 00:20:17,500
go wrong when you try to implement
authenticated encryption by yourself.

530
00:20:14,347 --> 00:20:17,500
当你试图自己实现认证加密时，还会发生什么错误


