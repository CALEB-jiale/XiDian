1
00:00:00,000 --> 00:00:03,515
Well, we're almost done with our
discussion of symmetric encryption. There

2
00:00:00,000 --> 00:00:03,515
好的，现在我们基本上完成了对对称加密的讨论。

3
00:00:03,515 --> 00:00:06,471
are just a couple of odds and ends that
I'd like to discuss before we move on to

4
00:00:03,515 --> 00:00:06,471
现在再开始下一个题目之前，有几个小问题

5
00:00:06,471 --> 00:00:10,431
the next topic. So the first thing I'd
like to mention is how we derive many keys

6
00:00:06,471 --> 00:00:10,431
我们需要讨论一下。首先我要提到的是我们应该怎么从很多密钥中

7
00:00:10,431 --> 00:00:14,497
from one key. And it, actually, this comes
up all the time in practice, so I'd like

8
00:00:10,431 --> 00:00:14,497
得到唯一密钥。实际上，这个问题会在实践中很多次的出现，所以我

9
00:00:14,497 --> 00:00:18,287
to make sure you know how to do this
correctly. So what's the setting that

10
00:00:14,497 --> 00:00:18,287
想确保你们直到怎么去正确的找到它。所以说我们寻找的

11
00:00:18,287 --> 00:00:22,775
we're looking at? Well, imagine we have a
certain source key that's generated by one

12
00:00:18,287 --> 00:00:22,775
是怎样的设置?好吧，想象我们现在有一个确定来源的很多

13
00:00:22,775 --> 00:00:26,435
of, a number of methods. Imagine the
source key is generated by a hardware

14
00:00:22,775 --> 00:00:26,435
理论中的一种密钥。想象有源密钥是被硬件随机

15
00:00:26,435 --> 00:00:30,094
random number generator or perhaps is
generated by a key exchange protocol

16
00:00:26,435 --> 00:00:30,094
数生成器生产或者是被我们一会将要讨论的密钥交换协议

17
00:00:30,094 --> 00:00:34,036
which we're going to discuss later. But
anyhow, there are a number of ways in

18
00:00:30,094 --> 00:00:34,036
所生成的。但是现在有很多方式

19
00:00:34,036 --> 00:00:38,110
which a source key might be generated
between Alice and Bob, such that the

20
00:00:34,036 --> 00:00:38,110
在Alice和Bob之间产生一个有源密钥，就是

21
00:00:38,110 --> 00:00:42,569
attacker doesn't know what the source key
is. But now, as we said, in many cases, we

22
00:00:38,110 --> 00:00:42,569
攻击者不知道的有源密钥。但是现在正如我们所说的，在很多情况下，

23
00:00:42,569 --> 00:00:46,863
actually need many keys to secure a
session, not just one single source key.

24
00:00:42,569 --> 00:00:46,863
我们确实需要很多密钥去保证会话的安全，不仅仅是一个简单地有源密钥。

25
00:00:46,863 --> 00:00:51,267
For example, if you remember, in TLS there
were unidirectional keys and we

26
00:00:46,863 --> 00:00:51,267
举个例子，如果你还记得，在安全传输层协议里面有单向性的密钥，我们

27
00:00:55,285 --> 00:00:59,469
needed keys in each direction. And in
fact, in each direction, we needed

28
00:00:55,285 --> 00:00:59,469
在每一个方向上都需要密钥。在事实上，在每一个方向上

29
00:00:59,469 --> 00:01:03,093
multiple keys. We needed a MAC key, we
needed an encryption key. We need an IV,

30
00:00:59,469 --> 00:01:03,093
我们都需要多样的密钥。我们需要介质访问控制层密钥，我们需要一个经过加密的密钥，我们交互式密码

31
00:01:03,093 --> 00:01:07,594
and so on. Similarly nonce based
encryption, you remember, there were

32
00:01:03,093 --> 00:01:07,594
以及其他的。不知道你们还记不记得，与基于随机数的加密相似

33
00:01:07,594 --> 00:01:12,031
multiple keys that were being used, and so
on. And so, the question is, how do we use

34
00:01:07,594 --> 00:01:12,031
我们曾经使用过并联密钥以及其他密钥，所以问题是我们怎么使用

35
00:01:12,031 --> 00:01:16,351
the one source key that we just derived,
either from a hardware process or

36
00:01:12,031 --> 00:01:16,351
我们得到的有源密钥，不论是从硬件随机生成数或者是

37
00:01:16,351 --> 00:01:20,531
by key exchange, and generate a bunch of
keys from it that we could then use to

38
00:01:16,351 --> 00:01:20,531
密钥交换协议生成的，并且从中得到一系列我们可以用它们

39
00:01:20,531 --> 00:01:24,951
secure our session. The way that's done,
is using a mechanism called a key

40
00:01:20,531 --> 00:01:24,951
提高我们的会话安全性的密钥。我们这样做是应用了被叫做

41
00:01:24,951 --> 00:01:29,846
derivation function, KDF. And I want to
talk a little bit about how KDF's are

42
00:01:24,951 --> 00:01:29,846
密钥推导函数的机制，简称KDF。现在我想简单介绍一下密钥推导函数是怎么

43
00:01:29,846 --> 00:01:34,993
constructed. So first of all, suppose we
have a secure PRF, that happens to have

44
00:01:29,846 --> 00:01:34,993
构造的。首先假设我们我们有个安全的脉冲重复频率，工作时有个

45
00:01:34,993 --> 00:01:41,207
key space K. And now, suppose that it so
happens that our source key SK is uniform

46
00:01:34,993 --> 00:01:41,207
密钥空间K。现在，假设它这样工作使我们的有源密钥SK在K空间中

47
00:01:41,207 --> 00:01:46,453
in the key K. In this case, the source key
is, in fact, a uniform random key for the

48
00:01:41,207 --> 00:01:46,453
随机分配。在这种情况下，一个对于安全脉冲频率F来说是均匀分布的

49
00:01:46,453 --> 00:01:50,444
secure PRF F. And we can use it directly to
generate keys, all the keys that we need

50
00:01:46,453 --> 00:01:50,444
随机密钥。我们可以用它直接来生成密钥，所有的我们需要的提高安全性

51
00:01:50,444 --> 00:01:53,771
to secure the session. So in this case,
the KDF is really simple. The key

52
00:01:50,444 --> 00:01:53,771
的密钥都可以用这种方法来构造。所以在这种情况下，密钥推导函数真的非常简单。

53
00:01:53,771 --> 00:01:58,025
derivation function would just work as
follows. It would take as input the

54
00:01:53,771 --> 00:01:58,025
该机制会像下面所说的一样工作。它得到作为输入的

55
00:01:58,025 --> 00:02:02,766
source key. It would take an input, a
parameter context, which I'm gonna

56
00:01:58,025 --> 00:02:02,766
有源密钥。它会有一个上下文参数的输入，我一会会讲到的

57
00:02:02,766 --> 00:02:07,615
describe in just a minute. And then it's
gonna take a length input as input as

58
00:02:02,766 --> 00:02:07,615
输入。之后它会把输入的长度也作为一个

59
00:02:07,615 --> 00:02:12,400
well. And then what it will do is it will
basically evaluate the PRF on zero. Then

60
00:02:07,615 --> 00:02:12,400
输入。接下来要做的就是在零的时候评估PRF。然后

61
00:02:12,400 --> 00:02:16,449
it will evaluate the PRF on one. Then it
will evaluate the PRF on two, up until L.

62
00:02:12,400 --> 00:02:16,449
在一的时候评估PRF,之后在二的时候评估PRF，一直提高到L。

63
00:02:16,449 --> 00:02:20,353
And I will talk about what this context is
in just a second. And then, basically, you

64
00:02:16,449 --> 00:02:20,353
我一会会谈论一下这样做的环境是什么。之后你会

65
00:02:20,353 --> 00:02:24,256
would use as many bits of the output as
you would need to generate all the keys

66
00:02:20,353 --> 00:02:24,256
将会使用跟你需要去为会话构造的密钥一样的

67
00:02:24,256 --> 00:02:28,355
for the session. So, if you need unidirectional keys you would generate, you

68
00:02:24,256 --> 00:02:28,355
的输出比特数。所以如果你需要你将要生成的单向密钥，你们知道的

69
00:02:28,355 --> 00:02:32,356
know, one key in each direction where each key
might include an encryption key and a MAC

70
00:02:28,355 --> 00:02:32,356
在每一个方向的密钥都会包含加密密钥和介质访问控制层密钥。

71
00:02:32,356 --> 00:02:36,259
key. And so, you would basically generate
as many bits as you need and then finally

72
00:02:32,356 --> 00:02:36,259
基本上，你可以生成你需要比特数的密钥，

73
00:02:36,259 --> 00:02:41,177
cut off the output at the time when you've
generated enough keys to secure your

74
00:02:36,259 --> 00:02:41,177
最后在你已经生成够了你所需要的保证会话安全的密钥，切断输出。

75
00:02:41,177 --> 00:02:45,656
session. Okay so this is a fairly straight
forward mechanism it's basically using the

76
00:02:41,177 --> 00:02:45,656
这是一个相当直接的机制，基本上只应用了

77
00:02:45,656 --> 00:02:49,451
secure PRF as a pseudo random generator.
And the only question is what is its

78
00:02:45,656 --> 00:02:49,451
安全脉冲重复频率作为伪随机数生成器。现在就只剩下一个问题

79
00:02:49,451 --> 00:02:53,545
context string. Well, I'll tell you that
the context string is basically a unique

80
00:02:49,451 --> 00:02:53,545
就是什么是它的上下文应用环境。好吧，基本上环境字符串是一个不同寻常的

81
00:02:53,545 --> 00:02:58,304
string that identifies the application. So
in fact you might have multiple

82
00:02:53,545 --> 00:02:58,304
定义应用的字符串。所以在事实上，你可能会在同一个系统上有很多

83
00:02:58,304 --> 00:03:03,169
applications on the same system that's
trying to establish multiple secure keys.

84
00:02:58,304 --> 00:03:03,169
不同的应用程序试图建立多个安全密钥。

85
00:03:03,169 --> 00:03:09,145
Maybe you have SSH running as one process,
you have a web server running as another process,

86
00:03:03,169 --> 00:03:09,145
你可能有运行安全外壳协议去做为一个进程，同时运行一个网络服务作为另一个进程

87
00:03:09,145 --> 00:03:13,533
IPsec as a third process and all three need
to have secret keys generated. And this

88
00:03:09,145 --> 00:03:13,533
Internet链接协议作为第三个进程，所有的三个进程都要求生成秘密密钥。

89
00:03:13,533 --> 00:03:16,589
context variable basically tries to separate
the three of them. So, let me ask you,

90
00:03:13,533 --> 00:03:16,589
基本上环境变量会尝试着把它们分成三份。所以，让我问一下你们，

91
00:03:19,204 --> 00:03:22,312
more precisely, what do you think
the purpose of this context variable is?

92
00:03:19,204 --> 00:03:22,312
更准确的说，你们觉得环境变量的目的是什么？

93
00:03:22,312 --> 00:03:26,166
So I guess I've given
it away and this context variable is

94
00:03:22,312 --> 00:03:26,166
我猜我已经把它放到一边了，基本上环境变量是被用来

95
00:03:26,166 --> 00:03:30,863
supposed to basically separate
applications, so that even if, for

96
00:03:26,166 --> 00:03:30,863
分离应用程序的，举个例子来说，即使

97
00:03:30,863 --> 00:03:35,741
example, the three services that we just
talked about, SSH, web server, and IPsec,

98
00:03:30,863 --> 00:03:35,741
上面三个我们谈论过的服务，安全外壳协议，网络服务和Internet链接，

99
00:03:35,741 --> 00:03:40,378
if they all happen to obtain the same
source key from the hardware random number

100
00:03:35,741 --> 00:03:40,378
如果它们都获得了从硬件随机数生成器生成的的相同有源密钥，

101
00:03:40,378 --> 00:03:45,617
generator then the context since it's
different for the three apps will make

102
00:03:40,378 --> 00:03:45,617
之后从三个环境不同对于应用程序不同开始，环境上下文

103
00:03:45,617 --> 00:03:49,873
sure that they still get three independent
strings that they can then use to secure

104
00:03:45,617 --> 00:03:49,873
会确保它们可以得到三个独立的字符串并且用它来提高会话的安全性。

105
00:03:49,873 --> 00:03:53,648
the sessions. I just want you to remember
that, even though this is actually fairly

106
00:03:49,873 --> 00:03:53,648
我只希望你们可以记住它，即使这实际上是非常

107
00:03:53,648 --> 00:03:57,374
straightforward, and we discussed this
before, the context string is actually

108
00:03:53,648 --> 00:03:57,374
简单的。之前我们谈论过，环境字符串事实上是很

109
00:03:57,374 --> 00:04:01,300
important, and it does need to be specific
to the application, so that each

110
00:03:57,374 --> 00:04:01,300
重要的。它确实是需要用来分辨应用程序，所以说，每一个应用程序

111
00:04:01,300 --> 00:04:05,139
application gets its own session keys,
even if multiple applications happen to

112
00:04:01,300 --> 00:04:05,139
都可以得到它独有的安全密钥，即使多个程序都要求

113
00:04:05,139 --> 00:04:09,714
sample the same SK. The next
question is, what do we do if the source

114
00:04:05,139 --> 00:04:09,714
一个相同的SK。下一个问题是当有源密钥实际上并不均匀时，

115
00:04:09,714 --> 00:04:14,113
key actually isn't uniform? Well, now we
got a problem. If the source key is not a

116
00:04:09,714 --> 00:04:14,113
我们应该怎么办？好吧现在我们有了一个新的问题，如果有源密钥对于伪随机数函数

117
00:04:14,113 --> 00:04:18,511
uniform key for the pseudo random function
then we can no longer assume that the

118
00:04:14,113 --> 00:04:18,511
来说不是均匀密钥我们就不能假设

119
00:04:18,511 --> 00:04:23,841
output of the pseudo random function is
indistinguishable from random. In fact, if

120
00:04:18,511 --> 00:04:23,841
伪随机函数的输出对于随机数来说是不可分辨的。

121
00:04:23,841 --> 00:04:27,416
we just use the KDF that we just described
then the output might not look random to

122
00:04:23,841 --> 00:04:27,416
我们就运用了刚刚描述过得密钥推导函数，之后输出对于敌手来说看上去就不想

123
00:04:27,416 --> 00:04:31,562
the adversary and then he might be able to
anticipate some of the session keys that

124
00:04:27,416 --> 00:04:31,562
是随机数了，之后他就可能有能力去预想一些我们可能使用的会话密钥

125
00:04:31,562 --> 00:04:35,510
we'll be using and thereby break the
session. So then we have a problem. Now

126
00:04:31,562 --> 00:04:35,510
从而打断这个会话。所以我们又出现了一个问题，为什么

127
00:04:35,510 --> 00:04:39,560
why would this source key not be uniform?
Well there are many reasons why this

128
00:04:35,510 --> 00:04:39,560
这个有源密钥不是均匀的呢？这会有很多发生的原因。

129
00:04:39,560 --> 00:04:42,826
happened. For example if you use a key
exchange protocol, it so happens typically

130
00:04:39,560 --> 00:04:42,826
比如如果你使用了密钥交换协议，通常该协议会

131
00:04:42,826 --> 00:04:46,774
that key exchange protocols will generate a
high entropy key. But the

132
00:04:42,826 --> 00:04:46,774
生成一个好熵的密钥。但是这个

133
00:04:46,774 --> 00:04:51,455
high entropy key is gonna be
distributed in some subspace of the key

134
00:04:46,774 --> 00:04:51,455
高熵的密钥将会分布在密钥空间的

135
00:04:51,455 --> 00:04:55,763
space. So it's not going to be a uniform
string. It will be uniform in some

136
00:04:51,455 --> 00:04:55,763
一些子空间里。所以它不会成为均匀的字符串。它将会均匀分布在一些

137
00:04:55,926 --> 00:05:00,317
subset of a larger set, And we'll see
examples of that as soon as we talk about

138
00:04:55,926 --> 00:05:00,317
大集合的子集中，并且我们将会看到这样的一些例子

139
00:05:00,317 --> 00:05:04,492
key exchange protocols. And so KDFs have
to kind of accommodate for the fact that

140
00:05:00,317 --> 00:05:04,492
存在在密钥交换协议里。KDF机制必须要容纳密钥交换协议

141
00:05:04,492 --> 00:05:08,830
key exchange protocols actually don't
generate uniform bit strings. The other

142
00:05:04,492 --> 00:05:08,830
通常不会生成均匀的比特字符。另外一个

143
00:05:08,830 --> 00:05:13,384
problem is, that, in fact, the hardware
random number generator you're using might

144
00:05:08,830 --> 00:05:13,384
问题是，事实上你使用的硬件随机数生成器

145
00:05:13,384 --> 00:05:17,252
actually produce biased outputs. We don't
wanna rely on the non bias of the hardware

146
00:05:13,384 --> 00:05:17,252
通常会生成有偏移的输出。我们不想依赖没有偏移的

147
00:05:17,252 --> 00:05:21,842
random number generator. And so all we
want to assume is that it generates a high

148
00:05:17,252 --> 00:05:21,842
硬件随机数生成器。所以我们想要假设的是它会生成

149
00:05:21,842 --> 00:05:26,735
entropy string, but one that might be
biased. In which case, we have to somehow

150
00:05:21,842 --> 00:05:26,735
一个高熵的字符串，但是会有一定的偏移。在这样的情况下，我们必须去

151
00:05:26,735 --> 00:05:31,962
clean this bias. And so this introduces
this, this paradigm for building KDFs.

152
00:05:26,735 --> 00:05:31,962
清除这样的偏移。所以这里介绍这样的方法，去创造KDF的范式。

153
00:05:31,962 --> 00:05:37,247
This is called the extract-then-expand
paradigm, where the first step

154
00:05:31,962 --> 00:05:37,247
叫做提取扩展模式，创建密钥推导函数的第一步就是

155
00:05:37,247 --> 00:05:40,829
of the KDF is to extract a pseudo random
key from the actual source key. So in a

156
00:05:37,247 --> 00:05:40,829
提取自然来源密钥中的伪随机密钥。所以在

157
00:05:40,829 --> 00:05:45,343
picture you can think about it like this.
In some sense these are the different

158
00:05:40,829 --> 00:05:45,343
这幅图中你可以认为这个就像是它。这些有源密钥可能有不同的可能

159
00:05:45,343 --> 00:05:49,541
possible values of the source key. This is
the horizontal line and the vertical axis

160
00:05:45,343 --> 00:05:49,541
性价值。这是x轴和y轴

161
00:05:49,541 --> 00:05:53,464
is basically the probability of each one
of these values, and you can see that this

162
00:05:49,541 --> 00:05:53,464
基本上是每一个密钥价值的可能性。你可以看到这是

163
00:05:53,464 --> 00:05:58,561
is a kind of a bumpy function which would
say that the source key is not uniformly

164
00:05:53,464 --> 00:05:58,561
一种摆动函数可以说有源密钥并不是在

165
00:05:58,561 --> 00:06:02,913
distributed in the key space. What we do
in this case is we use what's called an

166
00:05:58,561 --> 00:06:02,913
密钥空间里均匀分布。面对这种情况，我们要做的是使用被叫做

167
00:06:02,913 --> 00:06:07,462
extractor. So an extractor is something
that takes a bumpy distribution and makes

168
00:06:02,913 --> 00:06:07,462
提取器的东西。提取器是提取离散分布数据并且

169
00:06:07,462 --> 00:06:10,027
it into a uniform distribution over the
key space. In our case we're actually just

170
00:06:07,462 --> 00:06:10,027
使它们可以均匀分布在密钥空间里的东西。在这种情况下，我们事实上

171
00:06:10,027 --> 00:06:14,894
gonna be using what are called
computational extractors, namely

172
00:06:10,027 --> 00:06:14,894
只是使用了叫做计算提取器的东西，换句话说

173
00:06:14,894 --> 00:06:20,257
extractors that don't necessarily produce
uniform distribution at the end but

174
00:06:14,894 --> 00:06:20,257
提取器在必要的情况下最后并不产生均匀分布

175
00:06:22,910 --> 00:06:27,323
they generated distribution that's
indistinguishable from uniform.

176
00:06:22,910 --> 00:06:27,323
而是生成对于均匀分布来说不可分辨的分布。

177
00:06:27,323 --> 00:06:31,318
Now extractors typically take as input
something called a salt, and a salt just

178
00:06:27,323 --> 00:06:31,318
现在提取器通常获取作为输入的被叫做盐的东西，然后

179
00:06:31,318 --> 00:06:36,022
like in a salad, it kind of adds flavor to
things, what it does is basically kind of

180
00:06:31,318 --> 00:06:36,022
它就像在一份沙拉里调味的东西，它所起的作用就是

181
00:06:36,022 --> 00:06:39,738
jumbles things around, so that no matter
what the input distribution is, the output

182
00:06:36,022 --> 00:06:39,738
把局面搞混乱，所有无论输入的分布是什么，输出的分布总是

183
00:06:39,738 --> 00:06:43,973
distribution is still going to be
indistinguishable from random. So a salt

184
00:06:39,738 --> 00:06:43,973
从随机角度考虑是不可被分辨的。

185
00:06:43,973 --> 00:06:48,565
basically, what is it? It's a non-secret
string, so it's publicly known. It doesn't

186
00:06:43,973 --> 00:06:48,565
到底它是什么？实际不是私密的字符串，因此它是公开的

187
00:06:48,565 --> 00:06:53,096
matter if the adversary knows what the
salt is, and it's fixed forever. The only

188
00:06:48,565 --> 00:06:53,096
如何敌手知道盐是什么也没关系，它永远都是可操控的

189
00:06:53,096 --> 00:06:57,173
point is that when you chose it, you chose
one at random. And then the hope is that

190
00:06:53,096 --> 00:06:57,173
唯一的要点是当你选择它时，必须是随机选择一个。之后的希望是

191
00:06:57,173 --> 00:07:00,274
the funny distribution that you're trying
to extract from kinda doesn't inherently

192
00:06:57,173 --> 00:07:00,274
你尝试从kinda那里提取的有趣的分布

193
00:07:00,274 --> 00:07:03,729
depends on the salt that you chose and
hence as a result using your salt, you

194
00:07:00,274 --> 00:07:03,729
不是完全取决于你选择的盐，因此用你的盐

195
00:07:03,729 --> 00:07:07,020
will actually get a distribution that
looks indistinguishable from random. So

196
00:07:03,729 --> 00:07:07,020
你可以得到一个与随机的分布不可分辨的分布

197
00:07:07,020 --> 00:07:10,220
essentially the salt, you know, you can
just bang it the keyboard a couple of

198
00:07:07,020 --> 00:07:10,220
实际你可以一段时间内一直敲击键盘生成它

199
00:07:10,220 --> 00:07:14,249
times when you generate it but it just
needs to be something that's random

200
00:07:10,220 --> 00:07:14,249
但是需要一些真正随机的东西，

201
00:07:14,249 --> 00:07:20,304
initially but then it's fixed forever, and
it's fine if the adversary knows what

202
00:07:14,249 --> 00:07:20,304
但之后是永远可以被操控，如果敌手知道

203
00:07:20,304 --> 00:07:24,713
it is and nevertheless the extractor is
able to extract the entropy and output a

204
00:07:20,304 --> 00:07:24,713
它是什么将是很好的，因此提取器就可以提取出熵

205
00:07:24,713 --> 00:07:29,667
uniformly random string K. In some sense the
salt is only there to defend against

206
00:07:24,713 --> 00:07:29,667
并且输出一个均匀随机串K，在某种程度上，这个盐只是防御

207
00:07:29,667 --> 00:07:34,581
adversarially bad distributions that might
mess up our extractor. Okay, so now that

208
00:07:29,667 --> 00:07:34,581
对方可能搞混我们提取器的糟糕的分布，

209
00:07:34,581 --> 00:07:38,911
we have extracted a pseudo random key.
Now, we might as well just use it in a KDF

210
00:07:34,581 --> 00:07:38,911
好的，现在我们已经提取出一个伪随机的密钥，我们将把它用于一个KDF中

211
00:07:38,911 --> 00:07:43,481
that we just saw using a secure
pseudo random function to expand the key

212
00:07:38,911 --> 00:07:43,481
我们仅看到用一个安全的伪随机函数来扩大

213
00:07:43,481 --> 00:07:47,431
into as many bits as we need to actually
secure the session. Okay, so there are

214
00:07:43,481 --> 00:07:47,431
密钥使之成为能保证回话安全的密钥长度

215
00:07:47,431 --> 00:07:51,584
these two steps. The first one is we
extract a pseudo-random key, and then once

216
00:07:47,431 --> 00:07:51,584
好的这里有三个步骤，第一，我们提取一个伪随机密钥，

217
00:07:51,584 --> 00:07:56,033
we have a pseudo-random key we already
know how to extend it into as many keys as

218
00:07:51,584 --> 00:07:56,033
一旦我们有了一个伪随机密钥，我们就已经知道怎样用

219
00:07:56,033 --> 00:08:01,170
we need using a pseudo-random function. So
the standardized way of doing this is

220
00:07:56,033 --> 00:08:01,170
伪随机函数把它扩展成我们需要长度的密钥，所以执行这一步的

221
00:08:01,170 --> 00:08:06,561
called HKDF. This is a KDF, a key derivation function that's built from HMAC.

222
00:08:01,170 --> 00:08:06,561
标准方法叫做HKDF，它是一种从HMAC建立而成的密钥推导函数，

223
00:08:06,561 --> 00:08:11,699
And here HMAC is used both as the PRF for
expanding and an extractor for extracting

224
00:08:06,561 --> 00:08:11,699
这里的HMAC既可以用作扩大的PRF也可以当做提取原始密钥的提取器

225
00:08:11,699 --> 00:08:16,900
the initial pseudo-random key. So let me
explain how this works. So in the extract

226
00:08:11,699 --> 00:08:16,900
让我解释一下它是如何工作的

227
00:08:16,900 --> 00:08:21,101
step, we're gonna use our salt which you
remember is a public value just happened to

228
00:08:16,900 --> 00:08:21,101
在提取的这一步，我们用我们的盐，一开始它是一个公开的随机生成的价值

229
00:08:21,101 --> 00:08:27,526
be generated at random at the beginning of
time. And we use this salt as the HMAC

230
00:08:21,101 --> 00:08:27,526
我们把它当做HMAC密钥

231
00:08:27,526 --> 00:08:32,292
key. And then the source key we're gonna
use as the HMAC data. So we're kind of

232
00:08:27,526 --> 00:08:32,292
之后源密钥用作HMAC数据，所以我们把一个公开的值当做密钥

233
00:08:32,292 --> 00:08:37,623
using a public value as a key. And
nevertheless, one can argue that HMAC has

234
00:08:32,292 --> 00:08:37,623
因此，有人会质疑HMAC是否具有提取的特征

235
00:08:37,623 --> 00:08:42,452
extraction properties, such that, when we
apply HMAC, the resulting key is going to

236
00:08:37,623 --> 00:08:42,452
实际当我们应用HMAC时，最终的密钥与随机的是不可分辨的

237
00:08:42,452 --> 00:08:47,329
look indistinguishable from random,
assuming that the source key actually has

238
00:08:42,452 --> 00:08:47,329
前提是假设源密钥对它有足够的熵值。

239
00:08:47,329 --> 00:08:52,037
enough entropy to it. And now that we have
the pseudo random key we're simply going

240
00:08:47,329 --> 00:08:52,037
现在我们拥有了伪随机密钥

241
00:08:52,037 --> 00:08:56,389
to use HMAC as a PRF to generate a
session key of you know as many bits as we

242
00:08:52,037 --> 00:08:56,389
我们将仅用HMAC作为一个伪随机函数来生成一个我们需要长度的会话密钥

243
00:08:56,389 --> 00:09:00,763
need for the session keys. Okay. So that
basically concludes our discussion of

244
00:08:56,389 --> 00:09:00,763
好的，最终总结一下我们有关HKDF的讨论，

245
00:09:00,763 --> 00:09:04,912
HKDF. And I just want you to remember
that, once you obtain a source key, either

246
00:09:00,763 --> 00:09:04,912
我只想让你们记住一旦获得源密钥

247
00:09:04,912 --> 00:09:09,566
from hardware or from a key exchange
protocol, the way you convert it into

248
00:09:04,912 --> 00:09:09,566
无论是来自硬件还是密钥交换协议，你把它转化成

249
00:09:09,566 --> 00:09:14,108
session keys is not by using that sample
directly. You would never use a source key

250
00:09:09,566 --> 00:09:14,108
会话密钥的方法不是直接用那个样本，你永远不会

251
00:09:14,108 --> 00:09:18,369
directly as a session key in a protocol.
What you would do is you will run the

252
00:09:14,108 --> 00:09:18,369
把源密钥直接当做协议中的会话密钥，你可能会

253
00:09:18,369 --> 00:09:22,575
source key through a KDF. And the KDF
would give you all the keys and output

254
00:09:18,369 --> 00:09:22,575
通过一个密钥推导函数来运行原密钥。

255
00:09:22,575 --> 00:09:27,042
that you need, for, the randomness, for
the random keys to be used in your

256
00:09:22,575 --> 00:09:27,042
并且这个KDF将给出你所有的密钥

257
00:09:27,042 --> 00:09:31,952
protocol. And a typical KDF to use is
HKDF, which is actually getting quite a

258
00:09:27,042 --> 00:09:31,952
并且输出你所需要的密钥，将这个随机的密钥用在协议中

259
00:09:31,952 --> 00:09:36,430
bit of traction out there. Okay. The last
topic I wanna talk about in this segment

260
00:09:31,952 --> 00:09:36,430
应用的一个典型的密钥推导函数就是HKDF，在这里必须提出来

261
00:09:36,430 --> 00:09:41,921
is, how do you extract keys from
passwords. These are called password based

262
00:09:36,430 --> 00:09:41,921
好的，我想说的最后一个话题是

263
00:09:41,921 --> 00:09:45,764
KDFs or PBKDFs. The problem here is
that passwords have relatively low

264
00:09:41,921 --> 00:09:45,764
怎样从口令中提取出密钥，这叫做基于密钥推导函数的口令。简称PBKDF

265
00:09:45,764 --> 00:09:50,154
entropy. In fact, we're gonna talk about
passwords later on in the course when we

266
00:09:45,764 --> 00:09:50,154
问题是口令具有相当低的熵值

267
00:09:50,154 --> 00:09:54,291
talk about user authentication. And so,
I'm not gonna say too much here. I'll just

268
00:09:50,154 --> 00:09:54,291
实际，在我们后面讨论用户身份验证时会讨论口令

269
00:09:54,291 --> 00:09:59,010
say passwords generally have very little
entropy estimated on the order of twenty

270
00:09:54,291 --> 00:09:59,010
所以在这里我不想多说。

271
00:09:59,010 --> 00:10:02,882
bits of entropy, say. And as a result,
there is simply not enough entropy to

272
00:09:59,010 --> 00:10:02,882
我想说的是口令一般具有很小的熵，大约20比特序列的熵

273
00:10:02,882 --> 00:10:06,804
generate session keys out of a password.
And yet we still need to do it very

274
00:10:02,882 --> 00:10:06,804
因此，显然没有足够熵值从口令生成会话密钥，

275
00:10:06,804 --> 00:10:10,828
frequently. We still need to derive
encryption keys and MACs and so on out of

276
00:10:06,804 --> 00:10:10,828
并且我们仍然需要重复用它

277
00:10:10,828 --> 00:10:14,744
passwords, so the question is how to do
it. The first thing is, you know, for this

278
00:10:10,828 --> 00:10:14,744
我们仍需要从口令中推导出加密的密钥和MAC等等

279
00:10:14,744 --> 00:10:18,657
kind of purpose, don't use HKDF. That's
not what it's designed for. What will

280
00:10:14,744 --> 00:10:18,657
所以问题是如何推导

281
00:10:18,657 --> 00:10:22,105
happen is that the derived keys will
actually be vulnerable to something called

282
00:10:18,657 --> 00:10:22,105
首先是，

283
00:10:22,105 --> 00:10:27,787
a dictionary attack, which we're gonna
talk about much later in the course when

284
00:10:22,105 --> 00:10:27,787
对于这样的意图，我们不能用HKDF，它不是为推导而设计的

285
00:10:27,787 --> 00:10:33,002
we talk about user authentication. So, the
way PBKDFs defend against this low entropy

286
00:10:27,787 --> 00:10:33,002
可能的是推导出的密钥对于一些称作字典法的攻击实际是易受攻击的

287
00:10:33,002 --> 00:10:38,878
problem that results in a dictionary
attack is by two means. First of all, as

288
00:10:33,002 --> 00:10:38,878
这将在我们讨论用户身份验证的时候会提到，所以PBKDF的方法

289
00:10:38,878 --> 00:10:43,097
before they use a salt, a public,
random value that's fixed forever. But in

290
00:10:38,878 --> 00:10:43,097
防御低熵值问题会由于两种方式导致字典法攻击

291
00:10:43,097 --> 00:10:49,355
addition, they also use what's called a
slow hash function. And let me describe

292
00:10:43,097 --> 00:10:49,355
首先，和我们之前用的盐一样，一个公开的，随机的值可以永远被操控

293
00:10:49,355 --> 00:10:53,911
kind of the standard approach to deriving
keys from passwords. This is called PKCS#5,

294
00:10:49,355 --> 00:10:53,911
但是另外的，它们也使用一个叫做低哈希函数的方法，让我描述一种

295
00:10:53,911 --> 00:10:57,398
and in particular, the version I'll describe
is what's called PBKDF1. And I

296
00:10:53,911 --> 00:10:57,398
从口令提取密钥的标准方式，叫做PKCS#5

297
00:10:57,398 --> 00:11:00,663
should say that this mechanism is
implemented in most crypto libraries so

298
00:10:57,398 --> 00:11:00,663
特别地，我将描述的这个版本叫做PBKDF1

299
00:11:00,663 --> 00:11:03,788
you shouldn't have to implement this
yourself. All you would do, you know, you

300
00:11:00,663 --> 00:11:03,788
这种机制被用于很多加密文献中，所以你们没必要把它用于你自己

301
00:11:03,788 --> 00:11:08,353
would call a function, you know, derived
key from password. You would give the

302
00:11:03,788 --> 00:11:08,353
你们仅要做的是，你将有一个从口令中提取出来的函数

303
00:11:08,353 --> 00:11:11,741
password in as input, and you would get a
key as output. But you should be aware of

304
00:11:08,353 --> 00:11:11,741
将口令作为输入给出，得到一个密钥作为输出，但是你应该意识到

305
00:11:11,741 --> 00:11:17,155
course that this key is not going to have
high entropy so in fact it will be

306
00:11:11,741 --> 00:11:17,155
这个密钥没有很高的熵值，所以实际上它是可以猜测出来的

307
00:11:17,155 --> 00:11:20,964
guessable. What these PBKDFs try to do is
make the guessing problem as hard as

308
00:11:17,155 --> 00:11:20,964
这些PBKDF所尝试做的是使得这些猜测尽可能的困难

309
00:11:20,964 --> 00:11:25,693
possible. Okay. So the way they work,
first of all, is, as we said, they

310
00:11:20,964 --> 00:11:25,693
首先如我们说的，它们工作的方法实际就是哈希

311
00:11:25,693 --> 00:11:29,170
basically hash, the concatenation of the
password and the salt. And then the hash

312
00:11:25,693 --> 00:11:29,170
口令和盐的一系列值

313
00:11:29,170 --> 00:11:34,063
itself is designed to be a very slow hash
function. And the way we build a slow hash

314
00:11:29,170 --> 00:11:34,063
之后哈希本身被设计为很低的哈希函数。我们建立一个低哈希函数

315
00:11:34,063 --> 00:11:39,425
function is by taking one particular hash
function, say, SHA-256, and we

316
00:11:34,063 --> 00:11:39,425
的方法是通过用一个特殊的哈希函数SHA-256，反复申明它很多很多次

317
00:11:39,425 --> 00:11:43,356
iterate it many, many times, C times. So
you can imagine 1000 times, perhaps even a

318
00:11:39,425 --> 00:11:43,356
假设有1000次，也可能几百万次。

319
00:11:43,356 --> 00:11:48,494
million times. And what do I mean by
iterating it? So, well, we take the

320
00:11:43,356 --> 00:11:48,494
反复申明它是什么意思呢？我们有口令和盐

321
00:11:48,494 --> 00:11:54,025
password and the salt. And we put them
inside of one input to the hash function.

322
00:11:48,494 --> 00:11:54,025
把他们当做哈希函数的一个输入

323
00:11:54,025 --> 00:11:57,779
And then we apply the hash function, oops,
let me write it like this. And then we

324
00:11:54,025 --> 00:11:57,779
之后我们运用这个哈希函数，呦~让我写在这里

325
00:11:57,779 --> 00:12:00,779
apply the hash function and we get an
output, and then we apply the hash

326
00:11:57,779 --> 00:12:00,779
我们用这个哈希函数得到一个输出，再用这个哈希函数

327
00:12:00,779 --> 00:12:05,830
function again and we get another output.
And we do this again and again and again

328
00:12:00,779 --> 00:12:05,830
得到另一个输出。重复这样做一遍又一遍

329
00:12:05,830 --> 00:12:10,710
maybe a thousand times or a million times
depending on how fast your processors are

330
00:12:05,830 --> 00:12:10,710
可能1000次或者一百万次，取决于你的处理器有多快

331
00:12:10,710 --> 00:12:15,057
and then finally we get the final output
that we actually output as, as the key

332
00:12:10,710 --> 00:12:15,057
最后呢，我们得到最终的输出

333
00:12:15,057 --> 00:12:19,371
output of this key derivation function.
Now what is the point here? Iterating a

334
00:12:15,057 --> 00:12:19,371
也就是密钥推导函数的输出密钥，现在要点在这里吗？

335
00:12:19,371 --> 00:12:22,922
function 10,000 times or even a million
times is going to take very little time on

336
00:12:19,371 --> 00:12:22,922
重复申明一个函数1000次甚至一百万次对于现代的CPU只需很短的时间

337
00:12:22,922 --> 00:12:27,792
a modern CPU, and as a result, it doesn't
really affect the user's experience. The

338
00:12:22,922 --> 00:12:27,792
因此，它不能真实反映一个用户的经历

339
00:12:27,792 --> 00:12:31,654
user types in his password, it gets hashed
a million times and then it gets output.

340
00:12:27,792 --> 00:12:31,654
用户键入他的口令，哈希一百万次并得到输出

341
00:12:31,654 --> 00:12:35,489
And maybe that could even take, you know a
tenth of a second and the user wouldn't

342
00:12:31,654 --> 00:12:35,489
这可能会花费十分之一秒，用户几乎觉察不到

343
00:12:35,489 --> 00:12:39,689
even notice it. However the attacker, all
he can do is he can try all the passwords

344
00:12:35,489 --> 00:12:39,689
但是攻击者所做的尝试字典中的所有口令

345
00:12:39,689 --> 00:12:43,780
in the dictionary, because we know people
tend to pick passwords in dictionaries,

346
00:12:39,689 --> 00:12:43,780
因为知道人们习惯于在字典中选择密码口令

347
00:12:43,780 --> 00:12:49,232
and so he could just try them one by one,
remember the SALT is public, so he knows

348
00:12:43,780 --> 00:12:49,232
所以只要他一个一个的试，SALT是公开的，

349
00:12:49,232 --> 00:12:53,796
what the SALT is. And so he can just try this
hash one by one. However because the hash

350
00:12:49,232 --> 00:12:53,796
所以他就知道了SALT是什么了。所以他就可以一个一个的试这个哈希。但是因为

351
00:12:53,796 --> 00:12:57,965
function is slow, each attempt is gonna
take him a tenth of second. So if he needs

352
00:12:53,796 --> 00:12:57,965
哈希函数是低熵的，每一种尝试将花费十分之一秒，所以他

353
00:12:57,965 --> 00:13:02,416
to run through a dictionary, you know, with,
with a 200 billion passwords in it,

354
00:12:57,965 --> 00:13:02,416
需要跑完整个字典里的2000亿个口令

355
00:13:02,416 --> 00:13:06,584
because the hash function is slow, this is
gonna take quite awhile. And by doing

356
00:13:02,416 --> 00:13:06,584
由于哈希是低熵的，这将需要很短的时间

357
00:13:06,584 --> 00:13:11,608
that, we slow down the dictionary attack,
and we make it harder for the attacker to

358
00:13:06,584 --> 00:13:11,608
通过这样，我们可以减慢字典攻击，使得攻击者获得我们会话密钥更难

359
00:13:11,608 --> 00:13:15,748
get our session keys. Not impossible, just
harder. That's all this is trying to do.

360
00:13:11,608 --> 00:13:15,748
不是不可能，只是更难。这就是它所尽力做的

361
00:13:15,748 --> 00:13:19,835
Okay, so this is basically what I wanted
to say about password based KDFs. As I

362
00:13:15,748 --> 00:13:19,835
这就是我实际想说的，口令是基于KDF的

363
00:13:19,835 --> 00:13:23,976
said, this is not something you would
build yourself. All crypto libraries have

364
00:13:19,835 --> 00:13:23,976
就像我说的，这不是你给自己建立一些东西。所有的加密文献都运用PKCS#5机制

365
00:13:23,976 --> 00:13:28,275
an implementation of a PKCS#5
mechanism. And you would just call the

366
00:13:23,976 --> 00:13:28,275
而你将仅仅正确的函数

367
00:13:28,275 --> 00:13:32,362
appropriate function to convert a password
into a key, and then use the resulting

368
00:13:28,275 --> 00:13:32,362
把一个口令转化成一个密钥，之后用这个最终密钥

369
00:13:32,362 --> 00:13:35,229
key. Okay, in the next segment, we're
gonna see how to use symmetric encryption

370
00:13:32,362 --> 00:13:35,229
好的，在这小节中，我们明白了如何使用对称加密

371
00:13:35,229 --> 00:13:35,229
in a way that allows us to search on the
cipher texts.

372
00:13:35,229 --> 00:13:35,229
在某种程度上，允许我们在密文中搜索

