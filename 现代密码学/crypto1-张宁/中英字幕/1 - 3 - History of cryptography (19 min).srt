1
00:00:00,000 --> 00:00:04,194
在我开始讲技术内容之前，我想讲一点密码学的历史

2
00:00:00,000 --> 00:00:04,194
Before we start with the technical
material, I want to tell you a little bit

3
00:00:04,194 --> 00:00:09,012
关于密码学的历史，David Kahn写了一本很棒的书

4
00:00:04,194 --> 00:00:09,012
about the history of cryptography. There's
a beautiful book on this topic by David

5
00:00:09,012 --> 00:00:13,490
叫密码破译者,它概括了完整的密码学历史

6
00:00:09,012 --> 00:00:13,490
Kahn called the codebreakers. It covers
the history of cryptography all the way

7
00:00:13,490 --> 00:00:17,742
从古巴比伦时代到现在，我将给大家看

8
00:00:13,490 --> 00:00:17,742
from the Babylonian era, to the
present. Here, I'm just going to give you

9
00:00:17,742 --> 00:00:22,146
一些历史上已经被完全破解的密码方案的例子

10
00:00:17,742 --> 00:00:22,146
a few examples of historical ciphers, all
of which are badly broken. So to talk

11
00:00:22,146 --> 00:00:26,830
谈论到密码，首先要介绍我的朋友Alice和Bob

12
00:00:22,146 --> 00:00:26,830
about ciphers the first thing I'm going to
do is introduce our friends Alice and Bob,

13
00:00:26,830 --> 00:00:31,243
他们将伴随我们所有余下的课程,Alice与Bob试图安全的通信

14
00:00:26,830 --> 00:00:31,243
who are gonna be with us for the rest of
the quarter. So Alice and Bob are trying

15
00:00:31,243 --> 00:00:35,657
但有一个攻击者试图窃听他们的对话

16
00:00:31,243 --> 00:00:35,657
to communicate securely and there is an
attacker who's trying to eavesdrop on

17
00:00:35,657 --> 00:00:39,908
因此为了安全通信，他们将分享一个密钥

18
00:00:35,657 --> 00:00:39,908
their conversation. So to communicate
securely, they're going to share a secret

19
00:00:39,908 --> 00:00:44,544
我将它记为k,他两都知道这个密钥

20
00:00:39,908 --> 00:00:44,544
key, which I'll denote by K. They both know
the secret key. But the attacker does not

21
00:00:44,544 --> 00:00:49,665
但攻击者不知道。现在他们将使用加密方案

22
00:00:44,544 --> 00:00:49,665
know anything about this key K.
So now they're gonna use a cipher, which

23
00:00:49,665 --> 00:00:53,749
其实是一对算法，加密算法记为E

24
00:00:49,665 --> 00:00:53,749
is a pair of algorithms, an
encryption algorithm denoted by E, and a

25
00:00:53,749 --> 00:00:58,870
解密算法记为D，这些算法工作如下：

26
00:00:53,749 --> 00:00:58,870
decryption algorithm, D. These algorithms
work as follows: the encryption algorithm

27
00:00:58,870 --> 00:01:03,930
加密算法E需要信息原文m和密钥k作为输入

28
00:00:58,870 --> 00:01:03,930
E takes the message M as inputs. And it
takes as inputs, the key K. I'm gonna

29
00:01:03,930 --> 00:01:08,807
我在k上面画一个楔形标记是为了强调这个输入是密钥

30
00:01:03,930 --> 00:01:08,807
put a wedge above the key input just
to denote the fact that this input is

31
00:01:08,807 --> 00:01:14,670
然后它输出E加密算法用k密钥算出的密文

32
00:01:08,807 --> 00:01:14,670
really the key input. And then it outputs
a ciphertext. Which is the encryption of

33
00:01:14,670 --> 00:01:20,319
我总是将密钥写在前面

34
00:01:14,670 --> 00:01:20,319
the message M using the key K. I'm always
gonna write the key first. Now, and when I

35
00:01:20,319 --> 00:01:24,486
用=意味这个表达式是定义c，变量c代表什么

36
00:01:20,319 --> 00:01:24,486
write: = what I mean is that the
expression defines what C what the

37
00:01:24,486 --> 00:01:29,437
现在密文通过网络传输给Bob

38
00:01:24,486 --> 00:01:29,437
variable C stands for. Now the ciphertext
is transmitted over the internet to Bob,

39
00:01:29,437 --> 00:01:34,231
事实上它可以是网络传输，也可以是

40
00:01:29,437 --> 00:01:34,231
somehow. Actually it could be transmitted
over the internet. Could be transmitted

41
00:01:34,407 --> 00:01:39,156
使用加密文件系统传输，这都没有多大关系。但是当密文

42
00:01:34,407 --> 00:01:39,156
using an encrypted file system, it doesn't
really matter, but when the ciphertext

43
00:01:39,156 --> 00:01:43,402
发给Bob，他可以把它放到解密算法

44
00:01:39,156 --> 00:01:43,402
reaches Bob, he can plug it into the
decryption algorithm and give the

45
00:01:43,402 --> 00:01:47,985
并给解密算法一个一样的密钥k，我也做一个楔形标记

46
00:01:43,402 --> 00:01:47,985
decryption algorithm the same key K.
Again, I'm gonna put a wedge here as well. To

47
00:01:47,985 --> 00:01:53,191
来强调输入为密钥k，解密算法输出原始明文

48
00:01:47,985 --> 00:01:53,191
denote the key inputs and the decryption
algorithm outputs the original plaintext

49
00:01:53,191 --> 00:01:58,149
现在我想说明这里是对称加密，即加密与解密

50
00:01:53,191 --> 00:01:58,149
message. Now the reason we say that these
are symmetric ciphers is that both the

51
00:01:58,149 --> 00:02:03,169
事实上用的是同一个密钥k。正如我们后面将看到的

52
00:01:58,149 --> 00:02:03,169
encrypter and decrypter actually use the
same key K. As we'll see later

53
00:02:03,169 --> 00:02:08,312
有些加密中算法E使用一个密钥

54
00:02:03,169 --> 00:02:08,312
in the course, there are ciphers where the
encrypter uses one key and the decrypter

55
00:02:08,312 --> 00:02:13,394
解密算法D使用不同的密钥，但在这里我们只关注对称密码

56
00:02:08,312 --> 00:02:13,394
uses a different key. But here we're just
going to focus on symmetric cipher where

57
00:02:13,394 --> 00:02:18,280
它们使用的是同一个密钥，接下来让你们看看一些历史上加密的例子

58
00:02:13,394 --> 00:02:18,280
both sides use the same key. Okay, so let
me give you a few historic examples of

59
00:02:18,280 --> 00:02:23,159
第一个例子，也是最简单的，被称作置换加密

60
00:02:18,280 --> 00:02:23,159
ciphers. The first example, the simplest
one is called the substitution cipher. I

61
00:02:23,159 --> 00:02:27,977
我确信你们在幼儿园就玩过置换加密

62
00:02:23,159 --> 00:02:27,977
am sure all of you played the substitution
ciphers when you were in kindergarten.

63
00:02:28,162 --> 00:02:33,165
根本来说，置换加密的密钥就是置换表

64
00:02:28,162 --> 00:02:33,165
Basically a key for a substitution cipher
is a substitution table that basically

65
00:02:33,165 --> 00:02:38,230
最基本的来说就是如何置换值字母，因此对于这个例子，A将被映射C

66
00:02:33,165 --> 00:02:38,230
says how to map our letters. So here for
example the letter A would be mapped to C,

67
00:02:38,230 --> 00:02:43,232
B将被映射W，C将被映射N，一直这样下去

68
00:02:38,230 --> 00:02:43,232
the letter B would be mapped to W the
letter C would be mapped to N so on and so

69
00:02:43,232 --> 00:02:48,499
然后一直到Z被映射为A，这就是一个单钥置换加密的例子

70
00:02:43,232 --> 00:02:48,499
forth and then the letter Z would be
mapped, say, to A. So this is one example

71
00:02:48,499 --> 00:02:54,922
为了练习我们之前介绍的概念

72
00:02:48,499 --> 00:02:54,922
of a key for a substitution cipher. So just
to practice the notation we introduced

73
00:02:54,922 --> 00:03:00,775
加密一部分信息使用这个密钥，假设就是

74
00:02:54,922 --> 00:03:00,775
before, the encryption of a certain
message using this key, let's say the

75
00:03:00,775 --> 00:03:07,197
信息BCZA，这个信息就是使用这个密钥加密

76
00:03:00,775 --> 00:03:07,197
message is BCZA, the encryption of this
message using this key here would be, is

77
00:03:07,197 --> 00:03:13,782
一次转换一个字母，B--W,C--N,Z--A,A--C

78
00:03:07,197 --> 00:03:13,782
done by substituting one letter at a time.
So B becomes W, C becomes N, Z becomes A,

79
00:03:13,782 --> 00:03:20,530
因此BCZA就是对WNAC的加密，这就是的密文

80
00:03:13,782 --> 00:03:20,530
and A becomes C. So the encryption of BCZA
is WNAC, and this defines the ciphertext.

81
00:03:20,530 --> 00:03:25,654
同理的我们可以用这个密钥解密密文

82
00:03:20,530 --> 00:03:25,654
Similarly we can decrypt the ciphertext using the same key and of course

83
00:03:25,654 --> 00:03:31,073
我们将得到它原始的信息

84
00:03:25,654 --> 00:03:31,073
we'll get back the original message.
Okay. So, just for historical

85
00:03:31,073 --> 00:03:35,763
因为历史原因，这个有关置换密码的例子被叫做凯撒密码

86
00:03:31,073 --> 00:03:35,763
reasons, there is one example of something
that's related to the substitution cipher

87
00:03:35,763 --> 00:03:39,950
事实上凯撒密码根本不是真正的密码

88
00:03:35,763 --> 00:03:39,950
called the Caesar cipher. The Caesar
cipher, actually, is not really a cipher

89
00:03:39,950 --> 00:03:44,417
原因就是它不存在密钥

90
00:03:39,950 --> 00:03:44,417
at all. And the reason is that it doesn't
have a key. What a Caesar cipher is, is

91
00:03:44,417 --> 00:03:48,772
凯撒密码根本上是一个固定的置换表

92
00:03:44,417 --> 00:03:48,772
basically a substitution cipher where the
substitution is fixed. Namely, it's a

93
00:03:48,772 --> 00:03:56,796
也就是说它相当于一个变换，就像A--D,B--E,C--F等等

94
00:03:48,772 --> 00:03:56,796
shift by three. So A becomes D, B becomes
E, C becomes F and so on and so forth.

95
00:03:56,796 --> 00:04:05,197
那它是什么呢，Y变成B，Z变成C，它是一个应用于所有明文信息的固定置换

96
00:03:56,796 --> 00:04:05,197
What is it, Y becomes B and Z becomes C.
It's a fixed substitution that's applied

97
00:04:05,197 --> 00:04:10,931
重申一下，这不是加密，因为它没有密钥

98
00:04:05,197 --> 00:04:10,931
to all plaintext messages. So, again,
this is not a cipher, because there is no

99
00:04:10,931 --> 00:04:15,734
或者说密钥是固定的，如果攻击者知道加密原理

100
00:04:10,931 --> 00:04:15,734
key, the key is fixed. So if an attacker
knows how our encryption scheme works, he

101
00:04:15,734 --> 00:04:20,597
他可以很轻松的破解信息，这个密钥不是随机的

102
00:04:15,734 --> 00:04:20,597
can easily decrypt the message. The key is
not random, and therefore, decryption is

103
00:04:20,597 --> 00:04:25,233
因此一旦知道工作原理破解是很容易的

104
00:04:20,597 --> 00:04:25,233
very easy once you understand how the
scheme actually works. Okay, so now, let's

105
00:04:25,233 --> 00:04:29,941
现在让我们回到置换加密，这种加密中密钥选择是随机的

106
00:04:25,233 --> 00:04:29,941
go back to the substitution cipher, where
the keys really are chosen at random, the

107
00:04:29,941 --> 00:04:34,132
置换表选择也是随机的，让我们看看如何打破这种置换密码

108
00:04:29,941 --> 00:04:34,132
substitution tables are chosen at random.
And let's see how we break this

109
00:04:34,132 --> 00:04:38,724
其实这很简单。第一个问题是，

110
00:04:34,132 --> 00:04:38,724
substitution cipher. Turns out to be very
easy to break. The first question is, how

111
00:04:38,724 --> 00:04:43,030
密钥空间有多大，这里有多少种不同的密钥，总共有26个英文字母

112
00:04:38,724 --> 00:04:43,030
big is the key space? How many different
keys are there, assuming we have 26

113
00:04:43,030 --> 00:04:48,367
因此我想你们会说密钥的数量是26的阶乘

114
00:04:43,030 --> 00:04:48,367
letters? So, I hope all of you said that,
the number of keys is 26 factorial,

115
00:04:48,367 --> 00:04:53,874
因为一个密钥，一个置换密钥，就是26的排列组合

116
00:04:48,367 --> 00:04:53,874
because, a key, a substitution key, is
simply a table, a permutation of all 26

117
00:04:53,874 --> 00:05:00,115
26的排列组合就是26!

118
00:04:53,874 --> 00:05:00,115
letters. The number of permutations of 26
letters, is 26 factorial. If you calculate

119
00:05:00,115 --> 00:05:05,769
26!大约是2^88

120
00:05:00,115 --> 00:05:05,769
this out, twenty-sixth factorial is about
two to the 88th, which means that

121
00:05:05,769 --> 00:05:11,422
这意味着描述置换加密的密钥需要花费88比特

122
00:05:05,769 --> 00:05:11,422
describing a key in a substitution cipher
takes about 88 bits. So, each key is

123
00:05:11,422 --> 00:05:17,325
每种密钥被88比特表示，这作为密码空间大小非常合适

124
00:05:11,422 --> 00:05:17,325
represented by about 88 bits. Now, this is
a perfectly fine size for a keyspace. In

125
00:05:17,325 --> 00:05:22,076
事实上我们将看到加密是非常安全.或许，你知道，

126
00:05:17,325 --> 00:05:22,076
fact, we're gonna be seeing ciphers that
are perfectly secure, or, you know, that

127
00:05:22,076 --> 00:05:26,710
大致有这个大小的密码空间是足够安全的，然而，即使

128
00:05:22,076 --> 00:05:26,710
are adequately secure, with key spaces
that are roughly of this size. However,

129
00:05:26,710 --> 00:05:31,461
置换密码的空间是2^88，它仍然

130
00:05:26,710 --> 00:05:31,461
even though the substitution cipher has a
large key space of size 2^88, it's

131
00:05:31,461 --> 00:05:36,330
非常不安全，让我们看看如何破解它。破解它，我们

132
00:05:31,461 --> 00:05:36,330
still terribly insecure. So let's see how
to break it. And to break it, we're going

133
00:05:36,330 --> 00:05:40,523
将使用分析字母使用频率的方法，那么第一个问题是

134
00:05:36,330 --> 00:05:40,523
to be using letter frequencies. So the
first question is, what is the most

135
00:05:40,696 --> 00:05:45,099
英文中最常用的字母是什么呢，我猜你们都知道

136
00:05:40,696 --> 00:05:45,099
frequent letter in English text? So I
imagine all of you know that, in fact, E

137
00:05:45,099 --> 00:05:49,617
E就是最常用的字母，如果我们进行定量研究

138
00:05:45,099 --> 00:05:49,617
is the most common letter. And that is
gonna, if we make it quantitative, that's

139
00:05:49,617 --> 00:05:54,194
这将帮助我们破解置换加密，从而仅已知密文

140
00:05:49,617 --> 00:05:54,194
gonna help us break a substitution cipher.
So just given the ciphertext, we can

141
00:05:54,194 --> 00:05:59,012
我们就可以得到明文，我们的方法是，首先

142
00:05:54,194 --> 00:05:59,012
already recover the plaintext. So the way
we do that is, first of all, using

143
00:05:59,012 --> 00:06:04,094
利用英文字母的使用频率，看这个怎么操作。

144
00:05:59,012 --> 00:06:04,094
frequencies of English letters. So here's
how this works. So you give me an

145
00:06:04,094 --> 00:06:09,737
那么你给我一个使用置换加密的密文，我知道的只有

146
00:06:04,094 --> 00:06:09,737
encrypted message using the substitution
cipher. All I know is that the plaintext

147
00:06:09,737 --> 00:06:15,227
原文使用的是英文，我还知道E是最常用的字母

148
00:06:09,737 --> 00:06:15,227
is in English and I know that the letter E
is the most frequent letter in English.

149
00:06:15,227 --> 00:06:19,846
事实上，在标准英语文章中它出现的概率是12.7%

150
00:06:15,227 --> 00:06:19,846
And in fact, it appears 12.7 percent of
the time in standard English texts. So

151
00:06:19,846 --> 00:06:25,202
所以我要做的就是观察你给我的密文，我将

152
00:06:19,846 --> 00:06:25,202
what I'll do is I'll look at the ciphertext you gave me and I'm going to count

153
00:06:25,202 --> 00:06:30,692
统计出每个字母出现的次数，那么

154
00:06:25,202 --> 00:06:30,692
how many times every letter appears. Now
the most common letter in the ciphertext

155
00:06:30,692 --> 00:06:35,771
密文中出现最频繁的字母用很大可能就是字母E

156
00:06:30,692 --> 00:06:35,771
is going to be the encryption of the
letter E with very high probability. So

157
00:06:35,771 --> 00:06:41,187
现在我们得到求解密钥表一个入口，基本上

158
00:06:35,771 --> 00:06:41,187
now I'm able to recover one entry in the
key table. Mainly the letter, mainly now I

159
00:06:41,187 --> 00:06:46,855
在这些字母中我已经知道了E所对应的，第二常用的字母是T

160
00:06:41,187 --> 00:06:46,855
know what the letter E maps to. The
next, most common letter in English is the

161
00:06:46,855 --> 00:06:52,068
它占9.1%的概率，重复上面过程

162
00:06:46,855 --> 00:06:52,068
letter T, that appears about 9.1 percent
of the time. So now again, I count how

163
00:06:52,068 --> 00:06:56,526
计算密文中每个字母出现次数

164
00:06:52,068 --> 00:06:56,526
many times each letter appears in the
ciphertext. And the second most frequent

165
00:06:56,526 --> 00:07:01,269
第二常用的很有可能是T

166
00:06:56,526 --> 00:07:01,269
letter is very likely to be the encryption
of the letter T. So now I've recovered a

167
00:07:01,269 --> 00:07:05,784
这样我们就找到了第二个入口，然后继续这种方法

168
00:07:01,269 --> 00:07:05,784
second entry in the key table. And I can
continue this way. In fact, the letter A

169
00:07:05,784 --> 00:07:09,841
接下来是字母A，出现概率8.1%

170
00:07:05,784 --> 00:07:09,841
is the next most common letter; it appears
8.1 percent of the time. So now I can

171
00:07:09,841 --> 00:07:14,642
我们就可以肯定密文中第三常用对应的是A

172
00:07:09,841 --> 00:07:14,642
guess that the third most common letter in
the ciphertext is the encryption of the

173
00:07:14,642 --> 00:07:19,157
我们已经得到了密钥表中的三个入口

174
00:07:14,642 --> 00:07:19,157
letter A. And now I've recovered three
entries in the key table. Well, so now

175
00:07:19,157 --> 00:07:23,543
现在我们要做什么呢，余下的字母在英语中出现次数很相近

176
00:07:19,157 --> 00:07:23,543
what do I do? The remaining letters in
English appear roughly same amount of

177
00:07:23,543 --> 00:07:27,997
其他的几乎不出现像Q和X，我们好像困在这一步了

178
00:07:23,543 --> 00:07:27,997
time, other than some rare letters like Q
and X. But we're kinda stuck at this

179
00:07:27,997 --> 00:07:32,963
我们找到了密钥表中的三个入口，接下来怎么办呢

180
00:07:27,997 --> 00:07:32,963
point. We figured out three entries in
the key table but what do we do next? So,

181
00:07:32,963 --> 00:07:38,619
接下来我们使用成对字母的频率，我们也称它们

182
00:07:32,963 --> 00:07:38,619
the next idea is to use frequencies of
pairs of letters. Sometimes these are

183
00:07:38,619 --> 00:07:44,647
二连字，接下来我们需要数出密文中连字出现的次数

184
00:07:38,619 --> 00:07:44,647
called digrams. So, what I'll do is, I'll
count how many times each pair of letters

185
00:07:44,647 --> 00:07:50,527
当然我知道这是英文写的，最常用的成对字母

186
00:07:44,647 --> 00:07:50,527
appears in the cipher text, and, I know
that in English, the most common pairs of

187
00:07:50,527 --> 00:07:55,973
有he，an，in，th也是非常常用的字母对

188
00:07:50,527 --> 00:07:55,973
letters are things like, HE, AN. IN, I
guess TH is another common pair of

189
00:07:55,973 --> 00:08:02,240
这样我们知道密文中最频繁的连字

190
00:07:55,973 --> 00:08:02,240
letters. And so I know that the most
common pair of letters in the ciphertext

191
00:08:02,240 --> 00:08:08,134
就是这四对中的一个，通过试验，

192
00:08:02,240 --> 00:08:08,134
is likely to be the encryption of one of
these four pairs. And so by trial and

193
00:08:08,134 --> 00:08:13,257
我们可以找到找到密钥表的更多入口..元素，按照这种方法重复

194
00:08:08,134 --> 00:08:13,257
error I can sort of figure out more entry ...
more elements in the key table and again

195
00:08:13,257 --> 00:08:18,195
试验探错，我就可以得到整个的密钥表

196
00:08:13,257 --> 00:08:18,195
by more trial and error this way by
looking at trigrams. I can actually figure

197
00:08:18,195 --> 00:08:23,256
因此，事实上在置换加密还是易受攻击的

198
00:08:18,195 --> 00:08:23,256
out the entire key table. So the bottom
line here is that in fact the substitution

199
00:08:23,256 --> 00:08:28,441
而这是最差的可能的攻击，就是唯密文攻击

200
00:08:23,256 --> 00:08:28,441
cipher is vulnerable to the worst possible
type of attack namely a ciphertext only

201
00:08:28,441 --> 00:08:33,440
只要已知密文，就能破解出解密密钥

202
00:08:28,441 --> 00:08:33,440
attack. Just given the ciphertext the
attack that can recover the decryption key

203
00:08:33,440 --> 00:08:37,798
从而恢复出明文，因此，加密时使用置换加密

204
00:08:33,440 --> 00:08:37,798
and therefore recover the original plaintext. So there's really no point in

205
00:08:37,798 --> 00:08:41,949
是没有意义的，因为攻击者可以轻松

206
00:08:37,798 --> 00:08:41,949
encrypting anything using the substitution
cipher, because the attacker can easily

207
00:08:41,949 --> 00:08:46,100
地破译，这样如同清楚地发送明文效果一样。

208
00:08:41,949 --> 00:08:46,100
decrypt it all; you might as well send
your plaintext completely in the clear.

209
00:08:46,100 --> 00:08:50,471
接下来我们将快进到文艺复兴时期

210
00:08:46,100 --> 00:08:50,471
So, now we're gonna fast-forward to the
Renaissance, and, I guess we're moving

211
00:08:50,471 --> 00:08:55,073
也就是说，我们从罗马时代跳到了文艺复兴这期，

212
00:08:50,471 --> 00:08:55,073
from the Roman Era to the Renaissance, and
look at a cipher designed by a fellow

213
00:08:55,073 --> 00:08:59,042
来看一个叫Vigener(维吉尼亚)的哥们设计的密码，他生活在16世纪

214
00:08:55,073 --> 00:08:59,042
named Vigener, who lived in the
sixteenth century. He designed a couple

215
00:08:59,042 --> 00:09:03,529
他设计了一系列密码，现在我将展示其中一种的变体

216
00:08:59,042 --> 00:09:03,529
of ciphers. Here I'm gonna show you a
variant of one of his ciphers, this is

217
00:09:03,529 --> 00:09:07,153
它也被称作Vigener加密，在Vigener密码中，密钥是一个单词

218
00:09:03,529 --> 00:09:07,153
called a Vigener cipher. So, in a
Vigener cipher, the key is a

219
00:09:07,153 --> 00:09:11,870
这种情况下这个单词是CRYPTO，它由六个字母构成

220
00:09:07,153 --> 00:09:11,870
word. In this case the word, is CRYPTO,
it's got six letters in it. And then to

221
00:09:11,870 --> 00:09:16,272
然后为了加密信息，你要做的就是根据密钥重写信息

222
00:09:11,870 --> 00:09:16,272
encrypt a message, what you do is, you
write the message under the key. So in

223
00:09:16,272 --> 00:09:22,041
如果消息是“WHAT A NICE DAY TODAY”，然后按照需要重复地用密钥

224
00:09:16,272 --> 00:09:22,041
this case the message is "WHAT A NICE DAY
TODAY" and then you replicate the key as

225
00:09:22,041 --> 00:09:28,375
掩盖信息这种加密就是

226
00:09:22,041 --> 00:09:28,375
many times as needed to cover the message.
And then the way you encrypt is basically,

227
00:09:28,375 --> 00:09:34,514
将密钥字母加原文字母然后模26。这里给个例子说明一下

228
00:09:28,375 --> 00:09:34,514
you add the key letters to the message
letters, modulo 26. So just to give

229
00:09:34,514 --> 00:09:41,125
比如，Y加到A就得到Z

230
00:09:34,514 --> 00:09:41,125
you an example here, for example, if you
add Y and A, you get Z. If you add T and

231
00:09:41,125 --> 00:09:47,263
T加A得到U

232
00:09:41,125 --> 00:09:47,263
A, you get U. And you do this for all the
letters. And remember, whenever you add,

233
00:09:47,263 --> 00:09:52,541
对所有的字母都这样

234
00:09:47,263 --> 00:09:52,541
you add modulo 26. So if you go past Z,
you go back to A. So, that's the

235
00:09:52,541 --> 00:09:56,159
记住加的时候一定要模26，这样超过Z就会回到A

236
00:09:52,541 --> 00:09:56,159
Vigener cipher. And in fact,
decryption is just as easy as encryption.

237
00:09:56,159 --> 00:10:00,512
这就是Vigener加密，事实上解密和加密一样简单

238
00:09:56,159 --> 00:10:00,512
Basically, the way you would decrypt is,
again, you would write the ciphertext

239
00:10:00,512 --> 00:10:05,260
解密的方法就是在密钥下写出密文

240
00:10:00,512 --> 00:10:05,260
under the key. You would replicate the key
and then you would subtract the key from

241
00:10:05,260 --> 00:10:10,125
重复使用密钥，密文减去密钥就可以得到原文

242
00:10:05,260 --> 00:10:10,125
the ciphertext to get the original plain
text message. So, breaking the Vigener

243
00:10:10,125 --> 00:10:15,112
因此破译Vigener加密是相当容易的。让我们看看怎么做

244
00:10:10,125 --> 00:10:15,112
cipher is actually quite easy. Let me
show you how you do it. The first thing we

245
00:10:15,112 --> 00:10:20,038
首先我们假设知道密钥的长度

246
00:10:15,112 --> 00:10:20,038
need to do is we need to assume that we
know the length of the key. So let's just

247
00:10:20,038 --> 00:10:24,842
假设这种情况下密钥长度是六个

248
00:10:20,038 --> 00:10:24,842
assume we know that. In this case, the
length of the key is six. And then what we

249
00:10:24,842 --> 00:10:29,890
接下来我们就把明文6个6个分组，我们

250
00:10:24,842 --> 00:10:29,890
do is we break the cipher text into groups
of six letters each, okay? So we're gonna

251
00:10:29,890 --> 00:10:35,789
我们得到一串串这样的组。每一组都由六个字母组成

252
00:10:29,890 --> 00:10:35,789
get a bunch, a bunch of groups like this.
Each one, contains six letters. And then

253
00:10:35,789 --> 00:10:41,698
然后看一看每一组的第一个字母

254
00:10:35,789 --> 00:10:41,698
we're gonna look at, the first letter in
each group. Okay? So, in this case, yes,

255
00:10:41,698 --> 00:10:47,680
是的，我们正在看第一个字母，每六个字符

256
00:10:41,698 --> 00:10:47,680
we're looking at the first letter, every
six characters. Now, what do we know about

257
00:10:47,680 --> 00:10:53,514
关于这六个（应该是3个）字母我们知道什么呢

258
00:10:47,680 --> 00:10:53,514
these six letters? We know that, in fact,
they're all encrypted using the same

259
00:10:53,514 --> 00:10:59,496
事实上，他们加密使用的是一样的字母

260
00:10:53,514 --> 00:10:59,496
letter in the ciphertext. All of these
are encrypted using the letter c. In other

261
00:10:59,496 --> 00:11:09,170
都使用字母C加密, Z L W就是三个明文字母的转换

262
00:10:59,496 --> 00:11:09,170
words. Z L W is a shift by three of the
plaintext letters. So if we collect all

263
00:11:09,170 --> 00:11:14,782
如果我们收集了所有的字母，最常用的很可能是E的加密

264
00:11:09,170 --> 00:11:14,782
these letters then the most common letter
among the set is likely to be the

265
00:11:14,782 --> 00:11:20,394
E是最常用的英文字母

266
00:11:14,782 --> 00:11:20,394
encryption of E, right? E is the most
common letter in English, therefore, if I

267
00:11:20,394 --> 00:11:26,154
因此如果我们每寻找六个字母

268
00:11:20,394 --> 00:11:26,154
look at every sixth letter, the most
common letter in that set is likely to be

269
00:11:26,154 --> 00:11:32,209
最常用的的就是字母E的加密，那么我们假设事实上

270
00:11:26,154 --> 00:11:32,209
the encryption of the letter E. Ahah! So
let's just suppose that in fact the most

271
00:11:32,209 --> 00:11:38,009
最频繁的字母恰好还是H

272
00:11:32,209 --> 00:11:38,009
common letter every sixth letter happens
to be the letter H. Then we know that E

273
00:11:38,009 --> 00:11:43,624
就推出E加密钥的第一个字母得到H

274
00:11:38,009 --> 00:11:43,624
plus the first letter of the key is equal
to H. That says that the first letter of

275
00:11:43,624 --> 00:11:48,828
也就是说密钥第一个字母等于H减E，就是C

276
00:11:43,624 --> 00:11:48,828
the key is equal to H minus E. And in fact
that is the letter C. So now we've

277
00:11:48,828 --> 00:11:54,275
这样我们得出了密钥的第一个字母，对第二个字母重复以上过程

278
00:11:48,828 --> 00:11:54,275
recovered the first letter of the key. Now
we can continue doing this with the second

279
00:11:54,275 --> 00:11:59,238
那么，我们看一下每六个字符中的第二个字母

280
00:11:54,275 --> 00:11:59,238
letter. So we look at the second letter in
every group of six characters and again,

281
00:11:59,238 --> 00:12:04,141
重复试验，找到密文中最常用的的和我们已知最常用的

282
00:11:59,238 --> 00:12:04,141
we repeat the same exercise. We find
the most common letter among the sets and

283
00:12:04,141 --> 00:12:09,044
这个常用字母就是E的加密

284
00:12:04,141 --> 00:12:09,044
we know that the most, this most common
letter is likely the encryption of E and

285
00:12:09,044 --> 00:12:13,463
不管这个字母是什么

286
00:12:09,044 --> 00:12:13,463
therefore whatever this letter, whatever
this most common letter is if we

287
00:12:13,463 --> 00:12:18,666
减去E就可以得到密钥中的第二个字母

288
00:12:13,463 --> 00:12:18,666
subtract 'E' from it we're going to get the
second letter of the key. And so on and so

289
00:12:18,666 --> 00:12:23,418
重复这个过程，我们就可以得到密码中的第三个字母

290
00:12:18,666 --> 00:12:23,418
forth. With, the third letter every six
characters. And this way we recover, the

291
00:12:23,418 --> 00:12:27,900
这样依次就可以得到整个字母表，就可以破译信息了

292
00:12:23,418 --> 00:12:27,900
entire key. And that allows us to
decrypt, the message. Now, the only caveat

293
00:12:27,900 --> 00:12:32,496
唯一需要说明的是我们必须提前知道密钥的长度

294
00:12:27,900 --> 00:12:32,496
is that I had to assume ahead of time that
I know the length of the key, which in

295
00:12:32,496 --> 00:12:37,035
上面我们假设是6

296
00:12:32,496 --> 00:12:37,035
this case is six. But if I don't know the
length of the key ahead of time, that's

297
00:12:37,035 --> 00:12:41,461
但如果我们不知道长度，那也不是问题

298
00:12:37,035 --> 00:12:41,461
not a problem either. What I would do is I
would run this decryption procedure,

299
00:12:41,461 --> 00:12:45,629
我们要做的就是运行破译步骤，假设是1，再假设是2

300
00:12:41,461 --> 00:12:45,629
assuming the key length is one. Then I'd
run it assuming the key length is two.

301
00:12:45,629 --> 00:12:49,423
再假设长度是3，依次下去

302
00:12:45,629 --> 00:12:49,423
Then I would run it assuming the key
lengths is three. And so on, and so on,

303
00:12:49,423 --> 00:12:53,319
直到我们最后能得到信息，我们就得到有意义的破解

304
00:12:49,423 --> 00:12:53,319
and so on, until finally I get a message.
I get a decryption that makes sense,

305
00:12:53,319 --> 00:12:57,771
那的确有意义，一旦我们知道密钥的正确长度

306
00:12:53,319 --> 00:12:57,771
that's sensical. And once I do that I know
that I've kind of recovered the right

307
00:12:57,771 --> 00:13:02,141
我们就可以得到正确的密钥

308
00:12:57,771 --> 00:13:02,141
length of the key and I know that
I've also recovered the right key and

309
00:13:02,141 --> 00:13:06,348
然后就得到正确的信息，懂了吗

310
00:13:02,141 --> 00:13:06,348
therefore the right message. Okay? So
very, very quickly, you can recover, you

311
00:13:06,348 --> 00:13:10,571
非常快，你就可以破解Vigener加密，这唯密文攻击

312
00:13:06,348 --> 00:13:10,571
can decrypt Vigener cyphers. Again,
this is a ciphertext only attack. The

313
00:13:10,571 --> 00:13:14,954
有趣的是Vigener想到了很好的主意，模26

314
00:13:10,571 --> 00:13:14,954
interesting thing is, Vigener had a
good idea here. This addition mod

315
00:13:14,954 --> 00:13:19,123
的确是个好主意，以后我们会看到，就是在这里它被执行得非常

316
00:13:14,954 --> 00:13:19,123
26 is actually a good idea, and we'll see
that later, except it's executed very

317
00:13:19,123 --> 00:13:23,307
糟糕，这是我们将改正的一点，稍晚一点

318
00:13:19,123 --> 00:13:23,307
poorly here. And so we'll correct that, a
little bit later. Okay, we're gonna

319
00:13:23,307 --> 00:13:27,908
好吧，我们将从文艺复兴时期快进到19世纪

320
00:13:23,307 --> 00:13:27,908
fast-forward now from the Renaissance to, to the nineteenth century where

321
00:13:27,908 --> 00:13:32,738
这个时代很多东西开始用电，因此人们想设计使用电驱动的密码

322
00:13:27,908 --> 00:13:32,738
everything became electric. And so people
wanted to design ciphers that use electric

323
00:13:32,738 --> 00:13:37,396
这些加密被称作转子机，因为他们使用转子

324
00:13:32,738 --> 00:13:37,396
motors. In particular, these ciphers are
called rotor machines because they use

325
00:13:37,396 --> 00:13:42,111
一个较早的例子就是使用一个转子的Hibber机

326
00:13:37,396 --> 00:13:42,111
rotors. So an early example is called the
Hibber machine which uses a single motor.

327
00:13:42,111 --> 00:13:46,654
这里给你们一幅图片，这就是转子，我猜它在

328
00:13:42,111 --> 00:13:46,654
Here you have a picture of this machine.
The, the motor, the, I guess the rotor is

329
00:13:46,654 --> 00:13:51,941
这儿，密钥被这里的磁盘捕获，它被嵌入到磁盘的里面

330
00:13:46,654 --> 00:13:51,941
over here. And the secret key is captured
by this disc here, it's embedded inside of

331
00:13:51,941 --> 00:13:56,524
你每在键盘输入一个密钥它就旋转一个刻痕

332
00:13:51,941 --> 00:13:56,524
this disc, which rotates by one notch
every time you press a key on the

333
00:13:56,524 --> 00:14:01,687
所以你每敲一个键，盘转过一格

334
00:13:56,524 --> 00:14:01,687
typewriter, okay? So every time you, that
you hit a key, the disc rotates by one

335
00:14:01,687 --> 00:14:06,722
那这个密钥怎么工作呢，密钥实际上编码一个置换表

336
00:14:01,687 --> 00:14:06,722
notch. Now what does this key do? Well,
the key actually encodes a substitution

337
00:14:06,722 --> 00:14:11,950
因此，这个磁盘就是密钥

338
00:14:06,722 --> 00:14:11,950
table. So ... and therefore, the disc actually
is the secret key. And as I said, this

339
00:14:11,950 --> 00:14:17,049
正如我所说的，磁盘编码置换表，在这种情况下

340
00:14:11,950 --> 00:14:17,049
disc encodes a substitution table. In this
case, if you happen to press C as the

341
00:14:17,049 --> 00:14:22,211
如果你恰好第一字母按C，输出将会是字母T

342
00:14:17,049 --> 00:14:22,211
first letter, output would be the letter
T. And then the disc would rotate by one

343
00:14:22,211 --> 00:14:27,242
然后磁盘旋转一格，新的置换表就显示在这里

344
00:14:22,211 --> 00:14:27,242
notch. After rotating, rotating by one
notch, the new substitution table becomes

345
00:14:27,242 --> 00:14:31,693
你看到E移到上面去了

346
00:14:27,242 --> 00:14:31,693
the one shown here. You see that E,
basically, moves up, and then the

347
00:14:31,693 --> 00:14:36,531
余下的接在下面。想象一下这其实是一个由一格控制的二维

348
00:14:31,693 --> 00:14:36,531
remaining letters move down. So imagine
this is basically a two dimensional

349
00:14:36,531 --> 00:14:41,495
旋转磁盘。然后按下另一个字母。

350
00:14:36,531 --> 00:14:41,495
rendering of the disc rotating by one
notch. Then you press the next letter. And

351
00:14:41,495 --> 00:14:46,798
磁盘再次旋转 ，注意到N上移其它字母顺序接下

352
00:14:41,495 --> 00:14:46,798
the disc rotates again. You notice again N
moved up and the remaining letters moved

353
00:14:46,798 --> 00:14:51,590
特别的，如果我们敲击3次C，第一次

354
00:14:46,798 --> 00:14:51,590
down. So in particular, if we hit the
letter C three times, the first time we

355
00:14:51,590 --> 00:14:56,765
将会输出T，第二次输出S

356
00:14:51,590 --> 00:14:56,765
would output, the output would be T, the
second time the output would be S, and the

357
00:14:56,765 --> 00:15:01,756
第三次将会是K，这就是简单的转子机的工作方式

358
00:14:56,765 --> 00:15:01,756
third time the output wold be K. So this
is how the single rotor machine works and

359
00:15:01,756 --> 00:15:06,806
在它公布后很快就被使用字母频率

360
00:15:01,756 --> 00:15:06,806
as it turned out very quickly after it was
advertised it was again broken basically

361
00:15:06,806 --> 00:15:11,136
和连字频率和三连字频率的方法破解了

362
00:15:06,806 --> 00:15:11,136
using letter frequency, digram
frequencies and trigram frequencies. It's

363
00:15:11,136 --> 00:15:16,126
破译密钥，进而破译原文不是很难去

364
00:15:11,136 --> 00:15:16,126
not that hard given enough ciphertext to
directly recover the secret key and then

365
00:15:16,126 --> 00:15:20,756
再次说明这只是唯密文攻击

366
00:15:16,126 --> 00:15:20,756
the message. Again, a ciphertext only
attack. So to kind of work against these

367
00:15:20,756 --> 00:15:25,326
因此为了抵抗频率攻击，这种统计攻击

368
00:15:20,756 --> 00:15:25,326
frequency attacks, these statistical
attacks, these rotor machines became more

369
00:15:25,326 --> 00:15:29,861
这些转子机变得而越来越复杂，最终，你们肯定听过Enigma

370
00:15:25,326 --> 00:15:29,861
and more complicated over time. Until
finally, I'm sure you've all heard of the

371
00:15:29,861 --> 00:15:33,841
这是一种复杂的转子机

372
00:15:29,861 --> 00:15:33,841
Enigma. The Enigma is a kind of
complicated rotor machine. It uses

373
00:15:33,841 --> 00:15:37,991
它使用3到5个转子，还有不同版本的Enigma机

374
00:15:33,841 --> 00:15:37,991
three, four, or five rotors. There are
different versions of the Enigma

375
00:15:37,991 --> 00:15:42,311
给你们看一下3个转子的Enigma机，

376
00:15:37,991 --> 00:15:42,311
machine. Here you see an example of the
Enigma machine with three rotors. The

377
00:15:42,311 --> 00:15:47,086
Enigma机的密码是内置在转子里的。

378
00:15:42,311 --> 00:15:47,086
secret key in the Enigma machine is the
initial setting of the rotors. Okay. So in

379
00:15:47,086 --> 00:15:51,748
这种情况下，3个转子，会有26^3种可能的不同密钥

380
00:15:47,086 --> 00:15:51,748
the case of three rotors there would be 26
cubed possible different keys. When you

381
00:15:51,748 --> 00:15:57,049
当你从键盘输入时，转子就会以不同的速率旋转

382
00:15:51,748 --> 00:15:57,049
type on the typewriter basically these
rotors here rotate at different rates.  Oh,

383
00:15:57,049 --> 00:16:02,351
忘了说了这是4个转子的Enigma机图片

384
00:15:57,049 --> 00:16:02,351
forgot to say this is a diagram of an Enigma
machine using four rotors. As you type on

385
00:16:02,351 --> 00:16:07,463
当你在打字机上打字时，输出合适的密文字母

386
00:16:02,351 --> 00:16:07,463
the typewriter the rotors rotate and
output the appropriate, letters of, the

387
00:16:07,463 --> 00:16:12,576
这样密钥的数量就是26^4

388
00:16:07,463 --> 00:16:12,576
ciphertext. So in this case the number
of keys is 26 to the fourth, which is two

389
00:16:12,576 --> 00:16:17,372
这大约2^18,这是一个相当小的密钥空间

390
00:16:12,576 --> 00:16:17,372
to the eighteen, which is relatively a
small key space. Today you can kind of,

391
00:16:17,562 --> 00:16:22,359
今天你可以简单粗暴使用电脑检索2^88个不同的密钥

392
00:16:17,562 --> 00:16:22,359
brute-force a search using a computer
through two to the eighteen different

393
00:16:22,359 --> 00:16:26,723
这非常快，我们的智能手表能几秒内算出来

394
00:16:22,359 --> 00:16:26,723
keys, very, very quickly. You know, my
wristwatch can do it in just a few

395
00:16:26,723 --> 00:16:31,010
我想这个Enigma机使用相当少的空间

396
00:16:26,723 --> 00:16:31,010
seconds, I guess. And so, these, this
Enigma machine was, already was using

397
00:16:31,010 --> 00:16:35,529
我确信你们听过一个英国的破译者

398
00:16:31,010 --> 00:16:35,529
relatively small key spaces. But I'm sure
you've all heard that the British

399
00:16:35,529 --> 00:16:40,280
他在布莱奇利公园仅仅攻击了Enigma机就匹配了密文

400
00:16:35,529 --> 00:16:40,280
cryptographers at Bletchley Park were
able to mount ciphertext only attacks on

401
00:16:40,280 --> 00:16:44,915
他们在二战时破译了德军的密码

402
00:16:40,280 --> 00:16:44,915
the Enigma machine. They were able to
decrypt German ciphers back in World, in

403
00:16:44,915 --> 00:16:49,377
他们在世界大战的不同战役都扮演了重要角色

404
00:16:44,915 --> 00:16:49,377
World War Two. And that played an
important role in many different battles

405
00:16:49,377 --> 00:16:54,109
战争之后，那是机械时代的结束

406
00:16:49,377 --> 00:16:54,109
during the war. After the war, I guess
that was the end kind of the mechanical

407
00:16:54,109 --> 00:16:58,988
开启了数字时代，人们开始使用电脑

408
00:16:54,109 --> 00:16:58,988
age and started the digital age where
folks were using computers. And as the

409
00:16:58,988 --> 00:17:04,046
随着世界都开始使用电脑，政府意识到他们在从工业界购买

410
00:16:58,988 --> 00:17:04,046
world kind of migrated to using computers,
the government realized that it's buying a

411
00:17:04,046 --> 00:17:09,045
大量电子设备，因此政府希望从工业界购买设备时，希望

412
00:17:04,046 --> 00:17:09,045
lot of digital equipment from industry.
And so they wanted industry to use a good

413
00:17:09,045 --> 00:17:13,864
预装有好的加密机制

414
00:17:09,045 --> 00:17:13,864
cipher so that when it buys equipment from
the, from industry, it would be getting

415
00:17:13,864 --> 00:17:19,509
因此政府发出了数据加密标准的征集

416
00:17:13,864 --> 00:17:19,509
equipment with, with a decent cipher. And
so the government put out this request for

417
00:17:19,509 --> 00:17:24,691
一个联邦的数据加密标准

418
00:17:19,509 --> 00:17:24,691
proposal for a data encryption standard,
a Federal data encryption standard. And

419
00:17:24,691 --> 00:17:30,205
在这个课上，我们将详细谈论这个的影响

420
00:17:24,691 --> 00:17:30,205
we're gonna talk about this effort, in
more detail later on in the course, but in

421
00:17:30,205 --> 00:17:35,720
1974年，IBM的一个团队提出了一个密码，是DES，数据加密

422
00:17:30,205 --> 00:17:35,720
1974 a group at IBM put together a cipher
that became known as DES, data encryption

423
00:17:35,720 --> 00:17:41,633
标准，它成为了联邦的数据加密标准。DES的密钥空间

424
00:17:35,720 --> 00:17:41,633
standard, which became a Federal standard
for encrypting data. The key space for DES

425
00:17:41,633 --> 00:17:46,616
是2^56，如今来说相当小，但在1974年

426
00:17:41,633 --> 00:17:46,616
is two to the 56, which is relatively
small these days, but was large enough

427
00:17:46,616 --> 00:17:51,553
它足够大了，关于DES，另一个有趣的是，

428
00:17:46,616 --> 00:17:51,553
back in 1974. And another interesting
thing about DES is, rather than, unlike

429
00:17:51,553 --> 00:17:56,683
它不像转子机一次只能加密一个字节，

430
00:17:51,553 --> 00:17:56,683
rotor machines which encrypt one character
at a time the data encryption standard

431
00:17:56,683 --> 00:18:01,623
它能一次加密64比特，也就是8个字节，在后面的

432
00:17:56,683 --> 00:18:01,623
encrypts 64 bits at a time, namely eight
characters at a time. And we'll see the

433
00:18:01,623 --> 00:18:06,563
课程我们将明白其中的意义。因为DES使用

434
00:18:01,623 --> 00:18:06,563
significance of this later on in the
course. Because DES uses such

435
00:18:06,563 --> 00:18:11,440
如此小的密钥空间，如今可以使用暴力检索来破译

436
00:18:06,563 --> 00:18:11,440
a small key space, these days it can be
broken by a brute-force search and so

437
00:18:11,440 --> 00:18:15,994
所有如今DES被认为是不安全的，不允许在项目中使用

438
00:18:11,440 --> 00:18:15,994
these days DES is considered
insecure and should not be used in

439
00:18:15,994 --> 00:18:20,798
不幸的是，他仍然被使用在一些遗留系统中

440
00:18:15,994 --> 00:18:20,798
projects. Unfortunately, it is used in
some legacy systems, but it definitely is

441
00:18:20,798 --> 00:18:25,787
但现在很明显，它在没落，不会再用到新的项目上。

442
00:18:20,798 --> 00:18:25,787
on its way out and definitely should not
be used in new projects. Today there are

443
00:18:25,787 --> 00:18:30,529
如今已经有了新的加密方法，比如使用128比特密钥的AES。

444
00:18:25,787 --> 00:18:30,529
new ciphers, things like the advanced
encryption standard which uses 128 bit

445
00:18:30,529 --> 00:18:35,579
后面我们将会详细地讨论高级加密标准

446
00:18:30,529 --> 00:18:35,579
keys. Again, we'll talk about the advanced
encryption standards in much more detail

447
00:18:35,579 --> 00:18:40,383
这里有很多种其他的加密类型。这里我提一下

448
00:18:35,579 --> 00:18:40,383
later on in the course. There are many,
many other types of ciphers. I mentioned

449
00:18:40,383 --> 00:18:45,248
salsa20。我们马上就会看到为什么。这就是历史方面简短

450
00:18:40,383 --> 00:18:45,248
Salsa20 here. We'll see why in just a
minute. But this is all for the quick

451
00:18:45,248 --> 00:18:49,560
的介绍，现在我们就要开始学习技术资料了

452
00:18:45,248 --> 00:18:49,560
historical survey and now we can get into
the more technical material.

