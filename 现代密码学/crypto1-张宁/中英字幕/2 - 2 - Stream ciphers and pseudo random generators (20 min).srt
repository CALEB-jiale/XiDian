1
00:00:00,000 --> 00:00:04,524
既然我们已经了解了一次一密，现在来讨论如何利用流密码

2
00:00:00,000 --> 00:00:04,524
Now that we know about the one-time pad,
let's talk about making the one-time pad

3
00:00:04,524 --> 00:00:08,881
来使一次一密变得更加实用。开始之前

4
00:00:04,524 --> 00:00:08,881
more practical using something called the
stream cypher. But before we do that,

5
00:00:08,881 --> 00:00:13,573
让我们快速回顾一下我们进行到哪了。提醒一下大家，

6
00:00:08,881 --> 00:00:13,573
let's do a quick review of where we were.
So let me just remind you that a cypher is

7
00:00:13,573 --> 00:00:18,209
密码系统是定义在一个三元组上的,即密钥空间,明文空间和密文的空间

8
00:00:13,573 --> 00:00:18,209
defined over a triple of sets called a key
space, a message space, and a cypher text

9
00:00:18,209 --> 00:00:22,398
密码算法由一对高效的算法E和D组成

10
00:00:18,209 --> 00:00:22,398
bare space. And a cypher is a pair of
efficient algorithms called E and D; E

11
00:00:22,398 --> 00:00:27,086
E代表加密算法，D代表解密算法。这里唯一需要满足的特性就是

12
00:00:22,398 --> 00:00:27,086
stands for encryption and D stands for
decryption. And the only property. That we

13
00:00:27,086 --> 00:00:32,294
应当满足解密算法是加密算法的逆运算。换句话说

14
00:00:27,086 --> 00:00:32,294
need to satisfy is that decryption is the
opposite of encryption. In other words if

15
00:00:32,294 --> 00:00:36,954
如果我用特定的密钥给消息m加密，解密就得用相同的密钥

16
00:00:32,294 --> 00:00:36,954
I encrypt a message M using a particular
key. And I de-crypt using the same key. I

17
00:00:36,954 --> 00:00:41,272
这样就得到了最初的消息m。上节课我们看到一对弱密码机制

18
00:00:36,954 --> 00:00:41,272
get back the original message. Last time
we looked at a couple of weak cyphers like

19
00:00:41,272 --> 00:00:45,591
例如代换密码和vigonaire密码。我们可以看出它们都很容易

20
00:00:41,272 --> 00:00:45,591
the substitution cypher and the vigonaire
cypher. We showed that all of them can be

21
00:00:45,591 --> 00:00:49,650
被破解以至于你永远不应该用这些密码

22
00:00:45,591 --> 00:00:49,650
easily broken so you should never ever,
ever use those cyphers. Those were just

23
00:00:49,650 --> 00:00:53,604
这些都是历史经验证明,现在我们来看第一个例子,一个更优越的密码体制

24
00:00:49,650 --> 00:00:53,604
for historical reference. And then we
looked at our first exam.ple of a good

25
00:00:53,604 --> 00:00:57,819
称作“一次一密”,让我告诉你一次一密是如何定义的

26
00:00:53,604 --> 00:00:57,819
cypher, namely the one-time pad. So let me
just remind you how the one-time pad is

27
00:00:57,819 --> 00:01:01,877
首先明文空间是一连串的比特码

28
00:00:57,819 --> 00:01:01,877
defined. Basically the message space is
the set of all bit end bit strings. The

29
00:01:01,877 --> 00:01:05,892
密文是一组比特流。同样的，密钥是

30
00:01:01,877 --> 00:01:05,892
cypher text is a set of all bit end bit
strings. And similarly, the key. Is the

31
00:01:05,892 --> 00:01:10,310
N位比特流，并且加密方法是通过简单异或来加密明文。

32
00:01:05,892 --> 00:01:10,310
set of all N bit strings and the way we
encrypt is by a simple exor to encrypt the

33
00:01:10,310 --> 00:01:14,467
我们只用密钥与明文做异或就得到密文。

34
00:01:10,310 --> 00:01:14,467
message we just exor the message in the
key that gives us the cypher text. And

35
00:01:14,467 --> 00:01:18,990
之后对密文解密，只需用再一次做异或

36
00:01:14,467 --> 00:01:18,990
then to decrypt a cypher text, we just do
this x over again and it's easier to show

37
00:01:18,990 --> 00:01:23,240
这很容易看出整个算法过程,这就体现了解密是加密的逆运算

38
00:01:18,990 --> 00:01:23,240
by properties of x over that in fact
decryption is the opposite of encryption.

39
00:01:23,240 --> 00:01:27,380
现在我们讲一下这个定理。实际上，我们证明了

40
00:01:23,240 --> 00:01:27,380
And then we talked about this lemma, in
fact, we proved it, that says that the

41
00:01:27,380 --> 00:01:31,794
一次一密具有很好的保密性,指的是如果你是一个窃听者

42
00:01:27,380 --> 00:01:31,794
one-time pad has perfect secrecy, which
means that if you're just an eavesdropper

43
00:01:31,794 --> 00:01:35,935
且只有一个简单的密文，你将不可能

44
00:01:31,794 --> 00:01:35,935
and you just get to see a single cypher
text, you're not going to be able to

45
00:01:35,935 --> 00:01:40,332
推断出任何有关已经加密的文本的信息。很不幸，我们也说过

46
00:01:35,935 --> 00:01:40,332
deduce any information about the encrypted
plain text. Unfortunately. We also said

47
00:01:40,332 --> 00:01:44,648
香农证明了这个定理。我们称它为坏消息定理，它实际在说

48
00:01:40,332 --> 00:01:44,648
that Shannon proved this lema, we called
it the bad news lema, that basically says

49
00:01:44,648 --> 00:01:48,751
任何一个密码，要想要完全保密必须要有很长的密钥。换句话说

50
00:01:44,648 --> 00:01:48,751
that any cypher that has perfect secrecy
must have really long keys. In other

51
00:01:48,751 --> 00:01:53,067
密钥的长度至少和明文的长度一样

52
00:01:48,751 --> 00:01:53,067
words, the key length must be at least as
long as the length of the message, which

53
00:01:53,067 --> 00:01:57,490
也就意味着这种密码体制不是很实用。因为如果双方

54
00:01:53,067 --> 00:01:57,490
means that the cypher is not particularly
useful. Because if two parties have a way

55
00:01:57,490 --> 00:02:01,753
同意密钥的长度和明文一样长，在某种程度上

56
00:01:57,490 --> 00:02:01,753
to agree on really long keys that are as
long as the message, they, in some sense,

57
00:02:01,753 --> 00:02:05,931
他们可能早已用这种机制传送消息本身了。所以在这堂课上

58
00:02:01,753 --> 00:02:05,931
might as well use that mechanism to
already transmit the message itself. So in

59
00:02:05,931 --> 00:02:10,538
我们将使用一次一密的思想并且使之成为实用的加密方案

60
00:02:05,931 --> 00:02:10,538
this lecture we're going to take the idea
of the one time pad and try to make it

61
00:02:10,538 --> 00:02:15,031
所以，这就是所谓的流密码

62
00:02:10,538 --> 00:02:15,031
into a practical encryption scheme. So
this is called what's called a stream

63
00:02:15,031 --> 00:02:20,999
在流密码中，并不用随机密钥

64
00:02:15,031 --> 00:02:20,999
cypher. So the idea in this dream cypher
is rather than using a totally random key,

65
00:02:20,999 --> 00:02:26,346
实际我们用的是伪随机序列。为了解释它如何工作

66
00:02:20,999 --> 00:02:26,346
we're actually going to use a
pseudo-random key. And to explain how that

67
00:02:26,346 --> 00:02:31,544
我需要定义什么是伪随机生成器-PRG。PRG实际上就是

68
00:02:26,346 --> 00:02:31,544
works, I need to define what is a
pseudo-random generator, PRG. So a PRG,

69
00:02:31,544 --> 00:02:37,337
一个函数,记做种子密钥的生成器g

70
00:02:31,544 --> 00:02:37,337
really, all it is, is just a function,
I'll call it g for generator, that takes a

71
00:02:37,337 --> 00:02:43,277
我们用{0,1}集合的s次方来表示0,1比特串长度为s

72
00:02:37,337 --> 00:02:43,277
seed, so I'm going to use zero one to the
s to denote all strings of length s, so

73
00:02:43,277 --> 00:02:48,729
这个我们称这个集合为种子空间,他将s比特的种子转化成一个更长的比特串，

74
00:02:43,277 --> 00:02:48,729
this we'll call the seed space. So he
takes an s bit seed and maps it to a much

75
00:02:48,729 --> 00:02:53,978
该串的长度用{0,1}的n次方来表示。必须满足的是n比s大。

76
00:02:48,729 --> 00:02:53,978
larger string which will denote by zero
one to the n. And the property is that n

77
00:02:53,978 --> 00:02:59,161
换句话说我们输入种子密钥可能仅仅128比特

78
00:02:53,978 --> 00:02:59,161
must be much larger than s. So in other
words, we take a seed that might be only

79
00:02:59,161 --> 00:03:04,345
之后我们把他扩展成更长的可以达到千兆字节长度的输出串

80
00:02:59,161 --> 00:03:04,345
128 bits and we expand it into a much,
much larger output string that could be

81
00:03:04,345 --> 00:03:08,806
这就是伪随机生成器所做的。当然

82
00:03:04,345 --> 00:03:08,806
gigabytes long. That's what this
pseudo-random generator does. And of

83
00:03:08,806 --> 00:03:14,055
目标是首先发生器必须是高效可计算的

84
00:03:08,806 --> 00:03:14,055
course, the goal is that first of all, the
generator is efficiently computable, so

85
00:03:14,055 --> 00:03:19,248
所以对于函数g，应该是一类可计算的高效的算法来计算它

86
00:03:14,055 --> 00:03:19,248
the function g. There should be some sort
of an efficient algorithm that computes

87
00:03:19,248 --> 00:03:24,066
函数必须由一个确定的算法高效计算着。

88
00:03:19,248 --> 00:03:24,066
it. So, efficiently computable by a
deterministic algorithm. It's important to

89
00:03:24,066 --> 00:03:29,250
函数g自身没有随机性,理解这点是很重要的,它是确定性的。

90
00:03:24,066 --> 00:03:29,250
understand that the function g itself has
no more randomness, in it, it's a totally

91
00:03:29,250 --> 00:03:33,946
唯一具有随机性的是种子密钥

92
00:03:29,250 --> 00:03:33,946
deterministic. The only thing that's
random here is the random seed, that's

93
00:03:33,946 --> 00:03:38,703
它被作为函数g的输入。它的另一个特性是输出

94
00:03:33,946 --> 00:03:38,703
given as input to the function g. And the
other property, of course, is that the

95
00:03:38,703 --> 00:03:43,388
看起来是随机的。问题是它看起来是随机的指的是什么？

96
00:03:38,703 --> 00:03:43,388
output. Should look random and the
question is what does it mean to look

97
00:03:43,388 --> 00:03:48,694
这我们将在后面的课程中给出定义，好，假设

98
00:03:43,388 --> 00:03:48,694
random, and that's something we'll define
later on in the lecture. Okay so suppose

99
00:03:48,694 --> 00:03:53,869
我们有一个发生器，那么我们怎样用它生成流密码

100
00:03:48,694 --> 00:03:53,869
we have such a generator, how do we use
that, to build a stream cipher? We the

101
00:03:53,869 --> 00:03:59,503
我们的思路是用种子来作为密钥。短种子被作为秘密密钥，

102
00:03:53,869 --> 00:03:59,503
idea is that we're gonna use the seed, as
our key, so our short seed is gonna be our

103
00:03:59,503 --> 00:04:04,679
然后我们用生成器将种子密钥扩展

104
00:03:59,503 --> 00:04:04,679
secret key. And then we're gonna use the
generator to basically expand the seed

105
00:04:04,679 --> 00:04:09,723
成更长的类随机序列或者伪随机序列

106
00:04:04,679 --> 00:04:09,723
into a much, much larger random looking
sequence, or pseudo random sequence, as

107
00:04:09,723 --> 00:04:14,657
由已知,我们可以得到G(k),之后用它进行异或就像

108
00:04:09,723 --> 00:04:14,657
it's known, so this would be G of K. And then
we are going to X over it just like in the

109
00:04:14,657 --> 00:04:19,185
在一次一密中那样。我们用伪随机序列和明文做异或

110
00:04:14,657 --> 00:04:19,185
one time pad we're going to X over it the
student random sequence with the message

111
00:04:19,185 --> 00:04:24,185
就得到了密文。如果我们想用数学语言来表达

112
00:04:19,185 --> 00:04:24,185
and that's going to give us the cypher
text. Or if we want to write this in math,

113
00:04:24,185 --> 00:04:30,139
那么就用c代表信息经密钥k加密后的密文m，

114
00:04:24,185 --> 00:04:30,139
we'll write C equals the encryption of the
message M with a key K, which is simply

115
00:04:30,139 --> 00:04:35,619
则c定义为m和G(k)的异或。接下来我们要做解密,基本上就是在做

116
00:04:30,139 --> 00:04:35,619
defined as M XOR G of K. And then when we
want to decrypt, basically we do exactly

117
00:04:35,619 --> 00:04:41,234
同样的工作。用密文异或G(k),就像在一次一密中那样，

118
00:04:35,619 --> 00:04:41,234
the same thing. It's basically the cypher
text XOR G of K, just like in the one-time

119
00:04:41,234 --> 00:04:46,782
除了不是与K异或,我们用生成器的输出与K进行异或运算

120
00:04:41,234 --> 00:04:46,782
pad except then instead of XOR-ing with K,
we XOR with the output of the generator

121
00:04:46,782 --> 00:04:52,148
所以第一个要问的问题是为什么这是安全的

122
00:04:46,782 --> 00:04:52,148
applied to K. So the first question to ask
is why is it secure? So, basically you

123
00:04:52,148 --> 00:04:56,651
其实，到目前为止，我们现在只有一个安全概念即完全保密

124
00:04:52,148 --> 00:04:56,651
now, we only have one notion of security
so far, which we called perfect secrecy.

125
00:04:56,651 --> 00:05:01,552
所以让我们看看流密码是否具有完全保密性,记得在

126
00:04:56,651 --> 00:05:01,552
And so let's just quickly ask can a stream
cipher have perfect secrecy. Remember in

127
00:05:01,552 --> 00:05:06,132
流密码中,密钥长度远远比信息的,所以

128
00:05:01,552 --> 00:05:06,132
the stream cipher the key is much, much
shorter than the message. And so, never

129
00:05:06,132 --> 00:05:12,392
流密码是否具有完全保密性,我希望每个人的回答是"不"

130
00:05:06,132 --> 00:05:12,392
the less, can it have perfect secrecy. So
I hope everybody said the answer is, no.

131
00:05:12,392 --> 00:05:17,198
密钥远远比明文的长度短。而我们说

132
00:05:12,392 --> 00:05:17,198
The key is much shorter than the message.
And we said that in a, in a perfectly

133
00:05:17,198 --> 00:05:21,819
在完全保密体制中，密钥必须和明文一样长。因此

134
00:05:17,198 --> 00:05:21,819
secure cypher, the key must be as long as
the mesage. And therefore, it's not

135
00:05:21,819 --> 00:05:26,317
一个流密码要具有完全保密性是不可能的。

136
00:05:21,819 --> 00:05:26,317
possible that a, that a stream cypher
actually has perfect secrecy. So the

137
00:05:26,317 --> 00:05:30,774
所以问题是它为什么又是安全的呢？首先我们需要对安全性给出一个不同的定义

138
00:05:26,317 --> 00:05:30,774
question is, then, well, why is it secure?
First of all we would need a different

139
00:05:30,774 --> 00:05:34,410
才能讨论流密码的安全性。 尤其是

140
00:05:30,774 --> 00:05:34,410
definition of security to argue that
Stream Safe is, is secure and in

141
00:05:34,410 --> 00:05:38,783
安全性取决于我们所使用的特定的生成器

142
00:05:34,410 --> 00:05:38,783
particular, the security property is going
to depend on the specific generator that

143
00:05:38,783 --> 00:05:42,681
实际上，由流密码安全性所给出的私密性定义

144
00:05:38,783 --> 00:05:42,681
we used. So in fact the definition of
privacy that we'll need to argue the

145
00:05:42,681 --> 00:05:47,054
我们将在下一节课中给出。现在让我给你们展示

146
00:05:42,681 --> 00:05:47,054
security of Stream Cipher is we'll see in
the next lecture, but for now let me show

147
00:05:47,054 --> 00:05:51,614
一个特殊的特性。那就是发生器对于安全性的要求必须有一个最小限度

148
00:05:47,054 --> 00:05:51,614
you one particular property. That a
generator must have a minimum property

149
00:05:51,614 --> 00:05:56,510
这个特性被称为不可预测性,所以

150
00:05:51,614 --> 00:05:56,510
needed for security. This property is
called unpredictability. So let's we

151
00:05:56,510 --> 00:06:01,807
让我们暂时假设一个流密码是可预测的，那么

152
00:05:56,510 --> 00:06:01,807
suppose for one second that in fact a
stream cycle is predictable. So, what does

153
00:06:01,807 --> 00:06:07,172
这意味着什么？同样,PRG也是可预测的,意思就是主要这里存在一个i值

154
00:06:01,807 --> 00:06:07,172
that mean? Both the PRG is predictable.
What that means is essentially that there

155
00:06:07,172 --> 00:06:13,691
如果我给出输出的前i位，这个符号

156
00:06:07,172 --> 00:06:13,691
is some pi. Such that if I give you the
first I bits of the outputs. This notation

157
00:06:13,691 --> 00:06:18,920
的意思是函数输出的前i个比特

158
00:06:13,691 --> 00:06:18,920
Bar one to I means look at the first
I-bits of the output of the function.

159
00:06:18,920 --> 00:06:23,733
好的,我给你这个流密码的前i位。这里有一类

160
00:06:18,920 --> 00:06:23,733
Okay, so I give you the first I bits of
the stream. There is some sort of an

161
00:06:23,733 --> 00:06:28,995
可以计算剩余字串的有效算法

162
00:06:23,733 --> 00:06:28,995
algorithm, there's an efficient algorithm
that will compute the rest of the string.

163
00:06:28,995 --> 00:06:34,193
所以我给你前i位,你可以计算出剩余的比特串

164
00:06:28,995 --> 00:06:34,193
Okay, so given the first I bits, you can
compute the remainder of the bits. I claim

165
00:06:34,193 --> 00:06:39,392
如果是这种情况,流密码是不安全的。让我们看看为什

166
00:06:34,193 --> 00:06:39,392
that if this is the case, then the stream
cypher would not be secure. So let's see

167
00:06:39,392 --> 00:06:44,205
假设一个攻击者拦截了一个特定的密文c

168
00:06:39,392 --> 00:06:44,205
why. Suppose an attacker actually
intercepts a particular cypher text, let's

169
00:06:44,205 --> 00:06:49,511
如果是这样，那么我们有一个问题。因为假设

170
00:06:44,205 --> 00:06:49,511
call it c. If this is the case, then in
fact, we have a problem. Because suppose

171
00:06:49,511 --> 00:06:55,514
根据之前获得的信息，攻击者实际上知道的信息开头的部分

172
00:06:49,511 --> 00:06:55,514
that just by some prior knowledge, the
attacker actually knows that the initial

173
00:06:55,514 --> 00:07:01,298
刚好就是一些已知值,例如，我们知道

174
00:06:55,514 --> 00:07:01,298
part of the message happens to be some
known value. For example, we know that in

175
00:07:01,298 --> 00:07:07,448
在一些邮件传输协议中，比如smtp协议--应用在网络中的标准邮件发送协议

176
00:07:01,298 --> 00:07:07,448
the mail protocol, smtp, the standard mail
call used in the internet, you know that

177
00:07:07,448 --> 00:07:12,860
每条信息都以冒号开始。这是每一个敌手都知道的前缀

178
00:07:07,448 --> 00:07:12,860
every message starts with a word from
colon. Well, that would be a prefix that

179
00:07:12,860 --> 00:07:18,169
对网站来说发送的信息必须以冒号开始

180
00:07:12,860 --> 00:07:18,169
the adversary knows. That the site, that
the message must begin with from a colon.

181
00:07:18,169 --> 00:07:23,677
网站能做就是它能够用冒号引出加密的密文

182
00:07:18,169 --> 00:07:23,677
What it could do is it could [inaudible]
the cipher text with the words from colon,

183
00:07:23,677 --> 00:07:29,053
用已知明文的一点前缀引出密文。它能给的只是

184
00:07:23,677 --> 00:07:29,053
with the little prefix of the message that
it actually knows. And what that would

185
00:07:29,053 --> 00:07:33,951
这就能给他一个伪随机序列的前缀，结果就是我将

186
00:07:29,053 --> 00:07:33,951
give it is a prefix of. Of the pseudo
random sequence. And I would learn as a

187
00:07:33,951 --> 00:07:39,103
获得伪随机序列的前缀。但我们知道

188
00:07:33,951 --> 00:07:39,103
result of this, it would learn a prefix of
the pseudo random sequence but then we

189
00:07:39,103 --> 00:07:44,191
一旦知道伪随机序列前缀就可以推测出

190
00:07:39,103 --> 00:07:44,191
know that once it has a prefix of the
pseudo random sequence it can predict the

191
00:07:44,191 --> 00:07:49,280
剩余的序列码并且进一步可以推测出整个信息的剩余部分

192
00:07:44,191 --> 00:07:49,280
remainder of the pseudo random sequence
and that would allow it to then predict

193
00:07:49,280 --> 00:07:54,559
好的，例如如果伪随机序列生成器是

194
00:07:49,280 --> 00:07:54,559
the rest of the message end. Okay, so for
example if the pseudo random generator was

195
00:07:54,559 --> 00:07:59,132
可预测的并给他5个比特之后，每一个用此流密码加密的邮件

196
00:07:54,559 --> 00:07:59,132
predictable given five bits of the pad.
Then every email encrypted using the

197
00:07:59,132 --> 00:08:03,203
被解密，因为攻击者通过推断密码本的前缀

198
00:07:59,132 --> 00:08:03,203
stream cypher would be decryptable
because, again, the attacker knows the

199
00:08:03,203 --> 00:08:07,556
来获取消息的前缀，这样他就能够

200
00:08:03,203 --> 00:08:07,556
prefix of the message from which he
deduces the prefix of the pad, which then

201
00:08:07,556 --> 00:08:12,023
计算出剩余的密码本之后的部分，从而进一步恢复

202
00:08:07,556 --> 00:08:12,023
allows him to compute the rest of the pad,
which then allows him to recover the

203
00:08:12,023 --> 00:08:16,433
整个未加密的文本。好的这就是一个例子,说明了如果一个PRG

204
00:08:12,023 --> 00:08:16,433
entire plain text. Okay, so this is an
example that shows that in fact if a PRG

205
00:08:16,433 --> 00:08:21,485
是可预测的那么它就存在安全问题。因为一个小的前缀

206
00:08:16,433 --> 00:08:21,485
is predictable then already there are
security problems. Because a small prefix

207
00:08:21,485 --> 00:08:27,288
将泄漏整个信息。结果就是,如果我能预测出

208
00:08:21,485 --> 00:08:27,288
would reveal the entire message. As it
turns out, even if I could predict just

209
00:08:27,288 --> 00:08:33,163
输出的一位，如果给我前i位，我能预测出

210
00:08:27,288 --> 00:08:33,163
one bit of the outputs. Even if given, you
know, the first I bits, I can predict the

211
00:08:33,163 --> 00:08:38,764
下一位，再加上第一位。这显然存在一个问题。再解释一遍就是说

212
00:08:33,163 --> 00:08:38,764
next bits, the I plus first bits. Already,
this is a problem. Because that would say

213
00:08:38,764 --> 00:08:43,252
给出信息的前几个字母就可以预测和

214
00:08:38,764 --> 00:08:43,252
that given again, the first couple of
letters in a message can predict, can

215
00:08:43,252 --> 00:08:48,163
和解密，并且恢复出消息的下一位或者下一层，

216
00:08:43,252 --> 00:08:48,163
decrypt essentially, and recover the next
bit of the message, or the next layer of

217
00:08:48,163 --> 00:08:52,347
从而不断重复这个过程。所以说这种可预测的特性告诉我们

218
00:08:48,163 --> 00:08:52,347
the message, and so on. So this
predictability property shows that, you

219
00:08:52,347 --> 00:08:57,259
用于流密码的PRG最好是

220
00:08:52,347 --> 00:08:57,259
know, if we use a PRG that's going to be
used in a stream cypher, it had better be

221
00:08:57,259 --> 00:09:02,363
不可预测的。那么PRG是不可预测的意味着什么呢？接下来让我们更

222
00:08:57,259 --> 00:09:02,363
unpredictable. So what does it mean that a
PRG is unpredictable? So let's define more

223
00:09:02,363 --> 00:09:07,129
准确的阐述PRG的不可预测性有什么意义。我们先来阐述

224
00:09:02,363 --> 00:09:07,129
precisely what it means for a PRG to be
unpredictable. Well first we'll define

225
00:09:07,129 --> 00:09:11,833
PRG的可预测性有什么意义。我们先考虑G是可预测的

226
00:09:07,129 --> 00:09:11,833
more precisely what it means for a PRG to
be predictable. So we say that G is

227
00:09:11,833 --> 00:09:18,111
如果存在一个有效的算法，称为A

228
00:09:11,833 --> 00:09:18,111
predictable, if there exists an efficient
algorithm. Let's call it A and there is

229
00:09:18,111 --> 00:09:24,932
并且存在一个位置i存在于1到N-1之间。基于此，如果

230
00:09:18,111 --> 00:09:24,932
some position. There's a position I
between one and N minus one such that if

231
00:09:24,932 --> 00:09:31,587
我们观察一个随机密钥的概率,如果我生成一个随机密钥

232
00:09:24,932 --> 00:09:31,587
we look at the probability over a random
key. Probability if I generate a random

233
00:09:31,587 --> 00:09:36,791
你们记得，这个记号表示从集合K中选择一个随机密钥

234
00:09:31,587 --> 00:09:36,791
key. You remember, this notation means
choose a random key from the set k. So

235
00:09:36,791 --> 00:09:42,212
所以，这个带r的箭头符号表示从集合K选择随机密钥。基本上，如果我

236
00:09:36,791 --> 00:09:42,212
this arrow with r just means choose a
random key from the set k. Basically, if I

237
00:09:42,212 --> 00:09:47,632
把输出的前缀给这个算法，如果把输出的前I字节给这个算法，

238
00:09:42,212 --> 00:09:47,632
give this algorithm the prefix of the
output, if I give it the first I bytes of

239
00:09:47,632 --> 00:09:53,190
则算法能推测出输出的下一个位的概率

240
00:09:47,632 --> 00:09:53,190
the output, the probability that it's able
to predict the next bit of the outputs,

241
00:09:53,190 --> 00:10:00,890
大于1/2+ε因为一些不可忽略的ε

242
00:09:53,190 --> 00:10:00,890
this probability is greater than half plus
epislon. For some non-negotiable. For some

243
00:10:00,890 --> 00:10:07,389
例如

244
00:10:00,890 --> 00:10:07,389
non-negligible. >> [inaudible]. >> A non
[inaudible], for example, would be

245
00:10:07,389 --> 00:10:11,322
e的值大于1/2^30，比如1/10^9就是不可忽略的

246
00:10:07,389 --> 00:10:11,322
epsilon, which is great than one over two
to the 30. One over a billion, for

247
00:10:11,322 --> 00:10:15,415
我们认为是不可忽略的 这些术语，可忽略和

248
00:10:11,322 --> 00:10:15,415
example, we would consider it not
negligible. So these terms, negligible and

249
00:10:15,415 --> 00:10:19,508
不可忽略的，我们都将在这节课的最后回到这里并且给出更准确的定义

250
00:10:15,415 --> 00:10:19,508
non negligible will come back at the end
of the lecture, and define them more

251
00:10:19,508 --> 00:10:24,260
不过现在让我们凭直觉思考一下不可忽略

252
00:10:19,508 --> 00:10:24,260
precisely. But for now, let's just, stick
with the intuitive notion of what non

253
00:10:24,260 --> 00:10:28,684
意味着什么。它是指对于一个算法，一个发生器来说是可预测的

254
00:10:24,260 --> 00:10:28,684
negligible means. And so this is what it
means, for an algorithm, for a generator

255
00:10:28,684 --> 00:10:33,332
实际，有一些算法可以预测I加第一个比特

256
00:10:28,684 --> 00:10:33,332
to be, predictable. Basically, there is
some algorithm that is able to predict the

257
00:10:33,332 --> 00:10:37,813
甚至共同的前缀，明白了吗？我们说一个算法

258
00:10:33,332 --> 00:10:37,813
I plus first bits, even the mutual prefix,
okay? And then we say that an algorithm,

259
00:10:37,813 --> 00:10:42,013
P或者G是不可预测的。实际，如果它不满足

260
00:10:37,813 --> 00:10:42,013
that a P or G is unpredictable. If in
fact, well, if it's doesn't satisfy the

261
00:10:42,013 --> 00:10:46,269
我们之前定义的特性，那么它就是不可预测的

262
00:10:42,013 --> 00:10:46,269
property that we just defined. In other
words, it is not predictable. But what

263
00:10:46,269 --> 00:10:50,861
但是是什么意思呢，对于不可预测更确切的意思是

264
00:10:46,269 --> 00:10:50,861
does it mean, more precisely for it not to
be predictable. It means that, in fact,

265
00:10:50,861 --> 00:10:55,246
对于i的所有值 不存在有效的对手和

266
00:10:50,861 --> 00:10:55,246
for all positions, for all i there is
no efficient adversary no efficient

267
00:10:55,246 --> 00:10:59,881
有效的算法A,在不可忽略的概率下能预测出i+1位

268
00:10:55,246 --> 00:10:59,881
algorithm A that can predict the i + 1
bit with non negligible probability.

269
00:10:59,881 --> 00:11:04,642
好的，对于所有I这都是成立的，无论我给你怎样的前缀

270
00:10:59,881 --> 00:11:04,642
Excellent. Okay and this has to be true
for all I. So no matter which prefix I

271
00:11:04,642 --> 00:11:08,920
你都不能推测出前缀的后一位

272
00:11:04,642 --> 00:11:08,920
give you, you're not gonna be able to
predict the next bit that follows the

273
00:11:08,920 --> 00:11:13,267
好的，让我们看看一些例子，一个十分简单的例子

274
00:11:08,920 --> 00:11:13,267
prefix. Okay, so let's look at some
examples. Here is a silly, silly example.

275
00:11:13,267 --> 00:11:17,632
假设我给你一个生成器，我的问题是它是否可预测的

276
00:11:13,267 --> 00:11:17,632
Suppose I give you a generator, and I ask
you, is it predictable? Well, this

277
00:11:17,632 --> 00:11:22,476
这个生成器恰巧具有这种特性,这种特性就是如果我把所有输出位进行

278
00:11:17,632 --> 00:11:22,476
generator happens to have the property,
that if I XOR all the bits of the

279
00:11:22,476 --> 00:11:27,317
异或,我总是恰巧得到1。所以,我对所有位进行异或。异或第一位，

280
00:11:22,476 --> 00:11:27,317
outputs, I always happen to get one. Okay,
so I x over all the bits. Bit number one,

281
00:11:27,317 --> 00:11:31,895
异或第二位,异或第三位.如果我对所有位进行异或

282
00:11:27,317 --> 00:11:31,895
x over bit number two, xor  bit number
three. If I x over all those bits, I

283
00:11:31,895 --> 00:11:36,657
恰巧得到1 问题是这是一个可预测的生成器吗？

284
00:11:31,895 --> 00:11:36,657
happen to get one. The question is, is
that a predictable generator? And again, I

285
00:11:36,657 --> 00:11:41,113
再一次,我希望每个人回答"是", 主要是给出输出字节的前n-1位

286
00:11:36,657 --> 00:11:41,113
hope everybody answered yes, that
essentially given the first n minus one

287
00:11:41,113 --> 00:11:45,997
就可以推测出第n位 因为仅仅需要比特值

288
00:11:41,113 --> 00:11:45,997
bits of the outputs, I can predict the nth
bit because it would just be the bits

289
00:11:45,997 --> 00:11:50,819
让它做异或运算使所有位为1。换句话说,我给你们

290
00:11:45,997 --> 00:11:50,819
that's needed to make the x over all the
bits be one. In other words, I give you

291
00:11:50,819 --> 00:11:55,825
除了生成器的比特值中的一个其他的所有值,你就可以推测出生成器的最后一个字节

292
00:11:50,819 --> 00:11:55,825
all but one of the bits of the generator,
you can actually predict the last bit of

293
00:11:55,825 --> 00:12:00,230
既然我们已经明白了PRG必须是不可预测的。我想

294
00:11:55,825 --> 00:12:00,230
the generator. Now that we've seen that
PRGs have to be unpredictable, I just want

295
00:12:00,230 --> 00:12:04,469
提及一下一对永远都不会用于加密的弱伪随机序列生成器（PRGs)

296
00:12:00,230 --> 00:12:04,469
to mention a couple of weak PRGs that
should never ever be used for crypto. This

297
00:12:04,469 --> 00:12:08,762
这是一个非常普遍的错误，我希望你们中没人

298
00:12:04,469 --> 00:12:08,762
is a very common mistake and I just want
to make sure none of you guys make this

299
00:12:08,762 --> 00:12:12,895
犯这样的错误。一个很常见的PRG绝不会被用于加密,这种PRG被称作

300
00:12:08,762 --> 00:12:12,895
mistake. So a very common PRG that should
actually never be used for crypto is

301
00:12:12,895 --> 00:12:17,347
线性同余生成器 我来解释一下什么是线性同余生成器

302
00:12:12,895 --> 00:12:17,347
called a linear congruential generator. So
let me explain what a linear congruential

303
00:12:17,347 --> 00:12:22,773
首先它有一些参量,这里是三个参量,我将它们称作A

304
00:12:17,347 --> 00:12:22,773
generator is. Basically it has parameters.
It has three parameters. I'll call them A,

305
00:12:22,773 --> 00:12:28,910
B,和P。A和B是整数,P是一个素数。生成器定义如下：

306
00:12:22,773 --> 00:12:28,910
B and P. A and B are just integers and P
is a prime. And the generator is defined

307
00:12:28,910 --> 00:12:35,341
假设R0是生成器的种子密钥。然后

308
00:12:28,910 --> 00:12:35,341
as follows, essentially I'll say R zero is
the seed of the generator. And then the

309
00:12:35,341 --> 00:12:42,883
生成随机序列的方法主要有以下

310
00:12:35,341 --> 00:12:42,883
way you generate randomness is basically
you [inaudible] run through the following

311
00:12:42,883 --> 00:12:49,971
这些步骤。计算r[i]=a*r[i-1](mod P)之后输出

312
00:12:42,883 --> 00:12:49,971
steps. You compute a times r of I minus
one plus b modular p. Then you output a

313
00:12:49,971 --> 00:12:58,053
一些位的当前状值，输出i的几位，然后增加i

314
00:12:49,971 --> 00:12:58,053
few bits of the current states, output few
bits of our i. Then, of course, you

315
00:12:58,053 --> 00:13:02,782
并且一遍又一遍的重复。好的，现在你知道这种生成器是怎么进行了。

316
00:12:58,053 --> 00:13:02,782
increment I and you iterate this again and
again and again. Okay? So you can see how

317
00:13:02,782 --> 00:13:07,341
它由一个特殊的种子开始，在每一步

318
00:13:02,782 --> 00:13:07,341
this generator proceeds. It starts with a
particular seed. At every step there is

319
00:13:07,341 --> 00:13:11,934
这种线性转换都作用于种子密钥，之后输出部分位

320
00:13:07,341 --> 00:13:11,934
this leaner transformation that's being
applied to the seed. And then you output a

321
00:13:11,934 --> 00:13:16,258
的当前状态，并且不断地重复这个过程。

322
00:13:11,934 --> 00:13:16,258
few bits of the current state and then you
do that again and again and again and

323
00:13:16,258 --> 00:13:20,476
很不幸,即使这样,这个生成器在某种程度上也具有良好的

324
00:13:16,258 --> 00:13:20,476
again. Unfortunately even though this
generator has good statistical properties

325
00:13:20,476 --> 00:13:24,960
统计特性。例如，它输出的0的个数和输出中

326
00:13:20,476 --> 00:13:24,960
in the sense that, for example, the number
of zeroes it outputs is likely going to be

327
00:13:24,960 --> 00:13:29,231
1的个数相似等等，对于这一点，你可以探讨各种良好的统计

328
00:13:24,960 --> 00:13:29,231
similar to the number of ones and so on;
it has, you can actually argue all sorts

329
00:13:29,231 --> 00:13:33,662
特性。然而它是一个非常容易预测的生成器

330
00:13:29,231 --> 00:13:33,662
of nice statistical properties about this,
nevertheless it is a very easy generator

331
00:13:33,662 --> 00:13:37,925
实际是绝不会被应用的。实际上，给定一些

332
00:13:33,662 --> 00:13:37,925
to predict. And in fact should never ever
be used. In fact, just given a few

333
00:13:37,925 --> 00:13:42,592
输出样本很容易预测剩余序列

334
00:13:37,925 --> 00:13:42,592
outputs, a few output samples, it's easy
to predict the remainder of the sequence.

335
00:13:42,592 --> 00:13:47,143
导致这种生成器将不会被应用。另一个例子是

336
00:13:42,592 --> 00:13:47,143
And as a result, this generator should
never ever be used. Another example is a

337
00:13:47,143 --> 00:13:51,810
一个随机数生成器与线性同余生成器关系十分密切。

338
00:13:47,143 --> 00:13:51,810
random number generator that is very
closely related to the linear congruential

339
00:13:51,810 --> 00:13:56,244
这是一个运用于glibc的随机数生成器,glibc是一个很常见的库

340
00:13:51,810 --> 00:13:56,244
generator. This is a random number
generator implemented in glibc, very

341
00:13:56,244 --> 00:14:01,437
你能发现，我刚刚把定义写了出来

342
00:13:56,244 --> 00:14:01,437
common library. That you can see. I just
wrote down the definition here. You can

343
00:14:01,437 --> 00:14:07,056
就可以看出,每次循环输出几个比特，并且每一步都

344
00:14:01,437 --> 00:14:07,056
see that is basically outputs a few bits
at every ideration and it just does this

345
00:14:07,056 --> 00:14:12,470
做这样简单的线性变换。再次强调,这是一个非常简单的可预测的生成器

346
00:14:07,056 --> 00:14:12,470
simple linear transformation at every
step. Again, this is a very easy generator

347
00:14:12,470 --> 00:14:17,952
并且绝不应该应用于加密。所以第一节课我想强调

348
00:14:12,470 --> 00:14:17,952
to predict and should never ever be used
for crypto. And so the lesson I want to

349
00:14:17,952 --> 00:14:23,179
永远不要使用内置的glibc库函数。对于加密来说

350
00:14:17,952 --> 00:14:23,179
emphasize here is never ever use the
built-in glibc function random. For crypto,

351
00:14:23,179 --> 00:14:27,718
从容易预测的意义来看，它并不会减少密码随机性

352
00:14:23,179 --> 00:14:27,718
because it doesn't reduce,
cryptographic randomness, in the sense

353
00:14:27,718 --> 00:14:32,749
实际上，Kerberos版本4系统就使用了随机数生成器

354
00:14:27,718 --> 00:14:32,749
that it is easy to predict. And, in fact,
systems like Kerberos version four have

355
00:14:32,749 --> 00:14:37,717
并深受此害。请你们不要犯这样的错误。

356
00:14:32,749 --> 00:14:37,717
used random and, have been bitten by that.
So, please don't make that mistake

357
00:14:37,717 --> 00:14:42,643
在下节课我们将会讨论如何实现安全的随机数生成器。

358
00:14:37,717 --> 00:14:42,643
yourself. We will talk about how to do
secure random number generation actually in

359
00:14:42,643 --> 00:14:47,765
在总结这节课之前我想给出一些关于

360
00:14:42,643 --> 00:14:47,765
the next lecture. Before we conclude this
lecture I just want to give a little bit

361
00:14:47,765 --> 00:14:52,513
有关可忽略和不可忽略的概念的细节。

362
00:14:47,765 --> 00:14:52,513
more detail about these concepts of
negligible and non-negligible values, so

363
00:14:52,513 --> 00:14:57,449
密码界不同的派别对这些概念有不同的定义

364
00:14:52,513 --> 00:14:57,449
different communities in crypto actually
define these concepts differently, for

365
00:14:57,449 --> 00:15:02,879
对于实习者来说，这些可忽略和不可忽略的术语仅是

366
00:14:57,449 --> 00:15:02,879
practitioners basically these the term
negligible and non-negligible,

367
00:15:02,879 --> 00:15:06,991
被用在定义中的特殊的词。举个例子来说，

368
00:15:02,879 --> 00:15:06,991
are just, particular scalers that are used in the
definition. So, for example, a

369
00:15:06,991 --> 00:15:11,623
一个实习者会说如果一个值大于1/10^9,

370
00:15:06,991 --> 00:15:11,623
practitioner would say, that if a value is
more than one over, one over a billion,

371
00:15:11,623 --> 00:15:16,082
或者大于1/2^30我们就认为这个值不能忽略

372
00:15:11,623 --> 00:15:16,082
one over two to the 30, we say that the
value is non-negligible. The reason is,

373
00:15:16,082 --> 00:15:20,831
原因就在于，因为如果你恰巧用一个密钥来加密

374
00:15:16,082 --> 00:15:20,831
the reason that's so, is, because if you
happen to use a key, for example, for, for

375
00:15:20,831 --> 00:15:25,522
一个GB级别大小的数据。GB级别大小的数据大概就在2^30

376
00:15:20,831 --> 00:15:25,522
encrypting a gigabyte of data, a gigabyte
of data is about two to the 30 or maybe

377
00:15:25,522 --> 00:15:30,198
到2^32字节之间。一个以1/2^30的概率发生的事件

378
00:15:25,522 --> 00:15:30,198
even two to the 32 bytes. Then an event
that happens with the probability one over

379
00:15:30,198 --> 00:15:34,672
更可能出现在生成了GB大小的数据之后。那么既然

380
00:15:30,198 --> 00:15:34,672
two to the thirty will likely happen after
about a gigabyte of data. So since a

381
00:15:34,672 --> 00:15:39,090
GB级别大小的数据对于一个特定的密钥来说是可能的话，那么这个事件就很有可能

382
00:15:34,672 --> 00:15:39,090
gigabyte of data is within reason for a
particular key, this event is likely to

383
00:15:39,090 --> 00:15:43,338
发生。因此1/2^30就是不可忽略的。另一方面

384
00:15:39,090 --> 00:15:43,338
happen. Therefore one over two to the
thirty is non-negligible. On the other

385
00:15:43,338 --> 00:15:47,732
我们来考虑1/2^80，这是一个更小概率的事件

386
00:15:43,338 --> 00:15:47,732
hand, we'll say that one over two to the
eighty. Which is much, much, much smaller

387
00:15:47,732 --> 00:15:51,794
这种事件发生的概率对于

388
00:15:47,732 --> 00:15:51,794
is an event, an event that happens with
this probability is an event that's

389
00:15:51,794 --> 00:15:56,451
密钥的生命期来说基本是不会发生的。于是我们说

390
00:15:51,794 --> 00:15:56,451
actually not going to happen over the life
of the key. And therefore we'll say that

391
00:15:56,451 --> 00:16:00,559
这是可忽略的事件，如上所述，这些有关忽略和不可忽略的实际的定义

392
00:15:56,451 --> 00:16:00,559
that's a negligible event. As it turns
out, these practical definitions of

393
00:16:00,559 --> 00:16:05,212
是相当有问题的。我们通过例子来看看为什么说它有问题？

394
00:16:00,559 --> 00:16:05,212
negligible and non-negligible are quite
problematic and we'll see examples of why

395
00:16:05,212 --> 00:16:09,290
为什么说它有问题？实际上在许多严密的密码学理论中，

396
00:16:05,212 --> 00:16:09,290
they're problematic later on. So in fact
in the more rigerous theory of

397
00:16:09,290 --> 00:16:14,058
忽略性与不可忽略性的定义是有些不同的。

398
00:16:09,290 --> 00:16:14,058
cryptography, the definition of negligible
and non-negligible are somewhat different.

399
00:16:14,058 --> 00:16:18,251
实际上，我们在讨论一个事件的概率时，

400
00:16:14,058 --> 00:16:18,251
And in fact, when we talk about the
probability of an event, we don't talk

401
00:16:18,251 --> 00:16:23,019
我们并不去讨论这些概率的数值，反而我们将概率作为

402
00:16:18,251 --> 00:16:23,019
about these probabilities as scalers, but
rather we talk about them as functions of

403
00:16:23,019 --> 00:16:27,270
函数安全参数来讨论。让我来解释这是什么意思。这些函数

404
00:16:23,019 --> 00:16:27,270
a security parameter. So let me explain
what that means. So these functions,

405
00:16:27,450 --> 00:16:32,447
本质上是映射输出的函数。正实数值是可能作为概率值的

406
00:16:27,450 --> 00:16:32,447
essentially, are functions that map, that
outputs, positive real values. So, are non

407
00:16:32,447 --> 00:16:37,384
非负实数.但是它们是在非负整数集上工作的函数。

408
00:16:32,447 --> 00:16:37,384
negative real values that are supposedly
probabilities. But they're functions that

409
00:16:37,384 --> 00:16:41,960
那么对于一个函数来说，不可忽略意味着什么？

410
00:16:37,384 --> 00:16:41,960
act on non negative integers, okay? So,
what does it mean for a function to be

411
00:16:41,960 --> 00:16:46,836
它是指函数通常比一些无限多项式大

412
00:16:41,960 --> 00:16:46,836
non-negligible? What it means is that the
function is bigger than some polynomial

413
00:16:46,836 --> 00:16:51,171
换句话说，对于无限的取值，函数值比

414
00:16:46,836 --> 00:16:51,171
infinitely often. In other words, for
many, for infinitely many values, the

415
00:16:51,171 --> 00:16:55,867
1/poly大，明白吗？我把准确

416
00:16:51,171 --> 00:16:55,867
function is bigger than some, one over
polynomial, okay? So I wrote the exact

417
00:16:55,867 --> 00:17:01,130
的定义写在这里。我们来看个例子，如果一个数较大

418
00:16:55,867 --> 00:17:01,130
definition here, and we'll see an example,
in just a minute. Okay? So if something is

419
00:17:01,130 --> 00:17:06,100
它通常应大于1/poly，那么我们就说这个值是不可忽略的

420
00:17:01,130 --> 00:17:06,100
bigger, is often bigger than one of that
polynomial, we'll say that it's non-negligible.

421
00:17:06,100 --> 00:17:11,070
但是，如果存在数值小于所有多项式的值，那么

422
00:17:06,100 --> 00:17:11,070
However, if something is
smaller than all polynomials, then we'll

423
00:17:11,070 --> 00:17:15,908
我们认为他是可以忽略的。就说到这，通常对任何次的

424
00:17:11,070 --> 00:17:15,908
say that it's negligible. So, what this
says here, basically, for any degree

425
00:17:15,908 --> 00:17:20,838
多项式，对所有的d值，存在一些下限λd

426
00:17:15,908 --> 00:17:20,838
polynomial, for all d, there exists some
lower bound lambda-d such as, for all

427
00:17:20,838 --> 00:17:25,162
所有λ都大于λd，函数小于1/poly。

428
00:17:20,838 --> 00:17:25,162
lambda bigger than this lambda-d, the
function is smaller than one over the

429
00:17:25,162 --> 00:17:29,716
这些都在说如果函数小于多项式的每一部分就认为他可以忽略

430
00:17:25,162 --> 00:17:29,716
polynomial. So all this says is that the
function is negligible if it's less than

431
00:17:29,716 --> 00:17:33,924
换句话说就是存在足够大且小于1/λd的λ。

432
00:17:29,716 --> 00:17:33,924
all polynomial fractions. In other words, is
less than one over lambda-d for

433
00:17:33,924 --> 00:17:38,135
让我们看一些例子之后就会发现这些

434
00:17:33,924 --> 00:17:38,135
sufficiently large lambda. So let's look
at some examples. And we'll see

435
00:17:38,135 --> 00:17:43,085
这些忽略和不可忽略的概念的应用。但是我

436
00:17:38,135 --> 00:17:43,085
applications of these negligible and
non-negligible concepts later on. But I

437
00:17:43,085 --> 00:17:47,689
仅想使大家更清楚怎样才能严密地发现这些概念。

438
00:17:43,085 --> 00:17:47,689
just want to make, wanted to make it clear
that this is how you would rigorously find

439
00:17:47,689 --> 00:17:52,185
通常，不论小于1/poly或者大于1/poly

440
00:17:47,689 --> 00:17:52,185
these concepts. Basically either smaller
than one over poly or bigger than one over

441
00:17:52,185 --> 00:17:56,410
都是可忽略的 否则就是不可忽略的。让我们看一些例子

442
00:17:52,185 --> 00:17:56,410
poly, one would be negligible, the
other would be non-negligible. Let's look

443
00:17:58,522 --> 00:18:00,635
例如，一个函数以λ的指数形式下降

444
00:17:58,522 --> 00:18:00,635
at some examples. So, for example, a
function that drops exponentially in

445
00:18:00,635 --> 00:18:05,456
明显是可忽略的，因为对任何一个常量d存在一个有效很大的λ

446
00:18:00,635 --> 00:18:05,456
lambda clearly would be negligible because
for any constant d there is a sufficiently

447
00:18:05,456 --> 00:18:09,952
例如1/2^λ小于1/λ^d

448
00:18:05,456 --> 00:18:09,952
large, large lambda. Such as one over two
to the lambda is less than one over lambda

449
00:18:09,952 --> 00:18:15,405
好的明显这个值小于所有的多项式。这个函数，比如

450
00:18:09,952 --> 00:18:15,405
to the d. Okay. So this is clearly less
than all polynomials. Over the function,

451
00:18:15,405 --> 00:18:20,894
1/λ^1000这个函数增长得非常慢，

452
00:18:15,405 --> 00:18:20,894
say, one over lambda to a thousand, right.
This is a function that grows very, very,

453
00:18:20,894 --> 00:18:25,217
几乎不增长，然而这个函数

454
00:18:20,894 --> 00:18:25,217
very slowly. It barely ever moves.
Nevertheless, this function is

455
00:18:25,217 --> 00:18:30,432
是不可忽略的因为如果我设d等于10000 明显这个函数

456
00:18:25,217 --> 00:18:30,432
non-negligible because if I set d to be
10,000, then clearly this function is

457
00:18:30,432 --> 00:18:36,127
大于1/λ^10000，所以这个函数大于

458
00:18:30,432 --> 00:18:36,127
bigger than one over lambda to the 10,000.
And so this function is bigger than some

459
00:18:36,127 --> 00:18:41,238
部分多项式，让我们看一个费解且巧妙的例子

460
00:18:36,127 --> 00:18:41,238
polynomial fraction. And lets look at a
confusing example, just to be tricky. What

461
00:18:41,238 --> 00:18:45,925
你怎么认为？我有一个函数，当λ是奇数时，函数恰巧呈指数减小

462
00:18:41,238 --> 00:18:45,925
do you think? Suppose I have a function that for
an odd lambda it happens to be exponentially small,

463
00:18:45,925 --> 00:18:50,375
当λ是偶数时，函数恰好呈多式形式减小。那么这是一个可忽略的还是

464
00:18:45,925 --> 00:18:50,375
for even lambda, it happens to be
polynomially small. Is this a negligible or

465
00:18:50,375 --> 00:18:55,350
不可忽略的函数呢？按照我们的定义这个函数是不可忽略的

466
00:18:50,375 --> 00:18:55,350
non-negligible function? Well, by our
definition this would a non-negligible

467
00:18:55,350 --> 00:19:00,747
由直觉判断如果一个函数以多项式形式减小，

468
00:18:55,350 --> 00:19:00,747
function. And the intuition is, if a
function happens to be only polynomially

469
00:19:00,747 --> 00:19:05,815
那么通常意味着以这个概率发生的事件

470
00:19:00,747 --> 00:19:05,815
small, very often, that actually means
that this event, you know, an event

471
00:19:05,815 --> 00:19:10,680
在实际的密码系统中已经是很大的事件了，

472
00:19:05,815 --> 00:19:10,680
that happens with this probability, is
already too large to be used in a real

473
00:19:10,680 --> 00:19:15,420
所以，主要需要记住的点是这些术语

474
00:19:10,680 --> 00:19:15,420
cryptosystem. Okay, so, the main points to
remember here, are that these terms,

475
00:19:15,420 --> 00:19:19,559
分别对应着小于多项式或者大于多项式，

476
00:19:15,420 --> 00:19:19,559
basically, correspond to less than
polynomial or more than polynomial, but

477
00:19:19,559 --> 00:19:23,862
贯穿这门课程，我们大多数情况用忽略性表示小于一个指数。

478
00:19:19,559 --> 00:19:23,862
throughout the course, we'll mostly use
negligible to mean less than, than an

479
00:19:23,862 --> 00:19:28,328
不可忽略表示小于1/poly，所以现在可以看到

480
00:19:23,862 --> 00:19:28,328
exponential. And non-negligible to mean,
less than one over polynomial. So now we

481
00:19:28,328 --> 00:19:32,848
把一次一密转化为实用性密码的核心思想,这里的实用性密码

482
00:19:28,328 --> 00:19:32,848
saw the core idea for converting the one
time pad into a practical cipher. And I

483
00:19:32,848 --> 00:19:36,933
就是流密码。在下节课中我们将学习

484
00:19:32,848 --> 00:19:36,933
mean, the stream cipher. And then, in the
next lecture, we're gonna see how to

485
00:19:36,933 --> 00:19:41,236
如何讨论一个流密码是否是真的安全的。这就需要

486
00:19:36,933 --> 00:19:41,236
actually argue that the stream cipher is
actually secure. That's gonna require a

487
00:19:41,236 --> 00:19:45,757
对安全性进行全新的定义，因为完全安全对于密码说还不够好

488
00:19:41,236 --> 00:19:45,757
new definition of security, since perfect
secrecy is not good enough here, and we

489
00:19:45,757 --> 00:19:47,500
并且我们将在下一节课中看到。

490
00:19:45,757 --> 00:19:47,500
will see that in the next lecture.

