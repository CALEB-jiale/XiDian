1
00:00:00,000 --> 00:00:03,757
In the last segment in this module, I
wanna show you a general attack that

2
00:00:00,000 --> 00:00:03,757
在本单元最后一节里

3
00:00:03,757 --> 00:00:07,615
affects many implementations of Mac
algorithms. And there's a nice lesson to

4
00:00:03,757 --> 00:00:07,615
我来展示一个影响许多MAC算法实现的通用攻击

5
00:00:07,615 --> 00:00:11,727
be learned from an attack like this. So
let's look at a particular implementation

6
00:00:07,615 --> 00:00:11,727
从这个攻击中能学到很多，那么我们来看一个具体的HMAC验证的实现

7
00:00:11,727 --> 00:00:15,941
of HMAC verification. This happens to be
an implementation from the Keyczar library,

8
00:00:11,727 --> 00:00:15,941
这正好是Keyczar库的实现，使用Python编写

9
00:00:15,941 --> 00:00:20,003
that happens to be written in Python. So
here's the code that's used to verify a

10
00:00:15,941 --> 00:00:20,003
这个代码用来验证HMAC生成的标签

11
00:00:20,003 --> 00:00:23,709
tag generated by HMAC. This code is
actually simplified. I just wanted to

12
00:00:20,003 --> 00:00:23,709
代码实际是被简化了

13
00:00:23,709 --> 00:00:27,822
kinda simplify it as much as I can to get
the point across. So basically, what the

14
00:00:23,709 --> 00:00:27,822
我想使之尽可能简单而保留核心要点

15
00:00:27,822 --> 00:00:32,235
inputs are, the key, the message, and the
tag bytes. The way we verify it is, we

16
00:00:27,822 --> 00:00:32,235
输入的是密钥，消息，和标签字节

17
00:00:32,235 --> 00:00:38,082
re-compute the HMAC on the message and
then we compare say the resulting sixteen

18
00:00:32,235 --> 00:00:38,082
验证的方法是重新计算消息HMAC得到16个字节

19
00:00:38,082 --> 00:00:43,271
bytes. To the actual given signature
bites. So this looks perfectly fine.

20
00:00:38,082 --> 00:00:43,271
与给出的签名字节相比较。这看上去没有问题

21
00:00:43,271 --> 00:00:47,834
In fact, anyone might implement it like this.
And, in fact, many people have implemented

22
00:00:43,271 --> 00:00:47,834
任何人都有可能这么实现，事实上许多人的确就是这样实现的

23
00:00:47,834 --> 00:00:52,231
it like this. The problem is, that if you
look at how the comparison is done, the

24
00:00:47,834 --> 00:00:52,231
问题在于，如果你去观察比较的方式的话

25
00:00:52,231 --> 00:00:56,740
comparison, as you might expect, is done
byte by byte. There's a loop inside of the

26
00:00:52,231 --> 00:00:56,740
正如你所想，比较是逐字节比较的

27
00:00:56,740 --> 00:01:01,373
Python interpreter that loops over all
sixteen bytes. And it so happens that the

28
00:00:56,740 --> 00:01:01,373
Python的解释器内部有一个循环遍历所有16个字节

29
00:01:01,373 --> 00:01:06,297
first time it finds an inequality, the
loop terminates and says the strings are

30
00:01:01,373 --> 00:01:06,297
只要发现不同就立刻终止循环，表示字符串不相同

31
00:01:06,297 --> 00:01:10,972
not equal. And the fact that the
comparator exits when the first inequality

32
00:01:06,297 --> 00:01:10,972
比较器存在，直到找到第一个不同

33
00:01:10,972 --> 00:01:16,146
is found introduces a significant timing
attack on this library. So let me show you

34
00:01:10,972 --> 00:01:16,146
这就能对这个库进行时间攻击

35
00:01:16,146 --> 00:01:21,257
how one might attack it. So imagine you're
the attacker, and you have the message m,

36
00:01:16,146 --> 00:01:21,257
让我们来看是如何攻击的。假设你是攻击者，拥有消息m

37
00:01:21,257 --> 00:01:26,368
for which you want to obtain a valid tag.
Now, your goal is to attack a server that

38
00:01:21,257 --> 00:01:26,368
你想得到对应有效的标签，你的目标是攻击一个拥有HMAC密钥的服务器

39
00:01:26,368 --> 00:01:31,230
has an HMAC secret key stored in it. And
the server exposes an interface that

40
00:01:26,368 --> 00:01:31,230
服务器接收一对消息和MAC

41
00:01:31,230 --> 00:01:36,089
basically takes message MAC pairs. Checks
that the MAC is valid, if the MAC is valid

42
00:01:31,230 --> 00:01:36,089
检查MAC是否有效，如果有效就对消息做某些处理

43
00:01:36,089 --> 00:01:40,450
it does something with the message. And if
the MAC is not valid, it says reject.

44
00:01:36,089 --> 00:01:40,450
如果无效就拒绝

45
00:01:40,450 --> 00:01:45,039
Okay, so it's back to the originator or
the message rejects. So now this attacker

46
00:01:40,450 --> 00:01:45,039
回到初始或者拒绝

47
00:01:45,039 --> 00:01:49,685
has an opportunity to basically submit
lots of message it appears and see if it

48
00:01:45,039 --> 00:01:49,685
因此攻击者可以提交大量消息和MAC对

49
00:01:49,685 --> 00:01:54,274
can deduce the tags of the particular
message for which it once attacked. Here's

50
00:01:49,685 --> 00:01:54,274
观察能否推测出给定消息的标签

51
00:01:54,274 --> 00:01:59,036
how we might use the broken implementation
from the previous slide to do just that.

52
00:01:54,274 --> 00:01:59,036
下面我们来利用前面讲到的糟糕的实现

53
00:01:59,036 --> 00:02:03,661
So what the attacker is gonna do is to
submit many message tag queries, where the

54
00:01:59,036 --> 00:02:03,661
攻击者要做的就是提交许多消息标签询问，每次的消息都相同

55
00:02:03,661 --> 00:02:08,044
message is always the same. But with a
tag, he's gonna experiment with lots and

56
00:02:03,661 --> 00:02:08,044
而用很多很多不同的标签

57
00:02:08,044 --> 00:02:12,595
lots and lots of different tags. So in the
first query, what he's gonna do is just

58
00:02:08,044 --> 00:02:12,595
所以在第一次询问中

59
00:02:12,595 --> 00:02:17,202
submit a random tag along with the target
message. And he's gonna measure how long

60
00:02:12,595 --> 00:02:17,202
只需用一个随机的标签和特定消息，然后测出服务器给出回应的时间

61
00:02:17,202 --> 00:02:21,674
the server took to respond. The next query
that he's gonna submit, is he's gonna try

62
00:02:17,202 --> 00:02:21,674
下一次提交的询问，他就要尝试标签的首字节的所有可能性

63
00:02:21,674 --> 00:02:25,896
all possible first bytes for the tags. Let
me explain what I mean by that. So the

64
00:02:21,674 --> 00:02:25,896
我来解释一下

65
00:02:25,896 --> 00:02:30,011
remaining bytes of the tags that he
submits are just arbitrary, doesn't really

66
00:02:25,896 --> 00:02:30,011
标签剩下的字节都是任意的，无关紧要的

67
00:02:30,011 --> 00:02:34,557
matter what they are. But for the first
bite, what he'll do is he'll submit a tag

68
00:02:30,011 --> 00:02:34,557
但对于首字节，他会提交一个首字节为0的标签

69
00:02:34,557 --> 00:02:39,392
starting with a byte zero. And then he's
gonna see whether the server took a little

70
00:02:34,557 --> 00:02:39,392
然后观察服务器是不是比之前比较的时间长

71
00:02:39,392 --> 00:02:44,285
bit longer to verify the tag than before.
If the server took exactly the same amount

72
00:02:39,392 --> 00:02:44,285
如果服务器比较的时间和第一步的时间相同的话

73
00:02:44,285 --> 00:02:49,062
of time to verify the tag as in step one,
then he's gonna try again, this time with

74
00:02:44,285 --> 00:02:49,062
然后他用首字节为1的标签再试一次

75
00:02:49,062 --> 00:02:52,976
bytes at one. If still the server
responded very quickly, he's going to try

76
00:02:49,062 --> 00:02:52,976
如果服务器回应仍然很快的话

77
00:02:52,976 --> 00:02:56,961
with byte sets of two. If the server
responded quickly then he's going to try

78
00:02:52,976 --> 00:02:56,961
他就用首字节为2的标签再试。如果服务器回应仍然很快的话

79
00:02:56,961 --> 00:03:01,101
with byte sets of three, and so on until
finally, let's say, when the byte sets of

80
00:02:56,961 --> 00:03:01,101
他就用首字节为3标签再试

81
00:03:01,101 --> 00:03:05,344
three the server takes a little bit longer
to respond. What that means is actually

82
00:03:01,101 --> 00:03:05,344
直到最后首字节为3时，服务器回应的时间比以前长了一点

83
00:03:05,344 --> 00:03:09,484
when it did the comparison between the
correct MAC and the MAC submitted by the

84
00:03:05,344 --> 00:03:09,484
这说明在正确的MAC和攻击者提交的MAC进行比较时

85
00:03:09,484 --> 00:03:14,334
attacker. The two matched on this byte,
and the rejection happened on the second

86
00:03:09,484 --> 00:03:14,334
在这个字节上是匹配的，在第二个字节上被拒绝了

87
00:03:14,334 --> 00:03:19,073
bytes. Aha. So now the attacker knows that
the first bite of the tag is set to three

88
00:03:14,334 --> 00:03:19,073
因此攻击者知道了标签的第一个字节是3

89
00:03:19,073 --> 00:03:23,435
and now he can mount exactly the same
attack on the second bite. So here. It's

90
00:03:19,073 --> 00:03:23,435
现在他可以在第二个字节上重复相同的攻击

91
00:03:23,435 --> 00:03:28,519
going to submit the tag. And the second,
back here. Here This should go here. So

92
00:03:23,435 --> 00:03:28,519


93
00:03:28,519 --> 00:03:32,514
it's gonna submit a tag when the second
byte is set to zero. And it's gonna

94
00:03:28,519 --> 00:03:32,514
提交第二字节是0的标签

95
00:03:32,514 --> 00:03:36,516
measure whether this took a little bit
longer than in step two. If not, he's

96
00:03:32,514 --> 00:03:36,516
然后测量时间是不是比第二步的时间长

97
00:03:36,516 --> 00:03:40,502
gonna change this to be set to one, and
he's gonna measure if the server's

98
00:03:36,516 --> 00:03:40,502
如果不是，就把这个字节改成1

99
00:03:40,502 --> 00:03:44,758
response time is a little longer than
before. Eventually, let's say when he sets

100
00:03:40,502 --> 00:03:44,758
然后测量时间是不是比之前长

101
00:03:44,758 --> 00:03:48,960
this to, I don't know. When the byte is
set to, to 53, say, all of a sudden, the

102
00:03:44,758 --> 00:03:48,960
最后，当这个字节为...53时

103
00:03:48,960 --> 00:03:52,677
server takes a little bit longer to
respond. Which means that now, the

104
00:03:48,960 --> 00:03:52,677
时间比之前长

105
00:03:52,677 --> 00:03:56,943
comparator matched on the first two bytes.
And now the attacker learned that the

106
00:03:52,677 --> 00:03:56,943
说明前两个字节都匹配了

107
00:03:56,943 --> 00:04:01,056
first two bytes of the Mac are three and
53. And now he can move on and do the

108
00:03:56,943 --> 00:04:01,056
攻击者知道MAC的前两个字节为3和53

109
00:04:01,056 --> 00:04:05,274
exact same thing on the third byte and
then on the fourth byte and so on and so

110
00:04:01,056 --> 00:04:05,274
然后他对第三字节做同样的事，然后是第四个

111
00:04:05,274 --> 00:04:09,175
forth. Until finally, the server says,
yes, I accept. You actually gave me the

112
00:04:05,274 --> 00:04:09,175
直到最后服务器说，好我接受了，你给出了正确的MAC

113
00:04:09,175 --> 00:04:13,858
right Mac. And then we'll go ahead and act
on this bogus message. That, attack our

114
00:04:09,175 --> 00:04:13,858
然后我们就能使用这个伪造的消息了

115
00:04:13,858 --> 00:04:18,711
supply. So this is a beautiful example of
how a timing attack can reveal the value

116
00:04:13,858 --> 00:04:18,711
所以这是一个好例子

117
00:04:18,711 --> 00:04:23,140
of a MAC, the correct value of the MAC.
Kind of byte by byte, until eventually,

118
00:04:18,711 --> 00:04:23,140
用时间攻击逐字节获得正确的MAC字节

119
00:04:23,140 --> 00:04:28,094
the attacker obtains all the correct bytes
of the tag, and then he's able to fool the

120
00:04:23,140 --> 00:04:28,094
直到最后得到标签的所有正确字节

121
00:04:28,094 --> 00:04:32,640
server into accepting this message tag
pair. The reason I like this example is

122
00:04:28,094 --> 00:04:32,640
然后他就能欺骗服务器，使之接受消息标签对

123
00:04:32,640 --> 00:04:37,186
this is a perfectly reasonable way of
implementing a MAC verification routine.

124
00:04:32,640 --> 00:04:37,186
我喜欢这个例子的原因是它是实现MAC验证程序的一个完全合理的方式

125
00:04:37,186 --> 00:04:41,941
And yet, if you right it this way, it will
be completely broken. So what do we do? So

126
00:04:37,186 --> 00:04:41,941
然而，如果你用这种方式纠正它，它会被彻底地攻破。那么我们该怎么做呢？

127
00:04:41,941 --> 00:04:46,509
let me show you two defenses, the first
defense, I'll write it in again in python

128
00:04:41,941 --> 00:04:46,509
让我来给你展示两种防御方式，第一种防御，我会用程序按照如下的方式

129
00:04:46,509 --> 00:04:51,020
is, is as follows. In fact the Keyczar
library exactly implemented this defense.

130
00:04:46,509 --> 00:04:51,020
再把它写一遍。事实上Keyczar库恰好执行了这种防御

131
00:04:51,020 --> 00:04:55,588
This code is actually taken out of the
updated version of the library. The first

132
00:04:51,020 --> 00:04:55,588
这个代码实际上被用于库的更新方案

133
00:04:55,588 --> 00:05:00,328
thing we do is we test if the signature
bytes submitted by the attacker are of the

134
00:04:55,588 --> 00:05:00,328
我们要做的第一件事是我们要测试攻击者使用的签名字节是否是正确的长度

135
00:05:00,328 --> 00:05:04,896
correct length, say for HMAC this would
be say, you know 96 bits or 128 bits, and

136
00:05:00,328 --> 00:05:04,896
HMAC这将是说，你知道96比特或者128比特，

137
00:05:04,896 --> 00:05:09,421
if not we reject that as an invalid MAC.
But now, if the signature bytes really do

138
00:05:04,896 --> 00:05:09,421
如果不是我们拒绝它作为一个无效的MAC。但是现在，如果签名字节确实有正确的长度

139
00:05:09,421 --> 00:05:13,466
have the correct length, what we do is
implement our own comparator. And it

140
00:05:09,421 --> 00:05:13,466
那么我们要做的就是完成我们自己的比较

141
00:05:13,466 --> 00:05:17,895
always takes the same amount of time to
compare the two strings. So in particular,

142
00:05:13,466 --> 00:05:17,895
比较两个字符串总是需要同等量的时间。所以特别地，

143
00:05:17,895 --> 00:05:22,159
this uses the zip function in Python,
which will, essentially, if you are giving

144
00:05:17,895 --> 00:05:22,159
这个用邮编函数在程序中，将本质上，如果你给它两个16字节的字符串

145
00:05:22,159 --> 00:05:28,116
it two sixteen byte strings. It will
create sixteen pairs. Of bytes. So it'll

146
00:05:22,159 --> 00:05:28,116
两个16字节的字符串。它会创造出16对字节。

147
00:05:28,116 --> 00:05:32,666
just create a, a list of sixteen elements,
where each element is a pair of bytes. One

148
00:05:28,116 --> 00:05:32,666
所以它会创造出一系列16要素，每个要素都是一对字节。

149
00:05:32,666 --> 00:05:37,051
taken from the left and one taken from the
right. And then you loop, you know, you

150
00:05:32,666 --> 00:05:37,051
一个取自左边一个取自右边。然后你循环你会知道

151
00:05:37,051 --> 00:05:41,326
loop through this list of pairs. You
compute the XOR of the first pair, and the

152
00:05:37,051 --> 00:05:41,326
你会依次取遍这一系列对。你计算一下第一对的异或，再将结果取或

153
00:05:41,326 --> 00:05:45,492
OR into the result. Then you
compute the XOR of the second pair, and

154
00:05:41,326 --> 00:05:45,492
然后计算第二对的异或，再对结果取或。

155
00:05:45,492 --> 00:05:49,932
you OR that into the result. And
you note that, if at any point in this

156
00:05:45,492 --> 00:05:49,932
你会注意到，如果在这个循环中的任一点上，

157
00:05:49,932 --> 00:05:54,207
loop, two bytes happen to be not equal,
then the XOR will evaluate to something

158
00:05:49,932 --> 00:05:54,207
两个字节恰好不是相等的，然后异或会评估那些非零的。

159
00:05:54,207 --> 00:05:58,577
that's non zero. And therefore, when we
OR'ed it into the result. The result

160
00:05:54,207 --> 00:05:58,577
因此，当我们再对它取或后得到结果。

161
00:05:58,577 --> 00:06:02,632
will also be counting on zero, and then
we'll return false, at the end of the

162
00:05:58,577 --> 00:06:02,632
这结果也会算到零，我们会返回一个错误在比较以后。

163
00:06:02,632 --> 00:06:06,578
comparison. So the point here is that now
the comparator always takes the same

164
00:06:02,632 --> 00:06:06,578
所以关键就是现在比较者总会用同等量的时间

165
00:06:06,578 --> 00:06:10,720
amount of time. Even if it finds
difference in byte number three, it will

166
00:06:06,578 --> 00:06:10,720
即使它发现第三个字节不同，

167
00:06:10,720 --> 00:06:15,479
continue running down the both strings
until the very end. And only then will it

168
00:06:10,720 --> 00:06:15,479
它会继续惰转在两个字符串直到结尾。直到它返回结果。

169
00:06:15,479 --> 00:06:20,244
return the results. So now the timing
attack supposedly is impossible. However,

170
00:06:15,479 --> 00:06:20,244
所以现在计时攻击被认为是不可能的。

171
00:06:20,244 --> 00:06:25,256
this can be quite problematic, because
compilers tried to be too helpful here. So

172
00:06:20,244 --> 00:06:25,256
然而，这可能是相当有问题的，因为编译器试图在这里起很大作用。

173
00:06:25,256 --> 00:06:30,143
an optimized compiler might look at this
code and say, hey, wait a minute. I can

174
00:06:25,256 --> 00:06:30,143
所以一个优化的编译器可能会看这个代码并说,嘿,等一下

175
00:06:30,143 --> 00:06:35,107
actually improve this code by making the
four loop end. As soon as an incompatible

176
00:06:30,143 --> 00:06:35,107
我能通过使四个循环结束来改善这个代码。

177
00:06:35,107 --> 00:06:39,378
set of bytes is discovered. And so, an
optimizing compiler could be your, kind

178
00:06:35,107 --> 00:06:39,378
一旦发现不兼容的字节，并且，一个优化的编译器可能是你，有时，

179
00:06:39,378 --> 00:06:43,930
of, Achilles heel when it comes to making
programs always take the same amount of

180
00:06:39,378 --> 00:06:43,930
薄弱的环节当它总是花同样的时间来走程序的时候

181
00:06:43,930 --> 00:06:48,482
time. And so a different defense, which is
not as widely implemented, is to try and

182
00:06:43,930 --> 00:06:48,482
所以不同的防御,没被广泛实施的,

183
00:06:48,482 --> 00:06:52,978
hide from the adversary, what strings are
actually being compared. So let me show

184
00:06:48,482 --> 00:06:52,978
试图躲避对手,字符串实际上是被比较的。

185
00:06:52,978 --> 00:06:57,417
you what I mean by that. So again, here we
have our verification algorithm. So it

186
00:06:52,978 --> 00:06:57,417
让我来向你展示我所说的意思。再来一次，在这里我们有我们的验证算法。

187
00:06:57,417 --> 00:07:01,740
takes as inputs, a key, a message, and a
candidate's MAC from the adversary. And

188
00:06:57,417 --> 00:07:01,740
所以它需要作为输入,一个键,一个消息,一个来自敌手的候选人的MAC。

189
00:07:01,740 --> 00:07:06,156
then, the way we do the comparison is we
first of all, compute the correct MAC on

190
00:07:01,740 --> 00:07:06,156
然后，我们做比较是我们首先,计算正确的MAC上的消息。

191
00:07:06,156 --> 00:07:10,407
the message. But then instead of directly
comparing the MAC and the signature

192
00:07:06,156 --> 00:07:10,407
但随后而不是直接比较MAC和签名字节的敌手,我们要做的是我们要散列一次

193
00:07:10,407 --> 00:07:14,933
bytes adversary, what we're gonna do
is we're gonna hash one more time. So we

194
00:07:10,407 --> 00:07:14,933
我们要做的是我们要哈希一次。

195
00:07:14,933 --> 00:07:19,459
compute a hash here of the MAC. We compute
a hash of the signature bytes. Of course,

196
00:07:14,933 --> 00:07:19,459
所以我们这里计算MAC的哈希值。我们计算签名字节的哈希值。当然，

197
00:07:19,459 --> 00:07:23,765
if these two happen to be the same, then
the resulting HMACs will also be the

198
00:07:19,459 --> 00:07:23,765
如果这两个恰好是相同的，然后HMACs的结果也将会是相同的，

199
00:07:23,765 --> 00:07:27,794
same, so the comparison will actually
succeed. But the point is now, if sig

200
00:07:23,765 --> 00:07:27,794
所以比较就会成功。但是关键是现在，如果签名的字节

201
00:07:27,794 --> 00:07:31,690
bytes happen to equal MAC on the first
byte, but not on the remaining bytes.

202
00:07:27,794 --> 00:07:31,690
恰好和MAC的相同在一个字节中，但在剩余的字节里不同。

203
00:07:31,690 --> 00:07:35,607
Then, when we do this additional hash
layer, it's likely that the two resulting

204
00:07:31,690 --> 00:07:35,607
当我们做这些额外的散列层,很有可能这两个结果

205
00:07:35,607 --> 00:07:39,675
values are completely different. And as a
result, the byte by byte comparator will

206
00:07:35,607 --> 00:07:39,675
是完全不同的。因此,字节的字节比较器只会在第一次迭代输出。

207
00:07:39,675 --> 00:07:43,693
just output on the first iteration. The
point here is that the adversary doesn't

208
00:07:39,675 --> 00:07:43,693
只会在第一次迭代输出。这里的关键是敌手不确切地知道

209
00:07:43,693 --> 00:07:47,258
actually know what strings are being
compared. And as a result, he can't

210
00:07:43,693 --> 00:07:47,258
什么字符串正在被比较。因此，

211
00:07:47,258 --> 00:07:50,809
mount a timing attack that we
discussed earlier. Okay, so this is

212
00:07:47,258 --> 00:07:50,809
他不能装载一个之前我们讨论过的计时攻击。好的，

213
00:07:50,809 --> 00:07:55,447
another defense. At least now, you're not
at the mercy of an optimizing compiler.

214
00:07:50,809 --> 00:07:55,447
所以这就是另一个防御。至少现在，你不会在被一个优化的编译器摆布了。

215
00:07:55,447 --> 00:08:00,027
The main lesson from all of this is that
you realize that people who even are

216
00:07:55,447 --> 00:08:00,027
所有这一切的主要内容是,你意识到那些已经在实施密文库中成为专家的人

217
00:08:00,027 --> 00:08:04,490
experts at implementing cryptolibraries,
get this stuff wrong. And the right code

218
00:08:00,027 --> 00:08:04,490
误会了这些东西。正确的代码

219
00:08:04,490 --> 00:08:08,351
that words perfectly fine and yet is
completely vulnerable to a timing attack

220
00:08:04,490 --> 00:08:08,351
表达地非常完美并且是完全易遭受计时攻击的

221
00:08:08,351 --> 00:08:12,310
that completely undo all security of the
system. So the lesson here is of course

222
00:08:08,351 --> 00:08:12,310
这种攻击能完全地破坏系统的所有安全。所以这里要学到的当然是

223
00:08:12,310 --> 00:08:15,775
you should not be inventing your own
crypto but you shouldn't even be

224
00:08:12,310 --> 00:08:15,775
你不应该发明自己的密码,你甚至不应该实现自己的密码,

225
00:08:15,775 --> 00:08:19,785
implementing your own crypto because most
likely it'll be vulnerable to the side

226
00:08:15,775 --> 00:08:19,785
因为很有可能它容易受到侧信道攻击。

227
00:08:19,785 --> 00:08:23,546
channel attacks. Just use a standard
library like OpenSSL. Keyczar is actually a

228
00:08:19,785 --> 00:08:23,546
只是用一个标准的库像OpenSSL.Keyczar实际上是

229
00:08:23,546 --> 00:08:27,605
fine library to use that would reduce the
chances that you're vulnerable to these

230
00:08:23,546 --> 00:08:27,605
一个很好地库，用它会减少你遭受这些类型的攻击的机会。

231
00:08:27,605 --> 00:08:28,447


232
00:08:27,605 --> 00:08:28,447
types of attacks.

