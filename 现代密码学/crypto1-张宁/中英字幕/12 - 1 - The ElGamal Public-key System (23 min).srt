1
00:00:00,365 --> 00:00:02,577
In the previous lecture, we looked at a public key

2
00:00:00,365 --> 00:00:02,577
在之前的课程中 我们学习了公钥

3
00:00:02,577 --> 00:00:04,714
encryption system that is built from the RSA,

4
00:00:02,577 --> 00:00:04,714
加密系统 是基于RSA的

5
00:00:04,714 --> 00:00:06,733
or more generally from trapdoors functions.

6
00:00:04,714 --> 00:00:06,733
或者更一般的是来自陷门函数

7
00:00:06,733 --> 00:00:08,986
In this lecture, we are going to look at public key encryption

8
00:00:06,733 --> 00:00:08,986
这节课 我们将学习公钥加密

9
00:00:08,986 --> 00:00:12,516
schemes that are build from the Diffie-Hellman protocol.

10
00:00:08,986 --> 00:00:12,516
方案 这是基于diffie - hellman协议的

11
00:00:12,516 --> 00:00:14,327
So, first recall that a public key encryption system is

12
00:00:12,516 --> 00:00:14,327
先来回顾公钥加密系统 这里有

13
00:00:14,327 --> 00:00:16,370
made up of three algorithms. There is a key

14
00:00:14,327 --> 00:00:16,370
三个算法 有一个密钥

15
00:00:16,370 --> 00:00:19,017
generation algorithm that I will denote by Gen,

16
00:00:16,370 --> 00:00:19,017
生成算法由Gen表示

17
00:00:19,017 --> 00:00:20,968
that basically generates a public key and a

18
00:00:19,017 --> 00:00:20,968
可以生成一个公钥和

19
00:00:20,968 --> 00:00:23,057
secret key. And then there are two algorithms: E

20
00:00:20,968 --> 00:00:23,057
私钥 然后这里有两个算法 E

21
00:00:23,057 --> 00:00:27,237
and D that encrypt and decrypt. And the point is

22
00:00:23,057 --> 00:00:27,237
和D分别是加密和解密算法 重点是

23
00:00:27,237 --> 00:00:29,467
the encryption algorithm encrypts using the

24
00:00:27,237 --> 00:00:29,467
加密算法加密时用的是

25
00:00:29,467 --> 00:00:31,788
public key and the decryption algorithm decrypts

26
00:00:29,467 --> 00:00:31,788
公钥 解密算法解密时

27
00:00:31,788 --> 00:00:35,736
using the secret key. The physical world analogy for

28
00:00:31,788 --> 00:00:35,736
用的是私钥 物理世界中类似

29
00:00:35,736 --> 00:00:39,600
public key encryption is a locked box, where anyone

30
00:00:35,736 --> 00:00:39,600
公钥加密是一个锁箱 任何人

31
00:00:39,600 --> 00:00:42,609
can put a message inside the box and then lock the

32
00:00:39,600 --> 00:00:42,609
都可以置消息于箱子中 然后锁上

33
00:00:42,609 --> 00:00:45,200
box, that corresponds to the public key and then

34
00:00:42,609 --> 00:00:45,200
箱子 和公钥对应 而且

35
00:00:45,200 --> 00:00:47,733
no one can open this box, except the person who has

36
00:00:45,200 --> 00:00:47,733
没有人可以打开这个箱子 除了

37
00:00:47,733 --> 00:00:50,736
the secret key, that has the key can put it in the

38
00:00:47,733 --> 00:00:50,736
拥有私钥的人 他的钥匙可以插入

39
00:00:50,736 --> 00:00:52,872
lock, unlock the box and the recover the message in

40
00:00:50,736 --> 00:00:52,872
锁中 解锁箱子 恢复箱子里的消息

41
00:00:52,872 --> 00:00:56,912
the box. Now, in the previous lecture, we looked at

42
00:00:52,872 --> 00:00:56,912
之前的课程 我们学习了

43
00:00:56,912 --> 00:00:59,141
a number of applications for public key encryption.

44
00:00:56,912 --> 00:00:59,141
很多公钥加密的应用

45
00:00:59,141 --> 00:01:01,928
In particular, we looked at the key exchange

46
00:00:59,141 --> 00:01:01,928
特别的 我们研究了密钥交换

47
00:01:01,928 --> 00:01:03,878
application, in fact, this is how public key encryption

48
00:01:01,928 --> 00:01:03,878
的应用 事实上 这就是SSL中如何

49
00:01:03,878 --> 00:01:06,107
is used in SSL, where the server sends its public

50
00:01:03,878 --> 00:01:06,107
使用公钥加密 服务器将公钥发送

51
00:01:06,107 --> 00:01:08,667
key to the browser, the browser chooses a secret

52
00:01:06,107 --> 00:01:08,667
到浏览器 浏览器选择一个私钥

53
00:01:08,667 --> 00:01:11,434
and then encrypts the secret using the server's

54
00:01:08,667 --> 00:01:11,434
然后用服务器公钥加密秘密

55
00:01:11,434 --> 00:01:13,538
public key, sends it back to the server, the

56
00:01:11,434 --> 00:01:13,538
将其发送到服务器

57
00:01:13,538 --> 00:01:15,860
server decrypts and now both the browser and the

58
00:01:13,538 --> 00:01:15,860
服务器解密  现在浏览器和

59
00:01:15,860 --> 00:01:18,042
server have a common secret that they can then

60
00:01:15,860 --> 00:01:18,042
服务器有了公共的秘密信息 就可以

61
00:01:18,042 --> 00:01:20,600
use to encrypt data, going back and forth, between

62
00:01:18,042 --> 00:01:20,600
用它加密数据 在他们之间交互

63
00:01:20,600 --> 00:01:23,383
them. So, in the interactive settings, such as in a

64
00:01:20,600 --> 00:01:23,383
在交互设置中 像这样在一个

65
00:01:23,383 --> 00:01:25,983
networking protocol, public key encryption would

66
00:01:23,383 --> 00:01:25,983
网络协议中 公钥加密

67
00:01:25,983 --> 00:01:28,667
primarily be used for setting up shared symmetric key

68
00:01:25,983 --> 00:01:28,667
主要是被用于建立共享的对称密钥

69
00:01:28,667 --> 00:01:30,999
which the two parties can then use to exchange

70
00:01:28,667 --> 00:01:30,999
通信双方可以用它来交换

71
00:01:30,999 --> 00:01:33,228
information. However, there are many settings

72
00:01:30,999 --> 00:01:33,228
信息 然而 这有很多设置

73
00:01:33,228 --> 00:01:35,922
where interaction is simply not possible and then

74
00:01:33,228 --> 00:01:35,922
其交互就不可能的 那么

75
00:01:35,922 --> 00:01:38,429
public key encryption is directly used to encrypt

76
00:01:35,922 --> 00:01:38,429
公钥加密直接用于加密

77
00:01:38,429 --> 00:01:41,587
messages. One example of this is secure email.

78
00:01:38,429 --> 00:01:41,587
消息 对此有个例子是安全邮件系统

79
00:01:41,587 --> 00:01:44,002
The email system in some sense is designed to be non-

80
00:01:41,587 --> 00:01:44,002
邮件系统在某种意义上更适合于非

81
00:01:44,002 --> 00:01:46,696
interactive, in the sense that the sender sends an

82
00:01:44,002 --> 00:01:46,696
交互系统 在某种意义上 发送者发送一个

83
00:01:46,696 --> 00:01:49,250
email, the email travels from relay to relay, to

84
00:01:46,696 --> 00:01:49,250
邮件 邮件在中继之间传送

85
00:01:49,250 --> 00:01:52,067
relay, until it finally arrives at the destination

86
00:01:49,250 --> 00:01:52,067
直到最后到达目的地

87
00:01:52,067 --> 00:01:54,133
and the destination should be able to decrypt,

88
00:01:52,067 --> 00:01:54,133
目的地会有人可以解密

89
00:01:54,133 --> 00:01:56,262
without interacting with the sender at that point.

90
00:01:54,133 --> 00:01:56,262
不用与这边的发送者交互

91
00:01:56,262 --> 00:01:57,731
That can be done basically, by the sender

92
00:01:56,262 --> 00:01:57,731
这可以做到 基本上 借助于发送者

93
00:01:57,731 --> 00:02:00,467
encrypting the message using the recipient's public

94
00:01:57,731 --> 00:02:00,467
使用接收者的公钥加密这个消息

95
00:02:00,467 --> 00:02:04,250
key. The ciphertext would travel along the SMTP chain

96
00:02:00,467 --> 00:02:04,250
密文会沿着SMTP链传送

97
00:02:04,250 --> 00:02:06,990
until it reaches the recipient. The recipient would

98
00:02:04,250 --> 00:02:06,990
直到到达接收者那里 接收者会

99
00:02:06,990 --> 00:02:09,544
use a secret key and recover the original sent

100
00:02:06,990 --> 00:02:09,544
使用密钥去恢复原始发送的消息

101
00:02:09,544 --> 00:02:13,074
message. However, there are many other cases

102
00:02:09,544 --> 00:02:13,074
然而 有很多其他情况下

103
00:02:13,074 --> 00:02:15,227
where interaction is not possible and I want to show

104
00:02:13,074 --> 00:02:15,227
交互是不可能的 我想要给你们介绍

105
00:02:15,227 --> 00:02:17,857
you two such cases. The first example is

106
00:02:15,227 --> 00:02:17,857
这两种情况 第一个例子是

107
00:02:17,857 --> 00:02:20,922
file systems. And in fact, public key encryption is a

108
00:02:17,857 --> 00:02:20,922
文件系统 事实上 公钥加密是一个

109
00:02:20,922 --> 00:02:23,277
good way to manage file sharing, in an encrypted file

110
00:02:20,922 --> 00:02:23,277
管理文件共享的好方法 在加密文件系统

111
00:02:23,277 --> 00:02:24,934
system. So, let me show you what I mean

112
00:02:23,277 --> 00:02:24,934
我来解释这是什么意思

113
00:02:24,934 --> 00:02:27,379
by that. So, imagine we have our friend Bob

114
00:02:24,934 --> 00:02:27,379
想象我们的朋友Bob在这里

115
00:02:27,379 --> 00:02:29,792
here, who wants to store an encrypted file on some

116
00:02:27,379 --> 00:02:29,792
他想把一个加密文件存储在某个

117
00:02:29,792 --> 00:02:31,603
storage server. So, he will go ahead and write the

118
00:02:29,792 --> 00:02:31,603
存储服务器中 所以他要继续把

119
00:02:31,603 --> 00:02:34,533
encrypted file to the storage server. What he

120
00:02:31,603 --> 00:02:34,533
加密文件写到存储服务器中 其实

121
00:02:34,533 --> 00:02:36,867
actually writes in the server is basically the

122
00:02:34,533 --> 00:02:36,867
他写到服务器里的是如下内容：

123
00:02:36,867 --> 00:02:40,334
following: he will generate a random file encryption key, we

124
00:02:36,867 --> 00:02:40,334
他要产生一个随机文件加密密钥

125
00:02:40,334 --> 00:02:42,667
will call it 'K sub F' and then he will use the

126
00:02:40,334 --> 00:02:42,667
我们称之为Kf（下标） 然后他会使用用密钥Kf

127
00:02:42,667 --> 00:02:45,674
symmetric encryption system to encrypt the file

128
00:02:42,667 --> 00:02:45,674
用对称加密的方法

129
00:02:45,674 --> 00:02:49,715
using the key 'K sub F'. Then, he will encrypt the

130
00:02:45,674 --> 00:02:49,715
去加密文件，然后加密

131
00:02:49,715 --> 00:02:52,780
key 'K sub F', using his own public key. So public key

132
00:02:49,715 --> 00:02:52,780
密钥Kf' 用他所拥有的公钥 即Bob的公钥

133
00:02:52,780 --> 00:02:56,402
of Bob. This will give Bob access to the file at a later

134
00:02:52,780 --> 00:02:56,402
这可以使得Bob稍后有权限访问那个文件

135
00:02:56,402 --> 00:02:59,188
time, right. Using his secret key, Bob can decrypt

136
00:02:56,402 --> 00:02:59,188
好 使用私钥 Bob可以解密消息开头

137
00:02:59,188 --> 00:03:02,532
this header, recover 'K sub F'. Then he will

138
00:02:59,188 --> 00:03:02,532
恢复Kf 然后就可以

139
00:03:02,532 --> 00:03:04,933
decrypt the actual encrypted file and recover the

140
00:03:02,532 --> 00:03:04,933
解密实际的加密文件 恢复

141
00:03:04,933 --> 00:03:08,523
plaintext file. So, decryption will work in two steps.

142
00:03:04,933 --> 00:03:08,523
明文文件 所以 解密工作有两步

143
00:03:08,523 --> 00:03:11,216
However, Bob now wants also to give access to

144
00:03:08,523 --> 00:03:11,216
但是 Bob现在想让Alice也有权限

145
00:03:11,216 --> 00:03:13,678
Alice, to this file. What he will do is, he will go

146
00:03:11,216 --> 00:03:13,678
访问这个文件 他要做的就是继续下去

147
00:03:13,678 --> 00:03:16,400
ahead and in addition he will also include in the

148
00:03:13,678 --> 00:03:16,400
在文件头里面另外也加入

149
00:03:16,400 --> 00:03:19,529
file header, an encyption of 'K sub F' under Alice's

150
00:03:16,400 --> 00:03:19,529
一个用Alice的公钥加密的Kf'

151
00:03:19,529 --> 00:03:22,315
public key. OK. So, notice that there was no

152
00:03:19,529 --> 00:03:22,315
好 注意这里没有交互

153
00:03:22,315 --> 00:03:24,916
interaction here. All that Bob knows is Alice's public

154
00:03:22,315 --> 00:03:24,916
Bob现在只知道的是Alice的公钥

155
00:03:24,916 --> 00:03:27,192
key and yet he was able to the make the file

156
00:03:24,916 --> 00:03:27,192
但他能够将文件访问权

157
00:03:27,192 --> 00:03:29,699
accesible to Alice at a later time.

158
00:03:27,192 --> 00:03:29,699
稍后授权于Alice

159
00:03:29,699 --> 00:03:32,767
So, now Bob disappears and then Alice

160
00:03:29,699 --> 00:03:32,767
现在Bob走了 然后Alice

161
00:03:32,767 --> 00:03:35,272
comes and accesses the disk at a later time.

162
00:03:32,767 --> 00:03:35,272
过来 稍后接手这个磁盘

163
00:03:35,272 --> 00:03:37,966
She will read the ciphertext, decrypt  her part of

164
00:03:35,272 --> 00:03:37,966
她能看到密文 解密她那部分的

165
00:03:37,966 --> 00:03:41,542
the header, recover Kf and then she can decrypt

166
00:03:37,966 --> 00:03:41,542
文件头 恢复Kf 然后就可以解密

167
00:03:41,542 --> 00:03:44,533
the symmetrically encrypted file and recover the

168
00:03:41,542 --> 00:03:44,533
这个对称加密文件 恢复

169
00:03:44,533 --> 00:03:47,207
actual file contents. Ok, so you can see that without

170
00:03:44,533 --> 00:03:47,207
实际的文件内容 好 你们可以看见

171
00:03:47,207 --> 00:03:49,576
any interaction, Bob was able to write to the file

172
00:03:47,207 --> 00:03:49,576
无需任何交互 Bob可以对这个文件系统进行写操作

173
00:03:49,576 --> 00:03:55,195
system and enable Alice to access the file, as well.

174
00:03:49,576 --> 00:03:55,195
赋予Alice对文件的访问权 还有

175
00:03:55,195 --> 00:03:57,825
Again, at the time that Alice was reading the file, there is no

176
00:03:55,195 --> 00:03:57,825
当Alice在读这个文件的时候 是不能

177
00:03:57,825 --> 00:04:00,443
interaction with Bob, because maybe Bob is already

178
00:03:57,825 --> 00:04:00,443
与Bob交互的 因为可能已经找不到Bob了

179
00:04:00,443 --> 00:04:02,267
inaccesible and yet Alice can still read the file

180
00:04:00,443 --> 00:04:02,267
但目前Alice可以读取

181
00:04:02,267 --> 00:04:04,754
recovered by herself.

182
00:04:02,267 --> 00:04:04,754
自己恢复的文件

183
00:04:05,800 --> 00:04:07,933
So, another example of a non-interactive

184
00:04:05,800 --> 00:04:07,933
另外一个关于无交互应用的

185
00:04:07,933 --> 00:04:10,667
application of public key encryption is what's called

186
00:04:07,933 --> 00:04:10,667
公钥加密的例子叫做

187
00:04:10,667 --> 00:04:14,003
key escrow. Now, key escrow may actually sound

188
00:04:10,667 --> 00:04:14,003
密钥托管 也许这听起来

189
00:04:14,003 --> 00:04:16,186
like a bad thing but in fact it is a mandatory

190
00:04:14,003 --> 00:04:16,186
像是一件坏事情 但事实上它是

191
00:04:16,186 --> 00:04:18,740
feature in corporate environments. So, the idea

192
00:04:16,186 --> 00:04:18,740
公司环境中的强制性特征 所以这里的

193
00:04:18,740 --> 00:04:21,573
here is this. So imagine Bob writes data to a

194
00:04:18,740 --> 00:04:21,573
概念就是这个 想象Bob对

195
00:04:21,573 --> 00:04:25,733
disk and then later Bob becomes inaccesible.

196
00:04:21,573 --> 00:04:25,733
磁盘写数据 然后走了

197
00:04:25,733 --> 00:04:28,600
Maybe Bob is fired. Maybe Bob is out sick.

198
00:04:25,733 --> 00:04:28,600
假设是Bob被解雇 或者生病了

199
00:04:28,600 --> 00:04:30,675
And somehow the company needs to have access to

200
00:04:28,600 --> 00:04:30,675
公司在某种情况下需要访问

201
00:04:30,675 --> 00:04:33,667
Bob's files. So having Bob be the only one

202
00:04:30,675 --> 00:04:33,667
Bob的文件 那只能Bob可以解密

203
00:04:33,667 --> 00:04:36,133
able to decrypt these files is simply unacceptable in

204
00:04:33,667 --> 00:04:36,133
这些文件的情况在公司环境是不适用

205
00:04:36,133 --> 00:04:38,198
corporate settings. The corporation might need

206
00:04:36,133 --> 00:04:38,198
的 公司可能需要

207
00:04:38,198 --> 00:04:41,635
access to those files. So, the question is what to do.

208
00:04:38,198 --> 00:04:41,635
访问这些文件 那问题就是如何做到这一点

209
00:04:41,635 --> 00:04:43,667
And the answer is to introduce this entity called

210
00:04:41,635 --> 00:04:43,667
答案是介绍这个实体名为

211
00:04:43,667 --> 00:04:46,296
a key escrow service. The way the system then

212
00:04:43,667 --> 00:04:46,296
密钥托管服务 这个体系的

213
00:04:46,296 --> 00:04:48,322
would work is as follows:

214
00:04:46,296 --> 00:04:48,322
运行方式如下

215
00:04:48,322 --> 00:04:51,248
Basically, when Bob writes his file to disk, his

216
00:04:48,322 --> 00:04:51,248
基本上 当Bob向磁盘写他的文件时 他的

217
00:04:51,248 --> 00:04:54,406
system, as it's writing the file to this shared

218
00:04:51,248 --> 00:04:54,406
系统 就是他将文件里的内容写到这个共享的

219
00:04:54,406 --> 00:04:56,800
storage medium, what it would do of course, as before,

220
00:04:54,406 --> 00:04:56,800
存储介质 这当然跟以前的一样

221
00:04:56,800 --> 00:05:01,186
it would encrypt the file using the file encryption key Kf.

222
00:04:56,800 --> 00:05:01,186
他会用文件加密密钥Kf加密这个文件

223
00:05:01,186 --> 00:05:04,467
It would encrypt Kf using Bob's public key, but it would

224
00:05:01,186 --> 00:05:04,467
用Bob的公钥加密这个Kf 但也会

225
00:05:04,467 --> 00:05:08,200
also encrypt Kf using an escrow service. So here,

226
00:05:04,467 --> 00:05:08,200
用一个托管服务加密Kf 所以这里

227
00:05:08,200 --> 00:05:11,400
the escrow service is completely offline. We never

228
00:05:08,200 --> 00:05:11,400
托管服务是完全离线的 我们不

229
00:05:11,400 --> 00:05:14,329
talk to it unless we actually need its services.

230
00:05:11,400 --> 00:05:14,329
提到这个 除非我们真的需要这个服务

231
00:05:14,329 --> 00:05:17,000
As Bob is writing the file, all he does is he simply writes

232
00:05:14,329 --> 00:05:17,000
当Bob在写文件 他所做的就只是将

233
00:05:17,000 --> 00:05:20,366
the encryption of Kf under the escrow authority's

234
00:05:17,000 --> 00:05:20,366
托管组织公钥下的Kf加密的内容

235
00:05:20,366 --> 00:05:23,477
public key into the file header. Now, later Bob

236
00:05:20,366 --> 00:05:23,477
写到文件头 然后Bob

237
00:05:23,477 --> 00:05:26,067
disappears and now the company needs to recover

238
00:05:23,477 --> 00:05:26,067
离开了 现在公司需要恢复

239
00:05:26,067 --> 00:05:28,200
Bob's file. What does it do? Well, at this point it would

240
00:05:26,067 --> 00:05:28,200
Bob的文件 该怎么做？ 好 此时他们

241
00:05:28,200 --> 00:05:30,536
contact the escrow service. The escrow service

242
00:05:28,200 --> 00:05:30,536
应该联系托管服务 托管服务

243
00:05:30,536 --> 00:05:33,400
would read this part of the header, use its secret

244
00:05:30,536 --> 00:05:33,400
会读取这部分的文件头 用其私钥

245
00:05:33,400 --> 00:05:36,333
key to decrypt the header and recover Kf and then use Kf

246
00:05:33,400 --> 00:05:36,333
解密头文件来恢复Kf 然后用Kf

247
00:05:36,333 --> 00:05:38,802
to decrypt the actual file.

248
00:05:36,333 --> 00:05:38,802
去解密世纪文件

249
00:05:38,802 --> 00:05:42,007
Ok. So, in this way again you notice that  the escrow service was

250
00:05:38,802 --> 00:05:42,007
好 这种方法下你们也能注意到 托管服务是

251
00:05:42,007 --> 00:05:44,607
completely offline. There was no interaction with the

252
00:05:42,007 --> 00:05:44,607
完全离线的 公司与托管服务

253
00:05:44,607 --> 00:05:47,600
escrow service until the point at which the escrow

254
00:05:44,607 --> 00:05:47,600
没有交互 除非是真正需要

255
00:05:47,600 --> 00:05:50,737
services were actually needed. And again, you can

256
00:05:47,600 --> 00:05:50,737
托管的时候 同样可以看到

257
00:05:50,737 --> 00:05:53,133
see that this is a very clean and elegant application

258
00:05:50,737 --> 00:05:53,133
这是一个非常干净简洁的的

259
00:05:53,133 --> 00:05:56,333
of public key encryption. So, as I said in the

260
00:05:53,133 --> 00:05:56,333
公钥加密应用 如我在前面的

261
00:05:56,333 --> 00:05:58,867
previous lecture, we saw constructions for public

262
00:05:56,333 --> 00:05:58,867
课程中所说 我们看到了基于

263
00:05:58,867 --> 00:06:01,333
key encryption based on trapdoor functions.

264
00:05:58,867 --> 00:06:01,333
陷门函数的公钥加密结构

265
00:06:01,333 --> 00:06:03,667
In particular, we look at RSA. We looked at the

266
00:06:01,333 --> 00:06:03,667
特别的 我们来看RSA 我们学过

267
00:06:03,667 --> 00:06:05,867
generic construction we called ISO standard.

268
00:06:03,667 --> 00:06:05,867
通用的结构 名为ISO标准

269
00:06:05,867 --> 00:06:09,467
We looked at constructions like OAEP+ and so on and so forth.

270
00:06:05,867 --> 00:06:09,467
也学过像OAEP+等结构

271
00:06:09,467 --> 00:06:11,887
In this lecture, we are going to look at public key

272
00:06:09,467 --> 00:06:11,887
这节课我们要学习的公钥结构

273
00:06:11,887 --> 00:06:13,467
constructions from the Diffie-Hellman protocol.

274
00:06:11,887 --> 00:06:13,467
来自Diffie-Hellman协议

275
00:06:13,467 --> 00:06:15,800
This is another family of public key systems and

276
00:06:13,467 --> 00:06:15,800
这是公钥系统的另一个类别

277
00:06:15,800 --> 00:06:18,508
I am going to show you how they work. These public

278
00:06:15,800 --> 00:06:18,508
我来介绍他们是如何工作的这些公钥

279
00:06:18,508 --> 00:06:21,133
key systems are generally called ElGamal public key

280
00:06:18,508 --> 00:06:21,133
系统通常被称为EIGamal公钥

281
00:06:21,133 --> 00:06:24,200
encryption schemes. Taher ElGamal was actually Marty

282
00:06:21,133 --> 00:06:24,200
加密体制 Taher ElGamal其实是Marty

283
00:06:24,200 --> 00:06:26,635
Hellman's student. He came up with this ElGamal

284
00:06:24,200 --> 00:06:26,635
Hellman的学生 他想到这个EIGamal

285
00:06:26,635 --> 00:06:30,165
encryption system as part of his PhD thesis.

286
00:06:26,635 --> 00:06:30,165
加密系统作为其PhD论文的一部分

287
00:06:30,165 --> 00:06:32,400
And, in fact, ElGamal encryption, for historical

288
00:06:30,165 --> 00:06:32,400
其实ElGamal加密 因历史

289
00:06:32,400 --> 00:06:35,800
reasons, is used in an email encryption system called GPG,

290
00:06:32,400 --> 00:06:35,800
原因 被用于名为GPG的邮件加密系统

291
00:06:35,800 --> 00:06:39,360
the GNU Privacy Guard. As usual, when we

292
00:06:35,800 --> 00:06:39,360
GNU隐私保护 一如既然 当我们

293
00:06:39,360 --> 00:06:41,333
construct public key encryption systems, our goal is

294
00:06:39,360 --> 00:06:41,333
构建公钥加密系统 我们的目标是

295
00:06:41,333 --> 00:06:44,050
to build systems that have chosen ciphertext security,

296
00:06:41,333 --> 00:06:44,050
构建有选择密文安全的系统

297
00:06:44,050 --> 00:06:46,667
so that they are secure both against eavesdropping

298
00:06:44,050 --> 00:06:46,667
所以同时具有针对窃听和篡改

299
00:06:46,667 --> 00:06:50,599
and tampering attacks. So, before I show you the ElGamal

300
00:06:46,667 --> 00:06:50,599
攻击的安全性 所以在我介绍ELGamal

301
00:06:50,599 --> 00:06:53,333
system let's do a very brief review of the Diffie-Hellman

302
00:06:50,599 --> 00:06:53,333
系统之前 我们先来对Diffie-Hellman协议

303
00:06:53,333 --> 00:06:56,133
protocol. So, in my description here, I am going

304
00:06:53,333 --> 00:06:56,133
简短复习 在我的描述中 我要

305
00:06:56,133 --> 00:06:58,679
to abstract a little bit from the version that we saw last

306
00:06:56,133 --> 00:06:58,679
从我们上周版本中摘取一小部分

307
00:06:58,679 --> 00:07:00,467
week. In fact, I just going to use the concept

308
00:06:58,679 --> 00:07:00,467
其实 我只是想借用

309
00:07:00,467 --> 00:07:03,933
of a finite cyclic group. In fact, we have an arbitrary finite

310
00:07:00,467 --> 00:07:03,933
有限循环群的概念 事实上 比如我们有一个任意的有限

311
00:07:03,933 --> 00:07:07,131
cyclic group, for example, it could be the group (Zp) star,

312
00:07:03,933 --> 00:07:07,131
循环群 可以是群（Zp）

313
00:07:07,131 --> 00:07:10,521
but it could also be the points of an elliptic curve.

314
00:07:07,131 --> 00:07:10,521
它也可以是椭圆曲线上的点群

315
00:07:10,521 --> 00:07:12,533
And as I mentioned, there are some benefits to doing

316
00:07:10,521 --> 00:07:12,533
如我提到的 将Diffie-Hellman对应到

317
00:07:12,533 --> 00:07:15,467
Diffie-Hellman over an elliptic curve. But, for simplicity,

318
00:07:12,533 --> 00:07:15,467
椭圆曲线上有好处 但是为了简单起见

319
00:07:15,467 --> 00:07:18,000
I am just going to refer to G as an abstract finite

320
00:07:15,467 --> 00:07:18,000
我只提到G作为抽象的有限

321
00:07:18,000 --> 00:07:20,000
cyclic group, but in your heads you should be

322
00:07:18,000 --> 00:07:20,000
循环群 但是在你们脑海里 你们应该

323
00:07:20,000 --> 00:07:22,456
thinking G is the group (Zp) and let's suppose

324
00:07:20,000 --> 00:07:22,456
想象G是群（Zp） 我们来假设

325
00:07:22,456 --> 00:07:25,467
that the group has order n for some integer n.

326
00:07:22,456 --> 00:07:25,467
这个集合阶为n

327
00:07:25,467 --> 00:07:27,667
Now, we are going to fix a generator g of this group

328
00:07:25,467 --> 00:07:27,667
现在我们要选定这个群的一个生成元

329
00:07:27,667 --> 00:07:29,933
and all this means, is basically, if you look at the

330
00:07:27,667 --> 00:07:29,933
这就表示 基本上 如果你研究一下

331
00:07:29,933 --> 00:07:32,905
successive powers of g, that basically you get

332
00:07:29,933 --> 00:07:32,905
g的连续次数 那就可以得到

333
00:07:32,905 --> 00:07:35,200
all the elements in the group G. You notice,

334
00:07:32,905 --> 00:07:35,200
集合G里面的所有元素 注意

335
00:07:35,200 --> 00:07:37,667
because the group has order n, we know that

336
00:07:35,200 --> 00:07:37,667
因为集合有n阶 我们知道

337
00:07:37,667 --> 00:07:41,133
g to the power of n is equal to 1. And, therefore

338
00:07:37,667 --> 00:07:41,133
g的n次方等于1 因此

339
00:07:41,133 --> 00:07:44,053
there is no reason to go beyond the n-1st power

340
00:07:41,133 --> 00:07:44,053
不需要超过g的n-1次方

341
00:07:44,053 --> 00:07:48,036
of g. g to the n is equal to 1 so that we just wrap around.

342
00:07:44,053 --> 00:07:48,036
g的n次方等于1 我们就绕回来了

343
00:07:48,990 --> 00:07:51,600
Ok. So, we have this cyclic group G. We have this

344
00:07:48,990 --> 00:07:51,600
好 我们有了这个循环群G 有了

345
00:07:51,600 --> 00:07:54,453
generator whose powers gave us all the elements of

346
00:07:51,600 --> 00:07:54,453
生产元 它的幂次生成G的所有元素

347
00:07:54,453 --> 00:07:57,565
G, and now let me remind you how the Diffie-Hellman

348
00:07:54,453 --> 00:07:57,565
现在我来介绍Diffie-Hellman协议的

349
00:07:57,565 --> 00:08:00,133
protocol works. Basically, what Alice does is she  chooses a

350
00:07:57,565 --> 00:08:00,133
工作原理 基本上 Alice所做的就是她选择

351
00:08:00,133 --> 00:08:03,133
random a. She computes g to the a and sends it

352
00:08:00,133 --> 00:08:03,133
一个随机数a 然后计算g的a次方并把它

353
00:08:03,133 --> 00:08:06,621
over to Bob. Bob chooses a random b. Let's see who

354
00:08:03,133 --> 00:08:06,621
发送给Bob Bob选择了一个随机数b 我们来看有谁

355
00:08:06,621 --> 00:08:10,905
remembers. What does Bob send over to Alice?

356
00:08:06,621 --> 00:08:10,905
记得 Bob给Alice发送的什么

357
00:08:12,936 --> 00:08:15,398
So, Bob sends over to Alice g to the b and of

358
00:08:12,936 --> 00:08:15,398
好 Bob将g的b次方发送给了Alice

359
00:08:15,398 --> 00:08:18,370
course I should remind you that both g to the a and

360
00:08:15,398 --> 00:08:18,370
当然我要提醒你们 g的a次方和

361
00:08:18,370 --> 00:08:21,867
g to the b are just elements in this group G. Now,

362
00:08:18,370 --> 00:08:21,867
g的b次方都是集合G中的元素 现在

363
00:08:21,867 --> 00:08:24,133
they can derive the shared secret, If you remember,

364
00:08:21,867 --> 00:08:24,133
他们可以获得导处共享秘密 如果你们记得

365
00:08:24,133 --> 00:08:27,667
the shared secret is g to the ab, and these equalities

366
00:08:24,133 --> 00:08:27,667
共享密钥是g的ab次方 这些等式

367
00:08:27,667 --> 00:08:30,467
here shows that both sides can actually compute

368
00:08:27,667 --> 00:08:30,467
表明双方实际上都可以算得

369
00:08:30,467 --> 00:08:33,133
the shared secret given the values at their disposal.

370
00:08:30,467 --> 00:08:33,133
他们发送的值里隐含的共享秘密

371
00:08:33,133 --> 00:08:35,800
So, Alice for example, has B and she has a, and

372
00:08:33,133 --> 00:08:35,800
所以 比如Alice有B 也有a

373
00:08:35,800 --> 00:08:38,667
so raising B to the power of a, gives her the shared

374
00:08:35,800 --> 00:08:38,667
计算B的a次方 她就能得到共享密钥

375
00:08:38,667 --> 00:08:41,776
secret. The attacker, of course, the poor attacker

376
00:08:38,667 --> 00:08:41,776
攻击者 当然 弱攻击者

377
00:08:41,776 --> 00:08:46,512
he gets to see A and B and his goal is now,

378
00:08:41,776 --> 00:08:46,512
得到了A和B 现在他的目标是

379
00:08:46,512 --> 00:08:49,438
of course, he also gets to see the generated g, and

380
00:08:46,512 --> 00:08:49,438
当然 他还得到了生成元g

381
00:08:49,438 --> 00:08:52,333
his goal now is to compute g to the ab. But, we said that

382
00:08:49,438 --> 00:08:52,333
现在他的目标是计算g的ab次方 但是 我们讲过

383
00:08:52,333 --> 00:08:55,600
this is believed to be a hard problem. Given g, g to the a,

384
00:08:52,333 --> 00:08:55,600
这的确是个难题 给定g g的a次方

385
00:08:55,600 --> 00:08:59,067
and g to the b, in a group like  Zp<i>, computing g to </i>

386
00:08:55,600 --> 00:08:59,067
以及g的b次方 在一个集合比如Zp<i> 计算g

387
00:08:59,067 --> 00:09:03,533
the ab is difficult. So, now let's see how to convert to

388
00:08:59,067 --> 00:09:03,533
的ab次方很难 所以 我们来看怎么将

389
00:09:03,533 --> 00:09:05,467
the Diffie-Hellman protocol into an actual public key

390
00:09:03,533 --> 00:09:05,467
DH协议转换到一个实际的公钥系统

391
00:09:05,467 --> 00:09:08,533
system. As I said, this was a brilliant idea due to

392
00:09:05,467 --> 00:09:08,533
如我所讲 这是Taher EIGamal的一个杰出的注意

393
00:09:08,533 --> 00:09:11,133
Taher ElGamal. So, as before, we are going to fix our

394
00:09:08,533 --> 00:09:11,133
所以 一如既往 我们要准备我们的

395
00:09:11,133 --> 00:09:15,305
cyclic group G and a generator g inside of G.

396
00:09:11,133 --> 00:09:15,305
循环域G 和生成元G里面的g

397
00:09:15,305 --> 00:09:19,400
Now, here I wrote the Diffie-Hellman protocol again,

398
00:09:15,305 --> 00:09:19,400
现在 这里我再写一次DH协议

399
00:09:19,400 --> 00:09:21,800
except now we are going to assume that these guys

400
00:09:19,400 --> 00:09:21,800
就是我们现在要假设这些东西

401
00:09:21,800 --> 00:09:25,533
are separated in time. These two steps do not have

402
00:09:21,800 --> 00:09:25,533
在时间上是离散的 这两步不用

403
00:09:25,533 --> 00:09:28,133
to occur simultaneously; they could actually take place

404
00:09:25,533 --> 00:09:28,133
同时出现 实际上它们可以在不同

405
00:09:28,133 --> 00:09:31,800
at quite different times. The first step of the Diffie-Hellman

406
00:09:28,133 --> 00:09:31,800
的时刻发生 DH协议的第一步

407
00:09:31,800 --> 00:09:34,578
protocol is what we are going to view as key

408
00:09:31,800 --> 00:09:34,578
是我们要研究的密钥

409
00:09:34,578 --> 00:09:36,533
generation. That is the public key is going to be

410
00:09:34,578 --> 00:09:36,533
生成 那是因为公钥要用这个

411
00:09:36,533 --> 00:09:39,200
this capital A  and the secret key is simply going to

412
00:09:36,533 --> 00:09:39,200
大写字母A表示 私钥就用这个

413
00:09:39,200 --> 00:09:42,200
be the little a. So, you notice of course that

414
00:09:39,200 --> 00:09:42,200
小写字母a表示 当然你们可以注意到

415
00:09:42,200 --> 00:09:45,667
extracting the secret key from the public key,

416
00:09:42,200 --> 00:09:45,667
从公钥中提取私钥

417
00:09:45,667 --> 00:09:49,333
namely extracting the little a from capital A is a

418
00:09:45,667 --> 00:09:49,333
也就是从大写字母A得出小a是

419
00:09:49,333 --> 00:09:52,132
discrete log problem. So, that recovering a secret

420
00:09:49,333 --> 00:09:52,132
离散对数问题 所以 恢复私钥

421
00:09:52,132 --> 00:09:55,787
key is actually difficult. Ok, now this gives us our public key.

422
00:09:52,132 --> 00:09:55,787
实际上很困难 好 现在我们得到了公钥

423
00:09:55,787 --> 00:09:57,805
So, now at a later time Bob wants to encrypt a

424
00:09:55,787 --> 00:09:57,805
那等会儿Bob会加密一个消息并

425
00:09:57,805 --> 00:10:01,083
message to Alice, encrypted using her public key.

426
00:09:57,805 --> 00:10:01,083
发送给Alice 用她的公钥加密

427
00:10:01,083 --> 00:10:04,161
So how does Bob encrypt? Well, what he is going to do is

428
00:10:01,083 --> 00:10:04,161
那么Bob是怎么加密的呢？他会这么做

429
00:10:04,161 --> 00:10:06,400
he's going to compute his contribution to the Diffie-Hellman

430
00:10:04,161 --> 00:10:06,400
他计算在DH协议中他的部分

431
00:10:06,400 --> 00:10:08,990
protocol. Namely, he is going to send over g to the

432
00:10:06,400 --> 00:10:08,990
即，他把g的b次方发出去

433
00:10:08,990 --> 00:10:11,467
little b. Of course, he is going to choose this little b

434
00:10:08,990 --> 00:10:11,467
当然他会随机地选择小b

435
00:10:11,467 --> 00:10:14,005
at random and now he is going to compute by

436
00:10:11,467 --> 00:10:14,005
现在他会自己算

437
00:10:14,005 --> 00:10:16,133
himself the shared secret. So, he is going to

438
00:10:14,005 --> 00:10:16,133
共享密钥 即他就可以计算

439
00:10:16,133 --> 00:10:20,276
compute by himself g to the ab. From this g to the ab

440
00:10:16,133 --> 00:10:20,276
g的ab次方，从这个g的ab次方

441
00:10:20,276 --> 00:10:23,249
he is going to derive a symmetric key for a

442
00:10:20,276 --> 00:10:23,249
他能得到对称密码系统的对称密钥

443
00:10:23,249 --> 00:10:25,282
symmetric encryption system and then he is going to

444
00:10:23,249 --> 00:10:25,282
接着他会

445
00:10:25,282 --> 00:10:27,844
encrypt the message m using this symmetric key

446
00:10:25,282 --> 00:10:27,844
用这个对称密钥对消息m加密

447
00:10:27,844 --> 00:10:30,306
that he just derived. And that is the pair he is going to

448
00:10:27,844 --> 00:10:30,306
他刚推导出来的密钥 这就是他会发送的密钥组

449
00:10:30,306 --> 00:10:32,200
send. So, he is going to send over his contribution

450
00:10:30,306 --> 00:10:32,200
那么他把自己在

451
00:10:32,200 --> 00:10:34,933
to the Diffie-Hellman protocol plus the symmetric

452
00:10:32,200 --> 00:10:34,933
DH协议中部分和经过对称

453
00:10:34,933 --> 00:10:38,067
encryption of the message m that he wants to send

454
00:10:34,933 --> 00:10:38,067
加密的消息m，他想发给Alice

455
00:10:38,067 --> 00:10:41,733
over to Alice. Ok, so you can see basically, we are

456
00:10:38,067 --> 00:10:41,733
的消息m。好，现在你基本可以发现 我们

457
00:10:41,733 --> 00:10:43,933
doing the exact same thing as we would do in the Diffie-Hellman

458
00:10:41,733 --> 00:10:43,933
和在DH协议中一样，我们进行同样的操作

459
00:10:43,933 --> 00:10:48,046
protocol except now we, Bob directly immediately is using

460
00:10:43,933 --> 00:10:48,046
除了现在，Bob直接立即就使用

461
00:10:48,046 --> 00:10:51,067
his Diffie-Hellman secret to encrypt the message  that he

462
00:10:48,046 --> 00:10:51,067
他的DH秘密信息他要

463
00:10:51,067 --> 00:10:52,600
wants to send over to Alice.

464
00:10:51,067 --> 00:10:52,600
发送给Alice的加密消息

465
00:10:52,600 --> 00:10:54,200
Now, what does Alice do to decrypt?

466
00:10:52,600 --> 00:10:54,200
现在，Alice怎么解密呢？

467
00:10:54,200 --> 00:10:56,733
Basically, she is going also to compute the

468
00:10:54,200 --> 00:10:56,733
基本上，她会计算

469
00:10:56,733 --> 00:10:58,615
Diffie-Hellman secret. Remember, that now she just

470
00:10:56,733 --> 00:10:58,615
DH秘密信息 回忆一下 她现在

471
00:10:58,615 --> 00:11:00,600
received Bob's contribution to the Diffie-Hellman

472
00:10:58,615 --> 00:11:00,600
刚收到Bob在DH协议中的部分

473
00:11:00,600 --> 00:11:03,400
protocol and she has her secret key a. So, she can

474
00:11:00,600 --> 00:11:03,400
她有自己的秘密钥a，因此她可以

475
00:11:03,400 --> 00:11:06,733
compute also the Diffie-Hellman secret, namely

476
00:11:03,400 --> 00:11:06,733
计算DH秘密信息即

477
00:11:06,733 --> 00:11:09,400
g to the ab, from which she is going to derive the

478
00:11:06,733 --> 00:11:09,400
g的ab次方，从这个她可以导出

479
00:11:09,400 --> 00:11:12,055
symmetric encryption key k. And then, she is going

480
00:11:09,400 --> 00:11:12,055
对称密钥k，接着，她会

481
00:11:12,055 --> 00:11:13,800
to decrypt the message to recover the actual

482
00:11:12,055 --> 00:11:13,800
解密消息恢复出

483
00:11:13,800 --> 00:11:17,584
plaintext. Ok, so that is the intuition for how we

484
00:11:13,800 --> 00:11:17,584
真正的明文 好这是我们直观的解释

485
00:11:17,584 --> 00:11:20,461
convert the Diffie-Hellman protocol into a public key

486
00:11:17,584 --> 00:11:20,461
如何把DH协议转换成一个公钥加密

487
00:11:20,461 --> 00:11:22,318
system. By the way, this was kind of an interesting

488
00:11:20,461 --> 00:11:22,318
系统 通过这种方法 这是一种比较有意思的

489
00:11:22,318 --> 00:11:25,400
development at the time that it came out,  partially

490
00:11:22,318 --> 00:11:25,400
的改进方法，在一开始的时候 部分因为

491
00:11:25,400 --> 00:11:28,000
because, you notice this is a randomized encryption scheme.

492
00:11:25,400 --> 00:11:28,000
你注意到，这是一个随机加密体制

493
00:11:28,000 --> 00:11:31,188
So, every time Bob encrypts a message, it is

494
00:11:28,000 --> 00:11:31,188
因此，每次Bob加密一个消息

495
00:11:31,188 --> 00:11:34,133
required that he choose a new random b and

496
00:11:31,188 --> 00:11:34,133
需要他随机选一个b

497
00:11:34,133 --> 00:11:38,015
encrypt the message using this new random b.

498
00:11:34,133 --> 00:11:38,015
用这个新的随机数b对消息进行加密

499
00:11:38,015 --> 00:11:40,364
So, let's see the ElGamal system,  actually in more

500
00:11:38,015 --> 00:11:40,364
我们看一下ElGamal系统 更详细的

501
00:11:40,364 --> 00:11:42,708
detail. So, now actually let's  view it as an actual

502
00:11:40,364 --> 00:11:42,708
即我们认为它是一个实际的

503
00:11:42,708 --> 00:11:45,800
public key encryption system. Namely, algorithm Gen,

504
00:11:42,708 --> 00:11:45,800
公钥密码系统，即算法Gen

505
00:11:45,800 --> 00:11:48,333
algorithm E and algorithm D.

506
00:11:45,800 --> 00:11:48,333
算法E和算法D

507
00:11:48,333 --> 00:11:50,533
So, as usual, we are going to fix our finite cyclic

508
00:11:48,333 --> 00:11:50,533
所以，和往常一样，我们研究一下我们的有限

509
00:11:50,533 --> 00:11:53,133
group of order n. Another ingredient that we are going

510
00:11:50,533 --> 00:11:53,133
n阶循环群。我们需要的另外一个因素是

511
00:11:53,133 --> 00:11:55,600
to need is a symmetric encryption system. So, I am

512
00:11:53,133 --> 00:11:55,600
一个对称加密机制。因此我

513
00:11:55,600 --> 00:11:58,402
going to refer to it as E sub s, and D sub s. These are the

514
00:11:55,600 --> 00:11:58,402
用Es和Ds标识这个。这是

515
00:11:58,402 --> 00:12:00,651
encryption and decryption algorithms of a symmetric

516
00:11:58,402 --> 00:12:00,651
一个对称加密系统的加密和解密算法

517
00:12:00,651 --> 00:12:02,767
encryption system that happens to provide

518
00:12:00,651 --> 00:12:02,767
它能够保证

519
00:12:02,767 --> 00:12:05,077
authenticated encryption. And, the key space for

520
00:12:02,767 --> 00:12:05,077
认证加密。这个系统的密钥空间是

521
00:12:05,077 --> 00:12:08,667
this system is capital K. And, then we are also going

522
00:12:05,077 --> 00:12:08,667
大K。这样，我们还需要一个

523
00:12:08,667 --> 00:12:11,859
to need a hash function that maps pairs of elements

524
00:12:08,667 --> 00:12:11,859
杂凑函数能把这些元素映射到群里

525
00:12:11,859 --> 00:12:14,533
in the group, namely elements in G squared into

526
00:12:11,859 --> 00:12:14,533
即把G平方映射到

527
00:12:14,533 --> 00:12:17,200
the key space. Now, here is how the public key

528
00:12:14,533 --> 00:12:17,200
密钥空间 现在 这是公钥密码系统的

529
00:12:17,200 --> 00:12:19,467
encryption system works. So, I have to describe

530
00:12:17,200 --> 00:12:19,467
工作方式 现在我们描述

531
00:12:19,467 --> 00:12:22,133
three algorithms. Algorithm that generates the

532
00:12:19,467 --> 00:12:22,133
一下这算个算法 算法生成

533
00:12:22,133 --> 00:12:24,200
public key and the secret key, and then the  encryption

534
00:12:22,133 --> 00:12:24,200
公钥和私钥 接着加密

535
00:12:24,200 --> 00:12:26,600
and decryption algorithms. So, the key generation

536
00:12:24,200 --> 00:12:26,600
和解密算法 密钥生成算法

537
00:12:26,600 --> 00:12:28,733
algorithm works as follows: All we do is basically,

538
00:12:26,600 --> 00:12:28,733
工作如下 我们所做的，基本上，

539
00:12:28,733 --> 00:12:31,600
build up Alice's contribution to the Diffie-Hellman

540
00:12:28,733 --> 00:12:31,600
构造Alice的DH协议部分

541
00:12:31,600 --> 00:12:34,133
protocol. What we are going to do is going to choose a

542
00:12:31,600 --> 00:12:34,133
接下来选择一个

543
00:12:34,133 --> 00:12:37,662
random generator g in G and then we are going to

544
00:12:34,133 --> 00:12:37,662
G中的随机生成元g， 选一个随机

545
00:12:37,662 --> 00:12:39,800
choose a random exponent a. The secret key is

546
00:12:37,662 --> 00:12:39,800
的指数a 密钥就是

547
00:12:39,800 --> 00:12:42,267
going to be a and then the public key is going to be

548
00:12:39,800 --> 00:12:42,267
a，公钥是

549
00:12:42,267 --> 00:12:45,867
the generator g and Alice's contribution to the

550
00:12:42,267 --> 00:12:45,867
生成元g和Alice的

551
00:12:45,867 --> 00:12:48,262
Diffie-Hellman protocol. The reason, by the way,

552
00:12:45,867 --> 00:12:48,262
DH协议部分，我们不用

553
00:12:48,262 --> 00:12:50,090
we don't use a fix generator, is because it

554
00:12:48,262 --> 00:12:50,090
固定的生成元的原因是

555
00:12:50,090 --> 00:12:52,662
allows us to somewhat use a weaker assumption,

556
00:12:50,090 --> 00:12:52,662
这样允许我们使用一个弱假设

557
00:12:52,662 --> 00:12:54,933
improving security. And, so it is actually better to

558
00:12:52,662 --> 00:12:54,933
提高安全性 而且每次都

559
00:12:54,933 --> 00:12:57,845
choose a random generator every time. It is easy

560
00:12:54,933 --> 00:12:57,845
选一个随机生成元好一些，选随机

561
00:12:57,845 --> 00:13:00,000
enough to choose a random generator. All we do, is we

562
00:12:57,845 --> 00:13:00,000
生成元很容易 我们要做的就是

563
00:13:00,000 --> 00:13:02,533
take the generator that we started with and then we

564
00:13:00,000 --> 00:13:02,533
选一个起始的生成元 然后

565
00:13:02,533 --> 00:13:05,667
raise it to some power that is relatively prime to n.

566
00:13:02,533 --> 00:13:05,667
求a次方，a与n互素

567
00:13:05,667 --> 00:13:07,600
That will give us another generator. A random

568
00:13:05,667 --> 00:13:07,600
就能给我们另外一个生成元了 一个随机的

569
00:13:07,600 --> 00:13:10,400
generator of the group capital G. Ok. So, you can

570
00:13:07,600 --> 00:13:10,400
群G的生成元 好。这样 你会

571
00:13:10,400 --> 00:13:12,799
see here that again the public key is simply Alice's

572
00:13:10,400 --> 00:13:12,799
发现这里公钥就是Alice

573
00:13:12,799 --> 00:13:15,000
contribution to the Diffie-Hellman protocol. And, the

574
00:13:12,799 --> 00:13:15,000
在DH协议中的部分

575
00:13:15,000 --> 00:13:18,667
secret key is the random a that she chose. Now, how

576
00:13:15,000 --> 00:13:18,667
密钥是她随机选择的 现在

577
00:13:18,667 --> 00:13:21,400
do we encrypt and decrypt? Well, when Bob wants

578
00:13:18,667 --> 00:13:21,400
我们怎么加密和解密呢？好 当Bob想

579
00:13:21,400 --> 00:13:23,067
to encrypt the message, he is going to use the

580
00:13:21,400 --> 00:13:23,067
加密一个消息时，他会使用公钥

581
00:13:23,067 --> 00:13:25,467
public key. Remember, it consists of  g and h.

582
00:13:23,067 --> 00:13:25,467
记着，它由g和h组成

583
00:13:25,467 --> 00:13:28,533
Here, he wants to encrypt a message m.

584
00:13:25,467 --> 00:13:28,533
这里 他要加密消息m

585
00:13:28,533 --> 00:13:30,533
So, here is what he is going to do. So, he is going

586
00:13:28,533 --> 00:13:30,533
所以 他会这么做，他

587
00:13:30,533 --> 00:13:32,768
to choose his contribution to the Diffie-Hellman protocol.

588
00:13:30,533 --> 00:13:32,768
先构造他的DH协议部分

589
00:13:32,768 --> 00:13:35,200
So, this is the secret b that he would normally

590
00:13:32,768 --> 00:13:35,200
他选择秘密信息b和在DH协议

591
00:13:35,200 --> 00:13:37,267
choose in Diffie-Hellman. And, now he is going to

592
00:13:35,200 --> 00:13:37,267
中一样，他计算

593
00:13:37,267 --> 00:13:40,667
compute g to the b, which is actually his message,

594
00:13:37,267 --> 00:13:40,667
g的b次方 实际上就是他的消息

595
00:13:40,667 --> 00:13:43,600
that gets send to Alice in the Diffie-Hellman protocol.

596
00:13:40,667 --> 00:13:43,600
在DH协议中他发给Alice的

597
00:13:43,600 --> 00:13:46,050
He is going to compute the Diffie-Hellman secret,

598
00:13:43,600 --> 00:13:46,050
他计算DH秘密信息

599
00:13:46,050 --> 00:13:49,000
that's h to the b. If you remember, h was g to the a,

600
00:13:46,050 --> 00:13:49,000
即h的b次方 如果你还记得 h是g的a次方

601
00:13:49,000 --> 00:13:52,000
therefore, this value here is really g to the ab.

602
00:13:49,000 --> 00:13:52,000
因此这个值实际上是g的ab次方

603
00:13:52,000 --> 00:13:54,067
That's the Diffie-Hellman secret. That is the one thing that

604
00:13:52,000 --> 00:13:54,067
这就是DH秘密消息 这是

605
00:13:54,067 --> 00:13:56,600
the attacker doesn't actually know. Next, he is going

606
00:13:54,067 --> 00:13:56,600
攻击者不知道的一部分消息 接着他

607
00:13:56,600 --> 00:13:59,067
to compute a symmetric key by basically hashing

608
00:13:56,600 --> 00:13:59,067
计算一个对称密钥 通过hash

609
00:13:59,067 --> 00:14:02,333
this pair u comma v. So, u, of course, is something

610
00:13:59,067 --> 00:14:02,333
u,v  这里u是

611
00:14:02,333 --> 00:14:04,102
that the attacker is going to know because that is

612
00:14:02,333 --> 00:14:04,102
攻击者会知道的，因为这会

613
00:14:04,102 --> 00:14:06,733
going to be sent as part of the ciphertext. But v, the

614
00:14:04,102 --> 00:14:06,733
作为密文的一部分公开传播 但是v

615
00:14:06,733 --> 00:14:09,667
attacker isn't going to know. Again, for the proof of

616
00:14:06,733 --> 00:14:09,667
攻击者不知道。对安全性的证明

617
00:14:09,667 --> 00:14:13,267
security, actually it helps to hash both u and v. So, we

618
00:14:09,667 --> 00:14:13,267
实际上hash u和v对证明有帮助。

619
00:14:13,267 --> 00:14:15,667
hash both of them together. Although, strictly speaking

620
00:14:13,267 --> 00:14:15,667
这样我们对这两个进行hash，但是，严格地说

621
00:14:15,667 --> 00:14:18,600
we just needed to hash v, because v is the only value

622
00:14:15,667 --> 00:14:18,600
我们只需要hash v，因为v是唯一攻击者

623
00:14:18,600 --> 00:14:20,200
that the attacker doesn't know. The attacker

624
00:14:18,600 --> 00:14:20,200
不知道的值。攻击者已经知道

625
00:14:20,200 --> 00:14:22,737
already knows u, because that's going to be part of the data

626
00:14:20,200 --> 00:14:22,737
u，因为它是在网络上传送的数据的一部分

627
00:14:22,737 --> 00:14:25,000
that's sent on the network. So, anyhow, so Bob derives

628
00:14:22,737 --> 00:14:25,000
不管怎么样 Bob

629
00:14:25,000 --> 00:14:28,933
this symmetric key k, by hashing u and v. Then, he

630
00:14:25,000 --> 00:14:28,933
导出这个密钥k 通过hash u和v 接着

631
00:14:28,933 --> 00:14:30,867
goes ahead and encrypts the message using the

632
00:14:28,933 --> 00:14:30,867
他继续加密消息

633
00:14:30,867 --> 00:14:33,933
symmetric key k and finally he outputs his

634
00:14:30,867 --> 00:14:33,933
就用这个密钥k 最后他输出他的

635
00:14:33,933 --> 00:14:35,733
contribution to the Diffie-Hellman protocol.

636
00:14:33,933 --> 00:14:35,733
DH协议部分

637
00:14:35,733 --> 00:14:38,867
The value u and then the symmetric ciphertext that

638
00:14:35,733 --> 00:14:38,867
u值，然后对称密文

639
00:14:38,867 --> 00:14:41,223
directly encrypts the message m.

640
00:14:38,867 --> 00:14:41,223
是对消息m的直接加密

641
00:14:41,223 --> 00:14:43,841
That's it. So, the ciphertext consists of these two

642
00:14:41,223 --> 00:14:43,841
好了 密文包括这两个

643
00:14:43,841 --> 00:14:45,764
parts and that is the thing that gets sent over the

644
00:14:43,841 --> 00:14:45,764
部分 这些是我们要通过网络

645
00:14:45,764 --> 00:14:48,098
network. Let's see, how does Alice decrypt now.

646
00:14:45,764 --> 00:14:48,098
传送的 现在看一下 Alice怎么解密

647
00:14:48,098 --> 00:14:50,800
So, she is going to use her secret key a to decrypt

648
00:14:48,098 --> 00:14:50,800
她会用她的密钥解密

649
00:14:50,800 --> 00:14:53,800
and she receives here, Bob's contribution to the

650
00:14:50,800 --> 00:14:53,800
她这里接收到的 Bob在

651
00:14:53,800 --> 00:14:55,533
Diffie-Hellman protocol plus the symmetric

652
00:14:53,800 --> 00:14:55,533
DH协议中的部分和对称

653
00:14:55,533 --> 00:14:59,000
encryption of the message that Bob sent.

654
00:14:55,533 --> 00:14:59,000
消息加密，Bob发过来的

655
00:14:59,000 --> 00:15:01,800
What she will do is she'll compute herself the Diffie-Hellman

656
00:14:59,000 --> 00:15:01,800
她要做的是计算她自己的DH秘密

657
00:15:01,800 --> 00:15:05,267
secret. If you remember, u to the a is simply g to the b

658
00:15:01,800 --> 00:15:05,267
消息 如果你记得 u的a次方就是g的b次方

659
00:15:05,267 --> 00:15:07,933
to the a. Which is g to the ab. So, here Alice

660
00:15:05,267 --> 00:15:07,933
的a次方，就是g的ab次方 这里Alice

661
00:15:07,933 --> 00:15:11,467
computed the Diffie-Hellman secret. And, now let me

662
00:15:07,933 --> 00:15:11,467
计算DH秘密信息 那么我问个问题

663
00:15:11,467 --> 00:15:14,467
ask you, how does she derive the symmetric key k

664
00:15:11,467 --> 00:15:14,467
她怎么得到对称密钥k

665
00:15:14,467 --> 00:15:16,867
given the Diffie-Hellman secret, g to the ab and the

666
00:15:14,467 --> 00:15:16,867
已知DH秘密信息 g的ab次方

667
00:15:16,867 --> 00:15:19,103
ciphertext that she was given?

668
00:15:16,867 --> 00:15:19,103
和她得到的密文

669
00:15:22,088 --> 00:15:23,933
Well, what she will do, is simply again, now she has

670
00:15:22,088 --> 00:15:23,933
好， 她这么做 还是很简单

671
00:15:23,933 --> 00:15:27,267
u from the ciphertext and she has v, because she just

672
00:15:23,933 --> 00:15:27,267
从密文中得到u，她有v，因为她刚才

673
00:15:27,267 --> 00:15:29,667
computed it herself. So, now she can rederive the

674
00:15:27,267 --> 00:15:29,667
自己通过计算得到 那么现在她可以通过

675
00:15:29,667 --> 00:15:31,800
symmetric encryption key  by hashing u and v

676
00:15:29,667 --> 00:15:31,800
对u和v进行hash得到

677
00:15:31,800 --> 00:15:34,333
together to get the symmetric encryption key and

678
00:15:31,800 --> 00:15:34,333
对称加密密钥

679
00:15:34,333 --> 00:15:36,667
then she just decrypts the ciphertext to get the

680
00:15:34,333 --> 00:15:36,667
用这个密钥对密文解密即

681
00:15:36,667 --> 00:15:39,600
actual plaintext. OK, so that's it. That is the whole

682
00:15:36,667 --> 00:15:39,600
得到明文 好 就这样

683
00:15:39,600 --> 00:15:42,333
encryption and decryption algorithm. In a picture,

684
00:15:39,600 --> 00:15:42,333
这就是整个加密算法和解密算法 如果图形化

685
00:15:42,333 --> 00:15:45,493
the way the ciphertext would look, is also

686
00:15:42,333 --> 00:15:45,493
密文看起来是这样的 和我们

687
00:15:45,493 --> 00:15:47,667
as kind of what we saw in the last lecture. Basically,

688
00:15:45,493 --> 00:15:47,667
上一讲看到的类似 基本上

689
00:15:47,667 --> 00:15:50,323
there would be a short header that contains u.

690
00:15:47,667 --> 00:15:50,323
这里会有一个短的头文件包含u

691
00:15:50,323 --> 00:15:53,467
Which as you recall, is g to the b. And, then the rest of the

692
00:15:50,323 --> 00:15:53,467
想一下，就是g的b次方 剩下的

693
00:15:53,467 --> 00:15:56,800
ciphertext would be the encryption of the message

694
00:15:53,467 --> 00:15:56,800
这部分密文就是对所传送消息的加密

695
00:15:56,800 --> 00:16:01,441
that is being sent, under the symmetric key k.

696
00:15:56,800 --> 00:16:01,441
用密钥k的加密

697
00:16:01,441 --> 00:16:04,000
And, then to decrypt, Alice would use this header

698
00:16:01,441 --> 00:16:04,000
接着 对解密 Alice会用这个头文件

699
00:16:04,000 --> 00:16:06,533
to derive the Diffie-Hellman secret from which she

700
00:16:04,000 --> 00:16:06,533
导出DH秘密信息 通过它，她可以

701
00:16:06,533 --> 00:16:09,735
will derive k and then decrypts the body, to get the

702
00:16:06,533 --> 00:16:09,735
导出k 然后对这个部分进行解密 以此

703
00:16:09,735 --> 00:16:12,336
original plaintext. By the way, I should note that

704
00:16:09,735 --> 00:16:12,336
得到原始的明文 通过这种方法 我要说明一下

705
00:16:12,336 --> 00:16:14,667
the way I describe this system here, is actually not

706
00:16:12,336 --> 00:16:14,667
我用来描述这个系统的方法实际上

707
00:16:14,667 --> 00:16:17,544
how ElGamal described it originally, this is

708
00:16:14,667 --> 00:16:17,544
并不是ElGamal最初用的方法 这是

709
00:16:17,544 --> 00:16:19,775
in some sense a modern view about the ElGamal

710
00:16:17,544 --> 00:16:19,775
一种现代视觉的解释ELGaml加密算法的

711
00:16:19,775 --> 00:16:21,809
encryption, but it is pretty much equivalent to how

712
00:16:19,775 --> 00:16:21,809
的方法 但是和ELGamal的观点等同

713
00:16:21,809 --> 00:16:25,600
ElGamal viewed it. So, now let's look at the

714
00:16:21,809 --> 00:16:25,600
那么 现在 让我们看一下

715
00:16:25,600 --> 00:16:27,379
performance of ElGamal. So, here what I wrote

716
00:16:25,600 --> 00:16:27,379
ElGamal的效率 这里我写的是

717
00:16:27,379 --> 00:16:29,800
is the, kind of the time intensive steps of  ElGamal

718
00:16:27,379 --> 00:16:29,800
ElGamal加密算法的核心步骤

719
00:16:29,800 --> 00:16:32,400
encryption. Namely, during encryption, there are

720
00:16:29,800 --> 00:16:32,400
即，加密中

721
00:16:32,400 --> 00:16:35,133
these two exponentiations in the group G.

722
00:16:32,400 --> 00:16:35,133
有两个群G上的指数运算

723
00:16:35,133 --> 00:16:37,067
Exponentiation, remember is a cubic time algorithm

724
00:16:35,133 --> 00:16:37,067
指数运算， 我们知道是立方时间的算法

725
00:16:37,067 --> 00:16:39,867
using the repeated squaring algorithm. And, as a

726
00:16:37,067 --> 00:16:39,867
如果使用重复平方算法的话

727
00:16:39,867 --> 00:16:43,467
result, it is fairly time intensive. When I say, time

728
00:16:39,867 --> 00:16:43,467
所以 很耗时间 当我说

729
00:16:43,467 --> 00:16:45,819
intensive, I mean, that on a modern processor it would

730
00:16:43,467 --> 00:16:45,819
耗时，我的意思是说 用现代的处理器

731
00:16:45,819 --> 00:16:47,200
take a few milliseconds to compute these

732
00:16:45,819 --> 00:16:47,200
它会花几个毫秒的时间计算

733
00:16:47,200 --> 00:16:49,667
exponentiations and during decryption, basically,

734
00:16:47,200 --> 00:16:49,667
这些指数运算 解密过程 基本上

735
00:16:49,667 --> 00:16:52,353
the decryptor computes one exponentiation,

736
00:16:49,667 --> 00:16:52,353
解密者只需要做一个指数运算

737
00:16:52,353 --> 00:16:54,272
namely, u to the a. This is the bottleneck during

738
00:16:52,353 --> 00:16:54,272
即 u的a次方 这是解密过程的瓶颈

739
00:16:54,272 --> 00:16:57,667
decryption. Ok, so you would think that encryption

740
00:16:54,272 --> 00:16:57,667
好 你会认为加密过程

741
00:16:57,667 --> 00:17:00,067
actually is, takes twice as long as decryption, because

742
00:16:57,667 --> 00:17:00,067
实际上 是解密时间的两倍 因为

743
00:17:00,067 --> 00:17:02,400
encryption requires two exponentiations, while

744
00:17:00,067 --> 00:17:02,400
加密需要两个指数运算 而

745
00:17:02,400 --> 00:17:05,333
decryption requires only one. It turns out, that

746
00:17:02,400 --> 00:17:05,333
解密只需要一个 但是 我们发现

747
00:17:05,333 --> 00:17:08,133
is not entirely accurate because, you notice that the exponentiation

748
00:17:05,333 --> 00:17:08,133
这并不一定精确 因为 你会注意到

749
00:17:08,133 --> 00:17:11,533
during decryption is done to a variable basis.

750
00:17:08,133 --> 00:17:11,533
解密过程的指数运算是对变化的底数

751
00:17:11,533 --> 00:17:14,667
Namely, u changes every time. Whereas during

752
00:17:11,533 --> 00:17:14,667
即，u每次都变 而在

753
00:17:14,667 --> 00:17:18,267
encryption, the basis is fixed: g and h are derived

754
00:17:14,667 --> 00:17:18,267
加密过程中 底数不变 g和h是从

755
00:17:18,267 --> 00:17:21,067
from the public key and are fixed forever.

756
00:17:18,267 --> 00:17:21,067
公钥导出来的，永远固定

757
00:17:21,067 --> 00:17:23,000
So, in fact, in turns out that if you want to do

758
00:17:21,067 --> 00:17:23,000
所以 实际上 如果你要

759
00:17:23,000 --> 00:17:25,667
exponentiation to a fixed basis, you can do a lot of

760
00:17:23,000 --> 00:17:25,667
对一个固定的底数做指数运算

761
00:17:25,667 --> 00:17:28,600
precomputation. In particular, you can do all the

762
00:17:25,667 --> 00:17:28,600
你可以进行大量的雨季算 尤其，你可以

763
00:17:28,600 --> 00:17:32,067
squaring steps in the repeated squaring algorithm

764
00:17:28,600 --> 00:17:32,067
利用重复平方算法，先离线做所有的平方运算

765
00:17:32,067 --> 00:17:34,534
offline. So, here what you would do, you would

766
00:17:32,067 --> 00:17:34,534
那么你现在要做的就是

767
00:17:34,534 --> 00:17:36,733
compute all powers of 2 of g. So, you would

768
00:17:34,534 --> 00:17:36,733
算所有g的2的次幂次方 也就是说你先算

769
00:17:36,733 --> 00:17:39,267
compute g, g squared, g to the fourth, g to the

770
00:17:36,733 --> 00:17:39,267
g， g的平方，g的4次方

771
00:17:39,267 --> 00:17:41,872
eighth, go to the sixteenth, g to the thirty two, and so

772
00:17:39,267 --> 00:17:41,872
g的8次方 g的16次方 g的32次方

773
00:17:41,872 --> 00:17:44,565
on and so forth. These are all the squaring steps of

774
00:17:41,872 --> 00:17:44,565
以此类推 这是你需要做的所有的平方步骤

775
00:17:44,565 --> 00:17:47,333
the repeated squaring algorithm you would do offline.

776
00:17:44,565 --> 00:17:47,333
当你用重复平法算法离线时

777
00:17:47,333 --> 00:17:49,482
The same thing for h. And, then when it comes time to

778
00:17:47,333 --> 00:17:49,482
对h是一样的 那么当你需要做

779
00:17:49,482 --> 00:17:52,600
actually do the real exponentiation all you need to do is just do the

780
00:17:49,482 --> 00:17:52,600
实际的真实的指数运算时你需要做的就是

781
00:17:52,600 --> 00:17:56,733
multiplications, to accumulate these powers of 2 into the

782
00:17:52,600 --> 00:17:56,733
相乘 令这些个2的幂次组成

783
00:17:56,733 --> 00:17:58,533
exponent b, that you're trying to compute.

784
00:17:56,733 --> 00:17:58,533
指数b 这就是你想要算的

785
00:17:58,533 --> 00:18:00,267
So, if you think about it, this can actually speed up

786
00:17:58,533 --> 00:18:00,267
所以，如果你好好想一下，这个就能加速

787
00:18:00,267 --> 00:18:03,133
exponentiation by a factor of 3. In fact, it would

788
00:18:00,267 --> 00:18:03,133
以指数运算，3倍加速，实际上

789
00:18:03,133 --> 00:18:05,533
speed up it even more if you allow me to store even

790
00:18:03,133 --> 00:18:05,533
如果你允许我存储更大的表那么速度会更快

791
00:18:05,533 --> 00:18:09,133
larger tables. This is called a windowed exponentiation.

792
00:18:05,533 --> 00:18:09,133
这个称为窗口法指数运算

793
00:18:09,133 --> 00:18:12,133
But, regardless, if you allow the encryptor to

794
00:18:09,133 --> 00:18:12,133
但是 无论如何 如果你允许加密者

795
00:18:12,133 --> 00:18:14,937
store large tables that are derived from the public

796
00:18:12,133 --> 00:18:14,937
存储多大的表格 从公钥导出来的表格

797
00:18:14,937 --> 00:18:17,400
key, then in fact encryption is not going to be

798
00:18:14,937 --> 00:18:17,400
实际上加密不会比

799
00:18:17,400 --> 00:18:19,267
slower than decryption. In fact, encryption will be

800
00:18:17,400 --> 00:18:19,267
解密慢，实际上 加密会比解密快

801
00:18:19,267 --> 00:18:22,867
faster than decryption. But, again, this requires that

802
00:18:19,267 --> 00:18:22,867
但是这个需要

803
00:18:22,867 --> 00:18:25,467
the encryptor to precompute these large tables

804
00:18:22,867 --> 00:18:25,467
解密者预计算这些很大的表格

805
00:18:25,467 --> 00:18:28,126
and store them around. So, if all the encryptor is

806
00:18:25,467 --> 00:18:28,126
并存储 所以 如果所有的解密者都这么

807
00:18:28,126 --> 00:18:30,600
doing, is just constantly encrypting to a single

808
00:18:28,126 --> 00:18:30,600
做 就是持续地加密给一个固定的

809
00:18:30,600 --> 00:18:34,400
recipient, that can be done actually fairly fast using these

810
00:18:30,600 --> 00:18:34,400
接受者 可以进行地相当快 使用这些

811
00:18:34,400 --> 00:18:37,067
precomputed tables. If the encryptor, for every

812
00:18:34,400 --> 00:18:37,067
预计算表 如果加密者 对每一个

813
00:18:37,067 --> 00:18:39,800
message is encrypting to a different recipient, for

814
00:18:37,067 --> 00:18:39,800
消息 是给不同的接受者 例如

815
00:18:39,800 --> 00:18:41,933
example, if every time you send an email, you send

816
00:18:39,800 --> 00:18:41,933
如果你每发一封邮件

817
00:18:41,933 --> 00:18:44,612
an email to a different recipient, then, in fact, the

818
00:18:41,933 --> 00:18:44,612
你发给不同的接受者 那么 实际上

819
00:18:44,612 --> 00:18:47,671
encryption will be twice as slow as decryption.

820
00:18:44,612 --> 00:18:47,671
会比解密慢1倍

821
00:18:48,533 --> 00:18:51,200
So, this is a good trick to keep in mind. In fact, most

822
00:18:48,533 --> 00:18:51,200
所以 这是一个应该记住的不错的技巧。实际上

823
00:18:51,200 --> 00:18:54,467
cryptolibraries don't do this. So, if you see that you

824
00:18:51,200 --> 00:18:54,467
大部分密码学库都不这么做 所以 如果你发现

825
00:18:54,467 --> 00:18:57,000
are always encrypting to the same public key and

826
00:18:54,467 --> 00:18:57,000
你总是用同样公钥加密并且

827
00:18:57,000 --> 00:18:59,333
for some reason your encryption process takes a

828
00:18:57,000 --> 00:18:59,333
因为某些原因你的加密过程很耗

829
00:18:59,333 --> 00:19:01,400
lot of time, it's a bottleneck for you, keep in mind

830
00:18:59,333 --> 00:19:01,400
时间 这就是你的瓶颈 记住你

831
00:19:01,400 --> 00:19:04,021
that you can actually really speed things up

832
00:19:01,400 --> 00:19:04,021
可以通过预计算的方法

833
00:19:04,021 --> 00:19:05,333
using precomputation.

834
00:19:04,021 --> 00:19:05,333
提速

835
00:19:05,333 --> 00:19:07,200
Of couse, if encryption is a bottleneck for you, you

836
00:19:05,333 --> 00:19:07,200
当然 如果加密是你的瓶颈 你也

837
00:19:07,200 --> 00:19:10,133
might as well be using RSA, where an RSA encryption

838
00:19:07,200 --> 00:19:10,133
可以用RSA RSA的速度是相当快的

839
00:19:10,133 --> 00:19:14,067
is really fast. Ok, so that is the end of our

840
00:19:10,133 --> 00:19:14,067
好 我们对ELGamal加密算法的描述

841
00:19:14,067 --> 00:19:16,133
description of ElGamal encryption. Now, the next

842
00:19:14,067 --> 00:19:16,133
到这里就结束了 现在 下一个问题就是

843
00:19:16,133 --> 00:19:18,800
question of course, is why is the system secure,

844
00:19:16,133 --> 00:19:18,800
当然 为什么这个系统是安全的

845
00:19:18,800 --> 00:19:21,467
in particular, can we prove that it's chosen

846
00:19:18,800 --> 00:19:21,467
尤其 我们能证明它

847
00:19:21,467 --> 00:19:24,133
ciphertext secure and more importantly, under what

848
00:19:21,467 --> 00:19:24,133
是选择密文安全的吗？更重要的是 在什么样的

849
00:19:24,133 --> 00:19:26,267
assumptions can we prove that the system is

850
00:19:24,133 --> 00:19:26,267
假设下我们可以证明这个系统是

851
00:19:26,267 --> 00:19:27,600
chosen ciphertext secure? So, we are going to

852
00:19:26,267 --> 00:19:27,600
选择密文安全的 所以 我们下一节将

853
00:19:27,600 --> 00:19:29,310
discuss that in the next segment.

854
00:19:27,600 --> 00:19:29,310
讨论这个部分

