1
00:00:00,000 --> 00:00:03,662
So now that we understand what block
ciphers are  let's look at a classic

2
00:00:00,000 --> 00:00:03,662
好了 现在我们理解了什么是分组密码 让我们来看一个经典的

3
00:00:03,662 --> 00:00:07,655
example called the Data Encryption
Standard. So  just a quick reminder. Block

4
00:00:03,662 --> 00:00:07,655
例子 数据加密标准DES 先快速提醒一下 分组

5
00:00:07,655 --> 00:00:12,379
ciphers basically map N bits of input to N
bits of output. And we talked about two

6
00:00:07,655 --> 00:00:12,379
密码基本上就是N比特输入映射到N比特输出 我们讨论两个

7
00:00:12,379 --> 00:00:17,045
canonical examples  triple DES and AES. In
this segment  we're gonna talk about DES

8
00:00:12,379 --> 00:00:17,045
规范的例子 三重DES和AES 这一节 我们讨论DES

9
00:00:17,045 --> 00:00:21,480
and we'll talk about triple DES  actually
in the next segment. And then I also

10
00:00:17,045 --> 00:00:21,480
接着在下一节讨论三重DES 我之前

11
00:00:21,480 --> 00:00:26,031
mentioned before that block ciphers are
often built by iteration. In particular

12
00:00:21,480 --> 00:00:26,031
提到分组密码一般是迭代构成的 特别的

13
00:00:26,031 --> 00:00:30,985
we're gonna look at block ciphers that are
built by a form of iteration where a key K

14
00:00:26,031 --> 00:00:30,985
我们将看到 这种分组密码的迭代方式是 一个密钥

15
00:00:30,985 --> 00:00:35,863
is first expanded into a bunch of round
keys. And then a round function is applied

16
00:00:30,985 --> 00:00:35,863
先扩展成一堆密钥 接着 一个轮函数

17
00:00:35,863 --> 00:00:40,660
to the input message  again and again and
again. And essentially  after all these

18
00:00:35,863 --> 00:00:40,660
对输入信息一次次进行作用 基本上 所有的轮函数

19
00:00:40,660 --> 00:00:45,156
round functions are applied  we obtain the
resulting cipher text  okay? And again

20
00:00:40,660 --> 00:00:45,156
作用后 我们就得到了密文 对吧？回过来

21
00:00:45,156 --> 00:00:49,253
what we're gonna look at  how DES  the
data encryption standard  uses this

22
00:00:45,156 --> 00:00:49,253
我们将要看看 DES 数据加密标准 如何使用这种

23
00:00:49,253 --> 00:00:53,577
format. I just want to clear that  in
fact  to specify a block cipher of this

24
00:00:49,253 --> 00:00:53,577
形式 我想澄清一点 实际上 想搞清楚这种类型的分组密码

25
00:00:53,577 --> 00:00:57,788
type  one needs to specify the key
expansion mechanism  and one needs to

26
00:00:53,577 --> 00:00:57,788
一是要搞清楚密钥扩展机制 一是要

27
00:00:57,788 --> 00:01:02,113
specify the round function. In this segment
I'm gonna focus on the round

28
00:00:57,788 --> 00:01:02,113
搞清楚轮函数 本节这里 我将集中在

29
00:01:02,113 --> 00:01:06,551
function  and I'm not going to talk too much
about key expansion. But I just wanted to

30
00:01:02,113 --> 00:01:06,551
轮函数 不过多地讨论密钥扩展 但是我要提一下

31
00:01:06,551 --> 00:01:10,990
mention that  in fact  key expansion is
also a big part of describing how block

32
00:01:06,551 --> 00:01:10,990
实际上 密钥扩展也是分组密码工作很重要的一个部分

33
00:01:10,990 --> 00:01:15,892
cipher works. Okay  so let's talk about
the history of DES. Essentially  in the

34
00:01:10,990 --> 00:01:15,892
好 我们来看看DES的历史 基本上 在20世纪

35
00:01:15,892 --> 00:01:20,715
early 1970s  IBM realized that their
customers are demanding some special means of

36
00:01:15,892 --> 00:01:20,715
七十年代早期 IBM意识到他们的顾客要求某种形式的

37
00:01:20,715 --> 00:01:25,869
encryption. So they formed a Cryptography
team and the leader of that group  was

38
00:01:20,715 --> 00:01:25,869
加密 所以他们组建了一个密码学团队 这团队的头儿 是

39
00:01:25,869 --> 00:01:30,492
Horst Feistel  who  in the early 70s
designed a cipher called Lucifer.

40
00:01:25,869 --> 00:01:30,492
Horst Feistel 他在70年代早期设计了一种密码叫Lucifer密码

41
00:01:30,492 --> 00:01:35,560
Now actually it's interesting that Lucifer had a
number of variations but in fact one

42
00:01:30,492 --> 00:01:35,560
事实上现在 有趣的是Lucifer密码有很多种变形 但是实际上

43
00:01:35,560 --> 00:01:40,559
of the later variations had a key length that
was 128 bits and as well as a block length.

44
00:01:35,560 --> 00:01:40,559
后期的一种变形 令密钥长度为128比特 分组长度也是

45
00:01:40,559 --> 00:01:45,682
Okay  in 1973 the governor
realized that it's buying many commercial

46
00:01:40,559 --> 00:01:45,682
好 1973年的时候官方意识到 购买了大量商业

47
00:01:45,682 --> 00:01:50,867
off-the-shelf computers and so it wanted
its suppliers to actually have a good grip

48
00:01:45,682 --> 00:01:50,867
现货供应的计算机 需要供货商提供一种好的

49
00:01:50,867 --> 00:01:55,434
to algorithm that they could use in
products sold to the government. So in

50
00:01:50,867 --> 00:01:55,434
算法能使得他们可以用卖给政府的商品 所以

51
00:01:55,434 --> 00:02:00,157
1973 the National Bureau of Standards as
it was called at the time put out a

52
00:01:55,434 --> 00:02:00,157
1973年 当时的国家标准局 提出一项征集令

53
00:02:00,157 --> 00:02:04,503
request for proposals for a block cipher
that is going to become a federal

54
00:02:00,157 --> 00:02:04,503
征集一种分组密码作为联邦

55
00:02:04,503 --> 00:02:09,026
standard. And in fact IBM submitted a
variant of Lucifer. That variant actually

56
00:02:04,503 --> 00:02:09,026
标准 实际上 IBM提交了一个Lucifer密码的变种

57
00:02:09,026 --> 00:02:13,901
went through some modification during the
standardization process and then finally

58
00:02:09,026 --> 00:02:13,901
这个变种在标准化的过程中进行了一些修正 最终

59
00:02:13,901 --> 00:02:18,482
in 1976  the national bureau standard
adopted DES as a federal standard. And  in

60
00:02:13,901 --> 00:02:18,482
在1976年 国家标准局接受DES作为联邦标准 而且 实际上

61
00:02:18,482 --> 00:02:23,122
fact  for DES it's interesting that the
key length was far reduced from Lucifer.

62
00:02:18,482 --> 00:02:23,122
对DES来说 有趣的是它的密钥长度比Lucifer密码短得多

63
00:02:23,122 --> 00:02:27,602
It's only 56 bits. And the block length
was also reduced to 64 bits. And in

64
00:02:23,122 --> 00:02:27,602
只有56比特 分组长度也减少到64比特 事实

65
00:02:27,602 --> 00:02:31,838
fact  these decisions  especially the
decision to reduce the key length  is

66
00:02:27,602 --> 00:02:31,838
这些决定 尤其是缩短密钥长度的决定

67
00:02:31,838 --> 00:02:36,653
going to be a key length limit of DES and
was a source of many complaints over the whole

68
00:02:31,838 --> 00:02:36,653
成为DES密钥长度的一个限制 关于这个在整个DES的使用过程中

69
00:02:36,653 --> 00:02:41,062
process of using. In particular  already
back in 1997 DES was broken by exhaustive search

70
00:02:36,653 --> 00:02:41,062
不断遭人诟病 尤其 在1997年 DES遭受穷举搜索攻击

71
00:02:41,062 --> 00:02:45,994
meaning that a machine was able to search
through all two to the 56 possible keys to

72
00:02:41,062 --> 00:02:45,994
意味着一台机器可以搜素所有的2的56次方个密钥

73
00:02:45,994 --> 00:02:50,867
recover a particular challenge key. And in
fact we're going to talk about exhaustive

74
00:02:45,994 --> 00:02:50,867
从而恢复出特定挑战密钥 我们也会在后面讨论

75
00:02:50,867 --> 00:02:54,683
search quite a bit. It's quite an
interesting question  and there are

76
00:02:50,867 --> 00:02:54,683
一下穷举搜索攻击 那是个非常有意思的问题 但是

77
00:02:54,683 --> 00:02:59,335
various ways to defend against exhaustive
search. And basically the experiment in 1997

78
00:02:54,683 --> 00:02:59,335
抵抗穷举搜索攻击的方法有很多 基本上 1997年的这次实验

79
00:02:59,335 --> 00:03:03,655
kinda spelled the doom of DES. It meant
that DES itself  is no longer secure.

80
00:02:59,335 --> 00:03:03,655
注定了DES的命数 也就是说 DES本身不再安全

81
00:03:03,655 --> 00:03:08,251
As a result  the National Institute of
Standards  as it became known  issued a

82
00:03:03,655 --> 00:03:08,251
因此 现在的国家标准研究所 发布了新的

83
00:03:08,251 --> 00:03:12,755
request for proposals. For our next
generation's block cipher standard and in

84
00:03:08,251 --> 00:03:12,755
项目征集 我们下一代的分组密码标准

85
00:03:12,755 --> 00:03:17,427
2000 it standardized on a cipher called Rijndael.
Which became the advanced encryption

86
00:03:12,755 --> 00:03:17,427
在2000年确定为Rijindael密码 它最终成为高级加密

87
00:03:17,427 --> 00:03:21,903
standard  AES. And we'll talk about AES
later on. But in this segment  I wanna

88
00:03:17,427 --> 00:03:21,903
标准 AES 后面我们会讨论AES 但是在这一节 我想

89
00:03:21,903 --> 00:03:26,199
describe how DES works. Now  DES is a
cipher  it's an amazingly successful

90
00:03:21,903 --> 00:03:26,199
描述一下DES是怎么工作的 现在 DES是一种有着惊人成就的

91
00:03:26,199 --> 00:03:30,496
cipher. It's been used in the banking
industry. In fact  there's a classic

92
00:03:26,199 --> 00:03:30,496
密码 在银行业也广为采用 实际上 有一种经典的

93
00:03:30,496 --> 00:03:34,613
network called the Electronic
Clearinghouse  which banks use to clear

94
00:03:30,496 --> 00:03:34,613
网络 称为电子清算所 借助这个银行互相之间

95
00:03:34,613 --> 00:03:39,447
checks with one another. And DES is used
for integrity in those transactions. It's

96
00:03:34,613 --> 00:03:39,447
清算支票 DES被用来保证这些交易的完整性

97
00:03:39,447 --> 00:03:43,922
also used in commerce. In fact  it was
very popular up to date  as the

98
00:03:39,447 --> 00:03:43,922
商业上也用这个 实际上 截止最近 它还非常流行 在网络

99
00:03:43,922 --> 00:03:48,699
main encryption mechanism for the web. Of
course  now  that's been replaced by AES

100
00:03:43,922 --> 00:03:48,699
上还是主要的加密机制 当然 现在 已经逐渐被AES

101
00:03:48,699 --> 00:03:52,977
and other ciphers. Overall  it's a
very successful cipher in terms of

102
00:03:48,699 --> 00:03:52,977
和其它密码代替 总的来说 在应用上DES是一个非常成功的

103
00:03:52,977 --> 00:03:57,425
deployment. DES also has a very rich
history of attacks  which we'll talk about

104
00:03:52,977 --> 00:03:57,425
密码 对DES的攻击也是由来已久 我们将在下一节讨论

105
00:03:57,425 --> 00:04:01,931
at next segment. Okay  so now  let's
talking about the construction of DES. So

106
00:03:57,425 --> 00:04:01,931
好 现在 让我们看看DES的结构

107
00:04:01,931 --> 00:04:06,608
the core idea behind DES is what called
a Feistel network  named in Horst Feistel.

108
00:04:01,931 --> 00:04:06,608
DES的核心理念是Feistel网络 得名自Horst Feistel

109
00:04:06,608 --> 00:04:11,087
And basically  it's a very clever idea for
building the block cipher out of arbitrary

110
00:04:06,608 --> 00:04:11,087
基本上 Feistel网络是一个非常聪明的方法 利用任意f1到fd的函数

111
00:04:11,087 --> 00:04:15,485
functions  F1 to FD. Okay now imagine we
have these functions F1 to FD

112
00:04:11,087 --> 00:04:15,485
构造分组密码 好 现在想象我们有这些函数f1到fd

113
00:04:15,485 --> 00:04:18,765
that happens to match n bits to n bits.
Now these are arbitrary functions

114
00:04:15,485 --> 00:04:18,765
从n比特映射到n比特 这些是任意函数

115
00:04:18,765 --> 00:04:22,425
they don't have to be invertible or
anything. What we gonna do

116
00:04:18,765 --> 00:04:22,425
不需要不可逆或者其它条件 我们现在想做的是

117
00:04:22,425 --> 00:04:26,956
is building aninvertible function
out of those D functions by

118
00:04:22,425 --> 00:04:26,956
用d个函数构造一个可逆函数 通过构造

119
00:04:26,956 --> 00:04:31,484
building a new function we'll call capital
F that maps 2n bits to 2n bits.

120
00:04:26,956 --> 00:04:31,484
一个新的函数 用大写F来表示 将2n比特映射到2n比特

121
00:04:31,484 --> 00:04:35,593
And the construction is described right
here. So here we have our inputs. You

122
00:04:31,484 --> 00:04:35,593
这里描述了这个构造 所以 这里我们有输入 你会注意到

123
00:04:35,593 --> 00:04:40,299
notice  there are two blocks of n bits.
In other words  the input is actually

124
00:04:35,593 --> 00:04:40,299
这有两组n比特数据 换句话说 输入实际上就是

125
00:04:40,299 --> 00:04:44,792
2n bits. The R and L stand for right and
left. Typically  people describe a

126
00:04:40,299 --> 00:04:44,792
2n比特 R和L分别代表右边和左边 通常 人们描述

127
00:04:44,792 --> 00:04:49,205
Feistel network from top to bottom. In
that case  these n bits really would be

128
00:04:44,792 --> 00:04:49,205
Feistel网络都是从上到下 那样 这n比特分别为左边和右边

129
00:04:49,205 --> 00:04:52,214
right and left. But here it is more
convenient for me to describe it

130
00:04:49,205 --> 00:04:52,214
但是这里为了方便我描述 我横着来

131
00:04:52,214 --> 00:04:56,300
horizontally. So if we follow the R
inputs. You realize it basically gets

132
00:04:52,214 --> 00:04:56,300
现在我们看看R这边的输入 你看它就是

133
00:04:56,300 --> 00:05:01,555
copied into the L output  without any
change at all. Okay? However  the L

134
00:04:56,300 --> 00:05:01,555
L这边的输出 没有任何变化 对吧？但是L

135
00:05:01,555 --> 00:05:07,260
inputs  is changed somewhat. What
happens is  the R inputs is fit into

136
00:05:01,555 --> 00:05:07,260
这边的输入 发生变化了 变化就是 R这边的

137
00:05:07,260 --> 00:05:12,888
the function F1 and the result is then
XORed with L0 and that becomes the new R1

138
00:05:07,260 --> 00:05:12,888
输入经过一个函数变化f1的结果和L0进行异或 结果是新的R1

139
00:05:12,888 --> 00:05:17,711
input. Okay  so this is called one round
of a Feistel network  and is done using

140
00:05:12,888 --> 00:05:17,711
输入 好 这个就是Feistel网络的一轮

141
00:05:17,711 --> 00:05:22,584
the function F1. Now we do this again with
another round of the Feistel network

142
00:05:17,711 --> 00:05:22,584
这里用到了一个f1函数 现在我们再看下一轮Feistel网络

143
00:05:22,584 --> 00:05:26,122
with the function F2  and we do it again
and again and again  utill we get to the

144
00:05:22,584 --> 00:05:26,122
这里用到了f2 然后我们一遍遍地这样做 直到我们

145
00:05:26,122 --> 00:05:31,969
last round  and we do it again with the
function FD. And finally  the output is

146
00:05:26,122 --> 00:05:31,969
到最后一轮 用函数fd 最后输出

147
00:05:31,969 --> 00:05:37,542
R<u>d L<u>d. Okay. So  if you like  we can write
this in symbols. That basically  L<u>i is</u></u></u>

148
00:05:31,969 --> 00:05:37,542
是Rd和Ld.好 如你所愿 我们用符号把它写出来

149
00:05:37,542 --> 00:05:43,003
simply equal to R<u>i-1. And R<u>i
let's see  that's the more complicated</u></u>

150
00:05:37,542 --> 00:05:43,003
Li=Ri-1 Ri 要更复杂一些 我们看看

151
00:05:43,003 --> 00:05:50,451
one. R<u>i is equal  well  let's just follow
the lines here. R<u>i is just equal to F<u>i</u></u></u>

152
00:05:43,003 --> 00:05:50,451
就跟着这线条这里 Ri=Fi（Ri-1）异或Li-1（这里应该是bug不能是Li）

153
00:05:50,451 --> 00:05:58,968
applied to  R<u>i-1 XOR L<u>i. Okay?
So this  and this is basically  i goes</u></u>

154
00:05:50,451 --> 00:05:58,968
对吧？所以这个我基本上就是从

155
00:05:58,968 --> 00:06:06,618
from  1 to d. So this is the equation
that defines a Feistel network  mapping a

156
00:05:58,968 --> 00:06:06,618
1走到d 所以这就是定义Feistel网络的方程 把2n

157
00:06:06,618 --> 00:06:09,673
2n bit inputs to 2n bit outputs. So
here we have the  again  I just copied the

158
00:06:06,618 --> 00:06:09,673
比特的输入映射到2n比特的输出 所以这边我们还有 就是把

159
00:06:09,673 --> 00:06:14,831
picture of the Feistel network. And the
amazing claim is that  in fact  it doesn't

160
00:06:09,673 --> 00:06:14,831
Feistel网络的图复制一下 这里比较奇特的是 实际上

161
00:06:14,831 --> 00:06:19,541
matter what functions you give me. For
any functions  F1 to FD that you give me

162
00:06:14,831 --> 00:06:19,541
不管你给我什么函数 对于任何函数 f1到fd

163
00:06:19,541 --> 00:06:24,602
the resulting Feistel network function is
in fact  invertible. And the way we're

164
00:06:19,541 --> 00:06:24,602
Feistel网络函数 实际上是可逆的 我们证明

165
00:06:24,602 --> 00:06:27,635
going to prove that is basically we're
going to construct an inverse  because not

166
00:06:24,602 --> 00:06:27,635
这一点的方法 基本上就是我们要构造一个逆 因为不仅它可逆

167
00:06:27,635 --> 00:06:31,235
only is it invertible  it's efficiently
invertible. So let's see. Look at

168
00:06:27,635 --> 00:06:31,235
而且它的逆很容易计算 所以我们看一下 我们看

169
00:06:31,235 --> 00:06:36,628
one round of a Feistel network  so
here  this is the inputs  R<u>i L<u>i  and this</u></u>

170
00:06:31,235 --> 00:06:36,628
Feistel网络的一轮 这里 这个是输入 Ri和Li 这里是输出

171
00:06:36,628 --> 00:06:41,618
is the output R<u>i+1  L<u>i+1. And now what I'm
going to ask you is to invert this.</u></u>

172
00:06:36,628 --> 00:06:41,618
Ri+1和Li+1 现在我想让你求逆

173
00:06:41,618 --> 00:06:48,781
So let's see. Suppose now the input that
we're given is R<u>i+1  L<u>i+1 and we want to</u></u>

174
00:06:41,618 --> 00:06:48,781
所以 我们看 假设现在给的输入是Ri+1和Li+1 我们想计算

175
00:06:48,781 --> 00:06:54,883
compute R<u>i L<u>i. So we want to compute the
round in the reverse direction. So let's</u></u>

176
00:06:48,781 --> 00:06:54,883
Ri和Li 也就是我们想反方向计算这一轮 看一下我们咋做

177
00:06:54,883 --> 00:07:00,024
see if we can do it. Well  let's look at
R<u>i. So  R<u>i is very easy. Basically  R<u>i is</u></u></u>

178
00:06:54,883 --> 00:07:00,024
Ri Ri很简单 其实

179
00:07:00,024 --> 00:07:07,240
just equal to L<u>i+1. So L<u>i+1 just becomes
R<u>i. But now  let me ask you  to write the</u></u></u>

180
00:07:00,024 --> 00:07:07,240
Ri=Li+1 所以 Li+1变成Ri 现在 我问你了 如何用

181
00:07:07,245 --> 00:07:12,157
expression for L<u>i in terms of R<u>i+1  and L<u>i+1.</u></u></u>

182
00:07:07,245 --> 00:07:12,157
Ri+1和Li+1写出Li的表达式

183
00:07:13,049 --> 00:07:17,991
So I hope everybody sees that  basically  L<u>i+1
is fed into the function F<u>i+1.</u></u>

184
00:07:13,049 --> 00:07:17,991
我希望每个人都知道 Li+1输入函数fi+1的结果和

185
00:07:17,991 --> 00:07:24,810
The result is XORed with R<u>i+1
and that gives the L<u>i input.</u></u>

186
00:07:17,991 --> 00:07:24,810
Ri+1进行异或 就得到Li

187
00:07:24,810 --> 00:07:28,181
So this the inverse of one round
of a Feistel network.

188
00:07:24,810 --> 00:07:28,181
所以 这是Feistel网络一轮的逆

189
00:07:28,181 --> 00:07:32,865
And if we draw this as a diagram  let's just
write the picture for the inverse.

190
00:07:28,181 --> 00:07:32,865
如果我们画个图 让我们看看逆的图

191
00:07:32,865 --> 00:07:38,810
So here you notice the input is R<u>i+1  L<u>i+1
and the output is R<u>i L<u>i. Right?</u></u></u></u>

192
00:07:32,865 --> 00:07:38,810
这里你看到输入是Ri+1和Li+1 输出是Ri和Li 对吧？

193
00:07:38,810 --> 00:07:43,278
So we're computing  we're inverting  the
rounds. So you notice that the inverse of

194
00:07:38,810 --> 00:07:43,278
我们这样这一轮就算出来了 求逆了 你应该注意到

195
00:07:43,278 --> 00:07:47,242
a Feistel round looks pretty much the
same as the Feistel round in the

196
00:07:43,278 --> 00:07:47,242
Feistel的一轮的逆和正向的一轮基本一样

197
00:07:47,242 --> 00:07:50,237
forward direction. Literally see  you
know  just for a technical reason  it's

198
00:07:47,242 --> 00:07:50,237
字面上来看 你知道 因为技术原因

199
00:07:50,237 --> 00:07:54,309
kinda the mirror image of one another. But
it's basically  the same construct. And

200
00:07:50,237 --> 00:07:54,309
实际上这互为镜像 但是 它们就是一样的构造

201
00:07:54,309 --> 00:07:59,133
when we put these inverted rounds back
together. We essentially get the inverse

202
00:07:54,309 --> 00:07:59,133
如果我们把每一轮的逆都放到一起 我们就得到了整个

203
00:07:59,133 --> 00:08:03,446
of the entire Feistel network. So you
notice we start off with the round number D

204
00:07:59,133 --> 00:08:03,446
Feistel网络的逆 注意 我们这里从第d轮

205
00:08:03,446 --> 00:08:07,632
with the inverse of round number D
then we do the inverse of round number D-1

206
00:08:03,446 --> 00:08:07,632
开始算d轮的逆 接着做第d-1轮

207
00:08:07,632 --> 00:08:11,458
and so on and so forth until we
get to the inverse of the first round. And

208
00:08:07,632 --> 00:08:11,458
这么一直做下去 直到第一轮

209
00:08:11,458 --> 00:08:18,063
we get our final outputs which is R<u>0  L<u>0
like this is the inputs and we manage to</u></u>

210
00:08:11,458 --> 00:08:18,063
最后我们得到输出是R0和L0 就像这样 已知

211
00:08:18,063 --> 00:08:22,694
invert basically R<u>d  L<u>d and get R<u>0  L<u>0
and the interesting thing is that</u></u></u></u>

212
00:08:18,063 --> 00:08:22,694
Rd和Ld 得到R0和L0 有趣的是

213
00:08:22,694 --> 00:08:25,882
these inversion circuits look
pretty much the same as the encryption

214
00:08:22,694 --> 00:08:25,882
这个逆网络和加密网络

215
00:08:25,882 --> 00:08:31,105
circuits and the only difference is that
the functions are applied in reverse order.

216
00:08:25,882 --> 00:08:31,105
看起来基本是一样的 唯一不同的是这些作用函数的顺序是相反的

217
00:08:31,105 --> 00:08:35,566
Right here we started with F<u>d and ended with
F<u>1. Whereas when we were encrypting  we</u></u>

218
00:08:31,105 --> 00:08:35,566
就是我们这里从fd开始到f1结束 而在加密的时候

219
00:08:35,566 --> 00:08:40,539
started with F<u>1 and ended with F<u>d. So  for
hardware designers  this is very</u></u>

220
00:08:35,566 --> 00:08:40,539
从f1开始到fd结束 所以 对硬件设计师而言 这个很有

221
00:08:40,539 --> 00:08:44,808
attractive  because  basically  if you
wanna save hardware  you realize that your

222
00:08:40,539 --> 00:08:44,808
吸引力 因为 基本上 你可以节省硬件

223
00:08:44,808 --> 00:08:48,536
encryption hardware is identical to your
decryption hardware. So you only have to

224
00:08:44,808 --> 00:08:48,536
你会发现 你得加密硬件和解密硬件一样 所以你只需要实现

225
00:08:48,536 --> 00:08:52,674
implement one algorithm  and you get both
algorithms the same way. The only

226
00:08:48,536 --> 00:08:52,674
一个算法 那这两个算法你就都实现了 唯一的

227
00:08:52,674 --> 00:08:56,899
difference is that the functions are
applied in reverse order. Okay. So this

228
00:08:52,674 --> 00:08:56,899
区别就是这些函数是逆序的 好

229
00:08:56,899 --> 00:09:01,109
Feistel mechanism is a general method
for building invertible functions from

230
00:08:56,899 --> 00:09:01,109
这种Feistel机制作为一种基本方法利用任何函数f1到fd

231
00:09:01,109 --> 00:09:06,224
arbitrary functions F<u>1 to F<u>d and in fact
it's used in many different block ciphers.</u></u>

232
00:09:01,109 --> 00:09:06,224
构造可逆函数 在多种分组密码中广泛使用

233
00:09:06,224 --> 00:09:11,040
Although  interestingly  it's not actually
used in AES. So  there are many other

234
00:09:06,224 --> 00:09:11,040
但是有趣的是在AES中没有用 所以

235
00:09:11,040 --> 00:09:15,297
block ciphers that use a Feistel
network. Or  of course  they differ from

236
00:09:11,040 --> 00:09:15,297
Feistel网络在很多分组密码中都有 当然 因为f1到fd的不同

237
00:09:15,297 --> 00:09:19,838
DES in the functions F<u>1 to F<u>d. But AES
actually uses a completely different type</u></u>

238
00:09:15,297 --> 00:09:19,838
它们和DES不尽相同 但是AES用的是完全不同的一种

239
00:09:19,838 --> 00:09:24,033
of structure that's actually not a
Feistel network. We'll see how AES

240
00:09:19,838 --> 00:09:24,033
结构 不是Feistel网络 我们后面几节课

241
00:09:24,033 --> 00:09:29,043
works in a couple of segments. So now that
we know what Feistel networks are  let

242
00:09:24,033 --> 00:09:29,043
会研究AES是怎么工作的 所以现在我们知道Feistel网络了 我们

243
00:09:29,043 --> 00:09:32,898
me mention an important theorem about the
theory of Feistel networks that shows

244
00:09:29,043 --> 00:09:32,898
看一个重要的关于Feistel网络理论的定理 这个定理

245
00:09:32,898 --> 00:09:37,794
why they're a good idea. This theorem is
due to Luby and Rackoff back in 1985  and it

246
00:09:32,898 --> 00:09:37,794
也证明了它是一个好方法 定理是1985年Luby和Rackoff提出的

247
00:09:37,794 --> 00:09:41,774
says the following. Suppose I have a
function that is a secure pseudorandom

248
00:09:37,794 --> 00:09:41,774
描述如下 假设我有一个函数 伪随机

249
00:09:41,774 --> 00:09:46,804
function  okay. So it's indistinguishable
from random and happens to act on N bits.

250
00:09:41,774 --> 00:09:46,804
函数 它和随机函数不可区分 从n比特输入映射到

251
00:09:46,804 --> 00:09:52,857
So it maps N bits to N bits and uses a
key K. Then  it turns out  that if you use

252
00:09:46,804 --> 00:09:52,857
nbite输出 在密钥k的作用下 这样 结果是如果你

253
00:09:52,857 --> 00:09:57,621
this function in three rounds of a Feistel
network. What you end up with is a secure

254
00:09:52,857 --> 00:09:57,621
用这个函数进行三轮Feistel变化 你将得到一个

255
00:09:57,621 --> 00:10:03,208
pseudo random permutation. In other words
what you end up with is an invertible

256
00:09:57,621 --> 00:10:03,208
安全的伪随机置换 换句话说 你得到了一个可逆的函数

257
00:10:03,208 --> 00:10:07,724
function that is indistinguishable from a
truly random invertible function. And I

258
00:10:03,208 --> 00:10:07,724
这个可逆函数和随机可逆函数不可区分 我

259
00:10:07,724 --> 00:10:11,457
hope you remember that the true definition
of a secure block cipher is that it needs

260
00:10:07,724 --> 00:10:11,457
希望你记得安全分组密码的定义是 需要它是一个

261
00:10:11,457 --> 00:10:16,106
to be a secure pseudo random permutation.
So what this theorem says  is that if you

262
00:10:11,457 --> 00:10:16,106
安全的伪随机置换 所以 这个定理说的是 如果你用

263
00:10:16,106 --> 00:10:20,303
start with a secure pseudo random
function  you end up with a secure block

264
00:10:16,106 --> 00:10:20,303
一个安全的伪随机函数 那么你就能得到一个安全的分组

265
00:10:20,303 --> 00:10:23,824
cipher. Basically  that's what this is.
And let me explain in a little bit more

266
00:10:20,303 --> 00:10:23,824
密码 好 就是这样 让我多解释一下

267
00:10:23,824 --> 00:10:28,939
detail what's actually going on here. So
essentially  the PRF is used in every

268
00:10:23,824 --> 00:10:28,939
这是怎么回事 基本上 PRF在

269
00:10:28,939 --> 00:10:34,808
round of the Feistel network. So  in
other words  here  what's actually

270
00:10:28,939 --> 00:10:34,808
Feistel网络的每一轮都用 所以 换句话说 这里

271
00:10:34,808 --> 00:10:39,731
computed is the PRF using one secret key
K0. Here  what's computed is the PRF

272
00:10:34,808 --> 00:10:39,731
算的就是PRF在密钥K0作用下 这里算的是

273
00:10:39,731 --> 00:10:45,959
using a different secret key  of course
applied to R1. And here we have yet

274
00:10:39,731 --> 00:10:45,959
在密钥K1作用下R1的函数值 这里是另一个密钥K2

275
00:10:45,959 --> 00:10:51,578
another secret key  K1 applied  K2 applied
to R2. And you notice  this is why

276
00:10:45,959 --> 00:10:51,578
作用于R2 这你就会发现 为什么

277
00:10:51,578 --> 00:10:55,371
basically this Feistel construction
uses keys in K cubed. In other words  it

278
00:10:51,578 --> 00:10:55,371
这个Feistel结构的密钥空间是K的三次方 换句话说 它用了

279
00:10:55,371 --> 00:11:01,004
uses three independent keys. So it's very
important that the keys are actually

280
00:10:55,371 --> 00:11:01,004
3个独立的密钥 这里 密钥互相独立 十分重要

281
00:11:01,004 --> 00:11:07,438
independent. So really  we need three
independent keys. And then we end up with

282
00:11:01,004 --> 00:11:07,438
也就是说 我们需要真正独立的三个密钥 这样我们就得到了

283
00:11:07,438 --> 00:11:12,600
a secure pseudorandom permutation. Okay
so that's the theory behind Feistel

284
00:11:07,438 --> 00:11:12,600
一个安全的伪随机置换 好 这就是Feistel网络背后的理论

285
00:11:12,600 --> 00:11:16,051
networks. And now that we understand that
we can actually look at the specifics of DES.

286
00:11:12,600 --> 00:11:16,051
先在 我们明白了这个 我们可以看看具体DES的情况

287
00:11:16,051 --> 00:11:20,256
So DES is basically a sixteen round
Feistel network  okay. So there are

288
00:11:16,051 --> 00:11:20,256
DES实际上是一个16轮的Feistel网络 好 这是函数

289
00:11:20,256 --> 00:11:26,349
functions F1 to F16 that map 32 bits to
32 bits  and as a result  the DES itself

290
00:11:20,256 --> 00:11:26,349
f1到f16将32比特映射32比特 所以 DES

291
00:11:26,349 --> 00:11:33,054
acts on 64 bit blocks  2x32. Now the
sixteen round functions in DES are

292
00:11:26,349 --> 00:11:33,054
是作用在64比特的分组上 就是2*32.现在 DES的16个轮函数

293
00:11:33,054 --> 00:11:37,673
actually all derived from a single
function F. Just used with different keys.

294
00:11:33,054 --> 00:11:37,673
实际上是从一个函数F来的 就是用的不同的密钥

295
00:11:37,673 --> 00:11:44,765
So in fact  these are the different round
keys. So K<u>i is  a round key. And it's</u>

296
00:11:37,673 --> 00:11:44,765
所以 轮密钥不同 ki是一个轮密钥 它是

297
00:11:44,765 --> 00:11:52,585
basically derived from the key K which derived
from the 56 bit DES key K. Okay and I'll

298
00:11:44,765 --> 00:11:52,585
从密钥K得出的 长度为56比特的DES密钥K 好 我马上

299
00:11:52,585 --> 00:11:56,567
describe what this function F is in just a
minute. But basically that  you see that

300
00:11:52,585 --> 00:11:56,567
来说一下这个函数F 但是实际上 你看到使用

301
00:11:56,567 --> 00:12:01,856
by using sixteen different round keys  we
get sixteen different round functions. And

302
00:11:56,567 --> 00:12:01,856
16个不同的轮密钥 我们得到16个不同的轮函数

303
00:12:01,856 --> 00:12:06,460
that gives us the Feistel network. So just
on a high level how the DES works

304
00:12:01,856 --> 00:12:06,460
从而得到Feistel网络 这就是从上层看DES是怎么工作的

305
00:12:06,460 --> 00:12:10,829
basically you have a 64 bit input. The
first thing it does is  this initial

306
00:12:06,460 --> 00:12:10,829
基本上你有一个64比特的输入 首先 这个初始置换

307
00:12:10,829 --> 00:12:15,175
permutation that just permutes the 64 bits
around. Namely it maps bit number one to

308
00:12:10,829 --> 00:12:15,175
仅仅置换一下这64比特的位置 即把第一个比特置换到

309
00:12:15,175 --> 00:12:20,216
bit number six. Bit number two to bit
number seventeen  and so on. This is not

310
00:12:15,175 --> 00:12:20,216
第六个比特 第二个比特置换到第17个比特这样 这不是为了安全

311
00:12:20,216 --> 00:12:24,702
for security reasons  this is just
specified in the standard. Then we go into

312
00:12:20,216 --> 00:12:24,702
就是标准里有这一条（实际上是为了打乱语言统计特性）

313
00:12:24,702 --> 00:12:29,076
the sixteen round Feistel network. That
actually  you now know how it works.

314
00:12:24,702 --> 00:12:29,076
接着 进入到16轮Feistel网络 你知道它是怎么工作的

315
00:12:29,076 --> 00:12:33,810
Basically uses the function F1 to F16  as
specified before. And then  we

316
00:12:29,076 --> 00:12:33,810
就是使用我们前面说过的f1到f16函数 接着

317
00:12:33,810 --> 00:12:38,721
have another permutation  it's called the
final permutation. That's just the inverse

318
00:12:33,810 --> 00:12:38,721
有另外一个置换 称为最终置换 其实就是初始置换

319
00:12:38,721 --> 00:12:42,863
of the initial permutation. Again
it just permutes bits around  this is not

320
00:12:38,721 --> 00:12:42,863
的逆 也是置换位置 对安全性没什么

321
00:12:42,863 --> 00:12:47,728
necessary for security reasons. And then
we finally get  the final outputs. Okay.

322
00:12:42,863 --> 00:12:47,728
贡献 最终我们得到输出 好

323
00:12:47,728 --> 00:12:53,400
Now  as we said  there's a key expansion
step  which I'm not gonna describe. But

324
00:12:47,728 --> 00:12:53,400
现在 像我们前面说的 有一个密钥扩展的步骤 我就不描述了

325
00:12:53,400 --> 00:12:59,546
basically  this 56-bit DES key is expanded
into these rounds keys. Where each round

326
00:12:53,400 --> 00:12:59,546
但是 这56比特的DES密钥扩展出这些轮密钥 轮密钥是

327
00:12:59,546 --> 00:13:05,028
key  is 48 bits. Okay  so we have sixteen
48 bit round keys  and they're basically

328
00:12:59,546 --> 00:13:05,028
48比特的 好 我们有16个48比特的轮密钥

329
00:13:05,028 --> 00:13:10,243
used in the sixteen rounds of DES. And
then when you want to invert the cipher

330
00:13:05,028 --> 00:13:10,243
它们用于DES的16个轮 接下来 你要想一下怎么对这个密码求逆

331
00:13:10,243 --> 00:13:15,458
all you do is you use these  round keys
these sixteen round keys  in reverse

332
00:13:10,243 --> 00:13:15,458
你所要做的就是用这些轮密钥 这16个轮密钥 逆序

333
00:13:15,458 --> 00:13:20,490
order. Okay  so now that we understand the
DES structure  the only thing that's left

334
00:13:15,458 --> 00:13:20,490
好 现在我们明白DES的结构了 剩下唯一的问题就是解释

335
00:13:20,490 --> 00:13:24,809
to do is specify the function  capital F.
So let me explain how this function works.

336
00:13:20,490 --> 00:13:24,809
这个函数 大F 我来解释一下这个函数是怎么工作的

337
00:13:24,809 --> 00:13:30,238
So basically  it takes  as inputs  its  32
bit value  let's call it X. But in

338
00:13:24,809 --> 00:13:30,238
基本上 它有32比特的输入 写作X

339
00:13:30,238 --> 00:13:35,112
reality  you remember  this is R<u>0
R<u>1  R-2  R<u>3  so on and so</u></u></u>

340
00:13:30,238 --> 00:13:35,112
实际上 你得记得 这就是R0R1R3等等

341
00:13:35,112 --> 00:13:40,352
forth. These are 32 bit values. And then
it takes  also  a 48 bit round key. So

342
00:13:35,112 --> 00:13:40,352
这是32比特 它用了一个48比特的轮密钥

343
00:13:40,352 --> 00:13:45,391
here we have our key K<u>i  which happens to
be 48 bits. The first thing it does  is it</u>

344
00:13:40,352 --> 00:13:45,391
所以这里有密钥ki 它是48比特 首先

345
00:13:45,391 --> 00:13:50,039
goes through an expansion box. And this
expansion box basically take thirty two

346
00:13:45,391 --> 00:13:50,039
经过一个扩展盒 这个扩展盒是把32比特映射成

347
00:13:50,039 --> 00:13:57,152
bits  and maps them into 48 bits. Now  all
the expansion box does is just replicates

348
00:13:50,039 --> 00:13:57,152
48比特 现在 扩展盒就是重复其中

349
00:13:57,152 --> 00:14:04,312
some bits  and move other bits around. So
for example  bit #1 of X is replicated

350
00:13:57,152 --> 00:14:04,312
的一些比特 把其它比特移动一下 例如 X的1号比特在

351
00:14:04,312 --> 00:14:11,086
into positions 2 and 48 in the output.
Bit #2 of X is positioned in as bit

352
00:14:04,312 --> 00:14:11,086
位置2和48 X的2号比特被放在

353
00:14:11,086 --> 00:14:15,124
#3 of the output. And so on and so
forth  just by replicating some of the

354
00:14:11,086 --> 00:14:15,124
3号位置作为输出 就这样 重复X的某些比特

355
00:14:15,124 --> 00:14:20,588
bits of X  we expand the input into 48
bits. The next thing we do is we compute

356
00:14:15,124 --> 00:14:20,588
我们把这32比特扩展成48比特 下一步我们把这48比特

357
00:14:20,588 --> 00:14:23,940
an XOR with the round key.
Sometimes people say that cryptographers

358
00:14:20,588 --> 00:14:23,940
和轮密钥异或 有些人说密码学家就是算

359
00:14:23,940 --> 00:14:30,437
only compute XORs. This is an example of
that  where  well  we just do XORs in this

360
00:14:23,940 --> 00:14:30,437
异或 呵呵 这就是个例子 好 我们就在这个做异或

361
00:14:30,437 --> 00:14:35,817
function. And then comes the magic of DES
where  actually  these 48 bits are broken

362
00:14:30,437 --> 00:14:35,817
下面就是DES的神奇之处了 这里 这48比特分成

363
00:14:35,817 --> 00:14:42,756
into eight groups of six bits. Six  seven
eight. And so let me draw  and then what

364
00:14:35,817 --> 00:14:42,756
8组 每组6比特 6 7 8 让我在这儿画一下

365
00:14:42,756 --> 00:14:48,790
happens is  so yes. Each one
of these wires is  six bits. And

366
00:14:42,756 --> 00:14:48,790
好 自然的 这里这些 是6比特 接着

367
00:14:48,790 --> 00:14:53,857
then  they go into what  are called
S boxes. And I'll explain S boxes

368
00:14:48,790 --> 00:14:53,857
他们进入到所谓的S盒 我马上就会讲到

369
00:14:53,857 --> 00:15:01,524
in just a minute. The S boxes are kind of
the smarts of  DES. And then  the S

370
00:14:53,857 --> 00:15:01,524
S盒 S盒实际上是DES的核心 S盒

371
00:15:01,524 --> 00:15:07,380
box is basically a map  six bits to four
bits. So  the outputs of the S boxes are

372
00:15:01,524 --> 00:15:07,380
实际上是一个映射 把6比特映射到4比特 所以S盒输出是

373
00:15:07,380 --> 00:15:12,913
these four bits. They're collected. This
gives up 32 bits  right? Eight groups of

374
00:15:07,380 --> 00:15:12,913
这四个比特 把它们合起来 就给出32比特 对吧？8个

375
00:15:12,913 --> 00:15:17,914
four bits  gives us 32 bits and then
finally this is fed into yet another

376
00:15:12,913 --> 00:15:17,914
4比特 给我们32比特 最终 输入到另一个

377
00:15:17,914 --> 00:15:22,982
permutation which just maps the bits
around. So  for example bit number one

378
00:15:17,914 --> 00:15:22,982
置换中 这个置换就是换一下位置 例如第一个比特

379
00:15:22,982 --> 00:15:27,045
will go to bit number nine  bit number two
will go to bit number fifteen and so on.

380
00:15:22,982 --> 00:15:27,045
跑到第9个的位置 第二个比特跑到第15个的位置 等等

381
00:15:27,045 --> 00:15:34,353
So it just permutes the 32 bits around and
that's the final 32 bit output of this F function.

382
00:15:27,045 --> 00:15:34,353
它仅仅就是置换这32个比特 这是F函数最终的32比特输出

383
00:15:34,353 --> 00:15:39,306
Okay? So by using different
round keys  essentially  we get different

384
00:15:34,353 --> 00:15:39,306
好吧？所以 使用不同的轮密钥 基本上 我们得到不同

385
00:15:39,306 --> 00:15:44,355
round functions  and that's how we form
the sixteen round functions of DES. Now

386
00:15:39,306 --> 00:15:44,355
的轮函数 这样构成DES的16个轮函数

387
00:15:44,355 --> 00:15:49,093
the only thing that  left to specify are
these S boxes. So the S boxes  literally

388
00:15:44,355 --> 00:15:49,093
现在 剩下的唯一问题就是解释这个S盒 S盒 字面上讲

389
00:15:49,093 --> 00:15:54,982
are just functions from six bits to four
bits. They are just implemented as a look

390
00:15:49,093 --> 00:15:54,982
就是一个从6比特到4比特的函数 就像用一个查找

391
00:15:54,982 --> 00:15:59,993
up table. Right? So describing a function
from six bits to four bits basically

392
00:15:54,982 --> 00:15:59,993
表一样 对吧？描述一个从6比特到4比特的函数基本上就是

393
00:15:59,993 --> 00:16:05,134
amounts to writing the output of the
function on all two to the six possible inputs.

394
00:15:59,993 --> 00:16:05,134
写一个输入为2的6次方的函数的输出

395
00:16:05,134 --> 00:16:09,984
Two to the six is 64. So we just
have a table that literally contains 64 values.

396
00:16:05,134 --> 00:16:09,984
2的6次方是64 所以我们需要一个有64个值的表

397
00:16:09,984 --> 00:16:14,504
Where each value is four bits. So
here is an example  this happens to be the

398
00:16:09,984 --> 00:16:14,504
每个值是4比特 举个例子 这个是第五个S盒

399
00:16:14,504 --> 00:16:18,972
fifth S box  and you see that this is a
table that contains 64 values right?

400
00:16:14,504 --> 00:16:18,972
你看 这是一个含64个值的表吧？

401
00:16:18,972 --> 00:16:26,942
It's four by sixteen. So  64 values. For
example  if you wanna look at  the output

402
00:16:18,972 --> 00:16:26,942
4乘以16 所以64个值 例如 你想找输出

403
00:16:26,942 --> 00:16:35,468
that corresponds to 0-1-1-0-1-1. Okay  then
you look at these two bits. This is 01

404
00:16:26,942 --> 00:16:35,468
对应011011的输出 好 你看一下这两个比特 01

405
00:16:35,468 --> 00:16:41,689
and these four bits are 1101  and you see
that the output is 1001. The four bits

406
00:16:35,468 --> 00:16:41,689
这4个比特1101 你看到输出是1001.

407
00:16:41,689 --> 00:16:46,977
output 1001. Okay  so the S boxes are just
implemented as these tables.

408
00:16:41,689 --> 00:16:46,977
输出的四个比特是1001.好 S盒就是用这些个表

409
00:16:46,977 --> 00:16:51,524
Now the question is  how are these S boxes chosen.
How are these tables actually chosen by

410
00:16:46,977 --> 00:16:51,524
现在问题是 这些S盒是怎么选的 设计者是怎么选的

411
00:16:51,524 --> 00:16:56,167
the designers of this. So to give you some
intuitions for that  lets start with a

412
00:16:51,524 --> 00:16:56,167
为了让你更清楚些 我们先给个S盒

413
00:16:56,167 --> 00:17:02,395
very bad choice for S boxes. So imagine
the S boxes were linear. What do I mean by

414
00:16:56,167 --> 00:17:02,395
失败的例子 想象S盒是线性的 什么意思？

415
00:17:02,395 --> 00:17:07,266
that? I mean that imagine that these six
bit inputs literally were just

416
00:17:02,395 --> 00:17:07,266
就是想象这6比特的输入

417
00:17:07,266 --> 00:17:12,678
XORed with one another in different
ways to produce the four bit outputs.

418
00:17:07,266 --> 00:17:12,678
用不同的方式互相异或得到4比特输出

419
00:17:12,678 --> 00:17:17,893
Okay  another way of writing that is that
we can write the S box as a matrix vector product.

420
00:17:12,678 --> 00:17:17,893
好 另一种写法是我们可以把S盒写成一个矩阵向量积

421
00:17:17,893 --> 00:17:23,314
So here you have the matrix Ai.
And the vector  the six bit vector X.

422
00:17:17,893 --> 00:17:23,314
所以这里 你有矩阵Ai 和向量 6比特向量的向量X

423
00:17:23,314 --> 00:17:27,826
And you can see that  if we write this matrix
vector product  basically  we take the

424
00:17:23,314 --> 00:17:27,826
你可以看到 如果写这个矩阵向量积 就是用

425
00:17:27,826 --> 00:17:32,107
inner product of this vector with the
input vector. Remember  these are all bits.

426
00:17:27,826 --> 00:17:32,107
这个向量和输入向量的内积作为输出 记住 这都是比特

427
00:17:32,107 --> 00:17:36,446
So the six bits vector inner
product. Another six bit vector  and we do

428
00:17:32,107 --> 00:17:36,446
所以 6比特的向量内积 另外6比特向量 进行

429
00:17:36,446 --> 00:17:40,670
that modulo two  you realize  basically
what we're computing is X2 XOR X3.

430
00:17:36,446 --> 00:17:40,670
模2加 你看到了 我们计算的就是X2异或X3.

431
00:17:40,670 --> 00:17:44,668
Right? Because only position two and
position three have 1's in it.

432
00:17:40,670 --> 00:17:44,668
对吧 因为只有位置2和位置3有1

433
00:17:44,668 --> 00:17:50,034
And similarly the next  inner product will
produce X1 XOR X4 XOR X5 and so on and

434
00:17:44,668 --> 00:17:50,034
下面 类似的 这个内积是X1异或X4异或X5 下面类似

435
00:17:50,034 --> 00:17:55,096
so forth. Okay. So you can literally see
that if the S boxes are implemented this

436
00:17:50,034 --> 00:17:55,096
好 你可以看到这个S盒是这么操作的

437
00:17:55,096 --> 00:18:00,177
way. Then  all they do  is just apply the
matrix A to the input vector X. Which is

438
00:17:55,096 --> 00:18:00,177
那么 就是对输入向量X进行矩阵A的一个矩阵变换

439
00:18:00,177 --> 00:18:05,456
why we say  that in this case the S boxes
are completely linear. Now  I claimed that

440
00:18:00,177 --> 00:18:05,456
这就是我们说的S盒是完全线性的 现在我要说

441
00:18:05,456 --> 00:18:10,670
in fact that if the S boxes were linear  then DES
would be totally insecure. The reason is

442
00:18:05,456 --> 00:18:10,670
如果S盒是线性的 那么DES就是完全不安全的 原因是

443
00:18:10,670 --> 00:18:15,691
if the S boxes are linear  then all that
DES does is just compute XOR of various

444
00:18:10,670 --> 00:18:15,691
如果S盒是线性的 那么所有DES做的运算就是异或啊 各种置换之流

445
00:18:15,691 --> 00:18:20,127
things and permute and shuffle bits
around. So it's just XORs and bit

446
00:18:15,691 --> 00:18:20,127
所以 DES就是异或和比特

447
00:18:20,127 --> 00:18:24,514
permutations  which means that as a
result  all of DES is just a linear

448
00:18:20,127 --> 00:18:24,514
置换 这意味着 DES就是个

449
00:18:24,514 --> 00:18:30,505
function. In other words  there will be a
Matrix B. Of these dimensions. Basically

450
00:18:24,514 --> 00:18:30,505
线性函数 换句话说 会有一个矩阵B 这么多维的

451
00:18:30,505 --> 00:18:35,584
it's a matrix B that has width 832.
Basically what I will do is I will write

452
00:18:30,505 --> 00:18:35,584
实际上 这个矩阵是832维的 就是64

453
00:18:35,584 --> 00:18:41,065
the 64 bit message plus the sixteen round
keys as one long vector. Alright  so the

454
00:18:35,584 --> 00:18:41,065
比特消息中的64加16轮密钥中的16 所以消息是64比特

455
00:18:41,065 --> 00:18:46,411
message is 64 bits and there are sixteen
round keys. Each one is 48 and that  if

456
00:18:41,065 --> 00:18:46,411
密钥是16.每一个是48 如果你算一下 64+16*48=832

457
00:18:46,411 --> 00:18:51,825
you do the math  it's basically 832. Okay?
So I write these values  the keys and the

458
00:18:46,411 --> 00:18:51,825
就是832.这里我写下来 这些值 密钥和

459
00:18:51,825 --> 00:18:57,439
message  as one long vector and then there
will be this matrix that essentially when

460
00:18:51,825 --> 00:18:57,439
消息 作为一个长向量 这里有这个矩阵 你计算这个矩阵

461
00:18:57,439 --> 00:19:02,143
you compute these matrix vector products.
Essentially you get the different bits of

462
00:18:57,439 --> 00:19:02,143
向量积就行了 这样 你得到密文的不同比特 所以

463
00:19:02,143 --> 00:19:06,941
the ciphertext. So there's 64 of these
rows and as a result  you get 64 bits of

464
00:19:02,143 --> 00:19:06,941
这里有64行 所以 你得到64比特的密文

465
00:19:06,941 --> 00:19:10,954
ciphertext. Okay  so this is what it
means for DES to be linear. So if you

466
00:19:06,941 --> 00:19:10,954
好 这是说DES是线性的 所以 如果你稍微思考一下这个

467
00:19:10,954 --> 00:19:14,693
think a little bit about this  you realize
that the S boxes are the only nonlinear

468
00:19:10,954 --> 00:19:14,693
你就会意识到S盒是DES里唯一的非线性部件

469
00:19:14,693 --> 00:19:19,116
part of DES. So if the S boxes were
linear  then the entire circuit is linear

470
00:19:14,693 --> 00:19:19,116
所以 如果S盒也是线性的 那整个结构就是线性的

471
00:19:19,116 --> 00:19:23,358
and therefore can be expressed as this
matrix. Now if that's the case then DES

472
00:19:19,116 --> 00:19:23,358
因此 可以用这个矩阵来表示 如果是这种情况 那么DES是一

473
00:19:23,358 --> 00:19:28,066
would be terrible as a secure pseudorandom
permutation. And let me give you a very

474
00:19:23,358 --> 00:19:28,066
个糟糕的安全的伪随机置换 让我给你看个很简单的例子

475
00:19:28,066 --> 00:19:33,596
simple example. Basically if you did the
XOR of three outputs of DES  well

476
00:19:28,066 --> 00:19:33,596
如果你对DES的三个输出做异或 想一下这是

477
00:19:33,596 --> 00:19:38,984
let's think what that means. Basically we
would be looking at B times  the matrix B

478
00:19:33,596 --> 00:19:38,984
什么意思 基本上我们会看到B乘以 这个定义DES

479
00:19:38,984 --> 00:19:43,649
that defines DES  times  one vector
XOR B times another vector

480
00:19:38,984 --> 00:19:43,649
的矩阵B 乘以一个向量 异或上B乘以另外一个向量

481
00:19:43,649 --> 00:19:48,540
XOR B times a third vector. We
could take the B out of the parentheses so

482
00:19:43,649 --> 00:19:48,540
再异或B乘以第三个向量 我们把B提出来 这样

483
00:19:48,540 --> 00:19:54,338
we'd be basically doing B times this
vector over here. But of course K XOR K XOR K

484
00:19:48,540 --> 00:19:54,338
得到B乘以这个向量 但是显然k异或k再异或k

485
00:19:54,338 --> 00:19:59,664
this is just K. And so if you
think about what that means  basically we

486
00:19:54,338 --> 00:19:59,664
就是k 所以 你想一下 我们就得到

487
00:19:59,664 --> 00:20:06,503
just got back DES of K at the point M1 XOR M2 XOR M3. But this means that now DES

488
00:19:59,664 --> 00:20:06,503
以密钥k加密的m1异或m2异或m3的DES密文 但是这意味着DED

489
00:20:06,503 --> 00:20:10,896
has this horrible relation. That can be
tested. Right? So  basically  if you

490
00:20:06,503 --> 00:20:10,896
有这个可怕的相关关系 我可一检测一下 是吧？所以 本质上 如果你

491
00:20:10,896 --> 00:20:15,682
XOR the output of three values
M1  M2  M3  you'll get the value of

492
00:20:10,896 --> 00:20:15,682
异或这三个值的输出 m1 m2和m3 你会得到

493
00:20:15,682 --> 00:20:20,317
DES  at the point M1 XOR M2 XOR M3. Now this
is not a relation that is going to hold

494
00:20:15,682 --> 00:20:20,317
这三个值异或的DES加密结果 这个性质导致DES这个函数

495
00:20:20,317 --> 00:20:25,362
for a random function. A random function
is not going to satisfy this equality.

496
00:20:20,317 --> 00:20:25,362
不能作为随机函数 一个随机函数不能满足这样的条件

497
00:20:25,362 --> 00:20:29,707
And so you get a very easy test to tell you
that DES is not a random function.

498
00:20:25,362 --> 00:20:29,707
所以 你有一种很简单的方法告诉你DES不是一个随机函数

499
00:20:29,707 --> 00:20:34,099
In fact  maybe you can take that as a small
exercise. It's not even difficult to see

500
00:20:29,707 --> 00:20:34,099
实际上 我们可能会以此做个简单的练习（作业里有） 甚至不难发现

501
00:20:34,099 --> 00:20:39,195
that given enough input output pairs  you
can literally recover the entire secret key.

502
00:20:34,099 --> 00:20:39,195
有足够的输入输出对 你可以恢复出整个密钥

503
00:20:39,195 --> 00:20:44,988
Yeah. You just need 832 input output
pairs  and you'll be able recover the

504
00:20:39,195 --> 00:20:44,988
是的！你只需要832对输入输出 你就能恢复出

505
00:20:44,988 --> 00:20:50,290
entire secret key. And so if the S boxes
were linear  DES would be completely

506
00:20:44,988 --> 00:20:50,290
整个密钥 所以 如果S盒是线性的 DES将彻底

507
00:20:50,290 --> 00:20:55,652
insecure. It turns out  actually  even if
the S boxes were close to being linear. In

508
00:20:50,290 --> 00:20:55,652
不安全 事实表明 实际上 即便S盒是近似线性的 换句话说

509
00:20:55,652 --> 00:21:01,119
other words  the S boxes were linear most
of the time. So maybe for 60 out of the 64

510
00:20:55,652 --> 00:21:01,119
S盒在大多数时候是线性的 可能对64个输入有60个输出是线性的

511
00:21:01,119 --> 00:21:06,322
inputs  the S boxes were linear. It turns
out that would also be enough to break

512
00:21:01,119 --> 00:21:06,322
S就是线性的了 这样我们也能攻破DES

513
00:21:06,322 --> 00:21:11,092
DES  and we're gonna see why later on. In
particular  if you choose the S boxes at

514
00:21:06,322 --> 00:21:11,092
我们后面会研究一下为什么 特别的 如果你随机选择了S盒

515
00:21:11,092 --> 00:21:15,376
random  it turns out they'll tend to be
somewhat close to linear functions. As a

516
00:21:11,092 --> 00:21:15,376
你会发现它们都多少趋于线性函数

517
00:21:15,376 --> 00:21:19,606
result  you'll be able to totally break
DES. You'll just be able to recover the

518
00:21:15,376 --> 00:21:19,606
结果就是 你能彻底攻破DES 你能在

519
00:21:19,606 --> 00:21:23,619
key  in basically  very little time. And
so  the designers of DES actually

520
00:21:19,606 --> 00:21:23,619
很短的时间内获得密钥 DES的设计者

521
00:21:23,619 --> 00:21:27,687
specified a number of rules they use for
choosing the S boxes. And it's not

522
00:21:23,619 --> 00:21:27,687
给出了一系列选择S盒的规则 不出意料的

523
00:21:27,687 --> 00:21:31,711
surprising  the first rule is that these
functions are far away from being linear.

524
00:21:27,687 --> 00:21:31,711
第一规则就是这些函数不能是线性的

525
00:21:31,711 --> 00:21:36,208
Okay. So  in other words  there is no
function that agrees with a large fraction

526
00:21:31,711 --> 00:21:36,208
好 换句话说 就是没有（线性）函数能满足大部分S盒的输出

527
00:21:36,208 --> 00:21:39,840
of the outputs of the S box. And then
there are all these other rules  for

528
00:21:36,208 --> 00:21:39,840
还有一起其它的规则 比如

529
00:21:39,840 --> 00:21:44,146
example  there are exactly four to one
maps  right? So  every output has exactly

530
00:21:39,840 --> 00:21:44,146
S盒是个4对1的映射 就是说每个输出对应四个

531
00:21:44,146 --> 00:21:48,433
four pre-images and so on and so forth. So
we understand now why they chose the S

532
00:21:44,146 --> 00:21:48,433
原像 等等还有其它 现在在我们理解了为什么S盒要有这样的

533
00:21:48,433 --> 00:21:52,773
boxes they way they did and in fact its
all done to defeat certain attacks on DES.

534
00:21:48,433 --> 00:21:52,773
选择方式 实际上都是为了抵抗某种对DES的攻击

535
00:21:52,773 --> 00:21:56,742
Okay. So that's the end of the
description of DES  and in the next few

536
00:21:52,773 --> 00:21:56,742
好 我们对DES就讲到这里 下几节

537
00:21:56,742 --> 00:21:59,706
segments we are going to look at the
security of DES.

538
00:21:56,742 --> 00:21:59,706
我们将看一下DES的安全性

