1
00:00:00,000 --> 00:00:03,827
In the last segment, we explained what is
a public key encryption system. And we

2
00:00:00,000 --> 00:00:03,827
在这一小节中 我们来讲下什么是公钥加密系统

3
00:00:03,827 --> 00:00:07,557
defined what it means for a public key
encryption system to be secure. If you

4
00:00:03,827 --> 00:00:07,557
并且我们来定义下公钥加密系统的安全性

5
00:00:07,557 --> 00:00:11,142
remember, we required security against
active attacks. And in particular, we

6
00:00:07,557 --> 00:00:11,142
如果你还记得的话 我们需要针对主动攻击的安全性

7
00:00:11,142 --> 00:00:15,211
defined chosen cipher text security as our
goal. This week, we're gonna construct two

8
00:00:11,142 --> 00:00:15,211
而且我们要特别定义下选择密文攻击的安全性 这一周

9
00:00:15,211 --> 00:00:19,281
families of public key encryption systems
that are chosen cipher text secure. And in

10
00:00:15,211 --> 00:00:19,281
我们要构建两个具有选择密文攻击安全性的公钥加密系统

11
00:00:19,281 --> 00:00:22,914
this segment, we're gonna start by
constructing public key encryptions from,

12
00:00:19,281 --> 00:00:22,914
并且在这一小节 我们要从陷门置换来

13
00:00:23,059 --> 00:00:27,124
a concept called a trapdoor
permutation. So let's start by defining a

14
00:00:23,059 --> 00:00:27,124
构建一个公钥加密系统 所以我们先来

15
00:00:27,124 --> 00:00:31,064
general concept called a trapdoor
function. So what is a trapdoor function?

16
00:00:27,124 --> 00:00:31,064
定义一下什么是陷门函数

17
00:00:31,064 --> 00:00:35,484
Well, a trapdoor function basically is a
function that goes from some set X to some

18
00:00:31,064 --> 00:00:35,484
一个陷门函数就是一个集合X到集合Y的函数

19
00:00:35,484 --> 00:00:39,585
set Y. And it's really defined by a triple
of algorithms. There's a generation

20
00:00:35,484 --> 00:00:39,585
它是由三个算法定义而成的

21
00:00:39,585 --> 00:00:43,685
algorithm, the function f, and the inverse
of the function f. So the generation

22
00:00:39,585 --> 00:00:43,685
由一个生成算法 一个函数f 一个函数f的逆构成

23
00:00:43,685 --> 00:00:47,892
algorithm, basically what it does when you
run it, it will generate a key pair, a

24
00:00:43,685 --> 00:00:47,892
生成算法就是当你运行它时 会产生一个密钥对

25
00:00:47,892 --> 00:00:52,098
public key and a secret key. The public
key is gonna define a specific function

26
00:00:47,892 --> 00:00:52,098
就是一个公钥和一个私钥 公钥会确定一个特殊的

27
00:00:52,098 --> 00:00:56,869
from the set X to the set Y. And then the
secret key is going to define the inverse

28
00:00:52,098 --> 00:00:56,869
从集合X到集合Y的函数 并且密钥将会确定一个

29
00:00:56,869 --> 00:01:01,639
function now from the set Y to the set
X. So the idea is that you can evaluate

30
00:00:56,869 --> 00:01:01,639
从集合Y到集合X的逆函数 所以你可以用公钥PK来求这个函数值

31
00:01:01,639 --> 00:01:06,588
the function at any point using a public key
PK and then you can invert that function

32
00:01:01,639 --> 00:01:06,588
并且可以用私钥SK来求这个函数的逆

33
00:01:06,588 --> 00:01:12,443
using the secret key, SK. So what do I
mean by inversion? More precisely, if we

34
00:01:06,588 --> 00:01:12,443
那么我说逆的意思是什么呢 详细来说就是

35
00:01:12,443 --> 00:01:17,255
look at any public key and secret key pair
generated by the key generation algorithm

36
00:01:12,443 --> 00:01:17,255
如果我们看到密钥生成算法生成的任何密钥对

37
00:01:17,255 --> 00:01:21,727
G, then it so happens that if I evaluate
the function at the point X, and then I

38
00:01:17,255 --> 00:01:21,727
假如我求得了在点X的函数值

39
00:01:21,727 --> 00:01:26,142
evaluate the inverse at the resulting
point, I should get the original point X

40
00:01:21,727 --> 00:01:26,142
然后我想要求这个点的值的逆 我就可以得到原始的X的值

41
00:01:26,142 --> 00:01:30,670
back. So the picture you should have in
your mind, is there is this big set X and

42
00:01:26,142 --> 00:01:30,670
你们可以想象下 有一个大集合X和一个大集合Y

43
00:01:30,670 --> 00:01:35,857
this big set Y And then, this function
will map any point in X to a point in Y,

44
00:01:30,670 --> 00:01:35,857
这个函数从X中的一些点映射到Y中的一个点

45
00:01:35,857 --> 00:01:41,508
and this can be done using the public key.
So again any point in X can be mapped, to

46
00:01:35,857 --> 00:01:41,508
并且都这是用公钥来实现的 所以X中的点可以映射

47
00:01:41,508 --> 00:01:46,897
a point in Y. And then if someone has the
secret key, then basically they can go in

48
00:01:41,508 --> 00:01:46,897
Y中的点 那么如果有人拥有这个私钥 那么他们就可以

49
00:01:46,897 --> 00:01:53,758
the reverse direction by applying, this
secret key sk. So now that we

50
00:01:46,897 --> 00:01:53,758
用SK来颠倒这个过程 那么现在

51
00:01:53,758 --> 00:01:58,289
understand what a trapdoor function is,
let's define what it means for a trapdoor

52
00:01:53,758 --> 00:01:58,289
我们已经理解了陷门函数的意思 我们再来定义下

53
00:01:58,289 --> 00:02:02,652
function to be secure. And so we'll say
that this triple, (G, F, F inverse), is secure

54
00:01:58,289 --> 00:02:02,652
陷门函数的安全性 我们可以说 这三个函数(G,F,F的逆)

55
00:02:02,652 --> 00:02:06,903
if in fact this function F(PK, .) is what's
called a one way function. And let me

56
00:02:02,652 --> 00:02:06,903
他们整体是单向函数的话就是安全的

57
00:02:06,903 --> 00:02:10,986
explain what a, what is a one way
function. The idea is that basically the

58
00:02:06,903 --> 00:02:10,986
我来解释下什么是单向函数 就是说一个函数在

59
00:02:10,986 --> 00:02:15,516
function can be evaluated at any point,
but inverting it is difficult without the

60
00:02:10,986 --> 00:02:15,516
任意一点可以求值 但是如果没有私钥的话就难以求得它的逆函数

61
00:02:15,516 --> 00:02:19,639
secret key SK. So let's define that more
precisely. As usual we define that using a

62
00:02:15,516 --> 00:02:19,639
那么我们再用一个比赛来详细定义下吧

63
00:02:19,639 --> 00:02:23,764
game. So here we have our game between the
challenger and the adversary. And the game

64
00:02:19,639 --> 00:02:23,764
这里我们有一个挑战者和敌手之间的比赛

65
00:02:23,764 --> 00:02:27,496
proceeds as follows. Basically the
challenger will generate a public key and

66
00:02:23,764 --> 00:02:27,496
挑战者先生成一个公钥和一个私钥

67
00:02:27,496 --> 00:02:31,622
a secret key. And then they will generate
a random X. It will send the public key

68
00:02:27,496 --> 00:02:31,622
然后他们会生成一个随机数X 然后把公钥发送给敌方

69
00:02:31,622 --> 00:02:36,116
over to the adversary and then it will
evaluate the function at the point X and

70
00:02:31,622 --> 00:02:36,116
然后用公钥会求得这个函数在点X的值Y

71
00:02:36,116 --> 00:02:40,160
send the resulting Y also to the
adversary. So all the adversary gets to

72
00:02:36,116 --> 00:02:40,160
并将其发送给敌方 那么敌方的到的就

73
00:02:40,160 --> 00:02:44,653
see is just a public key, which defines
what the function is, and then he gets to

74
00:02:40,160 --> 00:02:44,653
仅仅是一个定义了这个函数的公钥

75
00:02:44,653 --> 00:02:49,483
see the image of this function on a random
point X and is goal is basically to invert

76
00:02:44,653 --> 00:02:49,483
然后他得看下这个函数在点X的值

77
00:02:49,483 --> 00:02:54,097
the function at this point Y. Okay, so he
outputs some X prime. And we said that the

78
00:02:49,483 --> 00:02:54,097
并且用Y求这个函数的逆 那么他就可以得到X的值了

79
00:02:54,097 --> 00:02:58,507
trap door function is secure if the
probability that the ad, adversary inverts

80
00:02:54,097 --> 00:02:58,507
前面我们说过 如果对手可以用Y求得这个函数的逆的概率非常小的话

81
00:02:58,507 --> 00:03:03,143
the given at point y is negligible. In
other words, given y the probability that

82
00:02:58,507 --> 00:03:03,143
那这个陷门函数就是安全的 就是说 通过给定Y

83
00:03:03,143 --> 00:03:07,271
the adversary's able to alter the pre
image of y is in fact a negligible

84
00:03:03,143 --> 00:03:07,271
无论使用那种算法

85
00:03:07,271 --> 00:03:11,907
probability and if that's true for all
efficient algorithms then we say that this

86
00:03:07,271 --> 00:03:11,907
来求得它的原象的概率非常低的话

87
00:03:11,907 --> 00:03:17,882
trapdor function is secure. So again
abstractly, it's a really interesting

88
00:03:11,907 --> 00:03:17,882
那么这个陷门函数就是安全的 这是一个很有趣的概念

89
00:03:17,882 --> 00:03:21,885
concept in that you can evaluate the
function in the forward direction very

90
00:03:17,882 --> 00:03:21,885
你可以非常简单从一个方向求得这个函数

91
00:03:21,885 --> 00:03:26,150
easily. But then no one can evaluate the
function in the reverse direction unless

92
00:03:21,885 --> 00:03:26,150
但是没人能从另一个方向求得这个陷门函数

93
00:03:26,150 --> 00:03:30,311
they have this trapdoor, the secret key
SK, which then all of a sudden lets them

94
00:03:26,150 --> 00:03:30,311
如果没有私钥SK的话 但是私钥SK可以让求逆变得非常

95
00:03:30,311 --> 00:03:35,424
invert the function very, very easily. So
using the concept of a trapdoor function,

96
00:03:30,311 --> 00:03:35,424
非常的简单 所以 通过使用陷门函数

97
00:03:35,424 --> 00:03:39,552
it's not too difficult to build a public key encryption system, and let me show you how

98
00:03:35,424 --> 00:03:39,552
建立一个公钥加密系统就不难了 我们来看看怎么做

99
00:03:39,552 --> 00:03:43,528
to do it. So here we have we our trap door
function, (G, F, and F inverse). The other

100
00:03:39,552 --> 00:03:43,528
这里我们有一个陷门函数(G,F,F的逆)

101
00:03:43,528 --> 00:03:47,605
tool that we are going to need is a symmetric encryption scheme, and I'm going to

102
00:03:43,528 --> 00:03:47,605
另一个我们需要的工具就是对称加密体制

103
00:03:47,605 --> 00:03:51,531
assume that this encryption scheme is actually
secure against active attacks, so in

104
00:03:47,605 --> 00:03:51,531
我们先假设这个加密体制面对主动攻击是安全的

105
00:03:51,531 --> 00:03:55,350
particular I needed to provide
authenticated encryption. Notice that the

106
00:03:51,531 --> 00:03:55,350
那么 我需要一个认证加密技术

107
00:03:55,350 --> 00:04:00,726
symmetric encryption system takes keys in
K and the trapdoor function takes inputs

108
00:03:55,350 --> 00:04:00,726
注意一下 对称加密系统用密钥来加密K 陷门函数用输入来加密X

109
00:04:00,726 --> 00:04:05,790
in X. Those are two different sets and so
we're also gonna need the hash function.

110
00:04:00,726 --> 00:04:05,790
有两个不同的集合 同时我们也需要一个从X映射到K的

111
00:04:05,790 --> 00:04:09,937
That goes from X to K. In other words, it
maps elements in the set X into keys for

112
00:04:05,790 --> 00:04:09,937
杂凑函数 换句话说 就是它把集合X中的元素映射到对称加密系统的密钥中

113
00:04:09,937 --> 00:04:14,033
the symmetric encryption systems. And now
once we have these three components, we

114
00:04:09,937 --> 00:04:14,033
现在我们有了这三个部分

115
00:04:14,033 --> 00:04:17,821
can actually construct the public key encryption system as follows: so the key

116
00:04:14,033 --> 00:04:17,821
我们就可以构建一个这样的公钥加密系统

117
00:04:17,821 --> 00:04:21,764
generation for the public key encryption
system is basically exactly the same as

118
00:04:17,821 --> 00:04:21,764
公钥加密系统中的密钥生成器和陷门函数中的

119
00:04:21,764 --> 00:04:25,655
the key generation for the trap door
function. So we run G for the trap door

120
00:04:21,764 --> 00:04:25,655
密钥生成器一样 那么我们运行陷门函数中的G函数

121
00:04:25,655 --> 00:04:29,956
function, we get a public key and a secret
key. And those are gonna be the public and

122
00:04:25,655 --> 00:04:29,956
得到一个公钥私钥对 并且这将会作为公钥加密系统的

123
00:04:29,956 --> 00:04:34,171
secret keys for the public key encryption
system. And how do we encrypt and decrypt? Let's

124
00:04:29,956 --> 00:04:34,171
公钥和私钥 那么我们如果来加密和解密呢

125
00:04:34,171 --> 00:04:38,978
start with encryption. So the encryption
algorithm takes a public key and a message

126
00:04:34,171 --> 00:04:38,978
我们先从加密说起 加密算法需要一个公钥和一个消息作为输入

127
00:04:38,978 --> 00:04:43,898
as input. So what it will do is it will
generate a random X from the set capital

128
00:04:38,978 --> 00:04:43,898
然后它会从集合X中生成一个随机数X

129
00:04:43,898 --> 00:04:48,545
X. It will then apply the trapdoor
function to this random X, to obtain Y. So

130
00:04:43,898 --> 00:04:48,545
然后把X代入到陷门函数中 生成Y

131
00:04:48,545 --> 00:04:53,130
Y is the image of X under the trapdoor
function. Then it will go ahead and

132
00:04:48,545 --> 00:04:53,130
那么Y就是X在陷门函数下的映射

133
00:04:53,130 --> 00:04:58,272
generate a symmetric key by hashing X. So
this is a symmetric key for the symmetric

134
00:04:53,130 --> 00:04:58,272
然后它会把X代入杂凑函数来产生一个对称密钥 即对称密钥系统的

135
00:04:58,272 --> 00:05:03,290
key system. And then finally it encrypts
the plain text message 'm' using this key that was

136
00:04:58,272 --> 00:05:03,290
对称密钥 然后最终 它用这个密钥来加密明文消息M

137
00:05:03,290 --> 00:05:08,123
just generated. And then it outputs the
value Y that it just computed, which is

138
00:05:03,290 --> 00:05:08,123
然后它就会输出Y的值 也就是X的映射

139
00:05:08,123 --> 00:05:13,260
the image of X, along the encryption under
the symmetric system of the message M. So

140
00:05:08,123 --> 00:05:13,260
在加密对称加密系统中的消息M时

141
00:05:13,260 --> 00:05:18,366
that's how encryption works. And I want to
emphasize again that the trapdoor function

142
00:05:13,260 --> 00:05:18,366
这就是加密过程如何工作的 我要再一次强调的是陷门函数

143
00:05:18,366 --> 00:05:23,112
is only applied to this random value X,
whereas the message itself is encrypted

144
00:05:18,366 --> 00:05:23,112
仅仅是适用于这个随机值X 而这个消息本身是

145
00:05:23,112 --> 00:05:28,098
using a symmetric key system using a key
that was derived from the value X that we

146
00:05:23,112 --> 00:05:28,098
用一个来自我们随机选择的X的值的秘钥加密的对称加密系统

147
00:05:28,098 --> 00:05:32,959
chose at random. So now that we understand
encryption, let's see how to decrypt.

148
00:05:28,098 --> 00:05:32,959
加密的 因此我们明白了加密过程 现在来看如何解密

149
00:05:32,959 --> 00:05:37,366
While the decryption algorithm takes a
secret key as input, and the ciphertext.

150
00:05:32,959 --> 00:05:37,366
当解密算法使用一个私钥和密文作为输入

151
00:05:37,366 --> 00:05:41,551
The ciphertext itself contains two
components, the value Y and the value C.

152
00:05:37,366 --> 00:05:41,551
密文本身包含两个部分 y值和c值

153
00:05:41,551 --> 00:05:46,070
So the first step we're gonna do, is we're
gonna apply the inverse transformation,

154
00:05:41,551 --> 00:05:46,070
所以第一步我们要做的是 我们要使用逆变换

155
00:05:46,070 --> 00:05:50,366
the inverse trap door function to the
value Y, and that will give us back the

156
00:05:46,070 --> 00:05:50,366
对y值使用逆陷门函数 那会让我们得到

157
00:05:50,366 --> 00:05:54,495
original X that was chosen during
encryption. So now let me ask you, how do

158
00:05:50,366 --> 00:05:54,495
加密时最原始的x的值 那么 我们怎么

159
00:05:54,495 --> 00:06:00,042
we derive the symmetric decryption key K
from this X that we just obtained? Well,

160
00:05:54,495 --> 00:06:00,042
从我们刚得到的x推导出对称解密密钥k

161
00:06:00,042 --> 00:06:04,736
so that's an easy question. We basically
hash X again. That gives us K just as

162
00:06:00,042 --> 00:06:04,736
这个问题很简单 我们再次HASH x 得到

163
00:06:04,736 --> 00:06:09,372
during encryption. And now that we have
this symmetric encryption key we can apply

164
00:06:04,736 --> 00:06:09,372
加密时的那个k 现在我们有对称加密密钥 我们可以

165
00:06:09,372 --> 00:06:13,783
the, the symmetric decryption algorithm to
decrypt the ciphertext C. We get the

166
00:06:09,372 --> 00:06:13,783
对应这个对称解密密钥到解密密文c 我们得到

167
00:06:13,783 --> 00:06:17,741
original message M and that's what we
output. So, that's how the public key

168
00:06:13,783 --> 00:06:17,741
原始消息m 这就是我们得到的输出 这就是公钥

169
00:06:17,741 --> 00:06:22,321
encryption system works were this trap
door function is only used for encrypting

170
00:06:17,741 --> 00:06:22,321
加密系统的工作过程 这个陷门函数只是用于加密

171
00:06:22,321 --> 00:06:26,788
some sort of a random value X and the
actual message is encrypted using the

172
00:06:22,321 --> 00:06:26,788
一些随机值x 真正的消息是用对称系统

173
00:06:26,788 --> 00:06:31,244
symmetric system. So in pictures here, we
have the message M obviously the plain

174
00:06:26,788 --> 00:06:31,244
加密的 在这张图片里 我们有消息m 显然

175
00:06:31,244 --> 00:06:35,545
text could be quite large. So, here we
have the body of the deciphered text which

176
00:06:31,244 --> 00:06:35,545
纯文本的可能会相当大 这里我们有解密文本的内容

177
00:06:35,545 --> 00:06:39,953
can be quite long is actually encrypted
using the symmetric system. And then again

178
00:06:35,545 --> 00:06:39,953
这会有相当长的一部分是用对称系统加密的 再次强调

179
00:06:39,953 --> 00:06:44,039
I emphasize that the key for the
symmetric system is simply the hash of X.

180
00:06:39,953 --> 00:06:44,039
对称系统的密钥仅仅是对x的HASH的函数

181
00:06:44,039 --> 00:06:48,232
And then the header of ciphertext is simply
this application of the trapdoor

182
00:06:44,039 --> 00:06:48,232
密文的开头仅仅是陷门函数对

183
00:06:48,232 --> 00:06:52,641
function to this random X that we picked.
And so during decryption what happens is

184
00:06:48,232 --> 00:06:52,641
我们得到的随机值x的应用 在解密期间会发生的是

185
00:06:52,641 --> 00:06:56,888
we first decrypt the header to get X and
then we decrypt the body using the

186
00:06:52,641 --> 00:06:56,888
我们首先解密开头以得到x 然后用

187
00:06:56,888 --> 00:07:01,829
symmetric system to actually get the
original plain text M. So as usual when I

188
00:06:56,888 --> 00:07:01,829
对称系统解密消息体以得到原始明文消息m 像往常一样

189
00:07:01,829 --> 00:07:06,542
show you a system like this, obviously you
want to verify that decryption in fact is

190
00:07:01,829 --> 00:07:06,542
我为你们介绍一个类似的系统 显然你们想验证这个解密过程其实是

191
00:07:06,542 --> 00:07:10,605
the inverse of encryption. But more
importantly you want to ask why is this

192
00:07:06,542 --> 00:07:10,605
加密过程的逆运算 但是更重要的是这个系统的安全性

193
00:07:10,605 --> 00:07:14,963
system secure. And in fact there's a nice
security theorem here that says. That if

194
00:07:10,605 --> 00:07:14,963
其实这里有一个好的安全定理 就是

195
00:07:14,963 --> 00:07:18,900
the trap door function that we started
with is secure. In other words, that's a

196
00:07:14,963 --> 00:07:18,900
如果我们使用的陷门函数安全 换句话说 

197
00:07:18,900 --> 00:07:22,634
one way function if the adversary doesn't
have a secret key. The symmetric

198
00:07:18,900 --> 00:07:22,634
有一个单向函数 如果对手没有密钥 对称

199
00:07:22,634 --> 00:07:26,621
encryption system provides authenticated
encryption. And the hash function is a

200
00:07:22,634 --> 00:07:26,621
加密系统提供身份验证的加密 HASH函数是一个

201
00:07:26,621 --> 00:07:30,558
random oracle, which simply means that
it's a random function from the set X to

202
00:07:26,621 --> 00:07:30,558
随机预言 它仅仅意味着它是来自集合x到密钥集k的

203
00:07:30,558 --> 00:07:34,696
the set of keys K. So a random oracle is
some sort of an idealization of, what a

204
00:07:30,558 --> 00:07:34,696
随机函数 所以一个随机预言是某种理想化的函数

205
00:07:34,696 --> 00:07:38,280
hash function is supposed to be. In
practice, of course, when you come to

206
00:07:34,696 --> 00:07:38,280
跟HASH函数应该很像 当然在实践中 当你去

207
00:07:38,280 --> 00:07:42,317
implement a system like this, you would
just use, SHA-256, or any of the

208
00:07:38,280 --> 00:07:42,317
实现这样一个系统的时候 你可能会用SHA-256，或者其他

209
00:07:42,317 --> 00:07:47,252
other hash functions that we discussed in
class. So, under those three conditions in

210
00:07:42,317 --> 00:07:47,252
任何我们在课堂上讲过的HASH函数 所以 在那三种情况下

211
00:07:47,252 --> 00:07:51,863
fact the system that we just described is
chosen cipher text secure so it is CCA

212
00:07:47,252 --> 00:07:51,863
事实上我们刚才讨论的系统是选择密文安全的 所以它是CCA安全的

213
00:07:51,863 --> 00:07:56,416
secure, the little ro here just denote the
fact that security is set in whats called

214
00:07:51,863 --> 00:07:56,416
这个随机预言只表示了随机预言模型中的集合的安全性

215
00:07:56,416 --> 00:08:00,572
a random oracle model. But, that's a detail
that's actually not so important for

216
00:07:56,416 --> 00:08:00,572
但是 这里还有一个不太重要的细节

217
00:08:00,572 --> 00:08:05,012
discussion here, what I want you to
remember is that if the trap door function

218
00:08:00,572 --> 00:08:05,012
你们要记住的是 如果陷门函数

219
00:08:05,012 --> 00:08:09,000
is in fact a secure trap door function. The
symmetric encryption system is secure

220
00:08:05,012 --> 00:08:09,000
是一个安全的陷门函数 对称加密系统

221
00:08:09,000 --> 00:08:13,017
against tampering so it provides
authenticated encryption. And H

222
00:08:09,000 --> 00:08:13,017
对应于篡改是安全的 则它提供经过身份验证的加密

223
00:08:13,017 --> 00:08:17,468
is in some sense a good hash function.
It's a random, function, which in practice

224
00:08:13,017 --> 00:08:17,468
h在某种程度上是一个好HASH函数 那个练习中的随机函数

225
00:08:17,468 --> 00:08:22,245
you would just use SHA-256, then in
fact the system that we just showed is CCA

226
00:08:17,468 --> 00:08:22,245
你们只用SHA-256 其实我们刚才讲的系统是

227
00:08:22,245 --> 00:08:27,615
secure, is chosen ciphertext secure. I should
tell you that there's actually an ISO

228
00:08:22,245 --> 00:08:27,615
CCA安全的 是选择密文安全的 我要告诉你们 其实有

229
00:08:27,615 --> 00:08:31,752
standard that, defines this mode of
encryption, of public encryption. ISO

230
00:08:27,615 --> 00:08:31,752
ISO标准 定义了这种加密 称为公开加密

231
00:08:31,752 --> 00:08:35,781
stands for International Standards
Organization. So in fact this particular

232
00:08:31,752 --> 00:08:35,781
ISO标准化组织 所以其实这个特殊的

233
00:08:35,781 --> 00:08:40,456
system has actually been standardized, and
this is a fine thing to use. I'll refer to

234
00:08:35,781 --> 00:08:40,456
系统事实上被标准化了 这用起来是个好东西 我要提一下这个

235
00:08:40,456 --> 00:08:44,947
this as the ISO encryption in the next few
segments. To conclude this segment, I want

236
00:08:40,456 --> 00:08:44,947
作为下面几节课的ISO加密 总结下这一节课

237
00:08:44,947 --> 00:08:48,925
to warn you about an incorrect way of
using a trapdoor function to build a

238
00:08:44,947 --> 00:08:48,925
我要警告你们关于一个使用陷门函数去建立

239
00:08:48,925 --> 00:08:53,328
public key encryption system. And in fact
this method might be the first thing that

240
00:08:48,925 --> 00:08:53,328
公钥加密系统的错误点 其实这个方法可能是第一个

241
00:08:53,328 --> 00:08:57,572
comes to mind, and yet it's completely
insecure. So let me show you, how not to

242
00:08:53,328 --> 00:08:57,572
能想到的 目前它是完全不安全的 我来讲解下怎样才能

243
00:08:57,572 --> 00:09:01,762
encrypt using a trapdoor function. Well
the first thing that might come to mind

244
00:08:57,572 --> 00:09:01,762
不用陷门函数加密 第一件事我们能想到的是

245
00:09:01,762 --> 00:09:05,696
is, well, let's apply the trapdoor
function directly to the message M. So we

246
00:09:01,762 --> 00:09:05,696
我们直接对这个消息m应用陷门函数 所以我们

247
00:09:05,696 --> 00:09:10,047
encrypt simply by applying a function to
the message M, and we decrypt simply by

248
00:09:05,696 --> 00:09:10,047
仅仅使用函数计算去加密消息m 那我们解密也仅仅是

249
00:09:10,047 --> 00:09:14,180
applying F inverse to the ciphertext C to
recover the original message M. So

250
00:09:10,047 --> 00:09:14,180
使用f对密文c求逆去恢复原始消息m

251
00:09:14,180 --> 00:09:18,639
functionally, this is in fact, decryption
is the inverse of encryption, and yet this

252
00:09:14,180 --> 00:09:18,639
这个其实函数的解密就是对加密的逆运算 目前

253
00:09:18,639 --> 00:09:22,881
is completely insecure for many, many
different reasons. The easiest way to see

254
00:09:18,639 --> 00:09:22,881
这有很多很多理由不安全 最简单的方法去看

255
00:09:22,881 --> 00:09:26,960
that this is insecure, is that it's
simply, this is deterministic encryption.

256
00:09:22,881 --> 00:09:26,960
这个不安全因素 就是它太简单 它是确定加密

257
00:09:26,960 --> 00:09:30,944
You notice there is no randomness being
used here. When we encrypt a message

258
00:09:26,960 --> 00:09:30,944
你会注意到这里没有用到随机性 当我们加密一个消息m

259
00:09:30,944 --> 00:09:34,154
M, and since it is
deterministic, it's cannot possibly be

260
00:09:30,944 --> 00:09:34,154
由于它是确定的 就不可能

261
00:09:34,154 --> 00:09:37,948
semantically secure. But in fact, as I
said, when we instantiate this trap door

262
00:09:34,154 --> 00:09:37,948
在语义上是安全的 但其实如我所说 当我们用特定的实现

263
00:09:37,948 --> 00:09:41,644
function with particular implementations,
for example with the RSA trap door

264
00:09:37,948 --> 00:09:41,644
去实例化这个陷门函数 以这个RSA陷门函数为例

265
00:09:41,644 --> 00:09:44,951
function, then there are many, many
attacks that are possible on this

266
00:09:41,644 --> 00:09:44,951
有很多很多可能的攻击

267
00:09:44,951 --> 00:09:48,794
particular construction, and so you should
never, ever, ever use it, and I'm gonna

268
00:09:44,951 --> 00:09:48,794
对这个特定的结构 所以你们以后千万不要用它 我要

269
00:09:48,794 --> 00:09:52,830
repeat this throughout this module, and in
fact in the next segment I'll show you a

270
00:09:48,794 --> 00:09:52,830
在这个模块多次重复这个 其实在下一节课 我会给你们

271
00:09:52,830 --> 00:09:56,699
number of attacks on this particular
implementation. Okay so, what I would like

272
00:09:52,830 --> 00:09:56,699
讲一些对这个特定实现的攻击 好 我希望你们记住

273
00:09:56,699 --> 00:10:00,717
you to remember is that you should be
using an encryption system like the ISO

274
00:09:56,699 --> 00:10:00,717
你们要按照ISO标准去应用加密系统

275
00:10:00,717 --> 00:10:04,992
standard, and you should never apply the
trap door function directly to the message M.

276
00:10:00,717 --> 00:10:04,992
永远不要直接将陷门函数应用于消息m

277
00:10:04,992 --> 00:10:09,010
Although in the next segment we'll
see other ways to encrypt using a trap

278
00:10:04,992 --> 00:10:09,010
即使下一节课我们会学习使用陷门函数加密的其他方法

279
00:10:09,010 --> 00:10:13,233
door function that are also correct, but
this particular method is clearly, clearly

280
00:10:09,010 --> 00:10:13,233
那些是正确的 但是这个特定的模型是明显

281
00:10:13,233 --> 00:10:17,560
incorrect. Okay, so now that we understand
how to build public key encryption

282
00:10:13,233 --> 00:10:17,560
明显不正确的 好 现在我们明白了如何使用给定的陷门函数

283
00:10:17,560 --> 00:10:21,423
given a trap door function, the next
question is how to construct trap door

284
00:10:17,560 --> 00:10:21,423
建立公钥加密 下一个问题就是如何建立

285
00:10:21,423 --> 00:10:24,360
functions, and we're going to do that in
the next segment.

286
00:10:21,423 --> 00:10:24,360
陷门函数 我们下节课再讲

