1
00:00:00,000 --> 00:00:04,616
In this segment, we're going to construct
two classic MACS, the CBC-MAC and the

2
00:00:00,000 --> 00:00:04,616
这一节，我们将构造两个经典的MAC，CBC-MAC和

3
00:00:04,616 --> 00:00:09,233
NMAC. Recall in the last segment, we said
that if you give me a secure PRF, then

4
00:00:04,616 --> 00:00:09,233
NMAC。回忆上一节，我们说如果你给我一个安全的PRF，那么

5
00:00:09,233 --> 00:00:14,087
that secure PRF can actually be used to
construct a secure MAC, simply by defining

6
00:00:09,233 --> 00:00:14,087
这个安全的PRF可以用来构造一个安全的MAC，就是简单

7
00:00:14,087 --> 00:00:18,763
the signature on the message m as the
value of the function at the point m. The

8
00:00:14,087 --> 00:00:18,763
地定义对消息m的签名是这个消息m的函数

9
00:00:18,763 --> 00:00:23,203
only caveat was that the output of the
PRF F had to be large. For example, it

10
00:00:18,763 --> 00:00:23,203
唯一的需要注意的是PEF的F函数输出必须足够大 比如 它

11
00:00:23,203 --> 00:00:27,947
could be 80 bits or 128 bits, and that
would generate a secure MAC Now we also

12
00:00:23,203 --> 00:00:27,947
必须是80或者128比特的，可以生成一个安全的MAC 现在我们

13
00:00:27,947 --> 00:00:33,220
said that because AES is a secure PRF,
essentially AES already gives us a secure

14
00:00:27,947 --> 00:00:33,220
说因为AES是一个安全的PRF，基本上AES已经给我们安全的

15
00:00:33,220 --> 00:00:37,899
MAC, except that it can only process
sixteen byte messages. And the question

16
00:00:33,220 --> 00:00:37,899
MAC了，除了它只能处理16字节的消息。现在问题

17
00:00:37,899 --> 00:00:42,889
now is, given a PRF for short messages
like AES for sixteen byte messages, can we

18
00:00:37,899 --> 00:00:42,889
是，给出一个像AES这样有16字节的短消息PRF，我们

19
00:00:42,889 --> 00:00:48,005
construct a PRF for long messages that are
potentially gigabytes long? And this is

20
00:00:42,889 --> 00:00:48,005
能构造出一个PRF可以处理可能G比特的数据吗？

21
00:00:48,005 --> 00:00:53,245
shorthand for what's coming. I'm going to
denote by X, the set {0,1} to the N where N

22
00:00:48,005 --> 00:00:53,245
把这个作为简写 我在这里用X表示，集合01n其中n是

23
00:00:53,245 --> 00:00:58,485
is the block size for the underlying PRF.
So since we're always going to be thinking

24
00:00:53,245 --> 00:00:58,485
内在PRF的分组大小 因为我们总是要考虑AES

25
00:00:58,485 --> 00:01:03,247
of AES as the underlying PRF, you can
think of N as essentially 128 bits. So

26
00:00:58,485 --> 00:01:03,247
作为内在PRF，你可以认为n就是128比特

27
00:01:03,247 --> 00:01:08,296
the first construction is called the
encrypted CBC MAC, or ECBC for short.

28
00:01:03,247 --> 00:01:08,296
第一种构造称为加密的CBC-MAC，或者简写为ECBC

29
00:01:08,296 --> 00:01:13,967
Encrypted CBC MAC. So ECBC uses a PRF that
takes messages in the set X {0,1} to the N

30
00:01:08,296 --> 00:01:13,967
加密的CBC MAC。因此ECBC以01n集合X中的消息为输入

31
00:01:13,967 --> 00:01:19,500
and outputs messages in the same set X.
And what we're going to be building is a

32
00:01:13,967 --> 00:01:19,500
输出消息也在集合X中。我们将要构造的

33
00:01:19,500 --> 00:01:24,687
PRF that basically takes pairs of keys. It
takes very long messages, in fact

34
00:01:19,500 --> 00:01:24,687
PRF基本上需要成对的密钥 消息很长 实际上

35
00:01:24,687 --> 00:01:29,667
arbitrarily long messages, and I'll
explain this in just a second and it

36
00:01:24,687 --> 00:01:29,667
是任意长的消息 后面我会解释

37
00:01:29,667 --> 00:01:34,596
outputs also tags in {0,1} to the N. So
that's our goal. Now what is this X to the

38
00:01:29,667 --> 00:01:34,596
它的输出也是01n集合中的元素 也就是我们的结果 现在问题是

39
00:01:34,596 --> 00:01:39,478
less than or equal to L? The point here is
that in fact CBC MAC can take very long

40
00:01:34,596 --> 00:01:39,478
X和L比是短了还是相等？这里的关键是 实际上CBC MAC可以取最多

41
00:01:39,478 --> 00:01:44,118
messages up to L blocks. L could be a
million or a billion. But it could also

42
00:01:39,478 --> 00:01:44,118
L块长度的消息 L 可能是一百万或一兆,也有可能

43
00:01:44,118 --> 00:01:49,063
take variable length messages as inputs.
In other words, X less than or equal to L

44
00:01:44,118 --> 00:01:49,063
以变化长度的消息作为输入 换句话说 X是小于等于L的

45
00:01:49,063 --> 00:01:53,825
means that we allow the input to be
messages that contain an arbitrary number

46
00:01:49,063 --> 00:01:53,825
意味着我们允许的消息有任意长的分组，

47
00:01:53,825 --> 00:01:58,709
of blocks between one and L. So each CBC
can process messages that are one block

48
00:01:53,825 --> 00:01:58,709
在1和L之间。每一个CBC可以处理消息的长度可以使1个分组

49
00:01:58,709 --> 00:02:03,349
long, two blocks long, ten blocks long,
100 blocks long. It's perfectly fine to

50
00:01:58,709 --> 00:02:03,349
2个分组，10个分组或100个分组等等 输入大小完全没问题

51
00:02:03,349 --> 00:02:07,826
give it variable size inputs. But just to
keep the discussion simple, we up our

52
00:02:03,349 --> 00:02:07,826
但是为了讨论简单起见，我们把上限定为

53
00:02:07,826 --> 00:02:12,301
bounds the maximum length by capital L. So
let's see how ECBC works. Well, we start

54
00:02:07,826 --> 00:02:12,301
大写L。现在我们看看ECBC是怎么工作的，好

55
00:02:12,301 --> 00:02:16,886
by taking our message and breaking it into
blocks, each block is as long as a block

56
00:02:12,301 --> 00:02:16,886
我们从消息开始，把消息分组，每组的长度就是内置函数F的

57
00:02:16,886 --> 00:02:21,250
of the underlying function f, and then
essentially we run through the CBC chain

58
00:02:16,886 --> 00:02:21,250
分组长度，接着我们把CBC链过一遍

59
00:02:21,250 --> 00:02:25,835
except that we don't output intermediate
values. So you notice we basically encrypt

60
00:02:21,250 --> 00:02:25,835
但我们不输出中间值 你会注意到 我们基本上就是加密了

61
00:02:25,835 --> 00:02:30,309
the first block and then feed the results
into the XOR with the second block and

62
00:02:25,835 --> 00:02:30,309
第一个分组，把加密结果与第二个分组进行异或后

63
00:02:30,309 --> 00:02:34,784
then feed that into f again, and we do
that again and again and again and finally

64
00:02:30,309 --> 00:02:34,784
然后再用F处理，我们一遍接一遍的做，直到最后我们

65
00:02:34,784 --> 00:02:39,302
we get a value out here. Which is called
the CBC outputs of this long chain. And

66
00:02:34,784 --> 00:02:39,302
得到这个结果，称作CBC这个长链输出

67
00:02:39,302 --> 00:02:44,235
then, I would like to point your attention
to the fact that we do one more encryption

68
00:02:39,302 --> 00:02:44,235
接着，我想让大家注意一下，我们实际上进行了另一个

69
00:02:44,235 --> 00:02:48,927
step. And this step is actually done using
an independent key, K1. That's different

70
00:02:44,235 --> 00:02:48,927
加密步骤，这个步骤实际上使用了一个独立的密钥k1，这个密钥

71
00:02:48,927 --> 00:02:53,756
and chosen independently of the key K, and
finally the output gives us the tag. So in

72
00:02:48,927 --> 00:02:53,756
和密钥k的选取互相独立，最后这个输出是标签

73
00:02:53,756 --> 00:02:58,183
this case the tag would be N bits long,
but we also mentioned in the previous

74
00:02:53,756 --> 00:02:58,183
这种情况下，标签式N比特长的，但是我们在前面的章节也提到了

75
00:02:58,183 --> 00:03:02,956
segment that it's fine to truncate the tag
to less than N bits long as long as one

76
00:02:58,183 --> 00:03:02,956
把标签截断短至N比特以下和？？？

77
00:03:02,956 --> 00:03:07,555
over two to the end is negligible. So now
you can see that FECBC takes a pair of

78
00:03:02,956 --> 00:03:07,555
是可以忽略的。所以我们现在看到Fecbc以一对密钥

79
00:03:07,555 --> 00:03:11,867
keys as inputs, it can process
variable length messages and it produces

80
00:03:07,555 --> 00:03:11,867
作为输入，它可以处理长度为变量的消息生成

81
00:03:11,867 --> 00:03:16,206
an output in the set X. So you might be
wondering what this last encryption step

82
00:03:11,867 --> 00:03:16,206
的输出属于集合X。所以你现在可能会疑惑这个最后一个加密

83
00:03:16,206 --> 00:03:20,228
is for. And I'll tell you that the
function that's defined without this last

84
00:03:16,206 --> 00:03:20,228
是为什么 我告诉你这个函数，如果没有最后这个

85
00:03:20,228 --> 00:03:24,196
encryption step is called the raw CBC
function. In other words, if we simply

86
00:03:20,228 --> 00:03:24,196
加密步骤，称之为 raw CBC（简化）函数。换句话说，如果我们

87
00:03:24,196 --> 00:03:28,377
stop processing over here, and we take
that as the output, that's called raw CBC.

88
00:03:24,196 --> 00:03:28,377
仅在这里就停了，以这个作为输出，就称为简化CBC

89
00:03:28,377 --> 00:03:32,852
And as we'll see in a minute, raw CBC is
actually not a secure MAC. So this last

90
00:03:28,377 --> 00:03:32,852
等一下我们会看到，这个简化CBC不是一个安全的MAC 所以这个最后一步

91
00:03:32,852 --> 00:03:37,120
step is actually critical for making
the MAC secure. So another class of

92
00:03:32,852 --> 00:03:37,120
实际上对构造一个安全的MAC是很重要的。另外一种把小规模

93
00:03:37,120 --> 00:03:41,511
construction for converting a small PRF
into a large PRF is called NMAC,

94
00:03:37,120 --> 00:03:41,511
PRF转换为大规模PRF构造MAC的方式称为NMAC

95
00:03:41,511 --> 00:03:46,264
for Nested MAC. Now, the NMAC starts
from PRF that, as before, takes inputs

96
00:03:41,511 --> 00:03:46,264
是为网状MAC。NMAC也是从PRF开始，像前面一样

97
00:03:46,264 --> 00:03:50,977
in X, but outputs elements in the key
space. And remember that for CBC, the

98
00:03:46,264 --> 00:03:50,977
输入为集合X重元素，但是输出是在密钥空间K。回忆前面的CBC

99
00:03:50,977 --> 00:03:56,136
output has to be in the set X. Here, the
output needs to be in the key space K. And

100
00:03:50,977 --> 00:03:56,136
输出必须在集合X中。这里输出在密钥空间K

101
00:03:56,136 --> 00:04:01,167
again, we basically obtain the PRF F-NMAC, which takes pairs of keys as inputs.

102
00:03:56,136 --> 00:04:01,167
这个基本上就是我们的FNMAC PRF了，它以两对密钥为输入

103
00:04:01,167 --> 00:04:06,008
Again, can process variable length
messages up until L blocks. And the output

104
00:04:01,167 --> 00:04:06,008
也能处理长度为L组以下的消息，输出是

105
00:04:06,008 --> 00:04:11,167
is an element in the key space. And the
way NMAC works is kind of, starts as

106
00:04:06,008 --> 00:04:11,167
密钥空间的一个元素，NMAC工作的方式，和

107
00:04:11,167 --> 00:04:16,313
before. We take our message, and we break
it into blocks. Each block is, again, as

108
00:04:11,167 --> 00:04:16,313
前面的类似。我们把消息分组，每个分组，和前面一样

109
00:04:16,313 --> 00:04:21,890
big as the block length of the underlying
PRF. And now we take our key and we feed

110
00:04:16,313 --> 00:04:21,890
和内置PRF的分组长度一样，现在我们把密钥作为函数

111
00:04:21,890 --> 00:04:27,171
our key as the key input into the function
F. And the message block is given as the

112
00:04:21,890 --> 00:04:27,171
F的密钥输入 这个消息分组也作为这个函数F

113
00:04:27,171 --> 00:04:32,515
data input into the function F. What comes
out is the key for the next block of NMAC.

114
00:04:27,171 --> 00:04:32,515
的输入 输出作为下一组NMAC的密钥

115
00:04:32,515 --> 00:04:37,414
So now we have a new key for the next
evaluation of the PRF. And the data for

116
00:04:32,515 --> 00:04:37,414
所以现在对这个PRF的下一组消息我们有了个新密钥，以此类推

117
00:04:37,414 --> 00:04:42,376
the next evaluation is the next message
block and so on and so forth until we

118
00:04:37,414 --> 00:04:42,376
对下一个消息进行函数变换，直到

119
00:04:42,376 --> 00:04:47,707
reach the final output. The final output
is gonna be an element in K. Okay? And

120
00:04:42,376 --> 00:04:47,707
我们得到最后的输出，最后的输出会是一个K中的元素，对吧？

121
00:04:47,707 --> 00:04:52,959
just as before, in fact, if we stop here.
The function that we obtain is called a

122
00:04:47,707 --> 00:04:52,959
和前面一样，实际上，如果我们这里就停了。这个函数我们称为

123
00:04:52,959 --> 00:04:57,938
cascade function. And we're gonna look at
cascade in more detail in just a minute.

124
00:04:52,959 --> 00:04:57,938
级联函数，我们再回来看一下这个级联

125
00:04:57,938 --> 00:05:02,734
So cascade will output an element in K.
However, that, as we'll see again, is not

126
00:04:57,938 --> 00:05:02,734
级联函数会输出一个K中的元素，但是，我们会看到，这不是

127
00:05:02,734 --> 00:05:07,529
a secure MAC. To get a secure MAC, what we
do is we need to map this element T,

128
00:05:02,734 --> 00:05:07,529
一个安全的MAC。为了获得安全的MAC，我们需要把这个

129
00:05:07,529 --> 00:05:12,679
which is in K, into the set X. And so,
typically, as we'll see, NMAC is used

130
00:05:07,529 --> 00:05:12,679
K中的元素t，映射到X中。基本上，我们会看到，NMAC

131
00:05:12,679 --> 00:05:18,495
with, PRFs, where the block length, X, is
much bigger than the key length. And so

132
00:05:12,679 --> 00:05:18,495
用到这些PRF，分组长度X要比密钥长度长得多。

133
00:05:18,495 --> 00:05:24,239
what we do is we simply append fixed pad.
fpad is called a fixed pad that gets

134
00:05:18,495 --> 00:05:24,239
就简单的固定填充就行。fpad称为固定填充，

135
00:05:24,239 --> 00:05:29,209
appended to this tag T. And then this
becomes, this input here, this block here

136
00:05:24,239 --> 00:05:29,209
就是对标签T附加些信息。然后这里，这个输入这里，这个分组

137
00:05:29,209 --> 00:05:33,885
becomes an element of X. We feed this into
the function, and again, notice here that

138
00:05:29,209 --> 00:05:33,885
成了了X中的元素，我们把这个输入给函数，再一次，

139
00:05:33,885 --> 00:05:38,334
there's an independent key that's being
used for the last encryption step. And

140
00:05:33,885 --> 00:05:38,334
注意到这里是一个独立的密钥，在最后一次加密中使用

141
00:05:38,334 --> 00:05:42,782
then finally, the last tag is an element
of K which we output as the output of

142
00:05:38,334 --> 00:05:42,782
最后，最后这个标签式一个K中的一个元素，我们作为NMAC的输出

143
00:05:42,782 --> 00:05:47,059
NMAC. So remember without the last
encryption step, the function is called a

144
00:05:42,782 --> 00:05:47,059
记住，如果没有最后这个加密步骤，这个函数称为

145
00:05:47,059 --> 00:05:51,393
cascade. With the last step as we'll see
which is necessary for security, we

146
00:05:47,059 --> 00:05:51,393
级联函数。有这个步骤，后面我们会看到对安全性来说是必要的，我们

147
00:05:51,393 --> 00:05:55,884
actually get a PRF which outputs elements
in K, and can process variable length

148
00:05:51,393 --> 00:05:55,884
得到了一个PRF，输出是K中的元素，可以处理变长度

149
00:05:55,884 --> 00:06:00,034
messages that are up to L blocks long.
Alright so that is the NMAC

150
00:05:55,884 --> 00:06:00,034
的消息，长度最长可到L个分组。好了，这就是NMAC

151
00:06:00,034 --> 00:06:06,587
construction. So now we have two MACs. That
we can use to build a large PRF, from AES,

152
00:06:00,034 --> 00:06:06,587
的构造。现在我们有了两个MAC。我们可以用AES来构造大型的PRF

153
00:06:06,587 --> 00:06:11,023
basically. So before I analyze the
security of MAC constructions, I'd like

154
00:06:06,587 --> 00:06:11,023
前面，我分析过了MAC的安全性，我希望

155
00:06:11,023 --> 00:06:15,170
you to understand better what the last
encryption step is for. So, let's start

156
00:06:11,023 --> 00:06:15,170
你们能更好地理解最后一步加密是为了什么。好，让我们从NMAC开始。

157
00:06:15,170 --> 00:06:19,533
with NMAC. So I explained that it
is actually very easy too see that if we

158
00:06:15,170 --> 00:06:19,533
这个我解释起来实际上很容易知道，如果我们

159
00:06:19,533 --> 00:06:23,573
omitted the last encryption step. In other
words, if we just use the cascade

160
00:06:19,533 --> 00:06:23,573
省掉了最后一步加密，换句话说，如果我们只用这个

161
00:06:23,573 --> 00:06:27,936
function, then the MAC will be completely
insecure. Okay so suppose we look at this

162
00:06:23,573 --> 00:06:27,936
级联函数，MAC就完全不安全了，好，现在假设我们来

163
00:06:27,936 --> 00:06:32,298
MAC to find over here. In other words, all
we do is we output directly the cascade

164
00:06:27,936 --> 00:06:32,298
看一下这个MAC的问题。也就是说，我们做的就是直接从这个级联

165
00:06:32,298 --> 00:06:36,661
applied to m without the last encryption
step. So let me ask you how do you forge

166
00:06:32,298 --> 00:06:36,661
输出m的结果，不用最后一步加密。我问一下，你怎么能复制出一个标签？

167
00:06:36,661 --> 00:06:40,809
tags in this MAC. And I guess I've kinda
given it away that this answer isn't

168
00:06:36,661 --> 00:06:40,809
在这个MAC中。我想我基本上帮你把这个答案排除掉

169
00:06:40,809 --> 00:06:45,360
correct. So I hope everybody sees that the
answer is, that, in fact, given one chosen

170
00:06:40,809 --> 00:06:45,360
正确。我希望每个人都选这个答案，实际上，给定一个

171
00:06:45,360 --> 00:06:49,203
message query, you can mount an
existential forgery. And the reason is,

172
00:06:45,360 --> 00:06:49,203
选择消息质询，你可以构造一个存在伪造。原因是

173
00:06:49,203 --> 00:06:53,769
I'll show you in a second in the diagram,
but let me write it out in symbols first.

174
00:06:49,203 --> 00:06:53,769
在这个图里我会给你解释一下，但是让我先用符号把它写出来

175
00:06:53,769 --> 00:06:58,113
The reason if, if you're given the output
of the cascade function applied to a

176
00:06:53,769 --> 00:06:58,113
原因是，如果你有这个消息m的级联函数的的输出

177
00:06:58,113 --> 00:07:02,918
message M. I can derive from it, me being
the adversary, I can derive from it the

178
00:06:58,113 --> 00:07:02,918
我可以从它推导出，我作为敌手，我可以从它推导出

179
00:07:02,918 --> 00:07:07,541
cascade applied to the message M
concatenated W for any message W, for any

180
00:07:02,918 --> 00:07:07,541
消息m和任意消息w串接的级联函数值，任意w。

181
00:07:07,541 --> 00:07:11,851
W. So first of all, it should be clear
that this is enough to mount an

182
00:07:07,541 --> 00:07:11,851
首先，应该清楚，这个足以让我们推导出一个

183
00:07:11,851 --> 00:07:17,287
existential forgery because essentially by
asking for a tag on this message I obtain

184
00:07:11,851 --> 00:07:17,287
存在伪造，因为基本上，有这个消息的标签，我

185
00:07:17,287 --> 00:07:22,472
the tag on this longer message which I can
then output as my forgery. Okay, so the

186
00:07:17,287 --> 00:07:22,472
就可以得到这个长消息的标签，那我就能得到我的伪造了。

187
00:07:22,472 --> 00:07:27,720
MAC is insecure because given a MAC in one
message, I can produce the MAC in another

188
00:07:22,472 --> 00:07:27,720
好，所以这个MAC是不安全的，因为给出一个消息的MAC，我可以构造出另一个

189
00:07:27,720 --> 00:07:32,259
message. But let's go back to the diagram
describing cascade, and see why this is

190
00:07:27,720 --> 00:07:32,259
消息的MAC。但是让我们回来看一下这个描述级联的图，看一下为什么会这样

191
00:07:32,259 --> 00:07:36,243
true. And so let's see what happens if
this last step isn't there. As an

192
00:07:32,259 --> 00:07:36,243
让我们看一下如果这里没有这个最后一步会怎样。作为一个

193
00:07:36,243 --> 00:07:40,451
attacker, what I can do, I can add one
more block here, which we called W. And

194
00:07:36,243 --> 00:07:40,451
攻击者，我能做的是，我可以在这里加一个分组，我称它为w，接着

195
00:07:40,451 --> 00:07:44,660
then, then basically, I can take the
output of cascade, which is this value T.

196
00:07:40,451 --> 00:07:44,660
我用级联的输出这个值T

197
00:07:44,660 --> 00:07:49,731
And we can simply apply the function F to
it again. So here I'll take this T value.

198
00:07:44,660 --> 00:07:49,731
输入到函数F中，所以我把这个T输入到

199
00:07:49,731 --> 00:07:54,995
I'll plug it in to F. And plug my last
block W into it and what I'll get is T

200
00:07:49,731 --> 00:07:54,995
F，把我最后一个分组w也输入，这样我得到t'，

201
00:07:54,995 --> 00:08:00,520
prime which is, well, the evaluation of
cascade on the message M concatenated W.

202
00:07:54,995 --> 00:08:00,520
T'是消息m串接w的级联输出，

203
00:08:00,520 --> 00:08:04,661
In [inaudible] calculated t prime, which I can use
for my existential forgery. Okay, so this

204
00:08:00,520 --> 00:08:04,661
计算t',我就得到我的存在伪造。好

205
00:08:04,661 --> 00:08:08,753
kind of shows you why this property of
cascade holes. This is called an extension

206
00:08:04,661 --> 00:08:08,753
这个大概给你说明了，为什么级联是有漏洞的，这个称为

207
00:08:08,753 --> 00:08:12,945
attack, Where giving a tag of the message
m I can deduce the tag for the extension

208
00:08:08,753 --> 00:08:12,945
延展攻击，有消息m的标签，我可以推导出m的延伸消息的标签。

209
00:08:12,945 --> 00:08:16,728
of m. And in fact for any extension of my
choice. So basically, Cascade is

210
00:08:12,945 --> 00:08:16,728
实际上，我可以随我所愿进行延展。所以，本质上，级联函数式

211
00:08:16,728 --> 00:08:20,917
completely insecure if we don't do this
last encryption step, and the last

212
00:08:16,728 --> 00:08:20,917
完全不安全的。如果我们不做最后的这一步加密。最后的这一步

213
00:08:20,917 --> 00:08:25,420
encryption step here basically prevents
this type of extension attack. I can tell

214
00:08:20,917 --> 00:08:25,420
加密就是为了防止这种延展攻击的。我可以告诉大家

215
00:08:25,420 --> 00:08:29,349
you by the way that in fact extension
attacks are the only attacks on a cascade

216
00:08:25,420 --> 00:08:29,349
用这种方法延展攻击时级联方式的唯一攻击

217
00:08:29,349 --> 00:08:33,706
and that could be made to precise. But I'm
not gonna do that here. The next question

218
00:08:29,349 --> 00:08:33,706
可确定的。但是这里我就不说了。

219
00:08:33,706 --> 00:08:38,091
is, why did we have the extra encryption
block in the ECBC construction? So again,

220
00:08:33,706 --> 00:08:38,091
那接下来的问题是 我们为什么要在ECBC里面构造额外加密块呢

221
00:08:38,091 --> 00:08:42,312
let me show you that without this extra
encryption block ECBC is insecure. So

222
00:08:38,091 --> 00:08:42,312
让我再一次向你们说明 没有额外加密块的ECBC是不安全的

223
00:08:42,312 --> 00:08:46,752
let's define a map that uses raw CBC. In
other words, it's the same as CBC MAC, but

224
00:08:42,312 --> 00:08:46,752
我们用简化CBC定义一个映射 也就是说 跟CBC MAC一样

225
00:08:46,752 --> 00:08:51,028
without the last encryption step. And
let's see that, that MAC is also insecure.

226
00:08:46,752 --> 00:08:51,028
但是没有最后的加密步骤 我们来看 这个MAC依然不安全

227
00:08:51,028 --> 00:08:55,249
Except now, the attack is a little bit
more difficult than a simple extension

228
00:08:51,028 --> 00:08:55,249
除非是遭到一个比扩展攻击还难的攻击

229
00:08:55,249 --> 00:08:59,360
attack. So suppose the attacker is given
this value, the raw CBC value for a

230
00:08:55,249 --> 00:08:59,360
假设攻击者给定这个值 简化CBC M值为

231
00:08:59,360 --> 00:09:03,592
particular message M. And now, the
attacker wants to extend and compute the

232
00:08:59,360 --> 00:09:03,592
特定的消息 现在攻击者想要就一些

233
00:09:03,592 --> 00:09:08,692
MAC on some message M, concatenated on
with some word W. So here's our W well the

234
00:09:03,592 --> 00:09:08,692
与w串接的消息m对MAC进行扩展和计算 这是我们的w

235
00:09:08,692 --> 00:09:13,377
core attacker can take this value and try
to XOR the two together but now you

236
00:09:08,692 --> 00:09:13,377
而核心攻击者可以得到这个值 然后试图将它们两个异或到一起

237
00:09:13,377 --> 00:09:18,046
realize he has to evaluate the function.
At this point. But he doesn't know what

238
00:09:13,377 --> 00:09:18,046
但是你会意识到 他必须计算这个函数 此时他并不知道

239
00:09:18,046 --> 00:09:22,814
this key K is. And as a result, he doesn't
know what the output of the function is.

240
00:09:18,046 --> 00:09:22,814
密钥k是什么 因此 他也无法知道函数的输出是什么

241
00:09:22,814 --> 00:09:27,112
So he simply can't just depend on
block W, and compute the value of

242
00:09:22,814 --> 00:09:27,112
所以 他不能简单地依靠分组w  计算出简化CBC

243
00:09:27,112 --> 00:09:31,763
raw CBC on N concatenated W. However, it
turns out that he can actually evaluate

244
00:09:27,112 --> 00:09:31,763
对n串接w的值 最终他不能计算这个函数

245
00:09:31,763 --> 00:09:36,234
this function. By using the chosen message
attack. And I wanna show you how to do

246
00:09:31,763 --> 00:09:36,234
如果使用选择消息攻击 我来告诉你们怎么做

247
00:09:36,234 --> 00:09:40,600
that. Okay, so we said that basically so
our goal is to show raw CBC is insecure.

248
00:09:36,234 --> 00:09:40,600
我们说 我们的目标是说明简化CBC是不安全的

249
00:09:40,600 --> 00:09:45,298
So let's look at a particular attack. So
in the attack, the adversary is going to

250
00:09:40,600 --> 00:09:45,298
我们来看一个典型的攻击 在这个攻击里 对手将从

251
00:09:45,298 --> 00:09:49,810
start by requesting the tag on a
particular message m that's a one-block

252
00:09:45,298 --> 00:09:49,810
对一个特殊消息m请求标签开始 这是一个单分组消息

253
00:09:49,810 --> 00:09:54,755
message. So what does it mean to apply CBC
to a one-block message? Well basically,

254
00:09:49,810 --> 00:09:54,755
那把CBC应用到一个单分组消息是什么意思呢 事实上

255
00:09:54,755 --> 00:09:59,701
all you do is you just apply the function
f directly. So what you get is the tag,

256
00:09:54,755 --> 00:09:59,701
你们所做的仅仅是直接应用这个函数f 所以你们可以得到一个标签

257
00:09:59,701 --> 00:10:04,421
which is just the application of f
directly to the one-block message m. Good,

258
00:09:59,701 --> 00:10:04,421
刚好是f直接到单分组消息m的应用 好

259
00:10:04,421 --> 00:10:09,586
so now the adversary has this value T. And
now I claim that he can define this

260
00:10:04,421 --> 00:10:09,586
现在对手得到了t的值 我申明他可以定义这个消息为

261
00:10:09,586 --> 00:10:14,487
message, M prime, which contains two
blocks. The first block is M, the second

262
00:10:09,586 --> 00:10:14,487
m' 它包含两个分组 第一个分组是m 第二个

263
00:10:14,487 --> 00:10:19,917
block is T XOR M. And I claim that the
value T that he just received is a valid

264
00:10:14,487 --> 00:10:19,917
分组是t异或m 我申明他刚得到的t值是对m'的这两个

265
00:10:19,917 --> 00:10:24,726
tag for this two block message, M Prime.
So let's see why that's true. Well, so

266
00:10:19,917 --> 00:10:24,726
分组消息的有效标记 我们来看这为什么是正确的

267
00:10:24,726 --> 00:10:29,782
suppose we apply the raw CBC construction
to this message M prime. So if you plug it

268
00:10:24,726 --> 00:10:29,782
假设我们我们把这个简化CBC构造应用到这个消息m' 如果

269
00:10:29,782 --> 00:10:34,296
in directly what, let's see. The way it
would work is first of all, the first

270
00:10:29,782 --> 00:10:34,296
你把它直接加进去 它将计算第一个

271
00:10:34,296 --> 00:10:39,213
message M is processed by encrypting it
directly using the function F. Then we XOR

272
00:10:34,296 --> 00:10:39,213
消息m是直接用函数f进行加密的 然后

273
00:10:39,213 --> 00:10:44,774
the results with the second block
with is T-XOR-M. And then we apply F to

274
00:10:39,213 --> 00:10:44,774
我们将结果与第二个分组进行异或 然后我们

275
00:10:44,774 --> 00:10:49,984
the results of that. That is the
definition of raw CBC. Now what do we know about

276
00:10:44,774 --> 00:10:49,984
把f应用到刚才的结果上 这是简化CBC的定义 那现在

277
00:10:49,984 --> 00:10:55,052
F(k,m)? F(k,m) is simply this value T by
definition. So the next step we get is

278
00:10:49,984 --> 00:10:55,052
我们对F(k,m)了解多少呢 F(k,m)仅仅是定义中的t值 下一步

279
00:10:55,052 --> 00:11:00,542
essentially T-XOR-T-XOR-M. But
this T- XOR-T simply goes away and what

280
00:10:55,052 --> 00:11:00,542
我们要做的是t异或t异或m 但是这个t异或t没有作用

281
00:11:00,542 --> 00:11:06,134
we get is F(k,m). Which is, of course, T.
And as a result, T is a valid MAC for the

282
00:11:00,542 --> 00:11:06,134
我们将得到F(k,m) 也就是t 因此t是这个双分组消息的

283
00:11:06,134 --> 00:11:11,505
two block message, (M, T-XOR-M). So
the adversary was able to produce this

284
00:11:06,134 --> 00:11:11,505
一个有效MAC (M, T-XOR-M) 所以对手可以为这个

285
00:11:11,505 --> 00:11:16,553
valid tag T for this two block message
that he never queried. And therefore, he

286
00:11:11,505 --> 00:11:16,553
双分组消息制作一个标签 他不用查询 因此

287
00:11:16,553 --> 00:11:20,195
was able to break the MAC. So let's look
at the ECBC diagram for just one more

288
00:11:16,553 --> 00:11:20,195
他就能够成功攻击这个MAC 我们看一下这个ECBC图

289
00:11:20,195 --> 00:11:24,071
second. And let me point out that if you
don't include this last encryption step in

290
00:11:20,195 --> 00:11:24,071
我要指出的是 如果你们在MAC的计算中不使用

291
00:11:24,071 --> 00:11:27,806
the computation of the MAC, essentially,
the MAC would be insecure because of the

292
00:11:24,071 --> 00:11:27,806
最后这一步的加密 事实上 这个MAC将因为我们

293
00:11:27,806 --> 00:11:31,728
attack that we just saw. And I'll tell you
that there are many products that do this

294
00:11:27,806 --> 00:11:31,728
刚才讲到的攻击而不安全 我要说的是这样会有很多

295
00:11:31,728 --> 00:11:35,323
incorrectly. And, in fact, there are even
standards that do this incorrectly, so

296
00:11:31,728 --> 00:11:35,323
不正确的结果 事实上甚至有标准 这样做不正确

297
00:11:35,323 --> 00:11:39,012
that the resulting MAC is insecure. You
now know that this needs to be done, and

298
00:11:35,323 --> 00:11:39,012
这就是MAC不安全的原因 你们现在知道要做这个

299
00:11:39,012 --> 00:11:43,080
you won't make this mistake yourself. So
let's state the CBC and NMAC security

300
00:11:39,012 --> 00:11:43,080
并且你们自己不会犯这样的错误 我要声明CBC

301
00:11:43,080 --> 00:11:47,817
theorems. And so the statement is as usual
for any message length that we'd like to,

302
00:11:43,080 --> 00:11:47,817
和NMAC安全定理 这个声明同样对可以应用

303
00:11:47,988 --> 00:11:52,269
apply the MAC to. Essentially for every
PRF adversary A, there's an efficient

304
00:11:47,988 --> 00:11:52,269
这个MAC的任何消息长度有效 事实上对每个PRF对手A

305
00:11:52,269 --> 00:11:56,778
adversary B and, you know, these are kind
of the usual statements. Where, the facts

306
00:11:52,269 --> 00:11:56,778
有一个非常高效的对手B 你知道这有点像常用语句

307
00:11:56,778 --> 00:12:01,458
that you need to know are the error terms
which are kind of similar in both cases.

308
00:11:56,778 --> 00:12:01,458
事实上你要知道的是这些错误项在这两种情况下很相似

309
00:12:01,458 --> 00:12:06,139
By the way, I'd like to point out that the
analysis for CBC actually uses the fact

310
00:12:01,458 --> 00:12:06,139
另外 我要指出的是对CBC的分析其实本质是

311
00:12:06,139 --> 00:12:10,938
that F is a PRP even though we never had
to invert F during the computation of

312
00:12:06,139 --> 00:12:10,938
f是PRF 即使我们在计算ECBC时不会逆用f

313
00:12:10,938 --> 00:12:16,279
ECBC, the analysis is better if you assume
that F is actually a PRP. In other words,

314
00:12:10,938 --> 00:12:16,279
但是如果你假设f是PRF 这个分析会更好 也就是说

315
00:12:16,279 --> 00:12:21,489
it's invertible, not just a function. For
a MAC, the PRF need not be invertible.

316
00:12:16,279 --> 00:12:21,489
它是可逆的 而不仅仅是一个函数 对一个MAC PRF不需要是可逆的

317
00:12:21,489 --> 00:12:26,829
So what these error terms basically say
is that these MACs are secure, as long as,

318
00:12:21,489 --> 00:12:26,829
所以这些错误项本质上是说明这些MACs是安全的 就像

319
00:12:26,829 --> 00:12:32,330
key is not used to MAC more than square
root of X or square root of K messages. So

320
00:12:26,829 --> 00:12:32,330
密钥不像平方根的X或K消息的平方根那样多用于MAC

321
00:12:32,330 --> 00:12:36,714
for AES of course this would be a two to
the 64. But I want to show you an example

322
00:12:32,330 --> 00:12:36,714
所以对AES过程 这是2的64次方 我要给你们一个例子

323
00:12:36,714 --> 00:12:40,937
of how you would use these bounds. So
here, I've stated the security theorem again

324
00:12:36,714 --> 00:12:40,937
关于你们怎么运用这些边界 这里我要再一次声明

325
00:12:40,937 --> 00:12:45,321
for the CBC MAC, and Q here, again, is the
number of messages that are MACed with a

326
00:12:40,937 --> 00:12:45,321
关于CBC MAC的安全协议 这里的Q是被特定密钥MACed

327
00:12:45,321 --> 00:12:49,598
particular key. So suppose we wanted to
ensure that for all adversaries that the

328
00:12:45,321 --> 00:12:49,598
的消息数量 假设我们要像所有的对手验证

329
00:12:49,598 --> 00:12:53,875
adversary has an advantage of less than
one over two to the 32 in distinguishing

330
00:12:49,598 --> 00:12:53,875
敌手区分一个prf和真正随机函数的优势（可能性）

331
00:12:53,875 --> 00:12:57,781
the PRF from a truly random function.
Suppose that is our goal. Well, by the

332
00:12:53,875 --> 00:12:57,781
少于2的32次方分之一 假设这就是我们要做的

333
00:12:57,781 --> 00:13:01,673
security theorem, what that means is we
need to ensure that Q squared over X is

334
00:12:57,781 --> 00:13:01,673
根据安全定理 那意味着我们要证明 x绝对值分之q的平方

335
00:13:01,673 --> 00:13:05,515
less than one over two to the 32, right.
We want this term to be, well, I'm going

336
00:13:01,673 --> 00:13:05,515
少于2的32次方分之一 是的 我们希望这一项

337
00:13:05,515 --> 00:13:09,210
to ignore this two here just for
simplicity. We want to ensure this term is

338
00:13:05,515 --> 00:13:09,210
我准备忽略这两个以示讲解简略 我们要证明这一项比

339
00:13:09,210 --> 00:13:13,201
less than one over two to the 32 and this
term, of course, is negligible, so we can

340
00:13:09,210 --> 00:13:13,201
2的32次方分之一少 当然 这一项是可以忽略不计的 所以

341
00:13:13,201 --> 00:13:17,914
just ignore it. This would imply that this
term is also less than one over two to the

342
00:13:13,201 --> 00:13:17,914
我们只好忽略它 这就意味着它也比2的32次方分之一少

343
00:13:17,914 --> 00:13:22,683
32. Okay, so if we want to ensure that the
advantage is less than one over two to the

344
00:13:17,914 --> 00:13:22,683
好 如果我们要证明其优势少于2的32次方分之一

345
00:13:22,683 --> 00:13:27,396
32, we need to ensure that Q squared over
X is less than one over two to the 32. For

346
00:13:22,683 --> 00:13:27,396
那就是要证明x绝对值分之q的平方少于2的32次方分之一

347
00:13:27,396 --> 00:13:31,881
AES, basically this means that after MACing
two to the 48 messages, you have to

348
00:13:27,396 --> 00:13:31,881
对AES 这就意味着对2的48次方个消息做MAC后

349
00:13:31,881 --> 00:13:35,970
change your key. Otherwise, you won't
achieve the security level. So you can

350
00:13:31,881 --> 00:13:35,970
你必须更换你的密钥 否则的话 你将无法达到安全水平

351
00:13:35,970 --> 00:13:40,412
MAC, at most, two to the 48 messages. You
notice that if I plug in triple DES, which

352
00:13:35,970 --> 00:13:40,412
因此你最多只能MAC2的48次方个消息 你注意到如果我用三重DES

353
00:13:40,412 --> 00:13:44,526
has a much shorter block, only 64 bits.
The same result says you now have to

354
00:13:40,412 --> 00:13:44,526
它有很多短分组 仅仅64比特 结果同意告诉你

355
00:13:44,526 --> 00:13:48,592
change your key every 65,000 messages. So
this basically is quite problematic

356
00:13:44,526 --> 00:13:48,592
必须每65000个消息换一次密钥 然而 很麻烦的是

357
00:13:48,592 --> 00:13:52,202
whereas this is fine. This is actually a,
a very fairly large number. For

358
00:13:48,592 --> 00:13:52,202
这没有关系 这其实是一个相当巨大对的数目了

359
00:13:52,202 --> 00:13:56,117
AES this means you have to change
your key only every 16 billion

360
00:13:52,202 --> 00:13:56,117
对AES来说 你每160亿个消息只换一次密钥

361
00:13:56,117 --> 00:14:00,000
messages which is perfectly reasonable.
And so this is one of the reasons why AES

362
00:13:56,117 --> 00:14:00,000
是相当合理的 这就是AES具有比三重DES

363
00:14:00,000 --> 00:14:03,657
has a larger block, than triple DES. Some of these modes remain

364
00:14:00,000 --> 00:14:03,657
大的分组的原因之一 三重DES中的一些模式

365
00:14:03,657 --> 00:14:07,410
secure and you don't have to change your
key as often as you would with triple

366
00:14:03,657 --> 00:14:07,410
依然安全 你不必那样频繁的更换你的密钥

367
00:14:07,410 --> 00:14:12,076
DES. Okay, so I want to show you
that in fact these attacks are not just in

368
00:14:07,410 --> 00:14:12,076
所以我要告诉你们的是 事实上攻击者们在安全理论中

369
00:14:12,076 --> 00:14:16,876
the statements in the security theorem, in
fact there really are real attacks that

370
00:14:12,076 --> 00:14:16,876
不仅是这样的状态 其实真的存在真是的攻击者

371
00:14:16,876 --> 00:14:21,616
correspond to these values. Now the macs
really do become insecure after you sign,

372
00:14:16,876 --> 00:14:21,616
他们对应使用这些值 那这些MAC在你对x的平方根

373
00:14:21,616 --> 00:14:26,474
you know, square root of X or square root
of K messages. So I'm going to show you an

374
00:14:21,616 --> 00:14:26,474
或者k的平方根个消息签名之后将不再安全 我要

375
00:14:26,474 --> 00:14:30,688
attack on both PRFs so either ECBC or
NMAC. Assuming that the underlying

376
00:14:26,474 --> 00:14:30,688
给你讲一个对PRF的攻击 是ECBC或者NMAC 假设

377
00:14:30,688 --> 00:14:35,195
function is a PRP, is actually a block
cipher like AES. Let's call F big, let's

378
00:14:30,688 --> 00:14:35,195
这个下面的函数是个PRP 这其实就像是AES一样的分组加密 我们叫它F big

379
00:14:35,195 --> 00:14:40,053
say that F big is either F ECBC or F NMAC.
So F big means that it's a PRF for large

380
00:14:35,195 --> 00:14:40,053
我们说F big是F ECBC或F NMAC 所以F big是一个大消息的PRF

381
00:14:40,053 --> 00:14:44,293
messages. Now, it turns out both
constructions have the following extension

382
00:14:40,053 --> 00:14:44,293
结果这两种构造都具有以下扩展属性

383
00:14:44,293 --> 00:14:49,859
property. Namely, if you give me a
collision. On messages X and Y. Then, in

384
00:14:44,293 --> 00:14:49,859
也就是 如果你给我一个碰撞 向消息x和y

385
00:14:49,859 --> 00:14:54,669
fact, that also implies a collision on an
extension of X and Y. In other words, if I

386
00:14:49,859 --> 00:14:54,669
事实上 这也意味着对消息x和y的扩展的碰撞 换句话说

387
00:14:54,669 --> 00:14:59,480
append W to both X and Y, I'll also get a
collision on the resulting words. So it's

388
00:14:54,669 --> 00:14:59,480
如果我吧w同时附加在x和y上 我将完成一个对结果字的碰撞

389
00:14:59,480 --> 00:15:04,349
fairly easy to convince yourself that this
extension property holds, you do it just

390
00:14:59,480 --> 00:15:04,349
所以这相当容易使你自己坚信对扩展属性的持有 你

391
00:15:04,349 --> 00:15:08,925
by staring at the diagram for a second.
And so imagine I give you two messages

392
00:15:04,349 --> 00:15:08,925
只是看了这个图表几秒钟就做到了 想象我给你的

393
00:15:08,925 --> 00:15:13,559
that happen to collide at this point. Now
remember, I assumed that F is a PRP. So

394
00:15:08,925 --> 00:15:13,559
两个消息在这一点上发生碰撞 记住我假设f是一个PRP

395
00:15:13,559 --> 00:15:18,018
once you fix K1, it's a one to one
function. So if the two messages happen to

396
00:15:13,559 --> 00:15:18,018
所以一旦你固定k1 这就是一个1对1函数 如果这两个消息

397
00:15:18,018 --> 00:15:23,023
map to the same value at the output. This
means they also happen to map to the same

398
00:15:18,018 --> 00:15:23,023
在输出映射到同一个集合 这意味着它们在简化CBC里

399
00:15:23,023 --> 00:15:27,457
value at the output of the raw CBC
function. But if they map to the same

400
00:15:23,023 --> 00:15:27,457
输出也是映射到同一个集合 但是如果它们在简化CBC里

401
00:15:27,457 --> 00:15:32,198
value at the output of the raw CBC
function, that means that if I add another

402
00:15:27,457 --> 00:15:32,198
输出也映射到同一个集合 那就意味着然后我添加其他的分组

403
00:15:32,198 --> 00:15:37,584
block, let's call it a W. And I take this
output here. Then I'm computing the same

404
00:15:32,198 --> 00:15:37,584
姑且称之为w 我得到这个输出结果 计算出两个

405
00:15:37,584 --> 00:15:43,162
value for both messages. And I'll get, for
both messages, I'll get the same value at

406
00:15:37,584 --> 00:15:43,162
消息的值 我同样能得到这两个消息在这一点上

407
00:15:43,162 --> 00:15:47,991
this point, too. And when I encrypt,
again, with K1, I'll also get, you know,

408
00:15:43,162 --> 00:15:47,991
的相同值 当我再一次用k1加密时 我也会

409
00:15:47,991 --> 00:15:53,501
so there's one more F here. I'll also get
the same output, final output, after I've

410
00:15:47,991 --> 00:15:53,501
得到另外的一个f 以及相同的输出 最终的输出

411
00:15:53,501 --> 00:15:58,123
appended the block W. Okay, so if the two
values happen to be the same for two

412
00:15:53,501 --> 00:15:58,123
在我附加了分组w之后 所以一旦两个不同的消息

413
00:15:58,123 --> 00:16:02,741
distinct messages. If I appended block W
to both messages, I'm still gonna get the

414
00:15:58,123 --> 00:16:02,741
的值相同 如果我同时对两个消息附加了分组w 我同样会

415
00:16:02,741 --> 00:16:07,189
same value out. It's easy to convince
yourself that the same is true for NMAC

416
00:16:02,741 --> 00:16:07,189
得到相同的输出 这也使你相信 对NMAC 相同是对的

417
00:16:07,189 --> 00:16:12,144
as well. Okay, so both of these, PRFs have
this extension property. So based on this,

418
00:16:07,189 --> 00:16:12,144
这些PRP同时具有扩展属性 基于此

419
00:16:12,144 --> 00:16:17,347
we can define an attack. So here's the
extension property stated again. And the

420
00:16:12,144 --> 00:16:17,347
我们可以定义一个攻击 又是一个具有扩展属性的状态

421
00:16:17,347 --> 00:16:22,350
attack would work as follows. Suppose I
issued square of Y chosen message

422
00:16:17,347 --> 00:16:22,350
这个攻击工作如下 假设我选择以y的二分之一次方

423
00:16:22,350 --> 00:16:27,567
queries. So, for AES, remember, the value
of Y is basically {0,1} to the 128. So this

424
00:16:22,350 --> 00:16:27,567
发布信息的查询 对AES 要记得y的值是{0,1}的128次方

425
00:16:27,567 --> 00:16:33,178
would mean that I would be asking, two to
the 64 shows in message queries. For just

426
00:16:27,567 --> 00:16:33,178
这意味着我要回应2的64次方的信息查询

427
00:16:33,178 --> 00:16:38,142
arbitrary messages in the input space.
Well, what will happen is, I'll obtain,

428
00:16:33,178 --> 00:16:38,142
对在输入空间中任意的消息 会发生的是 我会得到

429
00:16:38,142 --> 00:16:42,975
well, I'll obtain two to the 64 message
MAC pairs. Now, we're gonna see in the

430
00:16:38,142 --> 00:16:42,975
我会得到2的64次方个MAC消息对儿 我们来看下一个

431
00:16:42,975 --> 00:16:48,126
next module, actually, there's something
called a birthday paradox. Some of you may

432
00:16:42,975 --> 00:16:48,126
模块 事实上有一个理论称作生日悖论 你们中有人可能

433
00:16:48,126 --> 00:16:53,150
have heard of it already. It basically
says that if I have two to the 64 random

434
00:16:48,126 --> 00:16:53,150
已经听说过了 它讲的是如果你有2的64次方个随机元素

435
00:16:53,150 --> 00:16:58,046
elements of a space of size two to the
128, there's a good chance that two of

436
00:16:53,150 --> 00:16:58,046
存在于大小为2的128次方的空间 则其中两个元素相同

437
00:16:58,046 --> 00:17:02,879
them are the same. So I'm gonna look for
two distinct messages. MU and MV, for

438
00:16:58,046 --> 00:17:02,879
的概率会很大 我要找两个不同的消息 分别是Mu和Mv

439
00:17:02,879 --> 00:17:08,120
which the corresponding MACs are the same.
Okay, and as I said, by the birthday

440
00:17:02,879 --> 00:17:08,120
它们相对应的MAC相同 如我所讲 给予生日悖论

441
00:17:08,120 --> 00:17:14,070
paradox, these are very likely to exist.
Once I have that, now I've basically found

442
00:17:08,120 --> 00:17:14,070
这些很有可能存在 一旦我有了这些 就会发现

443
00:17:14,070 --> 00:17:19,947
MU and MV to have the same MAC. And as a
result, what I can do is, I can extend MU

444
00:17:14,070 --> 00:17:19,947
Mu和Mv有相同的MAC 因此 我可以根据生日悖论

445
00:17:19,947 --> 00:17:25,810
with an arbitrary word W, and ask for the
tag for the word MU concatenated W. But

446
00:17:19,947 --> 00:17:25,810
用w来扩展Mu 为Mu逻辑或w索要标签

447
00:17:25,810 --> 00:17:31,631
because NU and NV happen to have the same
output, I know that NU concatenated W has

448
00:17:25,810 --> 00:17:31,631
但是由于Nu和Nv也有相同的输出 那我可以得到Nu逻辑或w

449
00:17:31,631 --> 00:17:37,312
the same output as NV concatenated W. So
now that I've obtained the output for NU

450
00:17:31,631 --> 00:17:37,312
同Nv逻辑或w也有相同输出 因此我得到了Nu逻辑或

451
00:17:37,312 --> 00:17:42,953
concatenated W, I also have the output for
NV concatenated W. And therefore I have

452
00:17:37,312 --> 00:17:42,953
w的值 同时也得到了Nv逻辑或w的值 因此我得到了

453
00:17:42,953 --> 00:17:47,564
obtained my forgery. Okay, so now T is
also a forgery for the message MV

454
00:17:42,953 --> 00:17:47,564
我的伪码 现在t也是Mv逻辑或w的一个伪码

455
00:17:47,564 --> 00:17:52,695
concatenated W which I've never asked
before. And therefore, this is as valid as

456
00:17:47,564 --> 00:17:52,695
这是我之前从来没有要求过的 所以这跟潜在的

457
00:17:52,695 --> 00:17:57,890
a potential forgery. Okay, so this is kind
of an acute attack and the bottom line

458
00:17:52,695 --> 00:17:57,890
伪码一样有效 这是比较严重的攻击 最后一行

459
00:18:00,520 --> 00:18:03,151
here is that in fact after square root of
Y queries, I am able to forge a MAC with

460
00:18:00,520 --> 00:18:03,151
事实上是继y的平方根之后的查询 我可以

461
00:18:03,151 --> 00:18:07,605
fairly good probability. Okay, so what
does square root of Y mean? If we go back

462
00:18:03,151 --> 00:18:07,605
以相当大的概率打造一个MAC 那y的平方根有什么意义

463
00:18:07,605 --> 00:18:12,055
to the security theorems, this means that
basically for ECBC after square root of X

464
00:18:07,605 --> 00:18:12,055
我们回到安全定理 这意味着对于ECBC后x的平方根

465
00:18:12,055 --> 00:18:16,129
or for NMAC after square root of K,
messages have been MACed, the MAC becomes

466
00:18:12,055 --> 00:18:16,129
或者NMAC后k的平方根 消息已被MAC MAC变得

467
00:18:16,129 --> 00:18:20,365
insecure and the attacker can actually
find new MACs for messages for which he

468
00:18:16,129 --> 00:18:20,365
不安全 攻击者可以为他从来没有给MAC的消息

469
00:18:20,365 --> 00:18:24,707
was never given a MAC for. So again, this
is an acute attack that shows the bounds

470
00:18:20,365 --> 00:18:24,707
寻找新的MAC 同样 这是一个严重的感觉 说明

471
00:18:24,707 --> 00:18:29,507
of the theorem really are real. And as a
result these downs that derived in this

472
00:18:24,707 --> 00:18:29,507
边界的定理是真实的 因此这个例子里面的波动

473
00:18:29,507 --> 00:18:34,688
example are real and you should never use
a single key to MAC more than, say, two

474
00:18:29,507 --> 00:18:34,688
也是真实的 所以你不能再用单密钥去MACAES或CBC的

475
00:18:34,688 --> 00:18:39,398
to 48 messages with AES based CBC. So to
conclude, I'll just mention that we've

476
00:18:34,688 --> 00:18:39,398
超过2的48次方个消息 总结来看 我只提我们讲过的

477
00:18:39,398 --> 00:18:44,705
seen two examples. We saw ECBC and NMAC.
ECBC is in fact, a very commonly used MAC

478
00:18:39,398 --> 00:18:44,705
两个例子 来看ECBC和NMAC ECBC是一种常用的MAC

479
00:18:44,705 --> 00:18:49,481
that's built from AES. 80211I, for example,
uses ECBC with AES for integrity.

480
00:18:44,705 --> 00:18:49,481
是从AES衍生而来 举个例子 80211t 使用ECBC和AES的完整性

481
00:18:49,481 --> 00:18:54,921
There's also a NIST standard called CMAC,
that we'll talk in the next segment, that

482
00:18:49,481 --> 00:18:54,921
还有一个NIST标准叫做CMAC 我们下一节课会讲

483
00:18:54,921 --> 00:19:00,095
also is based on the ECBC MAC. NMAC with
contrast is not typically used with a

484
00:18:54,921 --> 00:19:00,095
也是基于ECBC MAC的 NMAC对比于分组加密中

485
00:19:00,095 --> 00:19:05,270
block cipher. And the main reason is, in
order to [inaudible] in the NMAC construction,

486
00:19:00,095 --> 00:19:05,270
并不常用 主要原因是 为了NMAC构造中的【不可闻性】

487
00:19:05,270 --> 00:19:10,766
the key changes from block to block. That
means that the whole AES key expansion has

488
00:19:05,270 --> 00:19:10,766
从一个分组到另一个分组的密钥更换 这意味着整个AES扩展

489
00:19:10,766 --> 00:19:15,710
to be computed and recomputed on every
block. And AES is not designed to perform

490
00:19:10,766 --> 00:19:15,710
不得不计算和重新计算每一个分组 AES要频繁的更换密钥

491
00:19:15,710 --> 00:19:20,777
well when he changes key very rapidly. And
so, typically, when you use NMAC, you use

492
00:19:15,710 --> 00:19:20,777
这一点设计的不好 所以 当你使用NMAC的时候 用分组加密

493
00:19:20,777 --> 00:19:25,446
block ciphers that are better at changing
their keys on every block. And as a

494
00:19:20,777 --> 00:19:25,446
比对每个分组更改密钥要好一些 因此

495
00:19:25,446 --> 00:19:29,489
result, NMAC typically is not used with
AES. But in fact, N Mac is a basis of a

496
00:19:25,446 --> 00:19:29,489
NMAC通常不跟AES一起用 不过 其实NMAC是一个

497
00:19:29,489 --> 00:19:33,688
very popular MAC called HMAC, which we're
also gonna look at next. And you'll see

498
00:19:29,489 --> 00:19:33,688
非常流行的MAC的基础 我们称其为HMAC 也会在下节课讲

499
00:19:33,688 --> 00:19:37,835
very clearly, the NMAC underlying the HMAC construction. Okay, so that's the end

500
00:19:33,688 --> 00:19:37,835
你会清楚地看到 NAMC下面的HMAC的构造是怎样的

501
00:19:37,835 --> 00:19:41,309
of this segment, and we'll talk about more
MACs in the next segment.

502
00:19:37,835 --> 00:19:41,309
好 这节课就到这里 我们下节课再讲更多的MAC

