1
00:00:00,000 --> 00:00:04,220
在前面一节我们讨论了模逆 我们说过

2
00:00:00,000 --> 00:00:04,220
In the previous segment we talked about
modular inversion and we said the Euclid's

3
00:00:04,220 --> 00:00:08,238
欧几里德算法给了我们一个有效的寻找元素N的模逆的方式

4
00:00:04,220 --> 00:00:08,238
algorithm gives us an efficient way to
find the inverse of an element modulo N.

5
00:00:08,238 --> 00:00:12,256
在这一节我们将按时间顺序继续向后看

6
00:00:08,238 --> 00:00:12,256
In this segment we're going to forward
through time and we're going to move to

7
00:00:12,256 --> 00:00:15,866
我们来到17、18世纪 我们将要讨论费马和欧拉的贡献的年代

8
00:00:12,256 --> 00:00:15,866
the seventeenth and eighteenth century
where we're going to talk about

9
00:00:15,866 --> 00:00:19,986
在此之前 让我们快速复习一下上一节所讨论的内容

10
00:00:15,866 --> 00:00:19,986
Fermat and Euler contributions.
Before that let's do a quick review of

11
00:00:19,986 --> 00:00:24,257
向往常一样 我将会用N代表正整数

12
00:00:19,986 --> 00:00:24,257
what we discussed in the previous segment.
So as usual I'm going to let N denote the

13
00:00:24,257 --> 00:00:28,427
N也可以说是一个N位的正整数

14
00:00:24,257 --> 00:00:28,427
positive integer and let's just say that N
happens to be a n-bit integer, in other

15
00:00:28,427 --> 00:00:32,445
换句话说 它在2^n和2^(n+1)之间 同样 我用P代表素数

16
00:00:28,427 --> 00:00:32,445
words it's between two to the n and two to
the n+1, as usual we're going to let P

17
00:00:32,445 --> 00:00:36,761
现在我们说ZN是是一个从0到N-1的整数集合

18
00:00:32,445 --> 00:00:36,761
denote a prime. Now we said that
ZN is a set of integers from zero

19
00:00:36,761 --> 00:00:41,370
我们可以在模N的意义下对集合中度元素进行加法和乘法

20
00:00:36,761 --> 00:00:41,370
to N-1 and we said that we can add and
multiply elements in the set modulo N. We

21
00:00:41,370 --> 00:00:46,186
我们也说过ZN^*是集合ZN中全体可逆元素的集合

22
00:00:41,370 --> 00:00:46,186
also said that ZN star is basically the
set of invertible elements in ZN. And we

23
00:00:46,186 --> 00:00:51,243
我们证明过一个简单的引理 如果x与n互质那么X是可逆的

24
00:00:46,186 --> 00:00:51,243
proved a simple lemma to say that, X is
invertible if and only if X is relatively

25
00:00:51,243 --> 00:00:55,879
我们不仅明白了什么样的元素是可逆的什么样的是不可逆的

26
00:00:51,243 --> 00:00:55,879
prime to N. And not only did we
completely understand which elements are

27
00:00:55,879 --> 00:01:00,635
我们也给出了一个十分有效的建立在欧几里德扩展算法上面的算法

28
00:00:55,879 --> 00:01:00,635
invertible and which aren't, we also
showed a very efficient algorithm based on

29
00:01:00,635 --> 00:01:05,572
去在ZN中找到一个元素X的逆

30
00:01:00,635 --> 00:01:05,572
Euclid's extended algorithm, to find the
inverse of an element X in ZN. And we said

31
00:01:05,572 --> 00:01:10,388
我们说过 这个算法的复杂度是O(n^2)

32
00:01:05,572 --> 00:01:10,388
that the running time of this algorithm,
is basically order n squared, where

33
00:01:10,388 --> 00:01:16,107
n是大写字母N的位数 好的 像我之前所说的

34
00:01:10,388 --> 00:01:16,107
again, n is the number of bits of the
number capital N. So as I said, now

35
00:01:16,107 --> 00:01:21,037
我们将从古希腊时代来到17世纪

36
00:01:16,107 --> 00:01:21,037
we're going to move from Greek times all
the way to the seventeenth century and

37
00:01:21,037 --> 00:01:26,276
讨论费马 费马提出了很多十分重要的理论

38
00:01:21,037 --> 00:01:26,276
talk about Fermat. So Fermat did a number
of important theorems. The one that I want

39
00:01:26,276 --> 00:01:31,206
我今天想给大家看的其中之一就是 假设我给大家一个素数P

40
00:01:26,276 --> 00:01:31,206
to show you here today is the following.
So suppose I give you a prime P. Then in

41
00:01:31,206 --> 00:01:36,260
然后事实上在ZP*中任何一个元素 如果我研究X^(p-1)

42
00:01:31,206 --> 00:01:36,260
fact for any element X in ZP star, it so
happens that if I look at X and raise it

43
00:01:36,260 --> 00:01:41,130
我将会在ZP中得到1 好的 现在让我们来快速的看一个例子

44
00:01:36,260 --> 00:01:41,130
to the power of P - 1, I'm a gonna get
one, in ZP. So let's look at a quick

45
00:01:41,130 --> 00:01:46,061
假设我让P等于5 然后我来研究3^(P-1)

46
00:01:41,130 --> 00:01:46,061
example. Suppose I set the number P to be
five. And I look at, three to the power of

47
00:01:46,061 --> 00:01:50,645
换句话说 3^4 是81

48
00:01:46,061 --> 00:01:50,645
P-1. In other words, three to the power of
four, Three to the power of four is 81,

49
00:01:50,645 --> 00:01:55,286
事实上 在模5的意义下它是1 这个例子满足了费马定理

50
00:01:50,645 --> 00:01:55,286
which in fact, is one modulo five. This
example satisfies Fermat's theorem.

51
00:01:55,286 --> 00:01:59,521
有趣的是 事实上费马自己并没有证明这个定理

52
00:01:55,286 --> 00:01:59,521
Interestingly, Fermat actually didn't prove this theorem himself. The proof

53
00:01:59,521 --> 00:02:04,337
这个定理实际上要等到欧拉在将近100年之后才被证明

54
00:01:59,521 --> 00:02:04,337
actually waited until Euler, who
proved that almost 100 years later. And in

55
00:02:04,337 --> 00:02:09,122
事实上 他证明了这个定理的更具有普适性的一个版本

56
00:02:04,337 --> 00:02:09,122
fact, he proved a much more general
version of this theorem. So let's look at

57
00:02:09,122 --> 00:02:14,154
让我们来看一下费马定理的一个简单应用 假设我在ZP*里寻找到一个元素X

58
00:02:09,122 --> 00:02:14,154
a simple application of Fermat's theorem.
Suppose I look at an element X in Z P

59
00:02:14,154 --> 00:02:19,441
我想要提醒大家这里的P必须是素数 那么 现在我们知道什么

60
00:02:14,154 --> 00:02:19,441
star. And I want to remind you here that P
[inaudible] must be a prime. Well, then what do we

61
00:02:19,441 --> 00:02:24,664
我们知道X^(P-1)=1 我们可以把X^(P-1)

62
00:02:19,441 --> 00:02:24,664
know? We know that X to the P minus one is
equal to one. Well, we can write X to the

63
00:02:24,664 --> 00:02:29,573
写成X*X^(P-2) 那么现在我们知道了

64
00:02:24,664 --> 00:02:29,573
P minus one as X times X to the power of P
minus two. Well so now we know that X

65
00:02:29,573 --> 00:02:34,087
X*X^(P-2)正好是1

66
00:02:29,573 --> 00:02:34,087
times X to the power of P minus two
happens to be equal to one. And what that

67
00:02:34,087 --> 00:02:39,310
也就是说 X^(P-2)就是X模P的逆

68
00:02:34,087 --> 00:02:39,310
says, is that really the inverse of X
modulo P, is simply X to the P minus two.

69
00:02:39,310 --> 00:02:44,042
这给了我们另一种找X模素数的逆的算法

70
00:02:39,310 --> 00:02:44,042
So this gives us another algorithm for
finding the inverse of X modulo a prime.

71
00:02:44,042 --> 00:02:48,835
计算X^(P-2) 就会得到X的逆

72
00:02:44,042 --> 00:02:48,835
Simply raise X to the power of p minus
two, and that will give us the inverse of

73
00:02:48,835 --> 00:02:53,508
事实上这是一个寻找模素数的逆的好方法

74
00:02:48,835 --> 00:02:53,508
x. It turns out, actually this is a fine
way to compute inverses modulo a prime.

75
00:02:53,508 --> 00:02:58,301
但是与欧几里德算法相比她有两点不足 第一

76
00:02:53,508 --> 00:02:58,301
But it has two deficiencies compared to
Euclid's algorithm. First of all, it only

77
00:02:58,301 --> 00:03:02,528
它仅仅适用于模素数 而欧几里德算法还适用于模合数

78
00:02:58,301 --> 00:03:02,528
works modulo primes, Whereas, Euclid's
algorithm worked modulo composites as

79
00:03:02,528 --> 00:03:07,017
第二 事实上这个算法的效率是比较低的

80
00:03:02,528 --> 00:03:07,017
well. And second of all, it turns out this
algorithm is actually less efficient. When

81
00:03:07,017 --> 00:03:10,911
当我们讨论如何计算模指数时 我们将会在本章最后一节讨论

82
00:03:07,017 --> 00:03:10,911
we talk about how to do modular
exponentiations--we're gonna do that in

83
00:03:10,911 --> 00:03:15,345
大家会看的计算这个指数的算法复杂度

84
00:03:10,911 --> 00:03:15,345
the last segment in this module--you'll
see that the running time to compute this

85
00:03:15,345 --> 00:03:19,792
事实上是P的大小的立方 所以这将会花掉大约（log P）^3的时间

86
00:03:15,345 --> 00:03:19,792
exponentiation is actually cubic in the
size of P. So this will take roughly log

87
00:03:19,792 --> 00:03:24,266
如果大家还记得 欧几里德算法可以在P的平方的时间里

88
00:03:19,792 --> 00:03:24,266
cube of P, whereas if you remember,
Euclid's algorithm was able to compute the

89
00:03:24,266 --> 00:03:30,343
计算出逆

90
00:03:24,266 --> 00:03:30,343
inverse in quadratic time in the
representation of P. So not only is this

91
00:03:30,343 --> 00:03:36,512
所以这个算法不仅使用于素数不具有普适性 而且不是那么有效

92
00:03:30,343 --> 00:03:36,512
algorithm less general it only works for
primes, it's also less efficient. So score

93
00:03:36,512 --> 00:03:41,473
所以欧几里德赢了 但是 这个关于素数的定理是极其重要的

94
00:03:36,512 --> 00:03:41,473
one for Euclid. But nevertheless, this
fact about primes is extremely important,

95
00:03:41,473 --> 00:03:47,506
我们将在未来的几周里大量用的它

96
00:03:41,473 --> 00:03:47,506
and we're gonna be making extensive use of
it in the next couple of weeks. So let me

97
00:03:47,506 --> 00:03:52,155
所以让我给大家快速的看一个费马定理的简单应用

98
00:03:47,506 --> 00:03:52,155
show you a quick and simple application
for Fermat's theorem suppose we wanted

99
00:03:52,155 --> 00:03:57,226
假设我们想生成一个大的随机素数 比如我们的素数要有1000位之类的长度

100
00:03:52,155 --> 00:03:57,226
to generate a large random prime, say our
prime needed to be 1,000 bits or so. So

101
00:03:57,226 --> 00:04:02,006
我们寻找的这个素数的量级在2^1024

102
00:03:57,226 --> 00:04:02,006
the prime we're looking for is on the
order of two to the 1024 [inaudible]. So here's

103
00:04:02,006 --> 00:04:06,724
这是一个非常简单的概率定理 我们将要做的就是

104
00:04:02,006 --> 00:04:06,724
a very simple probabilistic algorithm.
What we would do is we would choose a

105
00:04:06,724 --> 00:04:11,938
从一个给定的区间里随机选择一个整数 然后我们会检测

106
00:04:06,724 --> 00:04:11,938
random integer in the interval that was
specified. And then we would test whether

107
00:04:12,124 --> 00:04:17,153
这个整数是否满足费马定理 换句话说 我们会用以2为底的数检测

108
00:04:12,124 --> 00:04:17,153
this integer satisfies Fermat's theorem.
In other words, we would test for example

109
00:04:17,153 --> 00:04:22,367
我们将会检测2^(P-1)在Z p中是否为1

110
00:04:17,153 --> 00:04:22,367
using the base two; we would test whether
two to the power of p minus one equals one

111
00:04:22,367 --> 00:04:27,271
如果答案是否定的 等式不相等 那么我们可以

112
00:04:22,367 --> 00:04:27,271
in Z p. If the answer is no, then if this
equality doesn't hold, then we know for

113
00:04:27,271 --> 00:04:33,003
确定我们选择的p不是素数 如果这发生了 我们只好

114
00:04:27,271 --> 00:04:33,003
sure that the number p that we chose is
not a prime. And if that happens, all we

115
00:04:33,003 --> 00:04:37,284
回到第一步 换另一个素数 我们一遍遍的重复

116
00:04:33,003 --> 00:04:37,284
do is we go back to step one and we try
another prime. And we do this again and

117
00:04:37,284 --> 00:04:41,782
直到找到一个整数满足条件

118
00:04:37,284 --> 00:04:41,782
again and again, until finally we find an
integer that satisfies this condition. And

119
00:04:41,782 --> 00:04:46,009
一旦我们找到整数满足这个条件 我们简单的输出它并停下来

120
00:04:41,782 --> 00:04:46,009
once we find an integer that satisfies
this condition, we simply output it and

121
00:04:46,009 --> 00:04:51,573
这结束了  这事实上比较难以证明

122
00:04:46,009 --> 00:04:51,573
stop. Now it turns out, this is actually a
fairly difficult statement to prove. But

123
00:04:51,573 --> 00:04:56,305
但如果一个随机数通过测试 这很有可能是一个素数

124
00:04:51,573 --> 00:04:56,305
it turns out if a random number passes
this test, then it's extremely likely to

125
00:04:56,305 --> 00:05:01,398
特别的 P不是素数的可能性很小

126
00:04:56,305 --> 00:05:01,398
be a prime. In particular the probability
that P is not a prime is very small. It's

127
00:05:01,398 --> 00:05:06,191
小于2的-60次方 对1024比特范围的数

128
00:05:01,398 --> 00:05:06,191
like less than two to the -60 for the
range of 1024 bit numbers. As the

129
00:05:06,191 --> 00:05:10,744
随着数越来越大 通过测试但不是素数的可能性

130
00:05:06,191 --> 00:05:10,744
number gets bigger and bigger the
probability that it passes this test here,

131
00:05:10,744 --> 00:05:15,716
很快降到0 所以这是一个很有意思的算法

132
00:05:10,744 --> 00:05:15,716
but is not a prime drops to zero very
quickly. So this is actually quite an

133
00:05:15,716 --> 00:05:20,455
你会发觉我们不保证输出一定是

134
00:05:15,716 --> 00:05:20,455
interesting algorithm. You realize we're
not guaranteed that the output is in fact

135
00:05:20,455 --> 00:05:25,021
素数 我们只知道它很可能是一个素数

136
00:05:20,455 --> 00:05:25,021
a prime. All we know is that it's very,
very likely to be a prime. In other words

137
00:05:25,021 --> 00:05:29,587
换言之 他不是素数意味着我们很不幸运

138
00:05:25,021 --> 00:05:29,587
the only way that it's not a prime is that
we got extremely unlucky. In fact so

139
00:05:29,587 --> 00:05:34,298
事实上不幸到一个可以忽略可能性的事件发生了

140
00:05:29,587 --> 00:05:34,298
unlucky that a negligible probability
event just happened. Another way to say

141
00:05:34,298 --> 00:05:40,230
另一个说法是 如果你看1024整数的序列 然后 这是素数的序列

142
00:05:34,298 --> 00:05:40,230
this is that if you look at the set of all
1024 integers, then, well, there's the set

143
00:05:40,230 --> 00:05:45,233
我在这写素数 然后这是一些合数

144
00:05:40,230 --> 00:05:45,233
of primes. Let me write prime here. And
then there is a small number of

145
00:05:45,233 --> 00:05:50,805
这事实上会错误的通过测试 我们把错误的素数叫做F

146
00:05:45,233 --> 00:05:50,805
composites. That actually will falsify the
test. Let's call them F for false primes.

147
00:05:50,805 --> 00:05:55,653
我们把他们叫做FP 对错误的素数 又很少的合数

148
00:05:50,805 --> 00:05:55,653
Let's call them FP, for false primes.
There's a very small number of composites

149
00:05:55,653 --> 00:06:00,626
不是素数却会通过测试 但既然我们选择的是随机整数

150
00:05:55,653 --> 00:06:00,626
that are not prime and yet will pass this
test. But as we choose random integers,

151
00:06:00,626 --> 00:06:05,349
你看 我们在这里选择一个 这选一个 这样 当我们随机选数

152
00:06:00,626 --> 00:06:05,349
you know, we choose one here, one here,
one here, and so on, as we choose random

153
00:06:05,349 --> 00:06:10,260
我们选到错误素数的可能性很小

154
00:06:05,349 --> 00:06:10,260
integers, the probability that we fall
into the set of false primes is so small

155
00:06:10,260 --> 00:06:15,082
以至于我们可以忽略这个事件 换言之 我们可以证明

156
00:06:10,260 --> 00:06:15,082
That it's essentially a negligible event
that we can ignore. In other words, one

157
00:06:15,082 --> 00:06:20,591
错误素数的序列是相当小的 一个随机的选择

158
00:06:15,082 --> 00:06:20,591
can prove that the set of false primes is
extremely small, and a random choice is

159
00:06:20,591 --> 00:06:25,266
不可能导致这样一个错误素数 现在我应该提到 事实上 有一个非常简单的

160
00:06:20,591 --> 00:06:25,266
unlikely to pick such a false prime. Now I
should mention, in fact, this is a very

161
00:06:25,266 --> 00:06:28,960
算法生成素数 事实上 到现在为止不是最好的算法

162
00:06:25,266 --> 00:06:28,960
simple algorithm for generating primes.
It's actually, by far, not the best

163
00:06:28,960 --> 00:06:32,654
我们现在有好的多的算法 事实上 一旦你有一个备选的素数

164
00:06:28,960 --> 00:06:32,654
algorithm. We have much better algorithms
now. And, in fact, once you have a

165
00:06:32,654 --> 00:06:36,349
我们有非常高效的算法能

166
00:06:32,654 --> 00:06:36,349
candidate prime, we now have very
efficient algorithms that will actually

167
00:06:36,349 --> 00:06:40,498
明确证明这个备选素数是否真的是一个素数

168
00:06:36,349 --> 00:06:40,498
prove beyond a doubt that this candidate
prime really is a prime. So we don't even

169
00:06:40,498 --> 00:06:44,597
所以我们不用依赖于可能性状态 但费马测试是

170
00:06:40,498 --> 00:06:44,597
have to rely on probabilistic statements.
But nevertheless, this Fermat test is so

171
00:06:44,597 --> 00:06:48,595
那么简单 以至于我就想要展示给你们这是一个生成素数的很简单的方法

172
00:06:44,597 --> 00:06:48,595
simple, that I just wanted to show you
that it's an easy way to generate primes.

173
00:06:48,595 --> 00:06:53,076
尽管事实上素数不是这么生成的 最后一点

174
00:06:48,595 --> 00:06:53,076
Although in reality, this is not how
primes are generated. As the last point,

175
00:06:53,076 --> 00:06:57,468
我想你们可能想知道 这个迭代需要重复多少次

176
00:06:53,076 --> 00:06:57,468
I'll say that you might be wondering how
many times this iteration has to repeat

177
00:06:57,468 --> 00:07:01,536
我们才能真正找到这个素数 这是一个经典的结果

178
00:06:57,468 --> 00:07:01,536
until we actually find the prime. And
that's actually a classic result; it's

179
00:07:01,536 --> 00:07:05,820
被叫做素数定理 是这样描述的 在几百次迭代后

180
00:07:01,536 --> 00:07:05,820
called the prime number theorem, which
says that, after a few hundred iterations,

181
00:07:05,820 --> 00:07:09,833
我们有很大概率找到素数 也就是说

182
00:07:05,820 --> 00:07:09,833
in fact, we'll find the prime with
high probability. So in expectation, one would

183
00:07:09,833 --> 00:07:14,771
你需要准备几百次迭代而不是更多 现在我们理解了费马定理

184
00:07:09,833 --> 00:07:14,771
expect a few hundred iterations and no
more. Now that we understand

185
00:07:14,771 --> 00:07:19,314
我想说的下一个点是讨论ZP星结构

186
00:07:14,771 --> 00:07:19,314
Fermat's theorem, the next thing I want
to talk about is what's called the

187
00:07:19,314 --> 00:07:23,915
所以这里我们要向后看100年到十八世纪

188
00:07:19,314 --> 00:07:23,915
structure of ZP star. So here, we are
going to move 100 years into the future...

189
00:07:23,915 --> 00:07:28,576
看看欧拉的工作 欧拉展示的第一作品

190
00:07:23,915 --> 00:07:28,576
Into the eighteenth century and look at
the work of Euler. And one of the first

191
00:07:28,576 --> 00:07:33,118
是现在被称为ZP星曾被叫做

192
00:07:28,576 --> 00:07:33,118
things Euler showed is in modern language
is that ZP star is what's called a

193
00:07:33,118 --> 00:07:38,014
循环群 ZP星是循环圈是什么意思呢？ 它意味着在

194
00:07:33,118 --> 00:07:38,014
cyclic group. What does it mean that ZP
star is a cyclic group? What it means is

195
00:07:38,014 --> 00:07:42,734
ZP星中存在一些元素G 如果我们取G

196
00:07:38,014 --> 00:07:42,734
that there exists some element G in ZP
star, such that if we take G and raise to

197
00:07:42,734 --> 00:07:47,681
取一串G的幂次项 G方根 G平方 G四次 。。。

198
00:07:42,734 --> 00:07:47,681
a bunch of powers G, G squared, G cubed, G
to the fourth. And so on and so forth up

199
00:07:47,681 --> 00:07:52,590
直到我们得到G的P-2次 注意 不可能到G的P-2次外

200
00:07:47,681 --> 00:07:52,590
until we reach G to the P minus two.
Notice there's no point of going beyond G

201
00:07:52,590 --> 00:07:57,296
因为G的P-1次 依据费马定理等于1

202
00:07:52,590 --> 00:07:57,296
to the p minus two, because G to the p
minus one by Fermat's theorem is equal to

203
00:07:57,296 --> 00:08:02,178
所以我们会循环回一 如果我们回到G的p-1次

204
00:07:57,296 --> 00:08:02,178
one, so then we will cycle back to one. If
we go back to G to the p minus one, then G

205
00:08:02,178 --> 00:08:06,825
那么G的p次会等于G G的P-1次会等于G方根

206
00:08:02,178 --> 00:08:06,825
to the p will be equal to G, G to the p
plus one will be equal to G squared, and

207
00:08:06,825 --> 00:08:11,825
这样 我们事实上得到一个循环 如果我们继续取G的更高次

208
00:08:06,825 --> 00:08:11,825
so on and so forth. So we'll actually get
a cycle if we keep raising to higher and

209
00:08:11,825 --> 00:08:16,590
那么我们不如在G的P-2次停下来

210
00:08:11,825 --> 00:08:16,590
higher powers of G. So we might as well
stop at the power of G to the p minus two.

211
00:08:16,590 --> 00:08:21,413
欧拉展示的是 事实上有一个G如果你观察

212
00:08:16,590 --> 00:08:21,413
And what Euler showed is that in fact
there is an element G such that if you

213
00:08:21,413 --> 00:08:26,300
其所有幂次拓展称为ZP星

214
00:08:21,413 --> 00:08:26,300
look at all of its powers all of its
powers expand the entire group ZP Star.

215
00:08:26,300 --> 00:08:31,239
G的幂次个我们所有ZP星中的元素 这样的元素

216
00:08:26,300 --> 00:08:31,239
The powers of G give us all the elements
in ZP star. Elements of this, of this type

217
00:08:31,239 --> 00:08:35,997
我们称之为一个生成元 G是ZP星的一个生成元

218
00:08:31,239 --> 00:08:35,997
is called a generator. So G would be said
to be a generator of ZP star. So let's

219
00:08:35,997 --> 00:08:40,696
让我们快速的看一个例子 让P等于7

220
00:08:35,997 --> 00:08:40,696
look at a quick example. So let's look,
for example, at P equals seven. And let's

221
00:08:35,997 --> 00:08:40,696
我们来看一个简单的例子。例如，p=7

222
00:08:40,696 --> 00:08:45,575
look at all the powers of three. So three
squared three cubed, three to the fourth,

223
00:08:40,696 --> 00:08:45,575
我们看3的所有幂。3^2,3^3,3^4,

224
00:08:45,575 --> 00:08:50,130
three to the fifth, Three to the six,
already we know, is equal to one modular

225
00:08:45,575 --> 00:08:50,130
3^5,3^6,由费马小定理，我们已经知道

226
00:08:50,130 --> 00:08:54,917
seven by Fermat's Theorem. So there's no
point in looking at three to the six. We

227
00:08:50,130 --> 00:08:54,917
3^6=1 mod 7.所以没有必要看3^6了

228
00:08:54,917 --> 00:08:59,644
know we would just get one. So here, I
calculated all these powers for you, and I

229
00:08:54,917 --> 00:08:59,644
我们知道它会是1.这里我给大家计算了所有这些幂

230
00:08:59,644 --> 00:09:04,431
wrote them out. And you see that in fact,
we get all the numbers [inaudible] in Z,

231
00:08:59,644 --> 00:09:04,431
我写下它们，大家可以看到我们得到了（Z_7）*里

232
00:09:04,431 --> 00:09:09,313
in Z7 star. In other words, we get
one, two, three, four, five, and six. So

233
00:09:04,431 --> 00:09:09,313
所有的数。换句话说，我们获得了1.2.3.4.5.6

234
00:09:09,313 --> 00:09:14,599
we would say that three is a generator of
Z7 star. Now I should point out that not

235
00:09:09,313 --> 00:09:14,599
所以我们说，3是Z_7^*的一个生成元。现在我应该指出

236
00:09:14,599 --> 00:09:19,886
every element is a generator. For example,
if we look at all the powers of two, well,

237
00:09:14,599 --> 00:09:19,886
不是每个元素都是生成元。例如，如果我们看2的所有幂

238
00:09:19,886 --> 00:09:24,914
that's not gonna generate the entire
group. In particular, if we look at two to

239
00:09:19,886 --> 00:09:24,914
那不会生成整个群。特别地，如果我们看2^0

240
00:09:24,914 --> 00:09:29,650
the zero, we get one. Two to the one, we
get two. Two squared is four, and two

241
00:09:24,914 --> 00:09:29,650
会得到1，2^1=2,2^2=4

242
00:09:29,650 --> 00:09:34,455
cubed is eight, which is one modular
seven. So we cycled back and then two to

243
00:09:29,650 --> 00:09:34,455
2^3=8=1 mod 7,所以我们循环回来了

244
00:09:34,455 --> 00:09:39,766
the fourth would be two, two to the fifth
would be four. And so on and so forth. So

245
00:09:34,455 --> 00:09:39,766
那么2^4=2,2^5=4...等等

246
00:09:39,766 --> 00:09:44,697
if we look at the powers of two, we just
get one, two, and four. We don't get the

247
00:09:39,766 --> 00:09:44,697
那么如果我们看2的各个幂，我们只能获得1，2，4

248
00:09:44,697 --> 00:09:49,981
whole group and therefore we say that two
is not a generator of Z7 star. Now again,

249
00:09:44,697 --> 00:09:49,981
我们不能获得整个群，因此我们说2不是Z_7^*的生成元

250
00:09:49,981 --> 00:09:55,831
something that we'll use very often is
given an element G of ZP<i>, if we look at a</i>

251
00:09:49,981 --> 00:09:55,831
一个很常用的是，给定Z_p^*里的一个元素g

252
00:09:55,831 --> 00:10:01,901
set of all powers of G, the resulting set
is gonna be called the group generated by

253
00:09:55,831 --> 00:10:01,901
如果我们看g的全体幂组成的集合，得到的集合就叫做g的生成群

254
00:10:01,901 --> 00:10:06,947
G, okay? So these are all the powers of G.
They give us what's called a

255
00:10:01,901 --> 00:10:06,947
这些都是g的幂

256
00:10:06,947 --> 00:10:12,798
multiplicative group. Again, the technical
term doesn't matter. The point is we're

257
00:10:06,947 --> 00:10:12,798
他们给了我们一个乘法群。这些技术术语并不重要

258
00:10:12,798 --> 00:10:18,397
gonna call all these powers of G, the
group generated by G. In fact there's this

259
00:10:12,798 --> 00:10:18,397
重要的是，我们把所有这些g的幂，叫做g的生成群

260
00:10:18,397 --> 00:10:23,570
notation which I don't use very often,
angle G angle, to denote this group that's

261
00:10:18,397 --> 00:10:23,570
事实上这个记号我们不会经常使用：<g>

262
00:10:23,570 --> 00:10:30,010
generated by G. And then we call the order
of G in Z p star, we simply let that be

263
00:10:23,570 --> 00:10:30,010
<g>表示g的生成群，然后，我们把g的生成群的大小

264
00:10:30,010 --> 00:10:35,663
the size of the group that's generated by
G. So in other words, the order of G in Z

265
00:10:30,010 --> 00:10:35,663
叫做g在Z_p^*里的阶。换句话说

266
00:10:35,663 --> 00:10:40,626
p star is the size of this group. But
another way to think about that is

267
00:10:35,663 --> 00:10:40,626
g在Z_p^*里的阶等于<g>的大小。另一种思考的方法是

268
00:10:40,626 --> 00:10:46,280
basically it's the smallest integer A such
that G to the A is equal to one in Z P.

269
00:10:40,626 --> 00:10:46,280
g的阶是满足在Z_p中，g^a=1的最小的整数a

270
00:10:47,380 --> 00:10:52,838
Okay, it's basically the smallest power
that causes the power of G to be equal to

271
00:10:47,380 --> 00:10:52,838
是最小的次数，导致g的幂等于1

272
00:10:52,838 --> 00:10:58,566
one. And it's very easy to see that this
equality here basically if we look at all

273
00:10:52,838 --> 00:10:58,566
非常容易看出这个等式。如果我们看g的所有幂

274
00:10:58,566 --> 00:11:04,024
the powers of G and we look at one, G, G
squared, G cubed and so on and so forth up

275
00:10:58,566 --> 00:11:04,024
我们看1，g,g^2,g^3....

276
00:11:04,024 --> 00:11:09,887
until we get to G to the order of G minus
one. And then if we look at the order of G

277
00:11:04,024 --> 00:11:09,887
直到我们得到g^(|<g>-1|)。然后如果我们看

278
00:11:09,887 --> 00:11:15,420
to the order of G. This thing is simply
going to be equal to one, by definition.

279
00:11:09,887 --> 00:11:15,420
g^|<g>|，根据定义，g^|<g>|=1

280
00:11:16,080 --> 00:11:22,000
Okay, so there's no point in looking at
any higher powers. We might as well just

281
00:11:16,080 --> 00:11:22,000
好，再看更高的点没有意义了

282
00:11:22,000 --> 00:11:27,631
stop raising to powers here. And as a
result the size of the set, in fact, is

283
00:11:22,000 --> 00:11:27,631
这里我们可以停止升幂次了。因此这个集合的大小

284
00:11:27,631 --> 00:11:33,263
the order of G. And you can see that the
order is the smallest power such that

285
00:11:27,631 --> 00:11:33,263
事实上就是g的阶。大家可以看到这个阶是最小的幂次

286
00:11:33,263 --> 00:11:38,931
raising G to that power gives us one in Z
p. So I hope this is clear although it

287
00:11:33,263 --> 00:11:38,931
满足对应的g的幂在Z_p中等于1.那么我希望说清楚了

288
00:11:38,931 --> 00:11:43,455
might take a little bit of thinking to
absorb all this notation. But in the

289
00:11:38,931 --> 00:11:43,455
理解所有的这些记号需要费些功夫

290
00:11:43,455 --> 00:11:48,100
meantime let's look at a few examples. So,
again, let's fix our, our prime to be

291
00:11:43,455 --> 00:11:48,100
同时我们看几个例子，我们固定质素为7

292
00:11:48,100 --> 00:11:52,986
seven. And let's look at the order of the
number of elements. So what is the order

293
00:11:48,100 --> 00:11:52,986
我们看其各个元素的阶

294
00:11:52,986 --> 00:11:57,752
of three modulus of seven? Well, we're
asking what is the size of the group that

295
00:11:52,986 --> 00:11:57,752
3 mod 7的阶是多少？我们在问3模7的生成群的大小

296
00:11:57,752 --> 00:12:02,759
three generates modulus of seven? Well, we
said that three is a generator of Z7 star.

297
00:11:57,752 --> 00:12:02,759
我们说过，3是Z_7^*的一个生成元

298
00:12:02,759 --> 00:12:07,705
So it generates all of Z7 star. There are
six elements in Z7 star. And therefore we

299
00:12:02,759 --> 00:12:07,705
所以它生成了Z_7^*的全部元素。Z_7^*里共有6个元素

300
00:12:07,705 --> 00:12:12,758
say that the order of three is equal to
six. Similarly, I can ask, well, what is

301
00:12:07,705 --> 00:12:12,758
所以3的阶等于6.类似的，我可以问

302
00:12:12,758 --> 00:12:17,421
the order of two modulo seven? And in
fact, we already saw the answer. So let's,

303
00:12:12,758 --> 00:12:17,421
2模7的阶是多少？事实上，我们已经见过答案了

304
00:12:17,421 --> 00:12:22,084
I'll ask you, what is the order of two
modulo seven and see if you can f igure

305
00:12:17,421 --> 00:12:22,084
我问大家，2模7的阶是多少？看看大家能否解出答案

306
00:12:22,084 --> 00:12:28,549
out what this answer is. So the answer is
three and again, the reason is if we look

307
00:12:22,084 --> 00:12:28,549
那么答案是3，原因是如果我们看

308
00:12:28,549 --> 00:12:33,618
at the set of powers of two modulo seven,
we have one, two, two squared, and then

309
00:12:28,549 --> 00:12:33,618
2模7的幂组成的集合，我们有1，2，2^2

310
00:12:33,618 --> 00:12:39,077
two cubed is already equal to one. So this
is the entire set of powers of two modulo

311
00:12:33,618 --> 00:12:39,077
然后2^3又是1了。所以这些就是2模7的所有幂

312
00:12:39,077 --> 00:12:44,211
seven. There are only three of them and,
therefore, the order of two modulo seven

313
00:12:39,077 --> 00:12:44,211
只有三个，因此2模7的阶是3

314
00:12:44,211 --> 00:12:49,215
is exactly three. Now let me ask you a
trick question. What's the order of one

315
00:12:44,211 --> 00:12:49,215
我问大家一个有点难的问题:1模7的阶是多少？

316
00:12:49,215 --> 00:12:54,499
modulo seven? Well, the answer is one.
Because if you look at the group that's

317
00:12:49,215 --> 00:12:54,499
答案是1，因为大家看1的生成群

318
00:12:54,499 --> 00:12:58,633
generated by one, well, there's only one
number in that group, namely the number

319
00:12:54,499 --> 00:12:58,633
只有一个数在1的生成群里，即数1

320
00:12:58,633 --> 00:13:02,608
one. If I raise one to a whole bunch of
powers, I'm always gonna get one, And

321
00:12:58,633 --> 00:13:02,608
如果我计算1的一组幂，我总是得到1

322
00:13:02,608 --> 00:13:07,060
therefore the order of 1 modulo 7
In fact the order of 1 modulo any prime

323
00:13:02,608 --> 00:13:07,060
所以1模7的阶是1，事实上，1模任意质数的阶

324
00:13:07,060 --> 00:13:12,518
is always gonna be 1. Now there's an
important theorem of Lagrange, that

325
00:13:07,060 --> 00:13:12,518
总是1.现在有重要的拉格朗日定理

326
00:13:12,518 --> 00:13:17,137
actually this is a very, very special case
of it, what I am stating here. But

327
00:13:12,518 --> 00:13:17,137
我这里说的仅仅是拉格朗日定理的一个特例

328
00:13:17,137 --> 00:13:22,309
Langrage's theorem basically implies that
if you look at the order of G modulo p,

329
00:13:17,137 --> 00:13:22,309
拉格朗日定理意味着，如果你看g模p的阶

330
00:13:22,309 --> 00:13:27,112
the order is always going to divide P-1. So in our two example you see,

331
00:13:22,309 --> 00:13:27,112
这个阶始终整除p-1。那么在我们给大家的两个例子中

332
00:13:27,297 --> 00:13:32,100
six divides seven minus one, six divides
six, and similarly, three divides seven

333
00:13:27,297 --> 00:13:32,100
6整除7-1，即6整除6，类似地，3整除7-1

334
00:13:32,100 --> 00:13:37,026
minus one. Namely again three divides six.
But this is very general; your order is

335
00:13:32,100 --> 00:13:37,026
即3整除6.但这是很一般的

336
00:13:37,026 --> 00:13:41,333
always going be a factor of P minus one.
In fact, I'll tell you, maybe it's a

337
00:13:37,026 --> 00:13:41,333
你的阶始终是p-1的因子。事实上，我会告诉你

338
00:13:41,333 --> 00:13:45,177
puzzle for you to think about. It's
actually very easy to deduce Fermat's

339
00:13:41,333 --> 00:13:45,177
也许你会想想这个谜题,由拉格朗日定理的这个事实

340
00:13:45,177 --> 00:13:49,179
theorem directly from this fact, from this
Lagrange's theorem in fact. And so

341
00:13:45,177 --> 00:13:49,179
某种意义上来说，费马定理是拉格朗日定理的直接推导

342
00:13:49,179 --> 00:13:53,340
Fermat's theorem really in some sense
follows directly from Lagrange's theorem.

343
00:13:49,179 --> 00:13:53,340
顺便说一句，拉格朗日工作在十九世纪

344
00:13:54,580 --> 00:13:59,375
Lagrange, by the way, did his work in the
nineteenth century, so you can already see

345
00:13:54,580 --> 00:13:59,375
所以我们可以看到我们是怎么沿着历史前进的，我们从古希腊出发

346
00:13:59,375 --> 00:14:04,053
how we're making progress through time. We
started in Greek times, and already we

347
00:13:59,375 --> 00:14:04,053
然后我们结束于十九世纪，我可以告诉大家更多的是

348
00:14:04,053 --> 00:14:09,376
ended up in the nineteenth century. And I
can tell you that more advanced crypto

349
00:14:04,053 --> 00:14:09,376
更先进的密码学在二十世纪时被广泛的运用

350
00:14:09,376 --> 00:14:14,024
actually uses twentieth century math very
extensively. Now that we understand the

351
00:14:09,376 --> 00:14:14,024
既然现在我们已经了解了Z-p^*的结构，让我们把它推广的合数

352
00:14:14,024 --> 00:14:18,416
structure of ZP star, let's generalize
that to composites, and look at the

353
00:14:14,024 --> 00:14:18,416
并看看Z-n^*的结构，我想展示给你们什么是欧拉定理

354
00:14:18,416 --> 00:14:23,471
structure of ZN star. So what I wanna show
you here is what's called Euler's Theorem

355
00:14:18,416 --> 00:14:23,471
欧拉定理是费马定理的一个直接推广，所以欧拉定理定义如下函数

356
00:14:23,471 --> 00:14:28,044
which is a, a direct generalization of
Fermat's Theorem. So, Euler defined the

357
00:14:23,471 --> 00:14:28,044
给定一个整数N，欧拉定义了一个函数φ

358
00:14:28,044 --> 00:14:32,978
following function. So given an integer N,
he defined what's called the phi

359
00:14:28,044 --> 00:14:32,978
函数φ（M），是Z_N^*的大小

360
00:14:32,978 --> 00:14:37,190
function, phi of M, to be
basically the size of the set ZN star.

361
00:14:32,978 --> 00:14:37,190
有时也称为欧拉的φ函数，Z_N^*的大小

362
00:14:37,190 --> 00:14:42,686
This is sometimes called, Euler's phi
function. The size of the set Z N star. So

363
00:14:37,190 --> 00:14:42,686
例如，我们已经看过Z_12^*，我们说过Z_12^*中含有四个元素

364
00:14:42,686 --> 00:14:48,521
for example, we already looked at Z twelve
star. We said that Z twelve star contains

365
00:14:42,686 --> 00:14:48,521
1、5、7、11，因此我们说

366
00:14:48,521 --> 00:14:53,881
these four elements, one, five, seven, and
eleven. And therefore we say that phi of

367
00:14:48,521 --> 00:14:53,881
φ(12)只含有四个元素，问你们个问题，φ（P）是多少

368
00:14:53,881 --> 00:14:59,310
twelve is simply the number four. So let
me ask you as a puzzle, what is phi of P?

369
00:14:53,881 --> 00:14:59,310
它是Z_p^*的大小，所以事实上，我们说

370
00:14:59,310 --> 00:15:06,266
It will basically be the size of Z P star.
And so, in fact, we said that in the Z P

371
00:14:59,310 --> 00:15:06,266
Z_p^*含有除了0的所有的Z_p的所有元素。因此

372
00:15:06,266 --> 00:15:12,335
star contains all of Z P except for the
number zero. And therefore, phi of P for

373
00:15:06,266 --> 00:15:12,335
对于任意质数p有φ（p）=p-1。现在，讲一个特例

374
00:15:12,335 --> 00:15:18,533
any prime P is gonna be P minus one. Now,
there is a special case, which I'm gonna

375
00:15:12,335 --> 00:15:18,533
我在这说并且我们之后要用的RSA系统。如果N是由两质数之积

376
00:15:18,533 --> 00:15:23,282
state here and we're gonna use later for
the RSA system. If N happens to be a

377
00:15:18,533 --> 00:15:23,282
那么φ（N）=N-P-Q+1

378
00:15:23,282 --> 00:15:28,277
product of two primes, then phi of N is
simply N minus P minus Q plus one. And let

379
00:15:23,282 --> 00:15:28,277
让我展示给你们为什么，已知N是Z_N^*的大小，

380
00:15:28,277 --> 00:15:33,045
me just show you why that's true. So
basically N is the size of Z N. And now we

381
00:15:28,277 --> 00:15:33,045
现在我们需要移除所有与m不互素的元素。

382
00:15:33,045 --> 00:15:37,838
need to remove all the elements that are
not relatively prime to m. Well how can an

383
00:15:33,045 --> 00:15:37,838
怎么判断一个元素是否和m不互素呢？则它要不被p整除

384
00:15:37,838 --> 00:15:42,632
element not be relatively prime to m? It's
gotta be divisible by p or it's gotta be

385
00:15:37,838 --> 00:15:42,632
或者被q整除。在0到m-1中有多少个元素能被p整除？

386
00:15:42,632 --> 00:15:47,079
divisible by q. Well how many elements
between zero and m minus one are there,

387
00:15:42,632 --> 00:15:47,079
一定有q个，那么有多少个元素能被q整除呢？

388
00:15:47,079 --> 00:15:51,757
there that are divisible by p? Well there
are exactly q of them. How many elements

389
00:15:47,079 --> 00:15:51,757
这一定有p个。

390
00:15:51,757 --> 00:15:55,973
are there that are divisible by q. Well
there are exactly p of them. So we

391
00:15:51,757 --> 00:15:55,973
所以我们减去p来除去那些被q整除的数。我们减去q来除去那些被p整除的数

392
00:15:55,973 --> 00:16:00,593
subtract p to get rid of those divisible
by q. We subtract q to get rid of those

393
00:15:55,973 --> 00:16:00,593
注意到我们减了两次0

394
00:16:00,593 --> 00:16:05,776
divisible by p. And you notice we
subtracted zero twice, because zero is

395
00:16:00,593 --> 00:16:05,776
因为0既是P的除数也是Q的除数。因此，我们加1来保证我们只减了一次0

396
00:16:05,776 --> 00:16:12,020
divisible both by P and Q. And therefore,
we add one just to make sure we subtract

397
00:16:05,776 --> 00:16:12,020
所以不难得到，φ(N)=N-P-Q+1

398
00:16:12,020 --> 00:16:18,264
zero only once. And so it's not difficult
to see that phi(N) is N-P-Q+1. And another way

399
00:16:12,020 --> 00:16:18,264
另一种表达方式是φ（N)=(P-1)*(Q-1），这是我们一会要用到的定理

400
00:16:18,264 --> 00:16:24,599
of writing that is simply (P-1) times (Q-1). Okay,
so this is a fact that we will use later

401
00:16:18,264 --> 00:16:24,599
我们回到之前谈论的RSA系统。目前为止，只是定义了欧拉函数φ

402
00:16:24,599 --> 00:16:30,275
on, when we come back and talk about the
RSA system. So far, this is just defining

403
00:16:24,599 --> 00:16:30,275
但欧拉很好的运用了这个函数φ

404
00:16:30,275 --> 00:16:35,690
this phi function of Euler. But now Euler
put this phi function to really good use.

405
00:16:30,275 --> 00:16:35,690
他证明出这个惊人的事实

406
00:16:35,690 --> 00:16:41,104
And what he proved is this amazing fact
here that basically says that if you give

407
00:16:35,690 --> 00:16:41,104
如果你给我任意一个属于Z-N^*的元素X。事实上，X的φ（N）次方等于Z_N^*中的1，

408
00:16:41,104 --> 00:16:46,060
me any element X in Z N star. In fact, and
it so happens that X to the power of phi(N)

409
00:16:41,104 --> 00:16:46,060
现在你可以明白欧拉定理是费马定理的一个推广

410
00:16:46,060 --> 00:16:50,678
is equal to one in Z N. So you can see
that this is a generalization of Fermat's

411
00:16:46,060 --> 00:16:50,678
特别的，费马定理只应用于质数，我们知道

412
00:16:50,678 --> 00:16:55,239
theorem; in particular, Fermat's theorem
only applied to primes. For primes we know

413
00:16:50,678 --> 00:16:55,239
对于质数p，φ（p）=p-1，换句话说，如果N是质数，那么我们

414
00:16:55,239 --> 00:16:59,913
that phi(p) is equal to p minus one, and
in other words if N were prime we would

415
00:16:55,239 --> 00:16:59,913
简单的计算出p-1，并

416
00:16:59,913 --> 00:17:04,494
simply write p minus one here, and then we
would get exactly Fermat's theorem. The

417
00:16:59,913 --> 00:17:04,494
欧拉定理的美妙在于它不仅适用于质数，还适用于合数，

418
00:17:04,494 --> 00:17:08,892
beauty of Euler's theorem is that it
applies to composites, and not just

419
00:17:04,494 --> 00:17:08,892
让我们来看些例子，看5的φ（12）次方

420
00:17:08,892 --> 00:17:16,462
primes. So let's look at some examples. So
let's look at five to the power of phi(12).

421
00:17:08,892 --> 00:17:16,462
所以5是Z_12^*中的元素。如果我们算出5的φ（12）次方

422
00:17:16,462 --> 00:17:21,743
So five is an element of Z12 star.
If we raise it to the power of five of

423
00:17:16,462 --> 00:17:21,743
那么我们就可以得到Z_12^*中的1，我么知道φ（12）=4,

424
00:17:21,743 --> 00:17:27,155
twelve, we should be getting one. Well, we
know that phi(12) is 4, so we're

425
00:17:21,743 --> 00:17:27,155
我们可以求出5的4次方。5的4次方等于625

426
00:17:27,155 --> 00:17:32,037
raising 5 to the power of 4. Five to
the power of four is 625 and it's a simple

427
00:17:27,155 --> 00:17:32,037
很容易算出5^4等于1模12。这是用例证

428
00:17:32,037 --> 00:17:36,227
calculation to show that that's equal to
1 modulo 12. So this is proof

429
00:17:32,037 --> 00:17:36,227
但不是证明，这只是一个例子

430
00:17:36,227 --> 00:17:40,468
by example but of course it's not a proof
at all. It's just an example. But in fact

431
00:17:36,227 --> 00:17:40,468
但事实上不难证明欧拉定理，事实上，我将告诉大家

432
00:17:40,468 --> 00:17:44,555
it's not difficult to prove Euler's
theorem and in fact I'll tell you that

433
00:17:40,468 --> 00:17:44,555
欧拉定理是拉格朗日定理的特例

434
00:17:44,555 --> 00:17:48,900
Euler's theorem is also a very special
case of Lagrange's general theorem.

435
00:17:44,555 --> 00:17:48,900
我们也说欧拉定理是费马定理的一个推广

436
00:17:49,880 --> 00:17:53,888
Okay so we say that this is a
generalization of Fermat's theorem and

437
00:17:49,880 --> 00:17:53,888
实际上，我们将看到欧拉定理是RSA加密系统的基础

438
00:17:53,888 --> 00:17:58,230
in fact as we'll see this Euler's
theorem is the basis of the RSA crypto

439
00:17:53,888 --> 00:17:58,230
这节课就到这了，我们将在下节课继续

440
00:17:58,230 --> 00:18:03,922
system. So I stop here and we continue
with modular quadratic equations in the

441
00:17:58,230 --> 00:18:03,922
讨论模二次等式的问题

442
00:18:03,922 --> 00:18:04,740
next segment.

443
00:18:03,922 --> 00:18:04,740

