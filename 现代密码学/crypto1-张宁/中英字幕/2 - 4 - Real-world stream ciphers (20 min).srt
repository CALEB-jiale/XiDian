1
00:00:00,000 --> 00:00:04,010
In this segment, I want to give a few
examples of stream ciphers that are used in practice.

2
00:00:00,000 --> 00:00:04,010
在这一部分，我想举几个实践中用到的流密码的例子。

3
00:00:04,010 --> 00:00:07,072
I'm gonna start with two old
examples that actually are not

4
00:00:04,010 --> 00:00:07,072
我打算以两个过时的流密码例子开头，实际上它们已经不

5
00:00:07,072 --> 00:00:11,017
supposed to be used in new systems.
But nevertheless, they're still fairly

6
00:00:07,072 --> 00:00:11,017
应该被用在新的系统中。但是尽管如此，他们仍然相当

7
00:00:11,017 --> 00:00:14,164
widely used, and so I just want to mention
the names so that you're familiar with

8
00:00:11,017 --> 00:00:14,164
广泛地被使用着，所以我只想提及它们的名字以便于你们能熟悉这些概念

9
00:00:14,164 --> 00:00:19,087
these concepts. The first stream cipher I
want to talk about is called RC4, designed

10
00:00:14,164 --> 00:00:19,087
我想说的第一个流密码是于1987年被设计出来的被称为RC4，

11
00:00:19,087 --> 00:00:23,429
back in 1987. And I'm only gonna give you
the high-level description of it, and then,

12
00:00:19,087 --> 00:00:23,429
我只打算做一个高阶的描述

13
00:00:23,429 --> 00:00:27,818
we'll talk about some weaknesses of RC4
and leave it at that. So RC4 takes a

14
00:00:23,429 --> 00:00:27,818
然后我们将会谈论RC4的一些缺点，仅此而已。

15
00:00:27,818 --> 00:00:32,702
variable size seed, here I just gave
as an example where it would take 128

16
00:00:27,818 --> 00:00:32,702
RC4采用一个大小可变的种子，在这里
我只举一个采用128比特的种子作为例子

17
00:00:32,702 --> 00:00:36,980
bits as the seed size, which would then
be used as the key for the stream cipher.

18
00:00:32,702 --> 00:00:36,980
这个种子会被用作流密码的密钥。

19
00:00:36,980 --> 00:00:41,738
The first thing it does, is it expands the
128-bit secret key into 2,048 bits, which

20
00:00:36,980 --> 00:00:41,738
首先，CR4流密码先将128比特的密码扩展为2048比特，

21
00:00:41,738 --> 00:00:46,382
are gonna be used as the internal state
for the generator. And then, once it's done

22
00:00:41,738 --> 00:00:46,382
并将被扩展后的密码将作为生成器的内部状态。

23
00:00:46,382 --> 00:00:51,197
this expansion, it basically executes a
very simple loop, where every iteration of

24
00:00:46,382 --> 00:00:51,197
然后一旦它完成了扩展
基本上就开始执行一个非常简单的循环

25
00:00:51,197 --> 00:00:55,898
this loop outputs one byte of output. So,
essentially, you can run the generator for

26
00:00:51,197 --> 00:00:55,898
每次循环输出一个字节。所以，本质上你可以在任何时候

27
00:00:55,898 --> 00:01:00,653
as long as you want, and generate one byte
at a time. Now RC4 is actually, as I said,

28
00:00:55,898 --> 00:01:00,653
运行生成器,每次运行输出一个字节。现在RC4确实是像我说的那样

29
00:01:00,653 --> 00:01:05,205
fairly popular. It's used in the HTTPS
protocol quite commonly actually.

30
00:01:00,653 --> 00:01:05,205
相当流行。实际上它经常被用在HTTPS协议上。

31
00:01:05,205 --> 00:01:11,888
These days, for example, Google uses RC4 in its
HTTPS. It's also used in WEP as we

32
00:01:05,205 --> 00:01:11,888
例如，如今的谷歌在它的HTTPS协议上就使用了RC4,

33
00:01:11,888 --> 00:01:15,686
discussed in the last segment, but of
course in WEP, it's used incorrectly and

34
00:01:11,888 --> 00:01:15,686
就像我们在上一部分谈论的那样,它也被应用在WEP上,被错误和

35
00:01:15,686 --> 00:01:18,861
it's completely insecure the way it's used
inside of WEP. So over the years,

36
00:01:15,686 --> 00:01:18,861
以不安全的方式在WEP的内部使用。所以这些年来，

37
00:01:18,861 --> 00:01:23,886
some weaknesses have been found in RC4, and as a
result, it's recommended that new projects

38
00:01:18,861 --> 00:01:23,886
RC4的一些缺点已经被人们发现.于是,在新的工程中并不建议使用RC4

39
00:01:23,886 --> 00:01:28,793
actually not use RC4 but rather use a more
modern pseudo-random generator as we'll

40
00:01:23,886 --> 00:01:28,793
而是使用一种更加现代化的伪随机密码产生器,就像我们将要

41
00:01:28,793 --> 00:01:34,059
discuss toward the end of the segment. So
let me just mention two of the weaknesses.

42
00:01:28,793 --> 00:01:34,059
在最后一部分讨论的那样。所以我在此就提一下它的两个缺点，

43
00:01:34,059 --> 00:01:39,561
So the first one is, it's kind of bizarre
basically, if you look at the second byte

44
00:01:34,059 --> 00:01:39,561
第一个缺点，也是有点奇怪的，如果你注意到RC4输出的

45
00:01:39,561 --> 00:01:44,630
of the output of RC4. It turns out the
second byte is slightly biased. If RC4 was

46
00:01:39,561 --> 00:01:44,630
第二个字节，就会发现它是有轻微偏差的。如果RC4是

47
00:01:44,630 --> 00:01:49,780
completely random, the probability that the
second byte happens to be equal to zero

48
00:01:44,630 --> 00:01:49,780
完全随机的，第二个字节碰巧等于零的概率

49
00:01:49,780 --> 00:01:54,744
would be exactly one over 256. There are
256 possible bytes, the probability that

50
00:01:49,780 --> 00:01:54,744
将正好是1/256。一共有256种可能的字节，

51
00:01:54,744 --> 00:01:59,646
it's zero should be one over 256. It so
happens that for RC4 the probability is

52
00:01:54,744 --> 00:01:59,646
它是零的可能性应该是1/256。
然而对于RC4而言，概率恰恰是2/256

53
00:01:59,646 --> 00:02:04,486
actually two over 256, which means that if
you use the RC4 output to encrypt a

54
00:01:59,646 --> 00:02:04,486
那就意味着，如果你使用RC4的输出来加密一个消息,

55
00:02:04,486 --> 00:02:09,574
message the second byte is likely to not
be encrypted at all. In other words it'll

56
00:02:04,486 --> 00:02:09,574
加密一个消息,它的第二个字节可能根本不会被加密。换句话说

57
00:02:09,574 --> 00:02:14,575
be XOR-ed with zero with twice the
probability that it's supposed to.

58
00:02:09,574 --> 00:02:14,575
它与0异或的概率将会是原本概率的两倍

59
00:02:14,575 --> 00:02:19,436
So two over 256, instead of one over 256.
And by the way I should say that there's

60
00:02:14,575 --> 00:02:19,436
所以是2/256，而不是1/256。顺便说一下，应该说

61
00:02:19,436 --> 00:02:22,849
nothing special about the second byte. It
turns out the first and the third bytes

62
00:02:19,436 --> 00:02:22,849
第二个字节并没有什么特别之处。这就使得第一和第三个字节

63
00:02:22,849 --> 00:02:27,818
are also biased. And in fact it's now
recommended that if you're gonna use RC4,

64
00:02:22,849 --> 00:02:27,818
也产生了偏差。实际上,如果你打算使用RC4，更为推荐的做法是

65
00:02:27,818 --> 00:02:32,800
what you should do is ignore basically the
first 256 bytes of the output and just

66
00:02:27,818 --> 00:02:32,800
你应该忽视第一组的256字节的输出，而直接

67
00:02:32,800 --> 00:02:37,246
start using the output of the generator
starting from byte 257. The first couple

68
00:02:32,800 --> 00:02:37,246
从第257个字节开始使用产生器的输出。前几个

69
00:02:37,246 --> 00:02:41,241
of bytes turned out to be biased, so you
just ignore them. The second attack that

70
00:02:37,246 --> 00:02:41,241
字节是有偏差的,而你只需要忽它们。第二种攻击是

71
00:02:41,241 --> 00:02:48,482
was discovered is that in fact if you look
at a very long output of RC4 it so happens

72
00:02:41,241 --> 00:02:48,482
如果你考虑一个非常长的RC4的输出，而它正好

73
00:02:48,482 --> 00:02:53,863
that you're more likely to get the
sequence 00. In other words, you're more

74
00:02:48,482 --> 00:02:53,863
可能会得到一个‘00’序列。换句话说，你更

75
00:02:53,863 --> 00:02:58,970
likely to get sixteen bits, two bytes of
zero, zero, than you should. Again, if RC4

76
00:02:53,863 --> 00:02:58,970
可能会得到16比特,即两个字节的'00',这比你本应得到的要多。再说，如果RC4

77
00:02:58,970 --> 00:03:03,948
was completely random the probability of
seeing zero, zero would be exactly 1/256

78
00:02:58,970 --> 00:03:03,948
得到0的概率是完全随机的，
则得到00的概率将正好是1/256的平方

79
00:03:03,948 --> 00:03:08,556
squared. It turns out RC4 is a little
biased and the bias is 1/256 cubed. It

80
00:03:03,948 --> 00:03:08,556
因此使得RC4有一点偏差,而偏离率是1/256^3。

81
00:03:08,556 --> 00:03:13,718
turns out this bias actually starts after
several giga bytes of data are produced by

82
00:03:08,556 --> 00:03:13,718
事实证明这种偏离实际上是在RC4生成几千兆字节的数据之后开始的。

83
00:03:13,718 --> 00:03:18,634
RC4. But nevertheless, this is something
that can be used to predict the generator

84
00:03:13,718 --> 00:03:18,634
无论怎么说，这是可以用来预测产生器的

85
00:03:18,634 --> 00:03:23,120
and definitely it can be used to
distinguish the output of the generator

86
00:03:18,634 --> 00:03:23,120
更可以被用来
从一个真正随机的序列中辨别产生器的输出

87
00:03:23,120 --> 00:03:28,097
from a truly random sequence. Basically the
fact that zero, zero appears more often

88
00:03:23,120 --> 00:03:28,097
基本上，有更多的“00”出现

89
00:03:28,097 --> 00:03:32,414
than it should is the distinguisher. And
then in the last segment we talked about

90
00:03:28,097 --> 00:03:32,414
是区分二者的关键。在前面最近一部分，我们讨论了

91
00:03:32,414 --> 00:03:36,313
related-key attacks that were used to
attack WEP, that basically say that

92
00:03:32,414 --> 00:03:36,313
被用来攻击WEP的相关密钥攻击，基本上是说

93
00:03:36,313 --> 00:03:41,078
if one uses keys that are closely related
to one another then it's actually possible

94
00:03:36,313 --> 00:03:41,078
如果一个人使用的密钥与另一个人使用的是彼此密切相关的话，那么就很可能

95
00:03:41,078 --> 00:03:45,732
to recover the root key. So these are the
weaknesses that are known of RC4 and, as a

96
00:03:41,078 --> 00:03:45,732
还原出原始密钥。所以这些都是已知的RC4的弱点。所以最后的结论是

97
00:03:45,732 --> 00:03:50,217
result, it's recommended that new systems
actually not use RC4 and instead use a

98
00:03:45,732 --> 00:03:50,217
新的系统并不建议使用RC4，
而是使用一种现代化的伪随机序列生成器。

99
00:03:50,217 --> 00:03:54,421
modern pseudo-random generator. Okay,
second example I want to give you is a

100
00:03:50,217 --> 00:03:54,421
好了，我想举的第二个例子是一个

101
00:03:54,421 --> 00:03:59,131
badly broken stream cipher that's used for
encrypting DVD movies. When you buy a DVD

102
00:03:54,421 --> 00:03:59,131
被用于加密DVD电影，已经被严重破解的流密码

103
00:03:59,131 --> 00:04:03,504
in the store, the actual movie is
encrypted using a stream cipher called the

104
00:03:59,131 --> 00:04:03,504
当你在商店里买一部DVD，
真正的电影内容被一种称为影片加密系统（CSS）的流密码

105
00:04:03,504 --> 00:04:07,933
content scrambling system, CSS. CSS turns
out to be a badly broken stream cipher,

106
00:04:03,504 --> 00:04:07,933
加密了。CSS被证明是一种已经被严重破解的流密码

107
00:04:07,933 --> 00:04:12,523
and we can very easily break it, and I
want to show you how the attack algorithm

108
00:04:07,933 --> 00:04:12,523
我们能够很轻易地破解它，并且我想向你们展示一下这个攻击算法是怎么

109
00:04:12,523 --> 00:04:16,894
works. We're doing it so you can see an
example of an attack algorithm, but in

110
00:04:12,523 --> 00:04:16,894
工作的。我们自己做一遍所以你们可以看到个算法攻击的例子

111
00:04:16,894 --> 00:04:21,435
fact, there are many systems out there
that basically use this attack to decrypt

112
00:04:16,894 --> 00:04:21,435
而事实上，有很多系统基本上都使用这种攻击方式来解密

113
00:04:21,435 --> 00:04:25,749
encrypted DVDs. So the CSS stream cipher
is based on something that hardware

114
00:04:21,435 --> 00:04:25,749
被加密的DVD。CSS流密码是在基于一些

115
00:04:25,749 --> 00:04:30,291
designers like. It's designed to be a
hardware stream cipher that is supposed to

116
00:04:25,749 --> 00:04:30,291
硬件设施的基础上设计的。它被设计成一种硬件流密码，这种流密码是

117
00:04:30,291 --> 00:04:34,491
be easy to implement in hardware, and is
based on a mechanism called a linear

118
00:04:30,291 --> 00:04:34,491
容易在硬件中实现的和基于线性反馈移位寄存器的

119
00:04:34,491 --> 00:04:38,749
feedback shift register. So a linear
feedback shift register is basically a register

120
00:04:34,491 --> 00:04:38,749
所以一个线性反馈移位寄存器基本上就是一个

121
00:04:38,749 --> 00:04:43,801
that consists of cells where
each cell contains one bit. Then basically

122
00:04:38,749 --> 00:04:43,801
由一些单元小格组成的，每个小格储存一个比特的寄存器。然后

123
00:04:43,801 --> 00:04:49,046
what happens is there are these taps into
certain cells, not all the cells, certain

124
00:04:43,801 --> 00:04:49,046
有一些接口与这些单元小格连接，并不是所有的小格都被接口连接

125
00:04:49,046 --> 00:04:54,134
positions are called taps. And then these
taps feed into an XOR and then at

126
00:04:49,046 --> 00:04:54,134
这些特定的位置被称为接口。然后这些接口被输入到一个异或门，然后在

127
00:04:54,134 --> 00:04:59,053
every clock cycle, the shift register
shifts to the right. The last bit falls off

128
00:04:54,134 --> 00:04:59,053
每一个时钟周期内，移位寄存器就会进行一次右移。最后一位被去掉

129
00:04:59,053 --> 00:05:04,345
and then the first bit becomes the result
of this XOR. So you can see that

130
00:04:59,053 --> 00:05:04,345
第一位就成了异或门的输出。所以你可以看到

131
00:05:04,345 --> 00:05:08,703
this is a very simple mechanism to implement, and in hardware takes very few

132
00:05:04,345 --> 00:05:08,703
这是一个很容易实现的机制，在硬件上只需要很少的

133
00:05:08,703 --> 00:05:13,622
transistors. Just the shift right, the
last bit falls off and the first bit just

134
00:05:08,703 --> 00:05:13,622
晶体管就能实现。只要向右移,最后一个比特被移出,先前的异或

135
00:05:13,622 --> 00:05:18,541
becomes the XOR of the previous
bits. So the seed for this LFSR

136
00:05:13,622 --> 00:05:18,541
的结果就成为了第一比特位。所以这个LFSR的种子

137
00:05:18,541 --> 00:05:23,460
basically, is the initial state of the LFSR.

138
00:05:18,541 --> 00:05:23,460
就是LFSR的最初的状态。

139
00:05:23,650 --> 00:05:28,538
And it is the basis of a number of stream
ciphers. So here are some examples. So, as

140
00:05:23,650 --> 00:05:28,538
这是许多流密码的基础来源。这里有一些例子。所以，

141
00:05:28,538 --> 00:05:33,362
I said, DVD encryption uses two LFSRs.
I'll show you how that works in just a

142
00:05:28,538 --> 00:05:33,362
正如我说的那样，DVD加密运用了两次LFSR。我将快速给你们展示那是怎样工作的。

143
00:05:33,362 --> 00:05:38,060
second. GSM encryption, these are
algorithms called A51 and A52. And that

144
00:05:33,362 --> 00:05:38,060
GSM加密采用的算法被称为A51和A52，

145
00:05:38,060 --> 00:05:43,456
uses three LFSRs. Bluetooth encryption is
an algorithm called, E zero. These are all

146
00:05:38,060 --> 00:05:43,456
它使用三次LFSRs，还有蓝牙加密算法--E0，这些都是

147
00:05:43,456 --> 00:05:48,534
stream ciphers, and that uses four LFSRs.
Turns out all of these are badly broken,

148
00:05:43,456 --> 00:05:48,534
流密码，而且使用四次LFSRs。结果这些算法都被完全破解了

149
00:05:48,534 --> 00:05:53,245
and actually really should not be trusted
for encrypting traffic, but they're all

150
00:05:48,534 --> 00:05:53,245
在实际加密通信中并不可信，但是他们都是

151
00:05:53,245 --> 00:05:56,705
implemented in hardware, so it's a little
difficult now to change what the hardware

152
00:05:53,245 --> 00:05:56,705
在硬件上实现的,所以现在要改变硬件的工作机制是有难度的。

153
00:05:56,705 --> 00:06:01,047
does. But the simplest of these, CSS,
actually has a cute attack on it, so let

154
00:05:56,705 --> 00:06:01,047
但是这里面最简单的是：针对CSS，实际上有一个聪明的攻击方法，让

155
00:06:01,047 --> 00:06:05,459
me show you how the attack works. So,
let's describe how CSS actually works. So,

156
00:06:01,047 --> 00:06:05,459
我给你们展示这个攻击是怎么运作的。让我们让我们描述CSS实际上是如何运作的。

157
00:06:05,459 --> 00:06:11,073
the key for CSS is five bytes, namely 40
bits, five times eight is 40 bits. The

158
00:06:05,459 --> 00:06:11,073
CSS的密钥是五个字节,即40比特位,5乘8等于40位

159
00:06:11,073 --> 00:06:15,587
reason they had to limit themselves to
only 40 bits is that DVD encryption was

160
00:06:11,073 --> 00:06:15,587
它们被限制为40位的原因是DVD加密方式是被设计

161
00:06:15,587 --> 00:06:19,941
designed at a time where U.S. Export
regulations only allowed for export of

162
00:06:15,587 --> 00:06:19,941
在美国出口条例只允许出口

163
00:06:19,941 --> 00:06:25,086
crpyto algorithms where the key was
only 40 bits. So the designers of CSS were

164
00:06:19,941 --> 00:06:25,086
40位加密算法的密钥的时期。因此，CSS的设计者

165
00:06:25,086 --> 00:06:30,206
already limited to very, very short keys.
Just 40 bit keys. So, their design works

166
00:06:25,086 --> 00:06:30,206
将密钥限制的很短,很短,只有40位。因此,它们的设计如下，

167
00:06:30,206 --> 00:06:35,398
as follows. Basically, CSS uses two
LFSR's. One is a 17-bit LFSR. In other words,

168
00:06:30,206 --> 00:06:35,398
大体上,CSS用两个LFSR。一个是17位的LFSR,换句话说，

169
00:06:35,398 --> 00:06:40,806
the register contains
17 bits. And the other one is a 25-bit LFSR,

170
00:06:35,398 --> 00:06:40,806
寄存器容量是17比特。另一个是25位的LSFR，

171
00:06:40,806 --> 00:06:46,647
it's a little bit longer, 25-bit
LFSR. And the way these LFSRs are seeded

172
00:06:40,806 --> 00:06:46,647
25位的LFSR要更大一点。这些LSFR被植入的方式如下

173
00:06:46,647 --> 00:06:51,870
is as follows. So the key for the
encryption, basically looks as follows.

174
00:06:46,647 --> 00:06:51,870
用于加密的密钥，基本上看上去是这样的

175
00:06:51,870 --> 00:06:57,669
You start off with a one, and you concatenate to it the first two bytes of

176
00:06:51,870 --> 00:06:57,669
以1作为开头，把它与密钥的前两个字节连接。

177
00:06:57,669 --> 00:07:02,947
the key. And that's the initial state of the LFSR.

178
00:06:57,669 --> 00:07:02,947
这就是这个LFSR的初始状态。

179
00:07:02,947 --> 00:07:08,256
And then the second LFSR basically is intitialized the same way.

180
00:07:02,947 --> 00:07:08,256
然后，第二个LFSR基本上是同样的方式初始化。

181
00:07:08,256 --> 00:07:14,012
One concatenated the last three bytes of
the key. And that's

182
00:07:08,256 --> 00:07:14,012
一个寄存器连接最后的三个字节

183
00:07:14,012 --> 00:07:19,889
loaded into the initial state of the LFSR.
You can see that the first two bytes are

184
00:07:14,012 --> 00:07:19,889
并被装载进了LFSR的最初状态。你可以看到前两个字节

185
00:07:19,889 --> 00:07:25,411
sixteen bits, plus leading one, that's
seventeen bits overall, whereas the second

186
00:07:19,889 --> 00:07:25,411
即16位，加上开头的1位,一共17比特位。同时第二个LFSR

187
00:07:25,411 --> 00:07:31,217
LFSR is 24 bits plus one which is 25 bits.
And you notice we used all five bits of

188
00:07:25,411 --> 00:07:31,217
是24位再加一个是25位。你可以注意到我们使用了密钥的全部五位。

189
00:07:31,217 --> 00:07:36,881
the key. So then these LFSRs are basically
run for eight cycles, so they generate

190
00:07:31,217 --> 00:07:36,881
因此，这些LFSR基本上运行8个循环，它们产生

191
00:07:36,881 --> 00:07:42,333
eight bits of output. And then they go
through this adder that does basically

192
00:07:36,881 --> 00:07:42,333
8比特的输出。然后，它们经过加法器做

193
00:07:42,333 --> 00:07:48,197
addition modulo 256. Yeah so this is an
addition box, modulo 256. There's one more

194
00:07:42,333 --> 00:07:48,197
模256的加法运算。因此这是一个模256的加法计算器。

195
00:07:48,197 --> 00:07:54,325
technical thing that happens. In fact let's
actually—also added is the carry from the

196
00:07:48,197 --> 00:07:54,325
这里还有一点是，加法要考虑前面分组的进位，

197
00:07:54,325 --> 00:07:59,723
previous block. But that is not so
important. That's a detail that's not so

198
00:07:54,325 --> 00:07:59,723
不过这不是那么重要，它只是一个不怎么相关的细节。

199
00:07:59,723 --> 00:08:04,761
relevant. OK, so every block, you notice
we're doing addition modulo 256 and

200
00:07:59,723 --> 00:08:04,761
对于每一个分组，我们需要注意做模256加法运算时

201
00:08:04,761 --> 00:08:09,982
we're ignoring the carry, but the carry is
basically added as a zero or a one to the

202
00:08:04,761 --> 00:08:09,982
忽略了进位，进位是以0或1

203
00:08:09,982 --> 00:08:15,147
addition of the next block. Okay? And then
basically this output one byte per round.

204
00:08:09,982 --> 00:08:15,147
进入到下一分组。并且每次循环将输出一个字节。

205
00:08:15,147 --> 00:08:20,411
Okay, and then this byte is then of course
used, XOR-ed with the appropriate

206
00:08:15,147 --> 00:08:20,411
当然,这个字节同电影里的字节进行异或加密。

207
00:08:20,411 --> 00:08:25,167
byte of the movie that's being encrypted.
Okay, so it's a very simple stream

208
00:08:20,411 --> 00:08:25,167
它是一个非常简单的流密码，

209
00:08:25,167 --> 00:08:29,986
cipher, it takes very little hardware to
implement. It will run fast, even on very

210
00:08:25,167 --> 00:08:29,986
只需要很少硬件来实现的。它运行地非常快，甚至

211
00:08:29,986 --> 00:08:35,830
cheap hardware and it will encrypt movies.
So it turns out this is easy to break

212
00:08:29,986 --> 00:08:35,830
在非常低廉的硬件上也能够快速加密电影
因此导致只需要2的17次方次的尝试就可以将其破解

213
00:08:35,830 --> 00:08:41,222
in time roughly two to the seventeen. Now let me show you how.

214
00:08:35,830 --> 00:08:41,222
现在让我来给你们演示一下怎么做的。

215
00:08:41,222 --> 00:08:45,734
So suppose you
intercept the movies, so here we have an

216
00:08:41,222 --> 00:08:45,734
现在假设你截获了一部电影，这里有

217
00:08:45,734 --> 00:08:50,647
encrypted movie that you want to decrypt.
So let's say that this is all encrypted so

218
00:08:45,734 --> 00:08:50,647
你想要破解的加密电影。我们假设电影全都被加密了

219
00:08:50,647 --> 00:08:55,279
you have no idea what's inside of here.
However, it so happens that just because

220
00:08:50,647 --> 00:08:55,279
你不知道里面是什么。然而,碰巧由于

221
00:08:55,279 --> 00:08:59,970
DVD encryption is using MPEG files, it so
happens if you know of a prefix of the

222
00:08:55,279 --> 00:08:59,970
DVD加密是用MPEG文件，如果你碰巧知道明文的前缀，

223
00:08:59,970 --> 00:09:04,250
plaintext, let's just say maybe this is
twenty bytes. Well, we know if you

224
00:08:59,970 --> 00:09:04,250
我们假设它是20个字节的。那么我们知道如果你

225
00:09:04,250 --> 00:09:08,589
XOR these two things together, so in other words, you do the XOR here,

226
00:09:04,250 --> 00:09:08,589
对这两个进行异或，换句话说，你在这进行了异或

227
00:09:08,589 --> 00:09:13,523
what you'll get is the initial segment of the PRG. So, you'll get the

228
00:09:08,589 --> 00:09:13,523
你将会得到PRG（即：伪随机码发生器）的
最初的部分。因此，你将会得到

229
00:09:13,523 --> 00:09:18,472
first twenty bytes of the output of CSS,
the output of this PRG. Okay, so now

230
00:09:13,523 --> 00:09:18,472
CSS输出的前20个字节也就是PRG的输出。

231
00:09:18,472 --> 00:09:23,986
here's what we're going to do. So we have
the first twenty bytes of the output. Now

232
00:09:18,472 --> 00:09:23,986
我们有了20个字节的输出，那么接下来要做的就是

233
00:09:23,986 --> 00:09:31,405
we do the following. We try all two to the
seventeen possible values of the first

234
00:09:23,986 --> 00:09:31,405
尝试2的17次方个全部可能第一个LFSR的值。

235
00:09:31,405 --> 00:09:37,088
LFSR. Okay? So two to the seventeen
possible values. So for each value, so for

236
00:09:31,405 --> 00:09:37,088
因此，对于2的17次方种可能的

237
00:09:37,088 --> 00:09:42,622
each of these two to the seventeen initial
values of the LFSR, we're gonna run the

238
00:09:37,088 --> 00:09:42,622
LFSR寄存器的初始值，我们将运行

239
00:09:42,622 --> 00:09:47,953
LFSR for twenty bytes, okay? So we'll
generate twenty bytes of outputs from this

240
00:09:42,622 --> 00:09:47,953
这些LFSR来产生20个字节。因此我们将从假设的2的17次方个可能的初始设置中

241
00:09:47,953 --> 00:09:53,284
first LFSR, assuming—for each one of the
two to the seventeen possible settings

242
00:09:47,953 --> 00:09:53,284
生成第一个LFSR的20个字节

243
00:09:53,284 --> 00:09:58,615
Now, remember we have the full output of
the CSS system. So what we can do is we

244
00:09:53,284 --> 00:09:58,615
现在，记得我们有全部的CSS输出系统。现在我们可以做的是

245
00:09:58,615 --> 00:10:03,814
can take this output that we have. And
subtract it from the twenty bites that we

246
00:09:58,615 --> 00:10:03,814
我们可以把得到的输出减去从第一个LFSR产生的20个字节。

247
00:10:03,814 --> 00:10:08,928
got from the first LFSR, and if in fact our
guess for the initial state of the first

248
00:10:03,814 --> 00:10:08,928
事实上，如果我们对初始状态的猜测是正确的，

249
00:10:08,928 --> 00:10:14,042
LFSR is correct, what we should get
is the first twenty-byte output of the

250
00:10:08,928 --> 00:10:14,042
我们将得到的是第二个LFSR产生的前20个字节

251
00:10:14,042 --> 00:10:19,222
second LFSR. Right? Because that's by
definition what the output of the CSS

252
00:10:14,042 --> 00:10:19,222
对吗？因为这是根据CSS系统的定义而输出的。

253
00:10:19,222 --> 00:10:24,501
system is. Now, it turns out that looking
at a 20-byte sequence, it's very easy

254
00:10:19,222 --> 00:10:24,501
现在，事实上20个字节队列，非常容易

255
00:10:24,501 --> 00:10:29,763
to tell whether this 20-byte sequence
came from a 25-bit LFSR or not. If it

256
00:10:24,501 --> 00:10:29,763
辨别出来它是不是来自一个25字节的LFSR。如果

257
00:10:29,763 --> 00:10:33,561
didn't, then we know that our guess
for the 17-bit LFSR was

258
00:10:29,763 --> 00:10:33,561
不是，我们就知道我们的17位LFSR的假设是错误的，

259
00:10:33,561 --> 00:10:37,416
incorrect and then we move on to the next
guess for the 17-bit LFSR and

260
00:10:33,561 --> 00:10:37,416
并且我们进行下一步的假设，

261
00:10:37,416 --> 00:10:41,904
the next guess and so on and so forth.
Until eventually we hit the right initial

262
00:10:37,416 --> 00:10:41,904
下下步的假设，以此类推。直到最终我们得到正确的

263
00:10:41,904 --> 00:10:46,937
state for the 17-bit LFSR, and
then we'll actually get, we'll see that

264
00:10:41,904 --> 00:10:46,937
17位LFSR的初始状态。然后我们事实上会得到的，我们将会看到

265
00:10:46,937 --> 00:10:51,969
the 20 bytes that we get as the
candidate output for the 25-bit LFSR is

266
00:10:46,937 --> 00:10:51,969
得到的这20个字节可能的输出情况。

267
00:10:51,969 --> 00:10:56,936
in fact a possible output for a 25-bit LFSR. And then, not only will we have

268
00:10:51,969 --> 00:10:56,936
事实上，是25位LFSR的一种可能的输出情况。这样，我们不仅

269
00:10:56,936 --> 00:11:02,164
learned the correct initial state for the
17-bit LFSR, we will have also

270
00:10:56,936 --> 00:11:02,164
学会了正确的17位LFSR的初始状态，我们还

271
00:11:02,164 --> 00:11:07,523
learned the correct initial state of the
25-bit LFSR. And then we can predict the

272
00:11:02,164 --> 00:11:07,523
学会了25位LFSR的初始状态。我们可以预测

273
00:11:07,523 --> 00:11:12,796
remaining outputs of CSS, and of course,
using that, we can then decrypt the rest of

274
00:11:07,523 --> 00:11:12,796
剩余的CSS的输出。
当然，用这种方法，我们可以破解电影的剩余部分

275
00:11:12,796 --> 00:11:17,565
the movie. We can actually recover the
remaining plaintext. Okay. This is

276
00:11:12,796 --> 00:11:17,565
进而可以还原整个明文。

277
00:11:17,565 --> 00:11:22,335
things that we talked about before. So, I
said this a little quick, but hopefully,

278
00:11:17,565 --> 00:11:22,335
我们以前已经讲过这个了。因此，我说的快了一点点，但愿还算

279
00:11:22,335 --> 00:11:27,331
it was clear. We're also going to be doing
a homework exercise on this type of stream

280
00:11:22,335 --> 00:11:27,331
清晰。我们在流密码这部分有一道作业题，

281
00:11:27,331 --> 00:11:31,444
ciphers and you'll kind of get the point
of how these attack algorithms

282
00:11:27,331 --> 00:11:31,444
通过这道题你将会有掌握攻击算法是怎样做的。

283
00:11:31,444 --> 00:11:36,018
work. And I should mention that there are
many open-source systems now that actually

284
00:11:31,444 --> 00:11:36,018
我要提醒的是有许多开源系统，现在都是

285
00:11:36,018 --> 00:11:41,453
use this method to decrypt CSS-encrypted
data. Okay, so now that we've seen two

286
00:11:36,018 --> 00:11:41,453
用这种方法破解CSS密码的。好，现在我们看完了两个简单的例子，

287
00:11:41,453 --> 00:11:45,888
weak examples, let's move on to better
examples, and in particular the better

288
00:11:41,453 --> 00:11:45,888
让我们看看更好的例子，有个来自于eStreamd的

289
00:11:45,888 --> 00:11:49,370
pseudo-random generators come from what's
called the eStream Project. This is a

290
00:11:45,888 --> 00:11:49,370
更好的伪随机函数产生器。这个

291
00:11:49,370 --> 00:11:55,556
project that concluded in 2008, and they
qualify basically five different stream

292
00:11:49,370 --> 00:11:55,556
项目在2008年完成了，给出了5种不同的流密码，

293
00:11:55,556 --> 00:12:00,207
ciphers, but here I want to present just
one. So first of all the parameters for

294
00:11:55,556 --> 00:12:00,207
但是这里我只想讲一种。因此，首先，这些流密码的参数

295
00:12:00,207 --> 00:12:04,029
these stream ciphers are a little
different than what we're used to. So these

296
00:12:00,207 --> 00:12:04,029
与我们以前用过的有一点不一样。

297
00:12:04,029 --> 00:12:08,340
stream ciphers as normal they have a seed.
But in addition they also have, what's

298
00:12:04,029 --> 00:12:08,340
这些流密码和其他的正常的一样有种子。此外还有一个

299
00:12:08,340 --> 00:12:12,821
called a nonce and we'll see what a
nonce is used for in just a minute. So

300
00:12:08,340 --> 00:12:12,821
被称为随机数的，我们马上来看随机数是用来干嘛的。

301
00:12:12,821 --> 00:12:17,487
they take two inputs a seed and a nonce.
We'll see what the nonce is used for in

302
00:12:12,821 --> 00:12:17,487
它们需要输入一个种子和一个随机数。我们来看如何输入随机数。

303
00:12:17,487 --> 00:12:21,274
just a second. And the of course they
produce a very large output, so n here is

304
00:12:17,487 --> 00:12:21,274
理所应当，它们会产生一个非常大的输出，

305
00:12:21,274 --> 00:12:26,603
much, much, much bigger than s. Now, when
I say nonce, what I mean is a value that's

306
00:12:21,274 --> 00:12:26,603
这里的n远远大于s.现在,当我说到随机数的时候,就是指只要密钥确定,它的值

307
00:12:26,603 --> 00:12:31,218
never going to repeat as long as the key
is fixed. And I'll explain that in more

308
00:12:26,603 --> 00:12:31,218
就永远不变。我接下来将会详细解释。

309
00:12:31,218 --> 00:12:35,400
detail in just a second. But for now, just
think of it as a unique value that never

310
00:12:31,218 --> 00:12:35,400
而现在,只需要把它看作是一个独一无二的值

311
00:12:35,400 --> 00:12:40,527
repeats as long as the key is the same.
And so of course once you have this PRG,

312
00:12:35,400 --> 00:12:40,527
只要密钥确定，它就永不重复。当然，一旦你有了PRG，

313
00:12:40,527 --> 00:12:45,357
you would encrypt, you get a stream cipher
just as before, except now as you see, the

314
00:12:40,527 --> 00:12:45,357
你就能加密像之前流密码加密一样，
除了你现在看到的，PRG需要密钥和随机数

315
00:12:45,357 --> 00:12:49,955
PRG takes as input both the key and the
nonce. And the property of the nonce is

316
00:12:45,357 --> 00:12:49,955
作为输入。而随机数是一对的(k,r)

317
00:12:49,955 --> 00:12:56,350
that the pair, k comma r, so the key comma
the nonce, is never—never repeats. It's

318
00:12:49,955 --> 00:12:56,350
所以，切记切记：密钥,随机数,永远永远不会重复。

319
00:12:56,350 --> 00:13:03,096
never used more than once. So the bottom
line is that you can reuse the key, reuse

320
00:12:56,350 --> 00:13:03,096
它是一次一密，但底线是你可以重复利用密钥。

321
00:13:03,096 --> 00:13:09,710
the key, because the nonce makes the
pair unique, because k and r are only

322
00:13:03,096 --> 00:13:09,710
因为随机数让它们独一无二，因为k和r

323
00:13:09,710 --> 00:13:16,135
used once. I'll say they're unique. Okay
so this nonce is kind of a cute trick that

324
00:13:09,710 --> 00:13:16,135
只用一次，我说它们是唯一。
这个随机数是一个“狡猾”的小花招

325
00:13:16,135 --> 00:13:21,541
saves us the trouble of moving to a new
key every time. Okay, so the particular

326
00:13:16,135 --> 00:13:21,541
避免了我们每次更新密钥的麻烦。好，这个特殊的

327
00:13:21,541 --> 00:13:26,000
example from the eStream that I want to
show you is called Salsa twenty. It's a

328
00:13:21,541 --> 00:13:26,000
来自eStream的例子正是我想给你们展示的Salsa20.

329
00:13:26,000 --> 00:13:30,292
stream cipher that's designed for both
software implementations and hardware

330
00:13:26,000 --> 00:13:30,292
它是一个特别设计的在硬件和软件设施均可用的流密码。

331
00:13:30,292 --> 00:13:33,385
implementations. It's kind of interesting.
You realize that some stream ciphers are

332
00:13:30,292 --> 00:13:33,385
这有点意思，大家知道到一些流密码是为

333
00:13:33,385 --> 00:13:38,763
designed for software, like RC4.
Everything it does is designed to make

334
00:13:33,385 --> 00:13:38,763
软件而设计的，比如RC4.所有关于它的设计

335
00:13:38,763 --> 00:13:42,689
software implementation run fast, whereas
other stream ciphers are designed for

336
00:13:38,763 --> 00:13:42,689
都是为了让软件更快地运行。而其他的流密码是为硬件而设计的，

337
00:13:42,689 --> 00:13:48,143
hardware, like CSS, using an LFSR that's
particularly designed to make hardware

338
00:13:42,689 --> 00:13:48,143
比如CSS，运用了一个特别为低廉硬件定制的LFRS寄存器

339
00:13:48,143 --> 00:13:50,963
implementations very cheap. It's also, the
nice thing about that is that it's

340
00:13:48,143 --> 00:13:50,963
关于它的一件比较好的事情是

341
00:13:50,963 --> 00:13:55,008
designed so that it's both easy to
implement it in hardware and its software

342
00:13:50,963 --> 00:13:55,008
它被这样设计所以它对硬件和软件都有利，

343
00:13:55,008 --> 00:13:59,747
implementation is also very fast. So let
me explain how Salsa works. Well, Salsa

344
00:13:55,008 --> 00:13:59,747
运行速度都快。让我来解释Salsa是怎么工作的。好，

345
00:13:59,747 --> 00:14:05,130
takes either 128 or 256-bit keys. I'll
only explain the 128-bit version of Salsa.

346
00:13:59,747 --> 00:14:05,130
Salsa 输入128位或者256位的密钥，我将只解释128位版本的Salsa。

347
00:14:05,130 --> 00:14:11,244
So this is the seed. And then it also
takes a nonce, just as before, which

348
00:14:05,130 --> 00:14:11,244
这就是种子。需要输入一个随机数，像刚才一样，

349
00:14:11,244 --> 00:14:15,425
happens to be 64 bits. And then it'll
generate a large output. Now, how does it

350
00:14:11,244 --> 00:14:15,425
也是64位。然后会产生一个巨大的输出。现在看，它是

351
00:14:15,425 --> 00:14:21,060
actually work? Well, the function itself
is defined as follows. Basically, given

352
00:14:15,425 --> 00:14:21,060
怎么工作的呢？函数定义如下。基本上

353
00:14:21,060 --> 00:14:26,378
the key and the nonce, it will generate a
very long, well, a long pseudorandom

354
00:14:21,060 --> 00:14:26,378
给定的密钥和随机数，它将会产生一个很长,很长的伪随机序列，

355
00:14:26,378 --> 00:14:31,222
sequence, as long as necessary. And it'll do
it by using this function that I'll denote by

356
00:14:26,378 --> 00:14:31,222
相当的长,如果有必要的话。我将通过使用的函数我把它记作H来实现.

357
00:14:31,222 --> 00:14:35,653
H. This function H takes three inputs.
Basically the key. Well, the seed k,

358
00:14:31,222 --> 00:14:35,653
这个H函数需要三个输入。密钥，种子k,

359
00:14:35,653 --> 00:14:40,498
the nonce r, and then a counter that
increments from step to step. So it goes

360
00:14:35,653 --> 00:14:40,498
随机数r,一个计数器一步一步计数。

361
00:14:40,498 --> 00:14:45,263
from zero to one, two, three, four as long as
we need it to be. Okay? So basically,

362
00:14:40,498 --> 00:14:45,263
它从0到1，2,3,4,直到我们需要。明白了吗？

363
00:14:45,263 --> 00:14:49,956
by evaluating this H on this k r, but using
this incrementing counter, we can get a

364
00:14:45,263 --> 00:14:49,956
所以通过评估H函数和(k,r),用递增计数器，我们

365
00:14:49,956 --> 00:14:54,882
sequence that's as long as we want. So all
I have to do is describe how this function

366
00:14:49,956 --> 00:14:54,882
得到我们想要的队列。我们全部需要做的就是描述

367
00:14:54,882 --> 00:14:59,460
H works. Now, let me do that here for you.
The way it works is as follows. Well, we

368
00:14:54,882 --> 00:14:59,460
这个函数H是怎么工作的。现在，让我来描述一下。它是按以下方式工作的，

369
00:14:59,460 --> 00:15:04,693
start off by expanding the states into
something quite large which is 64 bytes

370
00:14:59,460 --> 00:15:04,693
开始先把状态扩充至64个字节长，

371
00:15:04,693 --> 00:15:10,156
long, and we do that as follows. Basically
we stick a constant at the beginning, so

372
00:15:04,693 --> 00:15:10,156
我们按以下方式做。我们在刚开始先定义一个常数，

373
00:15:10,156 --> 00:15:15,552
there's tao zero, these are four bytes,
it's a four byte constant, so the spec for

374
00:15:10,156 --> 00:15:15,552
τ0是4字节，它是个4字节常量，Salsa给定了

375
00:15:15,552 --> 00:15:20,611
Salsa basically gives you the value for
tao zero. Then we put k in which is

376
00:15:15,552 --> 00:15:20,611
τ0的值。然后，我们把k放在

377
00:15:20,611 --> 00:15:25,467
sixteen bytes. Then we put another
constant. Again, this is four bytes. And

378
00:15:20,611 --> 00:15:25,467
16字节的地方。然后我们把另一个常量，也是四字节的放进去。

379
00:15:25,467 --> 00:15:30,795
as I said, the spec basically specifies
what this fixed constant is. Then we put

380
00:15:25,467 --> 00:15:30,795
正如我所说，说明书上也定义了这个常量。

381
00:15:30,795 --> 00:15:37,435
the nonce, which is eight bytes. Then we
put the index. This is the counter zero,

382
00:15:30,795 --> 00:15:37,435
我们取8字节的随机数，再取索引表。这是计数器

383
00:15:37,435 --> 00:15:43,063
one, two, three, four, which is another
eight bytes. Then we put another constant

384
00:15:37,435 --> 00:15:43,063
0,1,2,3,4,是另外8比特。然后我们取另外一个常量

385
00:15:43,063 --> 00:15:49,056
tau two, which is another four bytes.
Then we put the key again, this is another

386
00:15:43,063 --> 00:15:49,056
τ2,也是四字节的。再取密钥，这是另外一个

387
00:15:49,056 --> 00:15:54,714
sixteen bytes. And then finally we put the
third constant, tau three, which is

388
00:15:49,056 --> 00:15:54,714
16字节的。最后我们取第三个常量，τ3,

389
00:15:54,714 --> 00:15:59,948
another four bytes. Okay so as I said, if you
sum these up, you see that you get 64

390
00:15:54,714 --> 00:15:59,948
还是4字节的。如我所说，如果你把这些加起来，你将会看到

391
00:15:59,948 --> 00:16:05,249
bytes. So basically we've expanded the key
and the nonce and the counter into 64

392
00:15:59,948 --> 00:16:05,249
你得到字节数。我们已经扩展了密钥，随机数，计数器为64字节，

393
00:16:05,249 --> 00:16:10,886
bytes. Basically the key is repeated twice
I guess. And then what we do is we apply a

394
00:16:05,249 --> 00:16:10,886
并且密钥重复了两次。接下来我们要用一个函数

395
00:16:10,886 --> 00:16:16,321
function, I'll call this functional little h.
Okay, so we apply this function, little h.

396
00:16:10,886 --> 00:16:16,321
我们把这个函数称为h。

397
00:16:16,321 --> 00:16:21,659
And this is a function that's one to one
so it maps 64 bytes to 64 bytes. It's a

398
00:16:16,321 --> 00:16:21,659
这个函数是由64字节到64字节一一对应的

399
00:16:21,659 --> 00:16:26,005
completely invertible function, okay? So
this function h is, as I say, it's an

400
00:16:21,659 --> 00:16:26,005
它是一个完全可逆的函数。这个函数h，正如我所说的，是一个可逆函数。

401
00:16:26,005 --> 00:16:30,260
invertable function. So given the input
you can get the output and given the

402
00:16:26,005 --> 00:16:30,260
因此，给定一个输入你将得到输出，

403
00:16:30,260 --> 00:16:34,906
output you can go back to the input. And
it's designed specifically so it's a- easy

404
00:16:30,260 --> 00:16:34,906
给一个输出将会返回输入。并且它被特殊设计过,因此

405
00:16:34,906 --> 00:16:39,553
to implement in hardware and b- on an x86,
it's extremely easy to implement because

406
00:16:34,906 --> 00:16:39,553
在x86上很容易运行

407
00:16:39,553 --> 00:16:44,199
x86 has this SSE2 instruction set which
supports all the operations you need to do

408
00:16:39,553 --> 00:16:44,199
因为x86有SSE2指令支持操作

409
00:16:44,199 --> 00:16:48,622
for this function. It's very, very fast.
As a result, Salsa has a very fast stream

410
00:16:44,199 --> 00:16:48,622
这个函数。它非常非常地快。总之，Salsa有一个

411
00:16:48,622 --> 00:16:52,764
cipher. And then it does this basically
again and again. So it applies this

412
00:16:48,622 --> 00:16:52,764
非常快的流密码。它不断地做这件事。因此它应用于

413
00:16:52,764 --> 00:16:57,744
function h again and it gets another 64
bytes. And so on and so forth, basically

414
00:16:52,764 --> 00:16:57,744
函数h得到另外的64字节。诸如此类，

415
00:16:57,744 --> 00:17:05,318
it does this ten times. Okay so the whole
thing here, say repeats ten times, so

416
00:16:57,744 --> 00:17:05,318
基本上它要这样做10次，好，这里是全部的，重复10次，

417
00:17:05,318 --> 00:17:17,961
basically apply h ten times. And then by
itself, this is actually not quite random.

418
00:17:05,318 --> 00:17:17,961
因此基本上用h用10次。对它自身来说，它并不是

419
00:17:17,961 --> 00:17:22,144
It's not gonna look random because like we
said, H is completely invertable. So given

420
00:17:17,961 --> 00:17:22,144
随机的，因为正如我们所说的，H是一个完全可逆的。

421
00:17:22,144 --> 00:17:25,521
this final output, it's very easy to
just invert h and then go back to the original

422
00:17:22,144 --> 00:17:25,521
因此给定了最终的输出就非常容易求h的逆，再返回

423
00:17:25,521 --> 00:17:31,831
inputs and then test that the input has
the right structure. So you do one more

424
00:17:25,521 --> 00:17:31,831
原始输入，然后测试输入的正确结构。

425
00:17:31,831 --> 00:17:36,979
thing, which is to basically XOR the
inputs and the final outputs. Actually,

426
00:17:31,831 --> 00:17:36,979
那么我们就再做另外一件事，
把最终输出和输入进行异或。事实上，

427
00:17:36,979 --> 00:17:42,405
sorry. It's not an XOR. It's actually an
addition. So you do an addition word by

428
00:17:36,979 --> 00:17:42,405
对不起，不是异或，实际上是相加。做一字一句地相加。

429
00:17:42,405 --> 00:17:47,762
word. So if there are 64 bytes, you do a
word-by-word addition four bytes at a

430
00:17:42,405 --> 00:17:47,762
因此，如果是64字节，要进行4字节一次地相加，

431
00:17:47,762 --> 00:17:52,980
time, and finally you get the 64-byte
output, and that's it. That's the whole

432
00:17:47,762 --> 00:17:52,980
最终得到64字节的输出，就是结果了。这就是整个

433
00:17:52,980 --> 00:17:57,175
pseudo-random generator. So that, that's
the whole function, little h. And as I

434
00:17:52,980 --> 00:17:57,175
伪随机数发生器。因此，对于整个函数是h,

435
00:17:57,175 --> 00:18:01,758
explained, this whole construction here is
the function big H. And then you evaluate

436
00:17:57,175 --> 00:18:01,758
正如我解释的，整个机制是函数H。然后

437
00:18:01,758 --> 00:18:06,009
big H by incrementing the counter I from
zero, one, two, three onwards. And that

438
00:18:01,758 --> 00:18:06,009
通过递增计数器从0,1,2,3向上来评估函数H。

439
00:18:06,009 --> 00:18:10,408
will give you a pseudo-random sequence
that's as long as you need it to be. And

440
00:18:06,009 --> 00:18:10,408
这样你会得到一个伪随机数发生器只要你需要。

441
00:18:10,408 --> 00:18:15,325
basically, there are no signifigant
attacks on this. This has security that's

442
00:18:10,408 --> 00:18:15,325
基本上在这方面还没有重大的攻击。它的安全系数接近

443
00:18:15,325 --> 00:18:20,371
very close to two to the 128. We'll see
what that means more precisely later on.

444
00:18:15,325 --> 00:18:20,371
2的128次方。我们随后将会讨论更详细的内容。

445
00:18:20,371 --> 00:18:25,417
It's a very fast stream cipher, both in
hardware and in software. And, as far as

446
00:18:20,371 --> 00:18:25,417
它是非常快的流密码，无论在硬件上还是在软件上。就我们而言，

447
00:18:25,417 --> 00:18:30,431
we can tell, it seems to be unpredictable
as required for a stream cipher. So I

448
00:18:25,417 --> 00:18:30,431
它看上去似乎是不可预测的作为流密码，
正如一个流密码需要的那样。

449
00:18:30,431 --> 00:18:34,797
should say that the eStream project
actually has five stream ciphers like

450
00:18:30,431 --> 00:18:34,797
因此为应该说eStream 工程实际上有五个像这样的流密码。

451
00:18:34,797 --> 00:18:39,395
this. I only chose Salsa 'cause I think
it's the most elegant. But I can give you

452
00:18:34,797 --> 00:18:39,395
我只举Salsa的例子我认为最合适的。但是我可以给你们

453
00:18:39,395 --> 00:18:44,053
some performance numbers here. So you can
see, these are performance numbers on a

454
00:18:39,395 --> 00:18:44,053
一些性能参数。这些是在x86机上的2.2Ghz性能值。可以看到这些性能参数，

455
00:18:44,053 --> 00:18:48,768
2.2 gigahertz, you know, x86 type machine.
And you can see that RC4 actually is the

456
00:18:44,053 --> 00:18:48,768
你可以看到RC4事实上是最慢的。

457
00:18:48,768 --> 00:18:53,017
slowest. Because essentially, well it
doesn't really take advantage of the

458
00:18:48,768 --> 00:18:53,017
因为在本质上，它在硬件上并不占优势。

459
00:18:53,017 --> 00:18:57,475
hardware. It only does byte operations.
And so there's a lot of wasted cycles that

460
00:18:53,017 --> 00:18:57,475
它只有字操作，因此有很多浪费的循环没有被用。

461
00:18:57,475 --> 00:19:01,182
aren't being used. But the E-Stream
candidates, both Salsa and other

462
00:18:57,475 --> 00:19:01,182
但是eStream,无论是Salsa还是其他的，

463
00:19:01,182 --> 00:19:05,202
candidate called Sosemanuk. I should say these
are eStream finalists. These are

464
00:19:01,182 --> 00:19:05,202
都被称为Sosemanuk.我认为它们是eStream的优胜者。

465
00:19:05,202 --> 00:19:09,588
actually stream ciphers that are approved
by the eStream project. You can see that

466
00:19:05,202 --> 00:19:09,588
事实上，有很多流密码都获得了eStream项目的批准。你可以看到

467
00:19:09,588 --> 00:19:13,712
they have achieved a significant rate.
This is 643 megabytes per second on this

468
00:19:09,588 --> 00:19:13,712
它们取得了很高的速率。这个架构每秒处理643M字节的数据，

469
00:19:13,712 --> 00:19:18,150
architecture, more than enough for a movie
and these are actually quite impressive

470
00:19:13,712 --> 00:19:18,150
这个速度足以应对电影并且相当令人印象深刻。

471
00:19:18,150 --> 00:19:22,432
rates. And so now you've seen examples of
two old stream ciphers that shouldn't be

472
00:19:18,150 --> 00:19:22,432
因此，现在你已经看到两个老的已经不应该被用到流密码的例子，

473
00:19:22,432 --> 00:19:26,661
used, including attacks on those stream ciphers.
You've seen what the modern stream ciphers

474
00:19:22,432 --> 00:19:26,661
包括流密码的攻击。你已经看到

475
00:19:26,661 --> 00:19:30,480
look like with this nonce. And you
see the performance numbers for these

476
00:19:26,661 --> 00:19:30,480
看起来像随机数的现代流密码。根据现代流密码的性能参数,如果

477
00:19:30,480 --> 00:19:34,546
modern stream ciphers so if you happen to
need a stream cipher you could use one of

478
00:19:30,480 --> 00:19:34,546
你需要使用流密码，你可以使用一种eStream的优胜方案。

479
00:19:34,546 --> 00:19:37,991
the eStream finalists. In particular you
could use something like Salsa.

480
00:19:34,546 --> 00:19:37,991
特别地,你可以用Salsa。

