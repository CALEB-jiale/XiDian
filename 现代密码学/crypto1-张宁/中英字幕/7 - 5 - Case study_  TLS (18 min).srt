1
00:00:00,000 --> 00:00:04,450
So I want to show you how authenticated
encryption is used in the real world, so

2
00:00:00,000 --> 00:00:04,450
我想演示如何在现实生活中运用认证加密技术

3
00:00:04,450 --> 00:00:08,844
let's use TLS as an example and see how
TLS works. So data encryption in TLS is

4
00:00:04,450 --> 00:00:08,844
让我们以TLS做为例子 并看看它是如何工作的 TLS中的数据加密

5
00:00:08,844 --> 00:00:13,183
done using a protocol called a TLS record
protocol. In this protocol, every TLS

6
00:00:08,844 --> 00:00:13,183
是通过使用TLS记录协议完成的 该协议中 每个TLS

7
00:00:13,183 --> 00:00:17,800
record starts with a header, we'll see the
structure of the header in just a minute,

8
00:00:13,183 --> 00:00:17,800
记录以一数据头开头 不久我们就会看到这个数据头的结构

9
00:00:17,800 --> 00:00:22,250
followed by encrypted data that is sent
from one side to the other. In TLS, it so

10
00:00:17,800 --> 00:00:22,250
紧接着是从一端到另一端的加密数据 TLS中

11
00:00:22,250 --> 00:00:26,534
happens that the records are at most
sixteen kilobytes and if more data than

12
00:00:22,250 --> 00:00:26,534
记录的长度至多为16KB 如果需要

13
00:00:26,534 --> 00:00:30,984
sixteen kilobytes needs to be sent, then
basically the record is fragmented into

14
00:00:26,534 --> 00:00:30,984
发送多于16KB数据 那么该记录就会分割成

15
00:00:30,984 --> 00:00:35,401
multiple records. Now TLS uses what's
called unidirectional keys, meaning that

16
00:00:30,984 --> 00:00:35,401
多个记录 TLS运用的是单向密钥

17
00:00:35,401 --> 00:00:40,087
there's one key from browser to server,
and there's a separate key from server to

18
00:00:35,401 --> 00:00:40,087
即一密钥从浏览器到服务器用 另一个密钥从服务器到浏览器使用

19
00:00:40,087 --> 00:00:44,774
browser. So one key is used for sending
messages from a browser to the server, and

20
00:00:40,087 --> 00:00:44,774
所以 一密钥供浏览器到服务器发送消息使用

21
00:00:44,774 --> 00:00:49,113
the other key is used from sending
messages from the server to the browser,

22
00:00:44,774 --> 00:00:49,113
另一密钥用于服务器到浏览器发送消息

23
00:00:49,113 --> 00:00:53,800
and of course both sides, both the server
and the browser, know both of these keys.

24
00:00:49,113 --> 00:00:53,800
当然 浏览器端与服务器端相互知道这两个密钥

25
00:00:53,800 --> 00:00:58,026
And just to be clear I'll say the browser
will use this key to send data to the

26
00:00:53,800 --> 00:00:58,026
为了更好理解 我这样假设 浏览器使用这个密钥发送数据给

27
00:00:58,026 --> 00:01:02,464
server and we'll use this key to read data
from the server and the server basically

28
00:00:58,026 --> 00:01:02,464
服务器 那我们使用该密钥从服务器读取数据 这里服务器也

29
00:01:02,464 --> 00:01:06,638
does exactly the same thing just with the
opposite keys. Now these keys, both of

30
00:01:02,464 --> 00:01:06,638
使用另一个密钥做相同操作 而这些

31
00:01:06,638 --> 00:01:10,811
these keys are actually generated by the
TLS key exchange protocol which we're

32
00:01:06,638 --> 00:01:10,811
供两端使用的密钥都是由TLS密钥交换协议产生的

33
00:01:10,811 --> 00:01:15,143
gonna talk about in the second part of the
course. Right now I'm gonna assume that

34
00:01:10,811 --> 00:01:15,143
该协议将在本节的第二部分讲到 现假设

35
00:01:15,143 --> 00:01:19,529
these keys have already been established.
They're known to both the server and the

36
00:01:15,143 --> 00:01:19,529
已创建了这些密钥 且服务器端与浏览器端都知道这些密钥

37
00:01:19,529 --> 00:01:23,859
browser, and now the browser and server
want to exchange information using those

38
00:01:19,529 --> 00:01:23,859
现在服务器和浏览器试图使用这些密钥交换数据

39
00:01:23,859 --> 00:01:27,591
keys. So the TLS record protocol uses
what's called stateful encryption, which

40
00:01:23,859 --> 00:01:27,591
那么TLS记录协议就会使用状态性加密 也就是

41
00:01:27,591 --> 00:01:31,693
means that the encryption of every packet.
Is done using certain state that's

42
00:01:27,591 --> 00:01:31,693
每一数据包都是使用由浏览器和服务器内部维护的

43
00:01:31,693 --> 00:01:36,575
maintained inside of the browser and the
server. In particular the state that's of

44
00:01:31,693 --> 00:01:36,575
特定状态来加密的 特别地 更能吸引我们的是

45
00:01:36,575 --> 00:01:41,368
interest to us are these 64 bit counters,
again there are two 64 bit counters. One

46
00:01:36,575 --> 00:01:41,368
64比特计数器 再次强调 有两个64比特计数器

47
00:01:41,368 --> 00:01:45,483
for traffic from browser to server, and
one from traffic from the server to the

48
00:01:41,368 --> 00:01:45,483
一个用于浏览器到服务器的信息流 另一个用于服务器到浏览器的信息流

49
00:01:45,483 --> 00:01:49,286
browser. These counters are initialized to
zero when the session is first

50
00:01:45,483 --> 00:01:49,286
当这些计数器第一次初始化时值为0

51
00:01:49,286 --> 00:01:53,558
initialized, and they're incremented every
time a record is sent. So every time the

52
00:01:49,286 --> 00:01:53,558
并且每次发送记录后 计数器的值都会增加 所以每当

53
00:01:53,558 --> 00:01:57,830
browser sends a record to the server, the
browser will go ahead and increment this

54
00:01:53,558 --> 00:01:57,830
浏览器发送一记录给服务器 浏览器都会增加计数器的值

55
00:01:57,830 --> 00:02:01,893
counter. When the server receives that
record, it'll go ahead and increment the

56
00:01:57,830 --> 00:02:01,893
而当服务器接收记录后 它也会增加

57
00:02:01,893 --> 00:02:06,086
counter on its side. And when the server
sends a record to the browser, he'll go

58
00:02:01,893 --> 00:02:06,086
它这边的计数器值 而当服务器发送一记录给浏览器 它就会

59
00:02:06,086 --> 00:02:10,454
ahead and increment the second counter and
again when the browser receives this

60
00:02:06,086 --> 00:02:10,454
增加第二个计数器的值 此外 当浏览器接收到这个记录后

61
00:02:10,454 --> 00:02:14,931
record it'll go ahead and increment its
copy of this counter. So this state these

62
00:02:10,454 --> 00:02:14,931
它就会增加它的计数器的值 这个状态即两个计数器

63
00:02:14,931 --> 00:02:19,463
two counters basically this state exists
both on the browser and on the server and

64
00:02:14,931 --> 00:02:19,463
既存在于浏览器上也存在于服务器上

65
00:02:19,463 --> 00:02:23,940
it's updated appropriately as records are
sent from one to the other and received

66
00:02:19,463 --> 00:02:23,940
此外它随记录从一端发送到另一端而更新 并且

67
00:02:23,940 --> 00:02:28,363
by the appropriate side. Now the purpose
of these counters as we'll see in just a

68
00:02:23,940 --> 00:02:28,363
被适当的接收方接收 这些计数器存在的目的是

69
00:02:28,363 --> 00:02:32,840
minute is to prevent replay attacks so
than an attacker can't simply record the record

70
00:02:28,363 --> 00:02:32,840
防止重放攻击 这样攻击者就不能记录消息

71
00:02:32,840 --> 00:02:37,044
and then replay at a later time because by
then the counters will have to be

72
00:02:32,840 --> 00:02:37,044
并在之后的时间内重放 因为这时计数器将不得不增加

73
00:02:37,044 --> 00:02:41,990
incremented. Okay, so let's look at the
details of how the record protocol works.

74
00:02:37,044 --> 00:02:41,990
现在我们来看记录协议的工作细节

75
00:02:41,990 --> 00:02:47,304
In particular I'll show you kind of the
mandatory cipher suit which is encryption

76
00:02:41,990 --> 00:02:47,304
特别地 我会演示强制密码组 也就是加密使用AES―CBC

77
00:02:47,304 --> 00:02:52,508
using AES-CBC and MACing using HMAC-SHA1. Okay,
so remember, TLS uses a MAC, then encrypt,

78
00:02:47,304 --> 00:02:52,508
杂凑使用HMAC―SHA1 记住 TLS使用杂凑算法 然后加密

79
00:02:52,508 --> 00:02:56,825
where the MAC algorithm is HMAC-SHA1, and the encryption

80
00:02:52,508 --> 00:02:56,825
而这个杂凑算法就是HMAC-SHA1 而加密算法

81
00:02:56,825 --> 00:03:02,043
algorithm is AES128 in CBC mode. Okay, so
let's look at how the browser sends data

82
00:02:56,825 --> 00:03:02,043
是使用AES128的CBC码 现让我们看看浏览器如何发送数据给

83
00:03:02,043 --> 00:03:07,068
to the server, which, as I said, is done
using the browser to server key. Now, the

84
00:03:02,043 --> 00:03:07,068
服务器 前面说过 它是通过使用浏览器到服务器的密钥实现的

85
00:03:07,068 --> 00:03:12,218
browser to server key itself, is made up
of a MAC key and an encryption key. Two

86
00:03:07,068 --> 00:03:12,218
而这个浏览器到服务器密钥是由一杂凑密钥与一加密密钥组成而成

87
00:03:12,218 --> 00:03:18,436
separated keys that are again as I said
negotiated during session setup. And again

88
00:03:12,218 --> 00:03:18,436
两不同的密钥均是在会话建立时协商的 为了使你们

89
00:03:18,436 --> 00:03:22,889
I wanna be absolutely clear. There is a
separate key for browser to server and a

90
00:03:18,436 --> 00:03:22,889
完全明白 解说如下 一独立密钥供浏览器到服务器使用

91
00:03:22,889 --> 00:03:27,176
separate key from server to browser. So
there, overall, there are four keys. Two

92
00:03:22,889 --> 00:03:27,176
另一密钥供服务器到浏览器使用 所以2*2共4个密钥

93
00:03:27,176 --> 00:03:31,406
MAC keys, and two encryption keys, each
one used in the appropriate direction.

94
00:03:27,176 --> 00:03:31,406
两个杂凑密钥和两个加密密钥 每个密钥都在合适的地方使用

95
00:03:31,406 --> 00:03:36,026
Okay, so here I wrote down the diagram of
what a tls packet looks like. It begins

96
00:03:31,406 --> 00:03:36,026
然后 这里我图示出了一TLS数据包的结构 它以一数据头打头

97
00:03:36,026 --> 00:03:40,368
with a header that contains the type of
the packet, the version number for the

98
00:03:36,026 --> 00:03:40,368
该数据头包含有数据包类型、协议版本号

99
00:03:40,368 --> 00:03:44,766
protocol, and the length of the packet.
Notice the length of the packet it sends

100
00:03:40,368 --> 00:03:44,766
数据包长度等信息 注意数据包长度以明文发送

101
00:03:44,766 --> 00:03:49,316
in the clear. Now, when encrypting
data, a certain record, the encryption

102
00:03:44,766 --> 00:03:49,316
而当要加密数据也就是一特定记录时 加密步骤如下

103
00:03:49,316 --> 00:03:54,083
procedure works as follows. Of course, it
takes key as input, and it takes the

104
00:03:49,316 --> 00:03:54,083
当然 它以密钥、当前状态等做为输入

105
00:03:54,083 --> 00:03:59,139
current status input. And then it works as
follows. What it'll do is first of all is

106
00:03:54,083 --> 00:03:59,139
接着 它首先

107
00:03:59,139 --> 00:04:03,851
it would MAC the following data, while
here's the actual payload that's MACed but

108
00:03:59,139 --> 00:04:03,851
对这个数据进行散列计算 这个是要计算散列值的实际有效载荷

109
00:04:03,851 --> 00:04:08,679
the heather is also MACed. In addition the
counter, the current value of the counter

110
00:04:03,851 --> 00:04:08,679
而数据头也需要进行散列计算 此外 计数器 也就是计数器的当前值

111
00:04:08,679 --> 00:04:12,926
is also MACed and of course, it's all the
counters implemented during the

112
00:04:08,679 --> 00:04:12,926
也需要进行散列计算 当然计数器的值会随着

113
00:04:12,926 --> 00:04:17,754
key fact that one more record has
been sent. Now the interesting thing here

114
00:04:12,926 --> 00:04:17,754
发送一记录而增加 这里有趣的是

115
00:04:17,754 --> 00:04:22,271
is that even though the value of the
counter is included in the tag. You notice

116
00:04:17,754 --> 00:04:22,271
虽然计数器的值包含在特征值中 但可以注意到

117
00:04:22,271 --> 00:04:26,356
the value of the counter is actually never
sent in the record, and the reason it

118
00:04:22,271 --> 00:04:26,356
计数器值不会包含在记录中被发送

119
00:04:26,356 --> 00:04:30,593
doesn't need to be sent in the record is
that the server on the other side already

120
00:04:26,356 --> 00:04:30,593
而不需要包含在记录中被发送的原因是在另一端的服务器已经

121
00:04:30,593 --> 00:04:34,729
knows what the value of the counter needs
to be. So it doesn't need to be told in

122
00:04:30,593 --> 00:04:34,729
知道计数器的值 所以不需要再次告诉

123
00:04:34,729 --> 00:04:38,814
the record what the value of the counter
is. It implicitly already knows what it

124
00:04:34,729 --> 00:04:38,814
服务器端计数器的值 服务器私底下是知道它的值的

125
00:04:38,814 --> 00:04:42,949
is, and when it's gonna verify the MAC, it
could just use the value that it thinks

126
00:04:38,814 --> 00:04:42,949
并且当服务器想要认证杂凑值时 它可以用它自己认为的

127
00:04:42,949 --> 00:04:47,072
the counter should be and verify the MAC
in that fashion. Okay, so this is kind of

128
00:04:42,949 --> 00:04:47,072
计数器值然后完成认证 比较有趣过程是

129
00:04:47,072 --> 00:04:51,315
an interesting approach, where even though
the two sides maintain these counters that

130
00:04:47,072 --> 00:04:51,315
即使两端都保存有作为临时数的计数器的值

131
00:04:51,315 --> 00:04:55,406
function as nonces, there is no
reason to send the nonces in the record,

132
00:04:51,315 --> 00:04:55,406
两端依然不需要将临时值包含在记录中发送

133
00:04:55,406 --> 00:04:59,397
because both sides actually already know
what counters they're expecting every

134
00:04:55,406 --> 00:04:59,397
因为两端都知道它们所接收的记录的计数器值

135
00:04:59,397 --> 00:05:04,024
record that they receive. Okay, so that's
the tag. The tag is computed, as we said,

136
00:04:59,397 --> 00:05:04,024
所以这个就是特征值 它是通过这三重数据计算出来的

137
00:05:04,024 --> 00:05:09,320
over this triple data. The next thing that
happens is that the tag is concatenated to

138
00:05:04,024 --> 00:05:09,320
接下来 特征值会串联在这些数据上

139
00:05:09,320 --> 00:05:13,930
the data. Remember, this is MAC-then-Encrypt. So here, we computed the MAC. Now

140
00:05:09,320 --> 00:05:13,930
记住是先计算散列值后加密 这个是计算的散列

141
00:05:13,930 --> 00:05:18,852
we're gonna encrypt the data along with
the tag. So the header, the data, and the

142
00:05:13,930 --> 00:05:18,852
接下来将数据与特征值一起加密 所以数据头、数据、和特征值

143
00:05:18,852 --> 00:05:23,649
tag are padded to the AES block, and I
think we already said that this pad, if

144
00:05:18,852 --> 00:05:23,649
会被填加到AES数据分组上 我想我们前面已经讲过这个填充

145
00:05:23,649 --> 00:05:28,696
the pad length is five, then the pad is
done by simply writing the byte five, five

146
00:05:23,649 --> 00:05:28,696
如果填充长度为5 那么填充就是将字节5重复写5次

147
00:05:28,696 --> 00:05:34,032
times. If the pad link leads to be 5, the
pad would just be 55555. And then we CBC

148
00:05:28,696 --> 00:05:34,032
如果填充的是5那么整个填充就是55555 接着我们使用密钥

149
00:05:34,032 --> 00:05:39,477
encrypt using the encryption key, we CBC
encrypt the data and the tag. And we do

150
00:05:34,032 --> 00:05:39,477
利用CBC加密方法加密数据与特征值 加密过程中

151
00:05:39,477 --> 00:05:44,715
that using a fresh random IV, which is
later embedded in the cipher text. And

152
00:05:39,477 --> 00:05:44,715
使用一个新随机数IV 该数之后会被嵌于密文中

153
00:05:44,715 --> 00:05:50,367
then we prepend the header, the type,
the version and the length. And that gives

154
00:05:44,715 --> 00:05:50,367
接着 我们来考虑数据头 也就是类型、版本、长度

155
00:05:50,367 --> 00:05:55,802
us the entire TLS record, which is then
sent over to the server. So the grayed out

156
00:05:50,367 --> 00:05:55,802
以上就是整个TLS记录 最后被送给服务器 

157
00:05:55,802 --> 00:06:00,231
fields in this diagram correspond to
encrypted data, and the white fields

158
00:05:55,802 --> 00:06:00,231
整个图中蓝色区域表示加密数据 白色区域

159
00:06:00,231 --> 00:06:05,146
correspond to plaintext data. So you can
see that this is TLS's implementation of

160
00:06:00,231 --> 00:06:05,146
表示未加密明文 以上就是TLS应用的

161
00:06:05,146 --> 00:06:10,121
MAC then encrypt. The only difference from
basic MAC then encrypt is the fact that

162
00:06:05,146 --> 00:06:10,121
散列与加密计算 与普通MAC不同的唯一之处是

163
00:06:10,121 --> 00:06:14,915
there is a state, namely this counter is
being included in the value of the MAC.

164
00:06:10,121 --> 00:06:14,915
它含一个状态值 也就是MAC值中包含的计数器值

165
00:06:14,915 --> 00:06:19,852
And again as I said that's done to prevent
replays. So let's see why that prevents

166
00:06:14,915 --> 00:06:19,852
这是为了防止重放攻击 为什么这样能防止重放攻击

167
00:06:19,852 --> 00:06:24,430
replays. In particular, let's see how the
record protocol decrypts an incoming

168
00:06:19,852 --> 00:06:24,430
我们来看记录协议是如何解密记录的

169
00:06:24,430 --> 00:06:28,829
record. So, here comes an incoming
encrypted record. And again, the server is

170
00:06:24,430 --> 00:06:28,829
假设这里有一个加密记录 当然 服务器会

171
00:06:28,829 --> 00:06:33,763
going to use it's own key that corresponds
to data, from browser to server. And it's

172
00:06:28,829 --> 00:06:33,763
使用从浏览器到服务器的秘钥得到对应的数据

173
00:06:33,763 --> 00:06:38,222
own browser to server counter. And the
first thing it's going to do, is it's

174
00:06:33,763 --> 00:06:38,222
并启动从浏览器到服务器的计数器 然后 服务器首先会

175
00:06:38,222 --> 00:06:42,681
going to decrypt the record using the
encryption key. After encryption, it's

176
00:06:38,222 --> 00:06:42,681
使用加密密钥来解密这个记录 解密后 服务器会

177
00:06:42,681 --> 00:06:47,318
going to check the format of the pad. In
other words, if the pad length is five

178
00:06:42,681 --> 00:06:47,318
检查填充的格式 如果填充长度是5字节

179
00:06:47,318 --> 00:06:51,826
bytes, it's going to check that it really
is five, five, five, five, five. And if

180
00:06:47,318 --> 00:06:51,826
它就会检查填充是否是55555 如果不是

181
00:06:51,826 --> 00:06:56,124
it's not, it's gonna send a bad record mac
alert message and terminate the

182
00:06:51,826 --> 00:06:56,124
服务器就会发送错误警告消息并终止链接

183
00:06:56,124 --> 00:07:01,061
connection. So that a new session key will
have to be negotiated if more records need

184
00:06:56,124 --> 00:07:01,061
如果想要另发送记录 就需要协商新的会话密钥

185
00:07:01,061 --> 00:07:05,935
to be sent. If the pad format is correct,
then removing the pad is really easy. All

186
00:07:01,061 --> 00:07:05,935
如果填充格式是正确的 那么移除填充就很简单

187
00:07:05,935 --> 00:07:10,595
the server does is it looks at the last
byte of the pad, say the last byte is

188
00:07:05,935 --> 00:07:10,595
由服务器观察填充的最后几字节 如果最后几字节等于5

189
00:07:10,595 --> 00:07:15,254
equal to five, and, then, it removes the
last five bytes of the record. By doing

190
00:07:10,595 --> 00:07:15,254
然后服务器移除最后5字节的记录

191
00:07:15,254 --> 00:07:20,216
that it strips off the pad. The next thing
it's gonna do is it's gonna extract the

192
00:07:15,254 --> 00:07:20,216
这样就可以移除填充 接下来 服务器会取出

193
00:07:20,216 --> 00:07:25,117
tag from the record. So, this would be the
subsequence bytes inside of the record.

194
00:07:20,216 --> 00:07:25,117
记录中的特征值 在记录中后面的字节

195
00:07:25,117 --> 00:07:30,079
So, this would be the, the trailing bytes
in the record after we remove the pad, and

196
00:07:25,117 --> 00:07:30,079
它在我们移除填充后的最后的字节

197
00:07:30,079 --> 00:07:34,860
then it's gonna verify the tag on the
header, the data and its value of counter.

198
00:07:30,079 --> 00:07:34,860
接着服务器检查特征值中的数据头、数据、计数器值等

199
00:07:34,860 --> 00:07:39,809
And if the Mac doesn't verify again, it's
gonna send an alert, bad record Mac, and

200
00:07:34,860 --> 00:07:39,809
如果这个散列值不能通过认证 服务器会发送警告和错误散列值记录并

201
00:07:39,809 --> 00:07:44,634
tear down the connection. And if the tag
does verify, it's gonna remove the tag,

202
00:07:39,809 --> 00:07:44,634
中断链接 如果特征值通过了认证 服务器会移除特征值

203
00:07:44,634 --> 00:07:49,460
remove the header, and the remaining part
of the record is the plain text data

204
00:07:44,634 --> 00:07:49,460
移除数据头 留下来的记录部分就是数据明文

205
00:07:49,460 --> 00:07:54,693
that's given to the application. Now, you
can see if a record is ever replayed, in

206
00:07:49,460 --> 00:07:54,693
这部分就是待发送给应用的数据 现在你应该了解到 如果记录被重放

207
00:07:54,693 --> 00:07:59,980
other words if an attacker records a
particular record and then replays it to the

208
00:07:54,693 --> 00:07:59,980
换句话说 如果一攻击者记录了一个特定记录并在之后的时间

209
00:07:59,980 --> 00:08:05,402
server at a later time, then, by then the
value of the counter would have changed

210
00:07:59,980 --> 00:08:05,402
将其重放给服务器 那时计数器的值已经被改变

211
00:08:05,402 --> 00:08:11,028
and as a result the tag on the replayed
record would simply not verify because the

212
00:08:05,402 --> 00:08:11,028
结果就是 重放记录的特征值就不会通过认证

213
00:08:11,028 --> 00:08:16,451
tag was computed using one value of the
counter but when the replayed record as

214
00:08:11,028 --> 00:08:16,451
因为特征值是使用计数器计算出来的 但当重放记录被服务器接收时

215
00:08:16,451 --> 00:08:21,285
received at the server The value of the
counter of the server is different from

216
00:08:16,451 --> 00:08:21,285
服务器的计数器值与上次用来计算特征值的

217
00:08:21,285 --> 00:08:25,996
the value that was used to compute a tag
and as a result the tag was not verified.

218
00:08:21,285 --> 00:08:25,996
计数值不同 结果通不过认证

219
00:08:25,996 --> 00:08:30,536
So these counters are very elegant and
simple way for preventing replays and the

220
00:08:25,996 --> 00:08:30,536
所以这些计数器是非常简便的防止重放攻击的方法 而且

221
00:08:30,536 --> 00:08:35,018
nice thing about this is because both
sides know the value of the counter implicitly

222
00:08:30,536 --> 00:08:35,018
由于两端均知道计数器的值

223
00:08:35,018 --> 00:08:39,499
there's never a need to send the
counter in the record itself. So the

224
00:08:35,018 --> 00:08:39,499
所以没有必要将计数器包含在记录中发送 所以

225
00:08:39,499 --> 00:08:43,787
counter itself doesn't increase the length
of cipher text L. Now, we already

226
00:08:39,499 --> 00:08:43,787
计时器不会随着密文的长度L增加 现在我们已经

227
00:08:43,787 --> 00:08:48,692
mentioned that this particular approach
to, authenticated encryption, namely, MAC,

228
00:08:43,787 --> 00:08:48,692
提到这种特殊的方法，认证加密，即 先做MAC

229
00:08:48,692 --> 00:08:53,358
then encrypt, using CBC encryption, is, in
fact, authenticated encryption. However,

230
00:08:48,692 --> 00:08:53,358
后加密，使用CBC加密方式 实际上 就是认证加密 但是

231
00:08:53,358 --> 00:08:57,904
it's only authenticated encryption if no
other information is leaked during

232
00:08:53,358 --> 00:08:57,904
它仅仅是在加密时没有信息泄露的情况下是认证加密

233
00:08:57,904 --> 00:09:02,211
decryption. And we're going to see some
acute attacks on TLS if there is

234
00:08:57,904 --> 00:09:02,211
泄露。我们讲一种对TLS严重攻击，如果在

235
00:09:02,211 --> 00:09:06,398
information being leaked during
decryption. I should say that this bad

236
00:09:02,211 --> 00:09:06,398
解密过程中有信息泄露。这个

237
00:09:06,398 --> 00:09:11,363
record MAC alert basically corresponds to
the decryption algorithm outputting this

238
00:09:06,398 --> 00:09:11,363
错误记录的MAC警告相当于解密算法中输出的拒绝符号也就是⊥符号

239
00:09:11,363 --> 00:09:16,058
reject symbol, the bottom symbol. Meaning
that the cipher text is invalid. And as

240
00:09:11,363 --> 00:09:16,058
这就意味着密文是无效的

241
00:09:16,058 --> 00:09:20,550
long as there's no way to differentiate
between why the cipher text was rejected,

242
00:09:16,058 --> 00:09:20,550
只要没有办法区分密文为何被拒绝

243
00:09:20,550 --> 00:09:25,152
in other words the decrypter only exposes
the fact that a rejection took place but

244
00:09:20,550 --> 00:09:25,152
即解密者只暴露了发生了拒绝这样一个事实但又

245
00:09:25,152 --> 00:09:29,311
it doesn't say why the rejection happened
this is in fact an authenticated

246
00:09:25,152 --> 00:09:29,311
没说明拒绝为什么发生 这其实就是一个认证加密系统

247
00:09:29,311 --> 00:09:33,300
encryption system. However, if you
differentiate and expose why the cipher

248
00:09:29,311 --> 00:09:33,300
然而 如果你区分并暴露了密文

249
00:09:33,304 --> 00:09:37,907
text was rejected whether it was because
of a bad pad or because of a bad mac then

250
00:09:33,304 --> 00:09:37,907
为何被拒绝 不管是因为错误的填充或者是因为错误的MAC

251
00:09:37,907 --> 00:09:42,510
it turns out there's a very acute attack.
Which we're gonna see in the next segment.

252
00:09:37,907 --> 00:09:42,510
那么这就是将在下一部分讲到的一个十分严重的攻击

253
00:09:42,510 --> 00:09:47,402
What I showed you so far is called TLS
Version 1.1. It turns out that earlier

254
00:09:42,510 --> 00:09:47,402
到目前我所展现的是1.1版本的TLS 实际上

255
00:09:47,402 --> 00:09:52,231
versions of TLS actually had significant
mistakes in it, and as a result, the

256
00:09:47,402 --> 00:09:52,231
更早版本的TLS存在重大的错误 结果就导致

257
00:09:52,231 --> 00:09:57,441
earlier Record Protocol is vulnerable to a
number of attacks. The first mistake is

258
00:09:52,231 --> 00:09:57,441
先前的记录协议容易受到各种攻击 它的第一个错误是

259
00:09:57,441 --> 00:10:02,397
that the IV used in CBC Encryption is
predictable. And we said earlier that in

260
00:09:57,441 --> 00:10:02,397
CBC加密算法中的IV是可预测的 我们之前说过在CBC中

261
00:10:02,397 --> 00:10:07,099
CBC, if the IV is predictable then the
resulting CBC Encryption is not CPA

262
00:10:02,397 --> 00:10:07,099
如果IV是可预测的 那么将导致CBC加密算法不是CPA安全的

263
00:10:07,099 --> 00:10:11,928
Secure. Well, in this older version of
TLS, TLS 1.0 and earlier, the IV for the

264
00:10:07,099 --> 00:10:11,928
在旧版本的TLS 比如在TLS1.0或者是更早的版本中

265
00:10:11,928 --> 00:10:16,921
next record is simply the last cipher text
block of the current record. And as a

266
00:10:11,928 --> 00:10:16,921
下一个记录的IV就是当前记录的最后一个密文分组

267
00:10:16,921 --> 00:10:21,200
result, if the adversary can observe the
current record, he knows the IV for the

268
00:10:16,921 --> 00:10:21,200
这就导致如果攻击者能够观察出当前记录 那么他就知道下一个记录的IV

269
00:10:21,200 --> 00:10:25,426
next record and that will allow him to
break the semantic security of the next

270
00:10:21,200 --> 00:10:25,426
这就让他能够破坏下一个记录的语义安全

271
00:10:25,426 --> 00:10:29,866
record. So the resulting scheme is not CPA
secure. But not only is it not CPA secure,

272
00:10:25,426 --> 00:10:29,866
于是最终的方案不是CPA安全的 这样的方案不仅不是CPA安全的

273
00:10:29,866 --> 00:10:34,146
in fact, there is a very acute attack
called a BEAST attack that's able to decrypt

274
00:10:29,866 --> 00:10:34,146
而且  还有一种能够解密TLS记录起始部分的被称为BEAST的攻击方式

275
00:10:34,146 --> 00:10:38,425
the initial part of the TLS record
simply based on the fact that this scheme

276
00:10:34,146 --> 00:10:38,425
就是因为这个系统不是语义安全的

277
00:10:38,425 --> 00:10:43,206
is not semantically secure. So, I should
say that this method of choosing the iv to

278
00:10:38,425 --> 00:10:43,206
这种选IV来做前一个记录的最后一个分组的方法

279
00:10:43,206 --> 00:10:47,999
be the last block of the previous record
is called chained iv's. And you should

280
00:10:43,206 --> 00:10:47,999
被称为链IV

281
00:10:47,999 --> 00:10:53,095
remember that this, actually should not be
used in practice because it always, always

282
00:10:47,999 --> 00:10:53,095
你们应当记住这种方法不应该被用于实践 因为它总是

283
00:10:53,095 --> 00:10:57,948
leads to an attack. Because of this TLS
1.1 moved to what's called, explicit iv's

284
00:10:53,095 --> 00:10:57,948
被攻击 由于TLS从版本1.1发展到了被称为外显IV

285
00:10:57,948 --> 00:11:02,801
where every TLS record has its own random
unpredictable iv. And that's fixed the

286
00:10:57,948 --> 00:11:02,801
每一个TLS记录都有自己的随机不可预测的IV的版本

287
00:11:02,801 --> 00:11:07,776
problem as soon as browsers and servers
move to TLS 1.1, this will no longer be an

288
00:11:02,801 --> 00:11:07,776
只要浏览器和服务器使用TLS1.1 问题就能被解决 而且这永远不会出现问题

289
00:11:07,776 --> 00:11:11,993
issue. Now another mistake that was done
in TLS 1.0 and earlier, enabled what's

290
00:11:07,776 --> 00:11:11,993
另一个TLS1.0和更早版本的错误就是

291
00:11:11,993 --> 00:11:15,954
called a padding oracle. Which is
something that we're going to talk about

292
00:11:11,993 --> 00:11:15,954
启用了一个被称作Oracle填充的的东西 我们将在下一部分来讨论Oracle填充

293
00:11:15,954 --> 00:11:20,182
in the next segment, were what happened
was, that if the cipher text was rejected

294
00:11:15,954 --> 00:11:20,182
Oracle填充就是如果密文

295
00:11:20,182 --> 00:11:24,683
due to an invalid pad The server was sent
back an alert message saying decryption

296
00:11:20,182 --> 00:11:24,683
因为无效填充而被拒绝的话 服务器就会收到一条

297
00:11:24,683 --> 00:11:29,113
failed. Whereas if the cipher text was
rejected due to a bad Mac, the server will

298
00:11:24,683 --> 00:11:29,113
解密无效的信息 然而 如果密文是因为无效的MAC而被拒绝的话 服务器就会回复

299
00:11:29,113 --> 00:11:33,267
send back a bad record Mac alert. As a
result, and adversary who observes the

300
00:11:29,113 --> 00:11:33,267
一个无效记录的MAC的警告 所以

301
00:11:33,267 --> 00:11:37,753
alert sends back from the server, can tell
whether the pad in the cipher text was

302
00:11:33,267 --> 00:11:37,753
观察服务器回复警告的攻击者能够分辨出密文中的填充是有效还是无效的

303
00:11:37,753 --> 00:11:42,184
valid or invalid. And this introduces a
very significant attack called a padding

304
00:11:37,753 --> 00:11:42,184
这就引入了一种十分重要的被称为填充攻击的攻击方式

305
00:11:42,184 --> 00:11:46,670
attack, which we're gonna talk about in
the next segment. The solution to this and

306
00:11:42,184 --> 00:11:46,670
我们将在下一部分讨论这种攻击 对于这种攻击和TSL1.1的解决方案

307
00:11:46,670 --> 00:11:50,713
TLS 1.1, was basically to say that,
instead of reporting decryption failed

308
00:11:46,670 --> 00:11:50,713
基本上就是 即使填充是错误的

309
00:11:50,713 --> 00:11:55,092
here, we're gonna report a bad record Mac,
even if the pad is incorrect. And, as a

310
00:11:50,713 --> 00:11:55,092
也只报告一个错误记录的MAC 而不报告一个失败的解密

311
00:11:55,092 --> 00:11:59,445
result, simply looking at which alert is
sent back from the server, an attacker

312
00:11:55,092 --> 00:11:59,445
所以 仅仅观察服务器送回的警告

313
00:11:59,445 --> 00:12:04,121
can't tell if a cipher text is rejected
because of a bad pad or a bad MAC. So this

314
00:11:59,445 --> 00:12:04,121
攻击者是不能分辨出密文是由于错误的填充还是错误的MAC而被拒绝的

315
00:12:04,121 --> 00:12:09,354
tries to mask this information. Now the
lesson from this is that when decryption

316
00:12:04,121 --> 00:12:09,354
这就是说 我们从中汲取的教训就是当解密失败时

317
00:12:09,354 --> 00:12:14,156
fails, you should never ever explain why,
I guess this is something that comes out

318
00:12:09,354 --> 00:12:14,156
你永远不要去解释为什么  我想这是一种源自于网络协议中的东西

319
00:12:14,156 --> 00:12:19,135
of networking protocols where if there is
a failure you wanna tell the peer why the

320
00:12:14,156 --> 00:12:19,135
如果出现了一个错故障 你就想对你的伙伴解释故障出现的原因

321
00:12:19,135 --> 00:12:24,114
failure occurred, where in cryptography if
you explain why the failure occurred that

322
00:12:19,135 --> 00:12:24,114
而在密码学中 解释故障出现的原因常常会导致被攻击

323
00:12:24,114 --> 00:12:28,797
very often leads to an attack. In other
words when decryption fails just output

324
00:12:24,114 --> 00:12:28,797
换句话说 当解密失败时直接输出拒绝

325
00:12:28,797 --> 00:12:33,540
reject and don't explain why the reject
actually happens just reject the ciphertext.

326
00:12:28,797 --> 00:12:33,540
不要去解释拒绝为什么会发生 直接拒绝密文就可以

327
00:12:33,860 --> 00:12:38,462
Okay, so now that we've seen TLS 1.1,
let's see a broken protocol. So of course

328
00:12:33,860 --> 00:12:38,462
我们讨论过了TLS1.1 现在来看一个被破解的协议

329
00:12:38,462 --> 00:12:43,363
I always like to pick on 802.11b WEP,
which pretty much got everything wrong. So

330
00:12:38,462 --> 00:12:43,363
当然我挑基本上什么都是有问题的802.11b WEP来做例子

331
00:12:43,363 --> 00:12:48,086
let's see how not to provide authenticated
encryption. So let me remind you how

332
00:12:43,363 --> 00:12:48,086
让我们来看一下如何不要提供认证加密 先让我提醒下你们802.11b WEP

333
00:12:48,086 --> 00:12:52,808
802.11b WEP works. Basically there's a
message that the laptop wants to send to

334
00:12:48,086 --> 00:12:52,808
是如何工作的，一个笔记本电脑想要给

335
00:12:52,808 --> 00:12:57,410
the access point. The first thing that
happens is it, the laptop computes a

336
00:12:52,808 --> 00:12:57,410
一个接入点发送一条信息 首先 笔记本电脑会计算

337
00:12:57,410 --> 00:13:02,371
cyclic redundancy checksum on the message
and concatenates the CRC checksum to the

338
00:12:57,410 --> 00:13:02,371
一条信息的循环冗余校验和并且把CRC校验和与这条信息连接在一起

339
00:13:02,371 --> 00:13:06,937
message. Then the result is encrypted
using a stream cipher, in particular RC4.

340
00:13:02,371 --> 00:13:06,937
然后结果用流密码加密 例如RC4

341
00:13:06,937 --> 00:13:12,067
If you recall, the key that's used is the
concatenation of an initial value IV

342
00:13:06,937 --> 00:13:12,067
如果你还记得的话  使用的密钥是

343
00:13:12,067 --> 00:13:17,263
that changes per packet and the long term
key K. And then the IV along with the

344
00:13:12,067 --> 00:13:17,263
每一个包都会变化初始值IV的连接和一个长效密钥K 然后IV和密文一同

345
00:13:17,263 --> 00:13:21,506
cipher text are transmitted to the other
side. Now we've already saw two

346
00:13:17,263 --> 00:13:21,506
被传输到了另一端 我们之前已经讨论过了

347
00:13:21,506 --> 00:13:26,089
problems with this approach. One was if
the IV is ever repeated and in fact it is

348
00:13:21,506 --> 00:13:26,089
这种方法的两个问题 一是如果IV被重复使用的话

349
00:13:26,089 --> 00:13:30,954
gonna be repeated then you get a two time
pad attack. And the other problem

350
00:13:26,089 --> 00:13:30,954
你就会受到两次一个两次填充攻击 另一个问题是

351
00:13:30,954 --> 00:13:35,310
is that [inaudible] uses very closely
related keys. In other words, the key is

352
00:13:30,954 --> 00:13:35,310
使用关联紧密的密钥 换句话说 密钥是

353
00:13:35,310 --> 00:13:39,949
simply IV concatenated to K and the only
thing that changes are the IV so the key

354
00:13:35,310 --> 00:13:39,949
IV与K的串接 唯一发生改变的就是IV 所以

355
00:13:39,949 --> 00:13:44,475
is always fixed, which means that these
PRG keys are very closely related to one

356
00:13:39,949 --> 00:13:44,475
密钥一直都是固定的 这意味着 这些PRG密钥互相之间

357
00:13:44,475 --> 00:13:48,831
another and as we said, the PRG that's
used here, RC4 is not designed for this

358
00:13:44,475 --> 00:13:48,831
联系很紧密 像我们前面说的 这里用了PRG RC4 不是设计来这么用的

359
00:13:48,831 --> 00:13:53,524
type of use and it completely breaks
if you use it with related keys, and as a

360
00:13:48,831 --> 00:13:53,524
如果你用相关密钥的话 它就完全被攻破

361
00:13:53,524 --> 00:13:58,110
result WEP has no security at all.
What I want to show you. Is that even the

362
00:13:53,524 --> 00:13:58,110
因此 WEP根本不安全 我想证明给大家的是

363
00:13:58,110 --> 00:14:02,332
crc mechanism that's used here. In an
attempt to provide integrity and prevent

364
00:13:58,110 --> 00:14:02,332
即使这里用到了CRC机制 试图提供完整性 防止

365
00:14:02,332 --> 00:14:05,872
an adversary from tampering with the
cipher text, even that mechanism is

366
00:14:02,332 --> 00:14:05,872
敌手篡改密文 即便这种机制

367
00:14:05,872 --> 00:14:09,960
completely broken, and it's actually very
easy to tamper with cipher texts en route.

368
00:14:05,872 --> 00:14:09,960
被完全攻破 实际上在传输中是很容易篡改密文的

369
00:14:09,960 --> 00:14:14,935
So let's see how that's done. The attack
uses a particular property of the CRC

370
00:14:09,960 --> 00:14:14,935
让我们看看这个怎么做 攻击利用了CRC校验的的一种性质

371
00:14:14,935 --> 00:14:20,399
check sum. Mainly the CRC is linear. What
that means is if I give you CRC of M, and

372
00:14:14,935 --> 00:14:20,399
主因是CRC是线性的 这意味着如果我给你m的CRC校验码 我

373
00:14:20,399 --> 00:14:25,525
I ask you to compute CRC of M XOR P, then
it's very easy to do. Basically you'll

374
00:14:20,399 --> 00:14:25,525
要求你计算m异或p的CRC，很容易 基本上你户

375
00:14:25,525 --> 00:14:30,989
just compute some well known and public
function of F(P), you XOR these two together,

376
00:14:25,525 --> 00:14:30,989
计算公开的函数F(p)你先异或这两个

377
00:14:30,989 --> 00:14:35,976
and that in fact will give you CRC of
M XOR P. So it [inaudible] the xor comes out

378
00:14:30,989 --> 00:14:35,976
这样就会给你m和p异或的CRC校验 所以异或

379
00:14:35,976 --> 00:14:40,380
of the parenthesis, and that basically
means the CRC is linear. Now here is how the

380
00:14:35,976 --> 00:14:40,380
就从这个括号里出来了，意味着CRC是线性的 现在我们看看

381
00:14:40,380 --> 00:14:44,727
attack works, suppose the adversary
intercepts a particular, packet that's

382
00:14:40,380 --> 00:14:44,727
攻击是怎么进行得 假设敌手截获了一个特定的包

383
00:14:44,727 --> 00:14:48,841
destined to the access point. Now the
packet say, sais it's destined for

384
00:14:44,727 --> 00:14:48,841
这个包是发往接入点的 现在这个包，令其目的

385
00:14:48,841 --> 00:14:53,535
destination port 80, and the attacker
knows that it's intended for destination

386
00:14:48,841 --> 00:14:53,535
是80端口 攻击者知道它要发往

387
00:14:53,535 --> 00:14:58,114
port 80 and what he wants to do is
modify the cipher texts such that now the

388
00:14:53,535 --> 00:14:58,114
80端口而且他想篡改这个密文使得目的端口

389
00:14:58,114 --> 00:15:02,550
destination port will say 25 instead of
80. And maybe the attacker can read

390
00:14:58,114 --> 00:15:02,550
变成25而不是80 攻击者可能能够读

391
00:15:02,550 --> 00:15:06,922
messages for port 25 and that's how he
actually obtains the actual data in the

392
00:15:02,550 --> 00:15:06,922
25端口的信息 这样他实际上就得到了这个包中的数据

393
00:15:06,922 --> 00:15:11,405
packet. So recall that the CRC checksum
is there to make sure that exactly the

394
00:15:06,922 --> 00:15:11,405
回忆CRC校验在这里是为了保证

395
00:15:11,405 --> 00:15:15,943
attacker cannot change data inside of the
cipher text. But I want to show you that

396
00:15:11,405 --> 00:15:15,943
攻击者不能改变密文中的数据 但是我想说明 实际上

397
00:15:15,943 --> 00:15:20,702
in fact it's really easy to modify data in
the cipher text and CRC basically provides

398
00:15:15,943 --> 00:15:20,702
想改变密文中的数据十分容易 CRC

399
00:15:20,702 --> 00:15:25,611
no security against tampering at all. So
let's see how to do it. Well, what the

400
00:15:20,702 --> 00:15:25,611
实际上根本不能对篡改提供安全性 让我们看看如何进行

401
00:15:25,611 --> 00:15:31,549
attacker would do is, he would basically
Xor some, a certain value XX into the byte

402
00:15:25,611 --> 00:15:31,549
好，攻击者 基本上就是一些特定的值XX

403
00:15:31,549 --> 00:15:37,130
that represents the eight zero in the
cipher text. Now what he'll Xor in will

404
00:15:31,549 --> 00:15:37,130
和代表密文中的8个0的字节异或 现在 他就是

405
00:15:37,130 --> 00:15:43,497
basically be the string 25 Xor 80 and you
remember that if I Xor a certain string XX

406
00:15:37,130 --> 00:15:43,497
把25和80进行异或 再与密文中特定的串XX进行异或

407
00:15:43,497 --> 00:15:48,890
into the cipher text. That was created
using a stream cipher. When that cipher

408
00:15:43,497 --> 00:15:48,890
这个是用来做流密码的 当密文

409
00:15:48,890 --> 00:15:54,653
gets, is decrypted, the plain text at this
position will also be Xored by XX. And as

410
00:15:48,890 --> 00:15:54,653
被解密 这个位置的明文将被XX异或

411
00:15:54,653 --> 00:16:00,176
a result after decryption the plain text
at this position basically will be the

412
00:15:54,653 --> 00:16:00,176
结果就是解密后这个位置的明文就是

413
00:16:00,176 --> 00:16:05,767
original 80XR 25 XR 80 which gives us 25.
Okay? So after decryption the plain text

414
00:16:00,176 --> 00:16:05,767
原始的80异或25异或25，结果就是25，对吧？

415
00:16:05,767 --> 00:16:11,152
of this position will now be 25. The
problem is that if that's all we did then

416
00:16:05,767 --> 00:16:11,152
所以解密后这个位置的明文将是25 问题是 如果我们就这么做

417
00:16:11,152 --> 00:16:16,537
this attack would fail because the CRC
check sum would now would not validate.

418
00:16:11,152 --> 00:16:16,537
这个攻击不会成功 因为CRC校验在这里就不成立了

419
00:16:16,537 --> 00:16:21,672
The CRC check sum. Was built with 80 as a
plain text but 25 is a different plain

420
00:16:16,537 --> 00:16:21,672
CRC校验 是对80这个明文建立的，25是

421
00:16:21,672 --> 00:16:26,883
text and needs a different CRC. But it's
not a problem because what we can do is we

422
00:16:21,672 --> 00:16:26,883
另一个明文需要另外一个CRC校验 但是这也不是问题 因为我们能做的是

423
00:16:26,883 --> 00:16:31,969
can easily correct the check sum, the CRC
check sum, even though the CRC check sum

424
00:16:26,883 --> 00:16:31,969
仅仅校正一下校验和 CRC校验和 虽然CRC校验和

425
00:16:31,969 --> 00:16:37,180
is encrypted. What we do is we XOR
F of XX into the cipher text at the place

426
00:16:31,969 --> 00:16:37,180
是被加密了。我们就是异或F(xx)到密文的这个位置

427
00:16:37,180 --> 00:16:42,266
where the CRC is supposed to be and as a
result, when the cipher text is decrypted

428
00:16:37,180 --> 00:16:42,266
这里应该是那个CRC 结果就是 密文被解密的时候

429
00:16:42,266 --> 00:16:47,271
what will happen is we'll get the correct
CRC check sum after decryption. So, the

430
00:16:42,266 --> 00:16:47,271
在解密后我们就能得到正确的CRC校验和

431
00:16:47,271 --> 00:16:52,275
interesting thing that happened here is
even though the attacker doesn't know what

432
00:16:47,271 --> 00:16:52,275
这里有意思的是 即便攻击者不知道

433
00:16:52,275 --> 00:16:57,157
the crc value is, he's able to correct it
using this linearity property such that

434
00:16:52,275 --> 00:16:57,157
CRC值是什么 他可以利用线性性质校对是的

435
00:16:57,157 --> 00:17:01,738
when the cipher text is decrypted the
correct crc value appears in the plain

436
00:16:57,157 --> 00:17:01,738
密文被解密为明文时，能得到正确的CRC值

437
00:17:01,738 --> 00:17:06,671
text. Okay? So the linearity property of
CRC plays a critical role in making this

438
00:17:01,738 --> 00:17:06,671
所以，CRC的线性性质在这个攻击中起到了重要的

439
00:17:06,671 --> 00:17:11,483
attack works. The end conclusion here is
basically that a CRC check sum provides

440
00:17:06,671 --> 00:17:11,483
作用 这里最终的结论是CRC校验绝对不能提供

441
00:17:11,483 --> 00:17:16,235
absolutely no integrity at all against
active attacks and it should never, ever,

442
00:17:11,483 --> 00:17:16,235
完整性，在针对主动攻击的情况下 因此永远

443
00:17:16,235 --> 00:17:20,686
ever be used as an integrity mechanism.
And instead if you want to provide

444
00:17:16,235 --> 00:17:20,686
不要用它作为一种完整性机制 所以为了提供完整性

445
00:17:20,686 --> 00:17:25,318
integrity you're supposed to use a
cryptographic mac not an ad hoc mechanism

446
00:17:20,686 --> 00:17:25,318
你应该用一种密码MAC体制而不是随便什么机制

447
00:17:25,318 --> 00:17:29,353
like CRC. Okay, so now we've seen how
authenticated encryption is implemented in

448
00:17:25,318 --> 00:17:29,353
比如CRC 好，现在我们了解了在现实世界中的协议中认证

449
00:17:29,353 --> 00:17:33,145
a real world protocol, like TLS. In the
next segment, we're gonna look at real

450
00:17:29,353 --> 00:17:33,145
加密是怎样使用的，比如TLS 下一节 我们将讨论

451
00:17:33,145 --> 00:17:37,287
world attacks on authenticated encryption
implementations that happen to implement

452
00:17:33,145 --> 00:17:37,287
一下现实的攻击，尤其是在认证加密在没有被正确使用

453
00:17:37,287 --> 00:17:39,134
authenticated encryption incorrectly.

454
00:17:37,287 --> 00:17:39,134
的情况下，对认证加密的攻击。

