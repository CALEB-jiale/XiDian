1
00:00:00,000 --> 00:00:04,450
So I want to show you how authenticated
encryption is used in the real world, so

2
00:00:04,450 --> 00:00:08,844
let's use TLS as an example and see how
TLS works. So data encryption in TLS is

3
00:00:08,844 --> 00:00:13,183
done using a protocol called a TLS record
protocol. In this protocol, every TLS

4
00:00:13,183 --> 00:00:17,800
record starts with a header, we'll see the
structure of the header in just a minute,

5
00:00:17,800 --> 00:00:22,250
followed by encrypted data that is sent
from one side to the other. In TLS, it so

6
00:00:22,250 --> 00:00:26,534
happens that the records are at most
sixteen kilobytes and if more data than

7
00:00:26,534 --> 00:00:30,984
sixteen kilobytes needs to be sent, then
basically the record is fragmented into

8
00:00:30,984 --> 00:00:35,401
multiple records. Now TLS uses what's
called unidirectional keys, meaning that

9
00:00:35,401 --> 00:00:40,087
there's one key from browser to server,
and there's a separate key from server to

10
00:00:40,087 --> 00:00:44,774
browser. So one key is used for sending
messages from a browser to the server, and

11
00:00:44,774 --> 00:00:49,113
the other key is used from sending
messages from the server to the browser,

12
00:00:49,113 --> 00:00:53,800
and of course both sides, both the server
and the browser, know both of these keys.

13
00:00:53,800 --> 00:00:58,026
And just to be clear I'll say the browser
will use this key to send data to the

14
00:00:58,026 --> 00:01:02,464
server and we'll use this key to read data
from the server and the server basically

15
00:01:02,464 --> 00:01:06,638
does exactly the same thing just with the
opposite keys. Now these keys, both of

16
00:01:06,638 --> 00:01:10,811
these keys are actually generated by the
TLS key exchange protocol which we're

17
00:01:10,811 --> 00:01:15,143
gonna talk about in the second part of the
course. Right now I'm gonna assume that

18
00:01:15,143 --> 00:01:19,529
these keys have already been established.
They're known to both the server and the

19
00:01:19,529 --> 00:01:23,859
browser, and now the browser and server
want to exchange information using those

20
00:01:23,859 --> 00:01:27,591
keys. So the TLS record protocol uses
what's called stateful encryption, which

21
00:01:27,591 --> 00:01:31,693
means that the encryption of every packet.
Is done using certain state that's

22
00:01:31,693 --> 00:01:36,575
maintained inside of the browser and the
server. In particular the state that's of

23
00:01:36,575 --> 00:01:41,368
interest to us are these 64 bit counters,
again there are two 64 bit counters. One

24
00:01:41,368 --> 00:01:45,483
for traffic from browser to server, and
one from traffic from the server to the

25
00:01:45,483 --> 00:01:49,286
browser. These counters are initialized to
zero when the session is first

26
00:01:49,286 --> 00:01:53,558
initialized, and they're incremented every
time a record is sent. So every time the

27
00:01:53,558 --> 00:01:57,830
browser sends a record to the server, the
browser will go ahead and increment this

28
00:01:57,830 --> 00:02:01,893
counter. When the server receives that
record, it'll go ahead and increment the

29
00:02:01,893 --> 00:02:06,086
counter on its side. And when the server
sends a record to the browser, he'll go

30
00:02:06,086 --> 00:02:10,454
ahead and increment the second counter and
again when the browser receives this

31
00:02:10,454 --> 00:02:14,931
record it'll go ahead and increment its
copy of this counter. So this state these

32
00:02:14,931 --> 00:02:19,463
two counters basically this state exists
both on the browser and on the server and

33
00:02:19,463 --> 00:02:23,940
it's updated appropriately as records as
sent from one to the other and received

34
00:02:23,940 --> 00:02:28,363
by the appropriate side. Now the purpose
of these counters as we'll see in just a

35
00:02:28,363 --> 00:02:32,840
minute is to prevent replay attacks so
than an attacker can't simply record the record

36
00:02:32,840 --> 00:02:37,044
and then replay at a later time because by
then the counters will have to be

37
00:02:37,044 --> 00:02:41,990
incremented. Okay, so let's look at the
details of how the record protocol works.

38
00:02:41,990 --> 00:02:47,304
In particular I'll show you kind of the
mandatory cipher suit which is encryption

39
00:02:47,304 --> 00:02:52,508
using AES-CBC and MACing using HMAC-SHA1. Okay,
so remember, TLS uses a MAC, then encrypt,

40
00:02:52,508 --> 00:02:56,825
where the MAC algorithm is HMAC-SHA1, and the encryption

41
00:02:56,825 --> 00:03:02,043
algorithm is AES128 in CBC mode. Okay, so
let's look at how the browser sends data

42
00:03:02,043 --> 00:03:07,068
to the server, which, as I said, is done
using the browser to server key. Now, the

43
00:03:07,068 --> 00:03:12,218
browser to server key itself, is made up
of a MAC key and an encryption key. Two

44
00:03:12,218 --> 00:03:18,436
separated keys that are again as I said
negotiated during session setup. And again

45
00:03:18,436 --> 00:03:22,889
I wanna be absolutely clear. There is a
separate key for browser to server and a

46
00:03:22,889 --> 00:03:27,176
separate key from server to browser. So
there, overall, there are four keys. Two

47
00:03:27,176 --> 00:03:31,406
MAC keys, and two encryption keys, each
one used in the appropriate direction.

48
00:03:31,406 --> 00:03:36,026
Okay, so here I wrote down the diagram of
what a tls packet looks like. It begins

49
00:03:36,026 --> 00:03:40,368
with a header that contains the type of
the packet, the version number for the

50
00:03:40,368 --> 00:03:44,766
protocol, and the length of the packet.
Notice the length of the packet it sends

51
00:03:44,766 --> 00:03:49,316
in the clear. Now, when the encrypting
data, a certain record, the encryption

52
00:03:49,316 --> 00:03:54,083
procedure works as follows. Of course, it
takes key as input, and it takes the

53
00:03:54,083 --> 00:03:59,139
current status input. And then it works as
follows. What it'll do is first of all is

54
00:03:59,139 --> 00:04:03,851
it would MAC the following data, while
here's the actual payload that's MACed but

55
00:04:03,851 --> 00:04:08,679
the heather is also MACed. In addition the
counter, the current value of the counter

56
00:04:08,679 --> 00:04:12,926
is also MACed and of course, it's all the
counters implemented during the

57
00:04:12,926 --> 00:04:17,754
[inaudible] fact that one more record has
been sent. Now the interesting thing here

58
00:04:17,754 --> 00:04:22,271
is that even though the value of the
counter is included in the tag. You notice

59
00:04:22,271 --> 00:04:26,356
the value of the counter is actually never
sent in the record, and the reason it

60
00:04:26,356 --> 00:04:30,593
doesn't need to be sent in the record is
that the server on the other side already

61
00:04:30,593 --> 00:04:34,729
knows what the value of the counter needs
to be. So it doesn't need to be told in

62
00:04:34,729 --> 00:04:38,814
the record what the value of the counter
is. It implicitly already knows what it

63
00:04:38,814 --> 00:04:42,949
is, and when it's gonna verify the MAC, it
could just use the value that it thinks

64
00:04:42,949 --> 00:04:47,072
the counter should be and verify the MAC
in that fashion. Okay, so this is kind of

65
00:04:47,072 --> 00:04:51,315
an interesting approach, where even though
the two sides maintain these counters that

66
00:04:51,315 --> 00:04:55,406
function as nonces, there is no
reason to send the nonces in the record,

67
00:04:55,406 --> 00:04:59,397
because both sides actually already know
what counters they're expecting every

68
00:04:59,397 --> 00:05:04,024
record that they receive. Okay, so that's
the tag. The tag is computed, as we said,

69
00:05:04,024 --> 00:05:09,320
over this triple data. The next thing that
happens is that the tag is concatenated to

70
00:05:09,320 --> 00:05:13,930
the data. Remember, this is MAC-then-Encrypt. So here, we computed the MAC. Now

71
00:05:13,930 --> 00:05:18,852
we're gonna encrypt the data along with
the tag. So the header, the data, and the

72
00:05:18,852 --> 00:05:23,649
tag are padded to the AES block, and I
think we already said that this pad, if

73
00:05:23,649 --> 00:05:28,696
the pad length is five, then the pad is
done by simply writing the byte five, five

74
00:05:28,696 --> 00:05:34,032
times. If the pad link leads to B5, the
pad would just be 55555. And then we CBC

75
00:05:34,032 --> 00:05:39,477
encrypt using the encryption key, we CBC
encrypt the data and the tag. And we do

76
00:05:39,477 --> 00:05:44,715
that using a fresh random IV, which is
later embedded in the cipher text. And

77
00:05:44,715 --> 00:05:50,367
then we prepend the header, the type,
the version and the length. And that gives

78
00:05:50,367 --> 00:05:55,802
us the entire TLS record, which is then
sent over to the server. So the grayed out

79
00:05:55,802 --> 00:06:00,231
fields in this diagram correspond to
encrypted data, and the white fields

80
00:06:00,231 --> 00:06:05,146
correspond to plaintext data. So you can
see that this is TLS's implementation of

81
00:06:05,146 --> 00:06:10,121
MAC then encrypt. The only difference from
basic MAC then encrypt is the fact that

82
00:06:10,121 --> 00:06:14,915
there is a state, namely this counter is
being included in the value of the MAC.

83
00:06:14,915 --> 00:06:19,852
And again as I said that's done to prevent
replays. So let's see why that prevents

84
00:06:19,852 --> 00:06:24,430
replays. In particular, let's see how the
record protocol decrypts an incoming

85
00:06:24,430 --> 00:06:28,829
record. So, here comes an incoming
encrypted record. And again, the server is

86
00:06:28,829 --> 00:06:33,763
going to use it's own key that corresponds
to data, from browser to server. And it's

87
00:06:33,763 --> 00:06:38,222
own browser to server counter. And the
first thing it's going to do, is it's

88
00:06:38,222 --> 00:06:42,681
going to decrypt the record using the
encryption key. After encryption, it's

89
00:06:42,681 --> 00:06:47,318
going to check the format of the pad. In
other words, if the pad length is five

90
00:06:47,318 --> 00:06:51,826
bytes, it's going to check that it really
is five, five, five, five, five. And if

91
00:06:51,826 --> 00:06:56,124
it's not, it's gonna send a bad record mac
alert message and terminate the

92
00:06:56,124 --> 00:07:01,061
connection. So that a new session key will
have to be negotiated if more records need

93
00:07:01,061 --> 00:07:05,935
to be sent. If the pad format is correct,
then removing the pad is really easy. All

94
00:07:05,935 --> 00:07:10,595
the server does is it looks at the last
byte of the pad, say the last byte is

95
00:07:10,595 --> 00:07:15,254
equal to five, and, then, it removes the
last five bytes of the record. By doing

96
00:07:15,254 --> 00:07:20,216
that it strips off the pad. The next thing
it's gonna do is it's gonna extract the

97
00:07:20,216 --> 00:07:25,117
tag from the record. So, this would be the
web sequence bytes inside of the record.

98
00:07:25,117 --> 00:07:30,079
So, this would be the, the trailing bytes
in the record after we remove the pad, and

99
00:07:30,079 --> 00:07:34,860
then it's gonna verify the pad on the
header, the data and its value of counter.

100
00:07:34,860 --> 00:07:39,809
And if the Mac doesn't verify again, it's
gonna send an alert, bad record Mac, and

101
00:07:39,809 --> 00:07:44,634
tear down the connection. And if the pad
does verify, it's gonna remove the tag,

102
00:07:44,634 --> 00:07:49,460
remove the header, and the remaining part
of the record is the plain text data

103
00:07:49,460 --> 00:07:54,693
that's given to the application. Now, you
can see if a record is ever replayed, in

104
00:07:54,693 --> 00:07:59,980
other words if an attacker records a
particular record and then replays it to the

105
00:07:59,980 --> 00:08:05,402
server at a later time, then, by then the
value of the counter would have changed

106
00:08:05,402 --> 00:08:11,028
and as a result the tag on the replayed
record would simply not verify because the

107
00:08:11,028 --> 00:08:16,451
tag was computed using one value of the
counter but with the replayed record as

108
00:08:16,451 --> 00:08:21,285
received at the server The value of the
counter of the server is different from

109
00:08:21,285 --> 00:08:25,996
the value that was used to compute a tag
and as a result the tag was not verified.

110
00:08:25,996 --> 00:08:30,536
So these counters are very elegant and
simple way for preventing replays and the

111
00:08:30,536 --> 00:08:35,018
nice thing about this is because both
sides know the value of the counter implicitly

112
00:08:35,018 --> 00:08:39,499
there's never a need to send the
counter in the record itself. So the

113
00:08:39,499 --> 00:08:43,787
counter itself doesn't increase the length
of cipher text L. Now, we already

114
00:08:43,787 --> 00:08:48,692
mentioned that this particular approach
to, authenticated encryption, namely, MAC,

115
00:08:48,692 --> 00:08:53,358
then encrypt, using CBC encryption, is, in
fact, authenticated encryption. However,

116
00:08:53,358 --> 00:08:57,904
it's only authenticated encryption if no
other information is leaked during

117
00:08:57,904 --> 00:09:02,211
decryption. And we're going to see some
acute attacks on TLS if there is

118
00:09:02,211 --> 00:09:06,398
information being leaked during
decryption. I should say that this bad

119
00:09:06,398 --> 00:09:11,363
record MAC alert basically corresponds to
the decryption algorithm outputting this

120
00:09:11,363 --> 00:09:16,058
reject symbol, the bottom symbol. Meaning
that the cipher text is invalid. And as

121
00:09:16,058 --> 00:09:20,550
long as there's no way to differentiate
between why the cipher text was rejected,

122
00:09:20,550 --> 00:09:25,152
in other words the decrypter only exposes
the fact that a rejection took place but

123
00:09:25,152 --> 00:09:29,311
it doesn't say why the rejection happened
this is in fact an authenticated

124
00:09:29,311 --> 00:09:33,300
encryption system. However, if you
differentiate and expose why the cipher

125
00:09:33,304 --> 00:09:37,907
text was rejected whether it was because
of a bad pad or because of a bad mac then

126
00:09:37,907 --> 00:09:42,510
it turns out there's a very acute attack.
Which we're gonna see in the next segment.

127
00:09:42,510 --> 00:09:47,402
What I showed you so far is called TLS
Version 1.1. It turns out that earlier

128
00:09:47,402 --> 00:09:52,231
versions of TLS actually had significant
mistakes in it, and as a result, the

129
00:09:52,231 --> 00:09:57,441
earlier Record Protocol is vulnerable to a
number of attacks. The first mistake is

130
00:09:57,441 --> 00:10:02,397
that the IV used in CBC Encryption is
predictable. And we said earlier that in

131
00:10:02,397 --> 00:10:07,099
CBC, if the IV is predictable then the
resulting CBC Encryption is not CPA

132
00:10:07,099 --> 00:10:11,928
Secure. Well, in this older version of
TLS, TLS 1.0 and earlier, the IV for the

133
00:10:11,928 --> 00:10:16,921
next record is simply the last cipher text
record of the current record. And as a

134
00:10:16,921 --> 00:10:21,200
result, if the adversary can observe the
current record, he knows the IEV for the

135
00:10:21,200 --> 00:10:25,426
next record and that will allow him to
break the semantic security of the next

136
00:10:25,426 --> 00:10:29,866
record. So the resulting scheme is not CPA
secure. But not only is it not CPA secure,

137
00:10:29,866 --> 00:10:34,146
in fact, there is a very acute attack
called a BEAST attack that's able to decrypt

138
00:10:34,146 --> 00:10:38,425
the initial part of the TLS record
simply based on the fact that this scheme

139
00:10:38,425 --> 00:10:43,206
is not semantically secure. So, I should
say that this method of choosing the iv to

140
00:10:43,206 --> 00:10:47,999
be the last block of the previous record
is called chained iv's. And you should

141
00:10:47,999 --> 00:10:53,095
remember that this, actually should not be
used in practice because it always, always

142
00:10:53,095 --> 00:10:57,948
leads to an attack. Because of this TLS
1.1 moved to what's called, explicit iv's

143
00:10:57,948 --> 00:11:02,801
where every TLS record has its own random
unpredictable iv. And that's fixed the

144
00:11:02,801 --> 00:11:07,776
problem as soon as browsers and servers
move to TLS 1.1, this will no longer be an

145
00:11:07,776 --> 00:11:11,993
issue. Now another mistake that was done
in TLS 1.0 and earlier, enabled what's

146
00:11:11,993 --> 00:11:15,954
called a padding oracle. Which is
something that we're going to talk about

147
00:11:15,954 --> 00:11:20,182
in the next segment, were what happened
was, that if the cipher text was rejected

148
00:11:20,182 --> 00:11:24,683
due to an invalid pad The server was sent
back an alert message saying decryption

149
00:11:24,683 --> 00:11:29,113
failed. Whereas if the cipher text was
rejected due to a bad Mac, the server will

150
00:11:29,113 --> 00:11:33,267
send back a bad record Mac alert. As a
result, and adversary who observes the

151
00:11:33,267 --> 00:11:37,753
alert sends back from the server, can tell
whether the pad in the cipher text was

152
00:11:37,753 --> 00:11:42,184
valid or invalid. And this introduces a
very significant attack called a padding

153
00:11:42,184 --> 00:11:46,670
attack, which we're gonna talk about in
the next segment. The solution to this and

154
00:11:46,670 --> 00:11:50,713
TLS 1.1, was basically to say that,
instead of reporting decryption failed

155
00:11:50,713 --> 00:11:55,092
here, we're gonna report a bad record Mac,
even if the pad is incorrect. And, as a

156
00:11:55,092 --> 00:11:59,445
result, simply looking at which alert is
sent back from the server, an attacker

157
00:11:59,445 --> 00:12:04,121
can't tell if a cipher text is rejected
because of a bad pad or a bad MAC. So this

158
00:12:04,121 --> 00:12:09,354
tries to mask this information. Now the
lesson from this is that when decryption

159
00:12:09,354 --> 00:12:14,156
fails, you should never ever explain why,
I guess this is something that comes out

160
00:12:14,156 --> 00:12:19,135
of networking protocols where if there is
a failure you wanna tell the peer why the

161
00:12:19,135 --> 00:12:24,114
failure occurred, where in cryptography if
you explain why the failure occurred that

162
00:12:24,114 --> 00:12:28,797
very often leads to an attack. In other
words when decryption fails just output

163
00:12:28,797 --> 00:12:33,540
reject and don't explain why the reject
actually happens just reject the ciphertext.

164
00:12:33,860 --> 00:12:38,462
Okay, so now that we've seen TLS 1.1,
let's see a broken protocol. So of course

165
00:12:38,462 --> 00:12:43,363
I always like to pick on 802.11b WEP,
which pretty much got everything wrong. So

166
00:12:43,363 --> 00:12:48,086
let's see how not to provide authenticated
encryption. So let me remind you how

167
00:12:48,086 --> 00:12:52,808
802.11b WEP works. Basically there's a
message that the laptop wants to send to

168
00:12:52,808 --> 00:12:57,410
the access point. The first thing that
happens is it, the laptop computes a

169
00:12:57,410 --> 00:13:02,371
cyclic redundancy checksum on the message
and concatenates the CRC checksum to the

170
00:13:02,371 --> 00:13:06,937
message. Then the result is encrypted
using a stream cipher, in particular RC4.

171
00:13:06,937 --> 00:13:12,067
If you recall, the key that's used is the
concatenation of an initial value IV

172
00:13:12,067 --> 00:13:17,263
that changes per packet and the long term
key K. And then the IV along with the

173
00:13:17,263 --> 00:13:21,506
cipher text are transmitted to the other
side. Now we've already saw two

174
00:13:21,506 --> 00:13:26,089
problems with this approach. One was if
the IV is ever repeated and in fact it is

175
00:13:26,089 --> 00:13:30,954
gonna be repeated then you get a two time
pad attack. And the other problem

176
00:13:30,954 --> 00:13:35,310
is that [inaudible] uses very closely
related keys. In other words, the key is

177
00:13:35,310 --> 00:13:39,949
simply IV concatenated to K and the only
thing that changes are the IV so the key

178
00:13:39,949 --> 00:13:44,475
is always fixed, which means that these
PRG keys are very closely related to one

179
00:13:44,475 --> 00:13:48,831
another and as we said, the PRG that's
used here, RC4 is not designed for this

180
00:13:48,831 --> 00:13:53,524
type of use and it completely breaks
if you use it with related keys, and as a

181
00:13:53,524 --> 00:13:58,110
result WEP has no security at all.
What I want to show you. Is that even the

182
00:13:58,110 --> 00:14:02,332
crc mechanism that's used here. In an
attempt to provide integrity and prevent

183
00:14:02,332 --> 00:14:05,872
an adversary from tampering with the
cipher text, even that mechanism is

184
00:14:05,872 --> 00:14:09,960
completely broken, and it's actually very
easy to tamper with cipher texts en route.

185
00:14:09,960 --> 00:14:14,935
So let's see how that's done. The attack
uses a particular property of the CRC

186
00:14:14,935 --> 00:14:20,399
check sum. Mainly the CRC is linear. What
that means is if I give you CRC of M, and

187
00:14:20,399 --> 00:14:25,525
I ask you to compute CRC of M XOR P, then
it's very easy to do. Basically you'll

188
00:14:25,525 --> 00:14:30,989
just compute some well known and public
function of F(P), you XOR these two together,

189
00:14:30,989 --> 00:14:35,976
and that in fact will give you CRC of
M XOR P. So it [inaudible] the xor comes out

190
00:14:35,976 --> 00:14:40,380
of the parenthesis, and that basically
means the CRC is linear. Now here is how the

191
00:14:40,380 --> 00:14:44,727
attack works, suppose the adversary
intercepts a particular, packet that's

192
00:14:44,727 --> 00:14:48,841
destined to the access point. Now the
packet say, sais it's destined for

193
00:14:48,841 --> 00:14:53,535
destination port 80, and the attacker
knows that it's intended for destination

194
00:14:53,535 --> 00:14:58,114
port 80 and what he wants to do is
modify the cipher texts such that now the

195
00:14:58,114 --> 00:15:02,550
destination port will say 25 instead of
80. And maybe the attacker can read

196
00:15:02,550 --> 00:15:06,922
messages for port 25 and that's how he
actually obtains the actual data in the

197
00:15:06,922 --> 00:15:11,405
packet. So recall that the CRC checksum
is there to make sure that exactly the

198
00:15:11,405 --> 00:15:15,943
attacker cannot change data inside of the
cipher text. But I want to show you that

199
00:15:15,943 --> 00:15:20,702
in fact it's really easy to modify data in
the cipher text and CRC basically provides

200
00:15:20,702 --> 00:15:25,611
no security against tampering at all. So
let's see how to do it. Well, what the

201
00:15:25,611 --> 00:15:31,549
attacker would do is, he would basically
Xor some, a certain value XX into the byte

202
00:15:31,549 --> 00:15:37,130
that represents the eight zero in the
cipher text. Now what he'll Xor in will

203
00:15:37,130 --> 00:15:43,497
basically be the string 25 Xor 80 and you
remember that if I Xor a certain string XX

204
00:15:43,497 --> 00:15:48,890
into the cipher text. That was created
using a stream cipher. When that cipher

205
00:15:48,890 --> 00:15:54,653
gets, is decrypted, the plain text at this
position will also be Xored by XX. And as

206
00:15:54,653 --> 00:16:00,176
a result after decryption the plain text
at this position basically will be the

207
00:16:00,176 --> 00:16:05,767
original 80XR 25 XR 80 which gives us 25.
Okay? So after decryption the plain text

208
00:16:05,767 --> 00:16:11,152
of this position will now be 25. The
problem is that if that's all we did then

209
00:16:11,152 --> 00:16:16,537
this attack would fail because the CRC
check sum would now would not validate.

210
00:16:16,537 --> 00:16:21,672
The CRC check sum. Was built with 80 as a
plain text but 25 is a different plain

211
00:16:21,672 --> 00:16:26,883
text and needs a different CRC. But it's
not a problem because what we can do is we

212
00:16:26,883 --> 00:16:31,969
can easily correct the check sum, the CRC
check sum, even though the CRC check sum

213
00:16:31,969 --> 00:16:37,180
is encrypted. What we do is we XOR
F of XX into the cipher text at the place

214
00:16:37,180 --> 00:16:42,266
where the CRC is supposed to be and as a
result, when the cipher text is decrypted

215
00:16:42,266 --> 00:16:47,271
what will happen is we'll get the correct
CRC check sum after decryption. So, the

216
00:16:47,271 --> 00:16:52,275
interesting thing that happened here is
even though the attacker doesn't know what

217
00:16:52,275 --> 00:16:57,157
the crc value is, he's able to correct it
using this linearity property such that

218
00:16:57,157 --> 00:17:01,738
when the cipher text is decrypted the
correct crc value appears in the plain

219
00:17:01,738 --> 00:17:06,671
text. Okay? So the linearity property of
CRC plays a critical role in making this

220
00:17:06,671 --> 00:17:11,483
attack works. The end conclusion here is
basically that a CRC check sum provides

221
00:17:11,483 --> 00:17:16,235
absolutely no integrity at all against
active attacks and it should never, ever,

222
00:17:16,235 --> 00:17:20,686
ever be used as an integrity mechanism.
And instead if you want to provide

223
00:17:20,686 --> 00:17:25,318
integrity you're supposed to use a
cryptographic mac not an ad hoc mechanism

224
00:17:25,318 --> 00:17:29,353
like CRC. Okay, so now we've seen how
authenticated encryption is implemented in

225
00:17:29,353 --> 00:17:33,145
a real world protocol, like TLS. In the
next segment, we're gonna look at real

226
00:17:33,145 --> 00:17:37,287
world attacks on authenticated encryption
implementations that happen to implement

227
00:17:37,287 --> 00:17:39,134
authenticated encryption incorrectly.
