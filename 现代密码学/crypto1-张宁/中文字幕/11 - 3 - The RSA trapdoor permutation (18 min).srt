1
00:00:00,000 --> 00:00:04,090
在上一节里我们了解了如何从陷门函数中构建公钥加密，

2
00:00:04,090 --> 00:00:08,390
在这一节我们将构造一个经典的陷门函数—RSA.

3
00:00:08,390 --> 00:00:13,295
首先让我们先来回顾一下什么是陷门函数。

4
00:00:13,295 --> 00:00:17,283
回想下陷门函数由三种算法组成。分别是密钥生成模式算法，

5
00:00:17,283 --> 00:00:21,056
函数本身和函数的逆。

6
00:00:21,056 --> 00:00:25,313
密钥生成模式算法输出一个公钥和一个私钥。在这种情况下，

7
00:00:25,313 --> 00:00:29,786
这公钥将定义一个函数，这个函数会将一集合X映射到本身。

8
00:00:29,786 --> 00:00:33,882
之所以我把这些叫做陷门排列，与陷门函数相对照，

9
00:00:33,882 --> 00:00:37,978
仅仅是因为这个函数将X映射到本身，

10
00:00:37,978 --> 00:00:43,356
然而陷门函数可能会将一集合X映射到一任意集合Y。

11
00:00:43,356 --> 00:00:47,819
现在给这个函数赋予一公钥，正如我们所说的，定义这函数是从集合X到集合X的。

12
00:00:47,819 --> 00:00:52,914
然后给一个私钥，我们能反转这个函数。

13
00:00:52,914 --> 00:00:57,401
所以函数F从正面评估本身，反转，也就是

14
00:00:57,401 --> 00:01:02,059
通过私钥SK从反面计算函数F。

15
00:01:02,059 --> 00:01:06,489
如果被公钥定义的函数事实上是单向函数则陷门置换是安全的，

16
00:01:06,489 --> 00:01:11,033
也就是说评估容易但没有陷门，

17
00:01:11,033 --> 00:01:15,404
秘密的陷门是很难反转的。

18
00:01:15,404 --> 00:01:20,076
在看第一个例子之前，我想对将用到的必需的一些算法

19
00:01:20,076 --> 00:01:24,467
做一个快速回顾。特别地，

20
00:01:24,467 --> 00:01:28,632
让我们来看一些以复合体为模的算法实例，所以有模数N,

21
00:01:28,632 --> 00:01:33,192
它恰好是两个素数产生的，取两大致等价的数p，q，

22
00:01:33,192 --> 00:01:37,864
使二者恰好大致上是N的平方根

23
00:01:37,864 --> 00:01:42,407
二者大致相同。

24
00:01:42,407 --> 00:01:46,834
回想一下,我们用ZN来表示从0到N - 1的一组整数,

25
00:01:46,834 --> 00:01:51,318
我们可以用模N来做加法和乘法。我们用ZN*来标记其中的可逆元素。

26
00:01:51,318 --> 00:01:55,801
所以所有的元素都有模块化的倒数。

27
00:01:55,801 --> 00:02:00,925
我们说X是可逆的当且仅当它与N互质。

28
00:02:00,925 --> 00:02:05,928
另外，我也会告诉你可逆元素的数量用这个函数φ(N)来表示。

29
00:02:05,928 --> 00:02:11,147
所以φ(N)就是ZN中可逆元素的数目，

30
00:02:11,147 --> 00:02:15,814
当N是由两个不同的素数产生时，

31
00:02:15,814 --> 00:02:20,788
事实上φ(N)等于(p - 1)乘以(q - 1)，如果你延长，

32
00:02:20,788 --> 00:02:26,007
这确实是等于(N - p - q + 1)。现在记住我说的

33
00:02:26,007 --> 00:02:30,858
p和q是N的平方根，p+q也是N的平方根。

34
00:02:30,858 --> 00:02:35,675
那么φ(N)大约是（N - 2） N的平方根

35
00:02:35,675 --> 00:02:41,050
换句话说，它会非常非常接近于N

36
00:02:41,050 --> 00:02:45,158
基本上，从一个数减去N的平方根，

37
00:02:45,158 --> 00:02:49,425
N将是一个巨大的数字在我们的例子中,像600位数。

38
00:02:49,425 --> 00:02:53,533
从一个600位数中减去,这个600位数字的平方根,也就是一个300位数字，

39
00:02:53,533 --> 00:02:57,534
几乎不影响这个数字的大小。也就是φ(N)是真的

40
00:02:57,534 --> 00:03:01,908
真的真的很接近N，我想让你记住，因为我们时不时的会用到这个，

41
00:03:01,908 --> 00:03:06,122
所以这个事实，意味着

42
00:03:06,122 --> 00:03:11,094
如果我们选一个随机元素模N，它会非常非常非常有可能是ZN*。

43
00:03:11,094 --> 00:03:15,633
所以这是非常不可能的通过选一个随机元素，我们最终将

44
00:03:15,633 --> 00:03:20,085
选出不可逆的一元素。所以就记住，

45
00:03:20,085 --> 00:03:25,479
事实上几乎所有的ZN中的元素都是可逆的。

46
00:03:25,479 --> 00:03:30,939
最后我们需要学习的就是欧拉定理，我们上周学过的，

47
00:03:30,939 --> 00:03:36,332
对于ZN*中任一元素，如果我把X加到φ(N)上，我会得到ZN中一个数。

48
00:03:36,332 --> 00:03:42,527
换句话说，，我得到1模N。我再说一次

49
00:03:42,527 --> 00:03:47,466
因为这对下面要说的是至关重要的。X加到φ(N)上等价于1模N。

50
00:03:47,466 --> 00:03:51,997
现在我们要有必需的背景来描述RSA陷门置换。

51
00:03:51,997 --> 00:03:55,927
这是一个很经典很经典的概念在密码学中，

52
00:03:55,927 --> 00:04:00,811
它是在1977年首次被刊登在科学美国人封面上的，

53
00:04:00,811 --> 00:04:05,576
这个一篇周所周知的文章在密码学界。从那时到现在，它有35年了，

54
00:04:05,576 --> 00:04:10,340
RSA陷门置换被广泛地应用在密码相关的应用程序中。

55
00:04:10,340 --> 00:04:15,110
例如，SSL和TLS用RSA来进行认证和密钥交换。

56
00:04:15,110 --> 00:04:19,452
有许多安全的电子邮件系统和安全的文件系统用RSA来加密邮件和文件

57
00:04:19,452 --> 00:04:23,515
在文件系统中。还有许多许多其他这个系统的应用程序。

58
00:04:23,515 --> 00:04:27,690
所以它是一个非常非常经典的加密结构，

59
00:04:27,690 --> 00:04:32,541
我会向你展示它是如何工作的。

60
00:04:32,541 --> 00:04:37,150
RSA是以它的发明者Ron RivEst, Adi Shamir和Len Adleman命名的

61
00:04:37,150 --> 00:04:41,758
他们都是在MIT完成这项重要的工作的

62
00:04:41,758 --> 00:04:46,425
那么我们来描述RSA陷门置换，首先我需要描述密钥产生算法

63
00:04:46,425 --> 00:04:50,159
函数A和函数AE

64
00:04:50,159 --> 00:04:54,826
密钥产生算法是这样做的：

65
00:04:54,826 --> 00:04:59,143
我们生成2个素数p、q，每个大约1000比特，300十进制位

66
00:04:59,143 --> 00:05:03,751
RSA模就等于两个素数的乘积

67
00:05:03,751 --> 00:05:08,801
然后我们选择两个指数e和d，使得e乘d等于1模φ(N)

68
00:05:08,801 --> 00:05:13,894
这意味着e和d首先与φ(N)互素

69
00:05:13,894 --> 00:05:19,051
其次它们互为模φ(N)的逆

70
00:05:19,051 --> 00:05:24,014
然后我们输出公钥对(N,e)

71
00:05:24,014 --> 00:05:29,172
私钥为(N,d)

72
00:05:29,172 --> 00:05:34,586
这个指数e有时称为加密指数

73
00:05:34,586 --> 00:05:39,135
指数d有时称为解密指数

74
00:05:39,135 --> 00:05:43,189
马上你就会知道为什么我称它为指数

75
00:05:43,189 --> 00:05:46,902
RSA函数定义是很简单的。简单起见，我称之为从ZN*到ZN*的函数

76
00:05:46,902 --> 00:05:51,801
这个函数定义为给定输入X

77
00:05:51,801 --> 00:05:57,001
我们取X在ZN中的e次幂

78
00:05:57,001 --> 00:06:02,137
因此我们只需计算X^e mod N

79
00:06:02,137 --> 00:06:07,451
解密时，给定输入Y，我们只需计算Y的d次幂模N

80
00:06:07,451 --> 00:06:12,483
现在你知道我把e,d称为指数的原因了

81
00:06:12,483 --> 00:06:17,767
它们是X和Y的指数。因此我们来快速验证F^-1确实是F的逆

82
00:06:17,767 --> 00:06:22,673
我们来看计算Y^d时会发生什么

83
00:06:22,673 --> 00:06:27,515
假设Y正好是函数RSA在X的值

84
00:06:27,515 --> 00:06:33,045
这时Y^d等于RSA(X)^d

85
00:06:33,045 --> 00:06:39,006
即等于X^e mod N。因此Y^d等于X^ed mod N

86
00:06:39,006 --> 00:06:44,896
这里又使用了指数相乘规则

87
00:06:44,896 --> 00:06:50,857
所以我们得到X^(ed)。但ed等于什么呢？

88
00:06:50,857 --> 00:06:57,390
ed等于1 mod φ(N)。这说明存在某个整数k

89
00:06:57,390 --> 00:07:04,177
使得ed=kφ(N)+1，也就是说ed=1 mod φ(N)

90
00:07:04,177 --> 00:07:09,820
因此我们把ed换成kφ(N)+1

91
00:07:09,820 --> 00:07:14,453
我写在这里。我们有X^(kφ(N)+1)

92
00:07:14,453 --> 00:07:19,868
现在再用指数法则，我们能把式子重写为（X^φ(N))^k*x

93
00:07:19,868 --> 00:07:24,827
这与kφ(N)+1作为指数相同

94
00:07:24,827 --> 00:07:29,917
我只是把指数放在不同项上

95
00:07:29,917 --> 00:07:35,137
现在通过欧拉定理，我们知道X^φ(N)等于1

96
00:07:35,137 --> 00:07:41,394
所以整个乘积等于多少？因为X^φ(N)=1

97
00:07:41,394 --> 00:07:45,961
1^k=1，因此整个式子就等于1

98
00:07:45,961 --> 00:07:50,757
只剩下X，因此我们证明了

99
00:07:50,757 --> 00:07:55,210
如果计算RSA函数的输出的d次幂，就得到X

100
00:07:55,210 --> 00:07:59,663
这说明d次幂就是RSA函数的逆

101
00:07:59,663 --> 00:08:04,638
就是这样。这就是函数的完整描述

102
00:08:04,638 --> 00:08:08,972
我们描述了密钥的产生，函数自身，即计算e次幂模N

103
00:08:08,972 --> 00:08:13,410
函数的逆，即计算d次幂模N

104
00:08:13,410 --> 00:08:17,483
接下来的问题是，为什么这个函数是安全的

105
00:08:17,483 --> 00:08:21,609
换句话说，为什么函数是单向的，如果我只有公钥但没有私钥？

106
00:08:21,609 --> 00:08:26,409
为了说明函数是单向的

107
00:08:26,409 --> 00:08:31,454
我们表述RSA假设，它告诉我们RSA是一个单向置换

108
00:08:31,454 --> 00:08:36,626
正式的表达是这样

109
00:08:36,626 --> 00:08:41,416
对于所有的有效算法A，如果产生两个随机素数p和q

110
00:08:41,416 --> 00:08:46,397
把它们相乘再模N，然后随机在ZN*中取y

111
00:08:46,397 --> 00:08:51,103
然后把模数，指数和y给算法A

112
00:08:51,103 --> 00:08:55,893
我得到RSA在y的逆的概率

113
00:08:55,893 --> 00:09:00,336
也就是得到y^(1/e)的概率

114
00:09:00,330 --> 00:09:04,600
这个事件的概率可以忽略不计。因此这种假设叫做RSA假设。

115
00:09:04,600 --> 00:09:09,330
它指出RSA是一种提供公共密钥的单向置换。

116
00:09:09,330 --> 00:09:13,950
并且这是一种陷门置换因为其中包含陷门。

117
00:09:13,950 --> 00:09:19,500
并且这使得每个知道陷门的人都很容易作反置。所以我们现在有了一个安全

118
00:09:19,500 --> 00:09:23,710
的陷门置换。我们可以简单地把它插入到我们为公共密钥加密的函数中，

119
00:09:23,710 --> 00:09:27,820
这就得到了世界上第一个公共密钥加密系统。

120
00:09:27,820 --> 00:09:32,360
我们要做到就是简单地将RSA的陷门置换插入

121
00:09:32,360 --> 00:09:36,150
我们之前已经见过的iso标准函数中。所以，回想一下，

122
00:09:36,150 --> 00:09:40,200
这个结构基于一个必须提供认证加密的对称加密系统。

123
00:09:40,200 --> 00:09:44,430
这个结构还基于哈希函数。

124
00:09:44,610 --> 00:09:48,860
然后转移到RSA中，它将元素映射进

125
00:09:48,860 --> 00:09:54,200
ZN，映射进对称密钥系统中的私密密钥里。现在，

126
00:09:54,200 --> 00:09:58,940
加密体系工作的方式很容易描述了。一般来说，算法G

127
00:09:58,940 --> 00:10:03,750
只运行RSA密钥算法并且产生一个公共密钥和一个私密密钥。

128
00:10:03,750 --> 00:10:07,810
就像之前一样，所以你会发现公共密钥包含加密指数

129
00:10:07,810 --> 00:10:11,940
私密密钥包含解密指数。

130
00:10:11,940 --> 00:10:16,290
并且我们是按顺序加密。接下来，我们要从ZN中随机地选取一个X。

131
00:10:16,290 --> 00:10:21,460
我们要对这个X申请使用RSA函数。 我们要从这个X中通过哈希函数演绎出一个对称密钥

132
00:10:21,460 --> 00:10:26,450
因此我们通过X计算出H并获得密钥K，接着输出Y和

133
00:10:26,450 --> 00:10:31,130
在对称密钥K下的信息加密后的结果。

134
00:10:31,130 --> 00:10:35,930
事实上，哈希函数H是运用了SHA-256来进行加密计算的，

135
00:10:35,930 --> 00:10:40,970
因此你才可以运用SHA-256的输出来生成一个稍后用来

136
00:10:40,970 --> 00:10:45,680
作为对称加密的助手的对称密钥。这就是加密的过程。

137
00:10:45,680 --> 00:10:50,080
接下来解密的过程和我们之前学过的很相似，

138
00:10:50,080 --> 00:10:54,950
第一个步骤，是用私密密钥

139
00:10:54,950 --> 00:10:59,750
倒置密文的报头。所以我们可以计算出RSA在Y下的倒置

140
00:10:59,750 --> 00:11:04,560
这样会得到一个值X. 接下来对X使用哈希函数，我们可以得到密钥K。

141
00:11:04,560 --> 00:11:09,190
接下来对密文中的对称系统运行解密算法

142
00:11:09,190 --> 00:11:15,170
这样就可以得到原始信息M。

143
00:11:15,170 --> 00:11:19,100
我们之前还学过一个理论，如果RSA的陷门排列是安全的。

144
00:11:19,100 --> 00:11:23,080
Es和Ds，那么对称加密系统[inaudible]

145
00:11:23,080 --> 00:11:27,170
会提供经过验证的加密。正如我们所说，H只是一种随机的预报。

146
00:11:27,330 --> 00:11:31,420
它只是一种从ZN到密钥区的随机函数。

147
00:11:31,420 --> 00:11:35,720
事实上，这种安全挑选密文的系统是一种很好的可以用作公共密钥的系统。

148
00:11:36,240 --> 00:11:41,720
那么现在我们就得到了第一个优质公共密钥系统运用的例子。

149
00:11:41,720 --> 00:11:46,970
这里我要再次提示大家RSA不能用于直接加密

150
00:11:46,970 --> 00:11:51,100
这又是我们之前讲过的内容，现在我又要重复一遍，

151
00:11:51,100 --> 00:11:55,530
把之前的理论针对RSA再讲一遍，所以我喜欢把这个称为RSA反面教材。

152
00:11:55,530 --> 00:11:59,400
当你要使用RSA加密时，

153
00:11:59,400 --> 00:12:03,670
公钥和私钥就像之前规定的那样生成，

154
00:12:03,670 --> 00:12:08,160
但此处我们不用哈希函数来得到对称密钥，

155
00:12:08,160 --> 00:12:12,330
而是直接用RSA加密来得到信息m的密文。

156
00:12:12,330 --> 00:12:16,200
那么，对于解密算法，我们也就直接使用私钥进行解密。

157
00:12:16,200 --> 00:12:20,770
来得到纯文本m。我要把这种称为RSA反面教材，

158
00:12:20,770 --> 00:12:25,350
而且这里有很多种密码学教材用这个方法来讲解RSA，这是完全的错误方法。

159
00:12:25,350 --> 00:12:29,490
这不是RSA加密的方式。这是一种不安全的系统。特别是，

160
00:12:29,490 --> 00:12:33,930
它是确定性加密，所以它可能不能保证语义安全。

161
00:12:33,930 --> 00:12:38,540
这里事实上有很多攻击存在，比如接下来我要展示一个只用一分钟就能攻破这个机制的攻击。

162
00:12:38,540 --> 00:12:42,700
这里我想讲清楚一点，

163
00:12:42,700 --> 00:12:47,150
RSA是一个陷门置换，对它自己来说，它不是一个加密系统。

164
00:12:47,150 --> 00:12:51,420
所以我们必须完善一下它，比如加上ISO标准，使它成为一个加密系统。

165
00:12:51,420 --> 00:12:55,820
仅仅就它自己来说，它只是个函数。那么如果我们用RSA反面教材的方法的话

166
00:12:55,820 --> 00:13:00,220
我们会犯什么错误呢？换句话说，如果你想直接用RSA加密一条消息，

167
00:13:00,220 --> 00:13:04,970
这里你会受到一个互联网的攻击，

168
00:13:04,975 --> 00:13:09,725
假设我们有个网络服务器，它有一个RSA私密密钥。我们用N和D来表示。

169
00:13:09,725 --> 00:13:14,738
我们有一个浏览器正在尝试建立一个安全的SSL会话

170
00:13:14,738 --> 00:13:19,124
通过web服务器。所以SSL的工作方式为：

171
00:13:19,124 --> 00:13:23,401
由浏览器发送“客户你好”这样的消息开始

172
00:13:23,401 --> 00:13:27,787
“你好，我想和你建立一个安全会话”。web服务器立即响应相应服务器的消息

173
00:13:27,787 --> 00:13:32,430
消息包括了服务器的公钥。之后浏览器将运行，

174
00:13:32,430 --> 00:13:36,615
并且生成一个随机的预主密钥K，

175
00:13:36,615 --> 00:13:40,692
它将用服务器公钥加密预主密钥K并将密文发送给服务器

176
00:13:40,692 --> 00:13:44,932
服务器会进行解密得到K，

177
00:13:44,932 --> 00:13:49,336
所以两者会得到一个共享密钥，用来进行之间的安全会话。

178
00:13:49,336 --> 00:13:53,630
如果我们直接使用RSA函数来加密K会出什么错误?

179
00:13:53,630 --> 00:13:57,762
换句话说，如果直接将K加密为K^e mod N

180
00:13:57,762 --> 00:14:02,828
为了论证，我们假设K为一个64比特的密钥

181
00:14:02,828 --> 00:14:08,097
我们将K取一在0到2的64次方范围内的整数

182
00:14:08,097 --> 00:14:13,100
更准确的说是2的64次方减一，现在我们继续往下

183
00:14:13,100 --> 00:14:18,302
首先，假设K取大致相等的一串数

184
00:14:18,302 --> 00:14:23,705
我们把K写成K1乘K2，并且K1和K2都为整数

185
00:14:23,705 --> 00:14:29,745
并且都小于2的34次方。事实证明这种情况发生

186
00:14:29,745 --> 00:14:34,508
的概率约为百分之二十，所以有五分之一的情况下K可以这么写

187
00:14:34,508 --> 00:14:39,740
但是现在如果将K，K=K1×K2加入方程式中

188
00:14:39,740 --> 00:14:45,241
定义你看到的密文可以简单地用K1×K2替换K

189
00:14:45,241 --> 00:14:50,875
然后我们就可以把K1换到另一边，这个方程式就结束了

190
00:14:50,875 --> 00:14:55,897
即K1的e次方分之C等于K2的e次方。注意，如果我在两边

191
00:14:55,897 --> 00:15:00,659
同乘K1的e次方，就得到了C等于K1×K2的e次方

192
00:15:00,659 --> 00:15:06,374
得到的就是这个方程。我只是把K用K1×K2替换

193
00:15:06,374 --> 00:15:11,955
然后再用K1的e次方分开。现在这看起来很熟悉吧

194
00:15:11,955 --> 00:15:16,146
这个方程中现在有两个变量。C会被攻击者知道

195
00:15:16,146 --> 00:15:20,092
E和N也会被攻击者知道

196
00:15:20,092 --> 00:15:24,518
而这个方程的两个变量为K1和K2,

197
00:15:24,518 --> 00:15:28,891
我们将其分到方程的两边，结果我们可以做一个这个方程的中间人攻击

198
00:15:28,891 --> 00:15:33,157
现在来解决中间人攻击

199
00:15:33,157 --> 00:15:37,524
建立一个包含左边式子所有可能值的表

200
00:15:37,524 --> 00:15:43,392
K1的e次方分之C的所有可能值，有2的34次方个

201
00:15:43,584 --> 00:15:48,878
而右边的所有可能值，即K2的e次方的所有可能值

202
00:15:48,878 --> 00:15:54,175
第一步，我们要检查这个值是否在表中

203
00:15:54,175 --> 00:15:58,749
如果我们发现一个碰撞，

204
00:15:58,749 --> 00:16:03,265
我们基本上就得到这个方程的解法了。当我们找到一个K2的e次方的元素

205
00:16:03,265 --> 00:16:07,962
在第一步建立的表中时，我们就解了这个方程

206
00:16:07,962 --> 00:16:12,717
并得到K1和K2。一旦我们找到了K1和K2

207
00:16:12,717 --> 00:16:16,950
我们就可以很简单地通过K1×K2将K还原出来

208
00:16:16,950 --> 00:16:21,428
所以我们将K1×K2得到密钥K，所以我们已经破坏了加密系统

209
00:16:21,428 --> 00:16:25,604
这花了多长时间？通过强行计算，

210
00:16:25,604 --> 00:16:29,890
我们不再需要2的64次方的时间，只要尝试所有可能的密钥

211
00:16:29,890 --> 00:16:33,792
攻击者在步骤一花了2的34次方时间，

212
00:16:33,792 --> 00:16:38,353
可能比这多一些，因为我们不得不做取幂

213
00:16:38,518 --> 00:16:42,969
步骤二也需要2的34次方时间，也可能因为取幂而多于这个时间

214
00:16:42,969 --> 00:16:47,530
所以这整个算法需要大约2的40次方时间

215
00:16:47,530 --> 00:16:52,277
关键是，这仍大大减少了所需时间，

216
00:16:52,277 --> 00:16:56,667
对于这个例子，如果你直接使用RSA加密，换句话说

217
00:16:56,667 --> 00:17:01,296
你直接计算出K的e次方，模N而不通过ISO标准

218
00:17:01,296 --> 00:17:05,983
你会受到攻击，并且并行起来比穷举搜索更快。

219
00:17:05,983 --> 00:17:10,730
你受到的攻击运行需要2的40次方时间，而不是2的64次方

220
00:17:10,730 --> 00:17:14,985
这是个好例子，说明密码可以被破译，

221
00:17:14,985 --> 00:17:19,299
如果直接用RSA陷门置换来加密信息的话。这里需要记住的是，

222
00:17:19,299 --> 00:17:23,670
千万不要直接使用RSA来加密。你得通过加密机制来加密，

223
00:17:23,670 --> 00:17:27,868
就像ISO标准一样。

224
00:17:27,868 --> 00:17:32,354
事实上，下一节我们就会看到其他方式来使用RSA建立

225
00:17:32,354 --> 00:17:33,620
公用密钥加密。【END】

