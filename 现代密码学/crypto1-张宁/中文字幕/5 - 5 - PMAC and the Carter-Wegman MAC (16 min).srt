1
00:00:00,000 --> 00:00:04,059
过去的两小节中我们讨论过使用CBC-MAC和NMAC将

2
00:00:04,059 --> 00:00:08,096
供短消息使用的PRF转换为供长消息使用的PRF 这两种构造方法都是

3
00:00:08,096 --> 00:00:13,045
时序的 意思是 即便你有多处理器 你仍然不能

4
00:00:13,045 --> 00:00:17,082
加快这种构造的工作效率 本节 我们将学习一种平行MAC

5
00:00:17,082 --> 00:00:21,065
它也能将小型PRF转成大型PRF 但它是否是

6
00:00:21,065 --> 00:00:26,014
平行模式呢 特别地 我们将学习一种叫做PMAC的平行MAC结构

7
00:00:26,014 --> 00:00:30,029
它可以用一个基本PRF来构建一个供更长消息使用的PRF

8
00:00:30,029 --> 00:00:34,062
更特别地 这个PRF可以处理变长和

9
00:00:34,062 --> 00:00:39,007
具有与L块相同数量的消息 这个结构的工作方式如下

10
00:00:39,007 --> 00:00:43,032
我们得到消息并分块 之后逐个处理块

11
00:00:43,032 --> 00:00:47,075
所以 首先要做的是 求函数

12
00:00:47,075 --> 00:00:52,003
P的值 然后将这个值与第一个消息值异或 接着

13
00:00:52,003 --> 00:00:56,052
将得到值送入函数F并用密钥K1 我们为每个消息块做相同的操作

14
00:00:56,052 --> 00:01:01,000
你应该注意到 我们可以平行地完成这个步骤 所有消息块

15
00:01:01,000 --> 00:01:05,038
都是独立地被处理的 然后 我们收集得到的所有结果并送入

16
00:01:05,038 --> 00:01:09,064
最终异或计算器 接着我们再加密一次从而得到最终的标记值

17
00:01:09,064 --> 00:01:13,074
由于技术的原理 最后一个 我们不必使用

18
00:01:13,074 --> 00:01:17,074
PRF F 但正如我所说 这只是因为技术原因 我打算忽视这个问题

19
00:01:17,074 --> 00:01:21,084
现在我想解释函数P是为了什么 并且

20
00:01:21,084 --> 00:01:26,028
它是用来干什么的 这里假设 函数P并不存在

21
00:01:26,028 --> 00:01:30,067
那么实际上 我们将直接将每个消息块送入

22
00:01:30,067 --> 00:01:34,062
PRF 而没有使用其它任何处理 所以我说

23
00:01:34,062 --> 00:01:38,087
作为结果的MAC是完全不安全的 因为本质上

24
00:01:38,087 --> 00:01:43,012
消息块之间没有执行任何操作 特别地 假设我交换两消息块位置

25
00:01:43,012 --> 00:01:47,052
将不会改变最终特征值 由于XOR是或交换的 所以特征值

26
00:01:47,052 --> 00:01:51,077
不会改变 不管我们交换消息块位置与否 就结果来说

27
00:01:51,077 --> 00:01:56,001
攻击者为一消息请求特征值 他交换两消息块 并得到这一消息的特征值

28
00:01:56,001 --> 00:02:00,021
这可算做一种伪造

29
00:02:00,021 --> 00:02:04,061
所以这个函数P所做的是为这些消息块执行命令操作

30
00:02:04,061 --> 00:02:08,079
注意到 首先这个函数是键控函数

31
00:02:08,079 --> 00:02:13,008
所以他需要一个密钥做为输入 更重要的第二点 它接收消息块号做为输入

32
00:02:13,008 --> 00:02:17,000
换言之 每块的函数值是不同的

33
00:02:17,000 --> 00:02:20,087
所以 正是这个属性可以防止这种

34
00:02:21,002 --> 00:02:25,006
消息块交换攻击 所以函数P 计算起来很容易

35
00:02:25,006 --> 00:02:29,013
基本上 给定密钥与消息块 所需的只是

36
00:02:29,013 --> 00:02:33,019
有限域内的乘法 所以它是个非常容易计算的函数

37
00:02:33,019 --> 00:02:36,094
它对于PMAC来说只会增加非常少的时间 与之相反的是

38
00:02:36,094 --> 00:02:40,097
它可确保PAMC是安全的 正如前面所说 PAMC的密钥

39
00:02:40,097 --> 00:02:45,082
是这对密钥 一个供PRF使用 一个供函数掩模P使用

40
00:02:45,082 --> 00:02:50,014
最后 我需要阐述一点如果消息长度不是

41
00:02:50,014 --> 00:02:54,076
块长度的整数倍 也就是 如果最后一个消息块短于一个整块

42
00:02:54,076 --> 00:02:59,088
那么PMAC就会使用一个与CMAC相似的补丁 因此

43
00:02:59,088 --> 00:03:04,004
根本没有必要增加一个傀儡块 这就是

44
00:03:04,004 --> 00:03:08,026
PMAC结构 照例 我们可以陈述它的安全理论

45
00:03:08,026 --> 00:03:12,071
现在你应该已经习惯于安全理论 本质上 这个公式是说 如果有一

46
00:03:12,071 --> 00:03:16,071
正在攻击PMAC的敌手 那么我可以构建一正在攻击基础PRF的敌手

47
00:03:16,071 --> 00:03:21,003
再加上误差项 这里PRF

48
00:03:21,003 --> 00:03:25,056
是安全的 我们知道该项是可忽略的 所以如果我想让该项也是

49
00:03:25,056 --> 00:03:30,063
可忽略的 我们应该知道 我们需要让误差项变得可忽略

50
00:03:30,063 --> 00:03:35,040
照例 Q是使用一特殊密钥计算的消息的杂凑值

51
00:03:35,040 --> 00:03:39,093
L是这些消息的最大长度 并且PMAC是安全的 只要

52
00:03:39,093 --> 00:03:44,082
这个乘积小于块大小的平方根 对AES来说 这个块大小为2^128

53
00:03:44,082 --> 00:03:49,028
所以平方根是2^64

54
00:03:49,028 --> 00:03:53,044
所以这个MAC算法是安全的条件是 Q*L的值小于2^64 并且每当

55
00:03:53,044 --> 00:03:57,025
积值越接近2^64 你就必须改变密钥

56
00:03:57,025 --> 00:04:01,010
来计算更多消息的杂凑值 所以主要要记住

57
00:04:01,010 --> 00:04:05,041
当PMAC逐条处理消息时 PMAC也可相当于PRF

58
00:04:05,041 --> 00:04:10,033
事实上PMAC有一个非常有意思的属性 即

59
00:04:10,033 --> 00:04:15,056
PMAC算法是增值的 这里让我解释下它的意思 假设

60
00:04:15,056 --> 00:04:20,055
PMAC结构中所用的函数F并不仅仅是一个PRF 而是一个置换

61
00:04:20,055 --> 00:04:25,025
PRP 所以如果需要 我们可以将其逆转 现假设

62
00:04:25,025 --> 00:04:30,008
我们已计算过消息m的杂凑值 接着

63
00:04:30,008 --> 00:04:34,059
假设该长消息中一消息换被改变 假定m[1]→m＇[1]

64
00:04:34,059 --> 00:04:38,099
但剩余的消息块保持原样

65
00:04:38,099 --> 00:04:43,081
对于其它杂凑算法 如CBC-MAC来说 即便仅改变一消息块

66
00:04:43,081 --> 00:04:48,027
还是需要重新计算整个消息的特征值 重新计算特征值

67
00:04:48,027 --> 00:04:52,073
会依消息长度成比例消耗更多时间

68
00:04:52,073 --> 00:04:57,012
事实上 对于PMAC 如果我们仅改变一消息块 或少量消息块

69
00:04:57,012 --> 00:05:01,088
我们可以非常快地为新消息重新计算特征值

70
00:05:01,088 --> 00:05:05,074
这里我为你们提一个疑问 来看看你们自己能否想出快速计算的方法

71
00:05:05,074 --> 00:05:09,036
记住 函数F是一个PRP 因此它是可逆的

72
00:05:09,036 --> 00:05:13,002
让我们看看能不能快速完成新消息杂凑值的计算

73
00:05:13,002 --> 00:05:16,087
事实上 是可以完成的 可以快速重计算新消息的新特征值

74
00:05:16,087 --> 00:05:20,093
只需要使用这里写的三条公式 为了确保大家都能明白

75
00:05:20,093 --> 00:05:25,024
这个解决办法 让我们回到前面讲过的PMAC的原理图 然后我会说明

76
00:05:25,024 --> 00:05:29,004
解决办法 假想这个消息块变成另一消息块

77
00:05:29,004 --> 00:05:33,066
如变成m＇[1] 接下来我们要做的是 获取改变

78
00:05:33,066 --> 00:05:38,060
之前的消息特征值 并且逆转函数F

79
00:05:38,060 --> 00:05:43,036
再利用逆转后F确定使用函数F之前的值 这个值是

80
00:05:43,036 --> 00:05:48,006
一群消息块的异或值 之后我们可以抵消

81
00:05:48,006 --> 00:05:53,033
原始块m[1]的异或 方法是将原始消息中的这个值

82
00:05:53,033 --> 00:05:58,068
与刚才得到的所有原始消息异或值进行异或  接着再次将新消息

83
00:05:58,087 --> 00:06:03,046
中的这个值与抵消后的异或值进行异或

84
00:06:03,046 --> 00:06:08,064
接着使用函数F 这样就得到了新消息的特征值

85
00:06:08,064 --> 00:06:13,090
而且新消息中仅有一消息块被改变

86
00:06:13,090 --> 00:06:18,060
这里 我写出了流程工式 你们能看到 我们解密特征值 然后

87
00:06:18,060 --> 00:06:23,092
将得到的值与由原始消息块得到的块异或 接着再将得到的值与

88
00:06:23,092 --> 00:06:28,099
由新消息块得到的消息块异或 然后我们重新加密最终

89
00:06:28,099 --> 00:06:33,089
异或累加来得到改变一消息块的新消息的特征值

90
00:06:33,089 --> 00:06:37,047
整个流程很整齐 也就是说如果你有一很长

91
00:06:37,047 --> 00:06:41,030
的消息 你能快速更新特征值 当然你可以利用私密钥来

92
00:06:41,030 --> 00:06:45,017
完成更新 但如果仅一小部分消息块改变了 你能用上述方法快速更新特征值

93
00:06:45,017 --> 00:06:49,013
这也就是我们所有要讨论的PMAC 现在

94
00:06:49,013 --> 00:06:53,031
我想转换下话题 来说说一次性MAC的概念

95
00:06:53,031 --> 00:06:57,050
它除在完整性算法中 均与一次性密码本相似

96
00:06:57,050 --> 00:07:02,007
这里让我解释下我想表达的意思 假想我们想构建一个MAC 且它

97
00:07:02,007 --> 00:07:06,065
仅能为单条消息的完整性算法使用 换言 每当我们计算

98
00:07:06,065 --> 00:07:11,028
特定消息的完整性时 我们会改变密钥 所以任何特定密钥

99
00:07:11,028 --> 00:07:15,081
仅供单条消息使用 接着我们可以由攻击者只能看到单条消息来

100
00:07:15,081 --> 00:07:20,033
定义安全性的测试方法 因此 我们只让攻击者攻击

101
00:07:20,033 --> 00:07:24,063
选定的单条消息 所以他会提交一条消息请求

102
00:07:24,063 --> 00:07:29,005
接着他会得到请求消息的响应特征值 攻击者目标是

103
00:07:29,005 --> 00:07:33,014
伪造消息特征值对 你可以看到他的目标是产生一个

104
00:07:33,014 --> 00:07:37,058
可以正确认证并与给定的对不相同的消息特征值对

105
00:07:37,058 --> 00:07:41,079
我们将看到 正如一次性密码本与流密码非常

106
00:07:41,079 --> 00:07:45,077
有用一样 事实上 对于一次性MAC来说

107
00:07:45,077 --> 00:07:50,023
当我们仅想用一密钥来为单条消息加密或提供完整性时 它是非常有用的

108
00:07:50,023 --> 00:07:54,030
所以照例 我们会说一次性的举动是安全的

109
00:07:54,030 --> 00:07:58,042
因为 基本上没有攻击者可以赢得这场比赛 这里有趣的事是

110
00:07:58,042 --> 00:08:02,060
一次性MAC 与一次性密码本一样 非常安全 并可抵御无限

111
00:08:02,060 --> 00:08:06,093
强大的攻击者们 不仅如此 因为这些MAC仅对于

112
00:08:06,093 --> 00:08:11,000
一次性使用来说是安全的 所以事实上一次性MACs 可以比以PRF为基础的MAC快

113
00:08:11,000 --> 00:08:15,017
这些我想给你们举一个一次性MAC的例子 这是一个

114
00:08:15,017 --> 00:08:19,042
一次性MAC的经典结构 我会展示它的工作方式 首先

115
00:08:19,042 --> 00:08:24,025
选定一个稍大于块大小的素数 本例中

116
00:08:24,025 --> 00:08:29,002
我们使用的是128bit块 所以我们选择第一个

117
00:08:29,002 --> 00:08:33,091
大于2^128的素数 这正好是2^128+51 接着密钥是从

118
00:08:33,091 --> 00:08:38,081
1到选定素数中的随机数对 即1—q

119
00:08:38,081 --> 00:08:43,046
所以我们从1-q中选两个随机整数 接着给定一个消息

120
00:08:43,046 --> 00:08:47,052
我们将该消息分块 每块大小128bits

121
00:08:47,052 --> 00:08:51,073
并且块中的每个数字是0-(2^128-1)中的任一整数

122
00:08:51,073 --> 00:08:55,089
这里MAC的定义如下 首先要做的是获取

123
00:08:55,089 --> 00:08:59,060
消息块然后依这些消息块构建一类多项式

124
00:08:59,060 --> 00:09:03,061
所以如果消息有L块 我们将构建L次多项式

125
00:09:03,061 --> 00:09:07,082
注意到多项式的常数项设为0

126
00:09:07,082 --> 00:09:11,050
之后MAC的定就非常简单了 基本上我们得到

127
00:09:11,050 --> 00:09:15,028
与消息对应的多项式 接着计算多项式取K时的值

128
00:09:15,028 --> 00:09:19,017
K是密钥的一半 然后再加上值A A是

129
00:09:19,017 --> 00:09:22,095
另一半密钥 这就是整个MAC 所以

130
00:09:22,095 --> 00:09:27,015
基本上只要构建与消息对应的多项多 计算定义域取

131
00:09:27,015 --> 00:09:31,035
密钥的一半时的值 再加上密钥的另一半

132
00:09:31,035 --> 00:09:35,050
当然还要对最后结果取模q 之后得到的就是

133
00:09:35,050 --> 00:09:40,049
完整的MAC 这就是一次性安全MAC 之后我们会讨论这个MAC是否是一次性

134
00:09:40,049 --> 00:09:45,041
安全的 本质上 通过讨论可以知道 假定给定一特定消息的MAC值

135
00:09:45,041 --> 00:09:49,093
它不能给你关于另一消息MAC值的任何信息

136
00:09:49,093 --> 00:09:54,031
结果就是 即使你已得到一特定消息的MAC值

137
00:09:54,031 --> 00:09:58,064
你依然没有办法伪造另一消息的MAC值

138
00:09:58,064 --> 00:10:03,018
这里我应该强调这是一次性MAC 不能保证二次使用的安全性

139
00:10:03,018 --> 00:10:07,067
换言之 如果你得到两不同消息的MAC值

140
00:10:07,067 --> 00:10:11,094
那么这肯定会危害密钥 并且你真的可以预测

141
00:10:11,094 --> 00:10:16,026
依你选择 第三 或第四条消息的MAC值 这时 MAC就变的可伪造了

142
00:10:16,026 --> 00:10:20,074
但对一次性使用来说 它是完全保密的MAC 并且

143
00:10:20,074 --> 00:10:24,099
它是一种可快速评估的算法 假定我们已经构建了一定次MAC

144
00:10:24,099 --> 00:10:29,035
但有一种通用技术可将一次性MAC转化成

145
00:10:29,035 --> 00:10:33,055
多次性MAC 我想简单演示下它的工作方式

146
00:10:33,055 --> 00:10:37,047
假定我们有一次性MAC （S，V)且该MAC用于签名和

147
00:10:37,047 --> 00:10:41,099
认证算法 再假设特征值是n比特串

148
00:10:41,099 --> 00:10:46,079
此外 我们再看看PRF 这个安全的PRF 它正好

149
00:10:46,079 --> 00:10:51,069
输出n比特串 且输入也为n比特串 所以这里我们定义

150
00:10:51,069 --> 00:10:56,047
一个MAC的通用结构 这种MAC叫做Carter-Wegman MAC

151
00:10:56,047 --> 00:11:01,050
它的工作方式如下 基本上就是我们对消息M使用一次性MAC

152
00:11:01,050 --> 00:11:06,040
接着再用PRF对输出结果进行加密 这里我们怎样加密这个

153
00:11:06,040 --> 00:11:11,006
输出结果呢 方式是选一个随机数r 接着

154
00:11:11,006 --> 00:11:15,064
使用r与PRF进行类似于一次性密码本的加密算法 然后我们将该结果与

155
00:11:15,064 --> 00:11:20,050
前面的一次性MAC结果进行异或 这个结构的利落之处是

156
00:11:20,050 --> 00:11:25,019
快速一次性MAC被用在了可能是千兆字节长的长消息上

157
00:11:25,019 --> 00:11:29,089
而较慢的PRF则被于用这个临时r r被用于

158
00:11:29,089 --> 00:11:34,068
加密整个MAC的最终结果 这里你可以疑惑

159
00:11:34,068 --> 00:11:39,046
给定的基础MAC是否是安全的 PRF是否是安全的

160
00:11:39,046 --> 00:11:44,036
若都是 则我们可以得到输出2n比特特征值的一个多次性MAC

161
00:11:44,036 --> 00:11:49,013
我们会在接下来讨论认证加密时学习Carter-Wegman

162
00:11:49,013 --> 00:11:53,043
事实上 NIST完整性加密标准中的一个

163
00:11:53,043 --> 00:11:58,001
正是用了carter-wegman来提供完整性 我还想补充

164
00:11:58,001 --> 00:12:03,012
Carter-wegman MAC是随机MAC的一个很好的例子 且每次计算特征值时

165
00:12:03,012 --> 00:12:08,010
会重新选择临时r  例如 你试图

166
00:12:08,010 --> 00:12:13,009
为同一次消息计算两次特征值 且选择的是不同的r 那么

167
00:12:13,009 --> 00:12:18,013
结果你会得到一对不同的特征值 所以这是一个关于MAC的很好的例子

168
00:12:18,013 --> 00:12:22,069
且该MAC并不是伪随机函数，即不是PRF 因为单一消息

169
00:12:22,069 --> 00:12:27,067
可以映射到许多不同的特征值上 且它们对于该消息都是有效的

170
00:12:27,067 --> 00:12:31,097
为了总结关于Carter-Wegman MAC的讨论 让我

171
00:12:31,097 --> 00:12:36,036
问你接下来的这个问题 这是个关于Carter-wegman MAC的问题

172
00:12:36,036 --> 00:12:40,082
照例 你能看到作为MAC一部分的临时r 和MAC的第二部分

173
00:12:40,082 --> 00:12:45,033
我以t表示这个部分 这个基本上是用于消息M的一次性MAC

174
00:12:45,033 --> 00:12:49,067
接着是 使用临时r 伪随机函数加密的这部分

175
00:12:49,067 --> 00:12:54,007
所以 我们就是将这个异或结果标记为t 我对你们的问题是

176
00:12:54,007 --> 00:12:58,047
给定计算特定消息m的carter-wegman mac值时需要的数对（r,t）

177
00:12:58,047 --> 00:13:03,045
怎么核实该MAC是有效的？ 这里回忆下它的算法V

178
00:13:03,045 --> 00:13:08,035
V是基础一次性MAC的认证算法 这个是正确的答案

179
00:13:08,035 --> 00:13:13,034
为了想通原因 注意这个XOR可以将数t解密成

180
00:13:13,034 --> 00:13:17,085
明文值 该值是原基础一次性MAC

181
00:13:17,085 --> 00:13:22,065
所以我们可以直接将其送入一次性MAC的认证算法

182
00:13:22,065 --> 00:13:26,076
我想讨论的最后一种MAC是一种在

183
00:13:26,076 --> 00:13:31,011
互联网协议中非常流行的MAC 叫做HMAC 但在讨论HMAC前 我们

184
00:13:31,011 --> 00:13:35,004
需要说明下HASH函数 尤其是 耐碰撞hash函数

185
00:13:35,004 --> 00:13:39,020
这些我们都将在下一模块中讨论 所以以上就是

186
00:13:39,020 --> 00:13:43,015
关于MAC的第一模块内容 还有 事实上有许多很好的

187
00:13:43,015 --> 00:13:47,005
关于构建我们看到的这些MAC的理论 我已经给了你们一些展示了

188
00:13:47,005 --> 00:13:50,086
主流构建的集锦 但确实有非常多的关于

189
00:13:50,086 --> 00:13:54,067
构建这些MAC的理论 如果你想了解更多

190
00:13:54,067 --> 00:13:58,062
我列出了你可能会想看的关键论文 让我快速做一下它们的说明

191
00:13:58,062 --> 00:14:03,017
第一个 称做三密钥构建 它是CMAC的基础

192
00:14:03,017 --> 00:14:07,853
且非常精简 并给出了CBC-MAC中的一种非常有效的结构

193
00:14:07,853 --> 00:14:12,005
论文二技术性较高 但基本上就是关于如何证明

194
00:14:12,005 --> 00:14:16,052
做为PRF的CBC-MAC的范围 第三篇讨论了PMAC和它的结构

195
00:14:16,052 --> 00:14:21,022
且该论文非常敏锐 第四篇讨论了

196
00:14:21,022 --> 00:14:26,028
NMAC与HMAC的安全性 下一模块我们会涉及到HMAC 最后一篇

197
00:14:26,028 --> 00:14:30,080
问了一个非常有趣的问题 回忆下所学的所有结构

198
00:14:30,080 --> 00:14:35,073
我们一直认为AES是一供16字节长消息使用的伪随机函数 

199
00:14:35,073 --> 00:14:40,055
所以我们构建了一伪随机函数 也构建了一供更长消息使用的MAC

200
00:14:40,055 --> 00:14:45,052
该论文认为 如果AES不是伪随机函数我们该怎么办 即使如此

201
00:14:45,052 --> 00:14:50,064
AES依旧可以满足一些较弱的安全属性 称为不可预知功能

202
00:14:50,064 --> 00:14:55,026
之后该论文提出 AES是否是唯一可提供
不可预测功能的算法 这里AES不是伪随机函数


203
00:14:55,026 --> 00:15:00,003
我们能否依旧为长消息构建MAC 之后论文成功给出

204
00:15:00,003 --> 00:15:03,059
以AES是不可预测函数为基础的结构

205
00:15:03,059 --> 00:15:07,035
但这个结构远不足我们在本节中讨论过的

206
00:15:07,035 --> 00:15:11,016
CBC-MAC、NMAC、PMAC充分 所以如果你对

207
00:15:11,016 --> 00:15:15,027
如何以分组密码 如AES 来构建MAC的不同观点感兴趣

208
00:15:15,027 --> 00:15:18,098
那就请你看看这些论文 其中确实有一些与本领域相关的

209
00:15:18,098 --> 00:15:23,014
非常好的开放性问题 所以关于完整性的第一节内容就讲完了

210
00:15:23,014 --> 00:15:26,051
下节 我们讲讨论耐碰撞理论。【END】

