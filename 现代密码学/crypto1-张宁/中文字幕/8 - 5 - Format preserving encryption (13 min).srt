1
00:00:00,000 --> 00:00:03,752
在这一节，我想跟大家讨论另一种形式的加密 格式保护加密

2
00:00:03,752 --> 00:00:07,322
这也是一种在实际中经常见到的加密方式

3
00:00:07,322 --> 00:00:10,617
特别是用来对信用卡卡号进行加密

4
00:00:10,617 --> 00:00:14,244
因此 让我们来看看它是如何工作的 记住 典型的信用卡卡号一般是16位数字的

5
00:00:14,244 --> 00:00:18,978
以每4位为一组分成4组 大家以前可能听说过

6
00:00:18,978 --> 00:00:23,416
前6位被称为BIN码 代表了发行方的ID

7
00:00:23,416 --> 00:00:28,124
举个例子 所有的VISA信用卡通常都以数字4为开头

8
00:00:28,124 --> 00:00:34,114
而所有的MasterCard信用卡都以数字51到55为开头 等等

9
00:00:34,114 --> 00:00:38,808
接下来的9位是事实上就是每个消费者所持有的账户数字

10
00:00:38,808 --> 00:00:43,275
最后一位则是校验和

11
00:00:43,275 --> 00:00:48,031
是由前15位数字计算得到的这里有大约20000个BIN码

12
00:00:48,031 --> 00:00:52,846
所以如果你计算一下会发现大约有2的42次方可能的信用卡号

13
00:00:52,846 --> 00:00:56,733
相应的你需要编码42位信息

14
00:00:56,733 --> 00:01:01,489
如果你想准确的表示信用卡卡号

15
00:01:01,489 --> 00:01:05,999
现在的问题是 假设我们想加密信用卡卡号

16
00:01:05,999 --> 00:01:10,713
使用户在销售终端上刷卡时

17
00:01:10,713 --> 00:01:14,640
比如 在商家的现金登记处

18
00:01:14,640 --> 00:01:18,670
现金登记处是一种销售终端

19
00:01:18,670 --> 00:01:22,751
首先使用密钥k机密信用卡卡号 并始终保持加密

20
00:01:22,751 --> 00:01:27,036
直到银行 甚至是VISA要用的时候

21
00:01:27,036 --> 00:01:31,117
现在的问题是这些信用卡号 事实上经历了许多许多处理节点

22
00:01:31,117 --> 00:01:35,300
它们都希望获得某些基本的

23
00:01:35,300 --> 00:01:39,683
看起来像是信用卡号的信息作为结果

24
00:01:39,683 --> 00:01:43,893
所以如果我们只想在一个终端加密 在另一个终端解密

25
00:01:43,893 --> 00:01:48,087
这实际上并不那么容易 因为如果我们全部所做的仅仅是使用AES加密

26
00:01:48,087 --> 00:01:52,748
即使用的是确定的AES 加密输出后的信用卡号将会是128位的分组

27
00:01:52,748 --> 00:01:57,164
16字节一组 将会被从一个系统发送到下一个系统

28
00:01:57,164 --> 00:02:01,691
直到到达它的目的地

29
00:02:01,691 --> 00:02:06,107
但是这些处理节点每个都必须改变 因为它们都希望获得信用卡卡号

30
00:02:06,107 --> 00:02:10,192
所以问题是 我们能否在现金登记处加密

31
00:02:10,192 --> 00:02:14,388
使得加密结果本身看上去像一个信用卡卡号

32
00:02:14,388 --> 00:02:18,528
因此 这些中间系统都不用做出改变

33
00:02:18,528 --> 00:02:22,937
只有端点需要改变 通过这样做

34
00:02:22,937 --> 00:02:27,399
我们实际上将会获得端到端的加密 而不需要改变大量的沿途软件

35
00:02:27,399 --> 00:02:31,973
接下来的问题是 我们能否构造这种叫做格式保护加密的机制

36
00:02:31,973 --> 00:02:36,546
加密一个信用卡本身能产生某些类似于信用卡的信息

37
00:02:36,546 --> 00:02:40,881
这就是我们的目标

38
00:02:40,881 --> 00:02:44,719
被加密的信用卡卡号应该看起来像一个通常的有效信用卡卡号

39
00:02:44,719 --> 00:02:48,768
这就是格式保护加密的目标 现在我们试图做更抽象的

40
00:02:48,768 --> 00:02:54,055
在集合｛0，1，……，s-1｝上构建一个伪随机置换  其中s是任意的

41
00:02:54,055 --> 00:02:59,105
所以对于信用卡号的集合来说 s约等于2的42次方

42
00:02:59,105 --> 00:03:03,966
而不是严格的2的42次方

43
00:03:03,966 --> 00:03:08,415
它将会是一些接近于2的42次方的有趣的数

44
00:03:08,415 --> 00:03:14,326
我们的目标是建立一个从0到s-1区间上的PRF

45
00:03:14,326 --> 00:03:20,369
我们已有的输入是某些PRF 比如AES 它可以处理更大的分组

46
00:03:20,369 --> 00:03:24,384
比如16字节的分组 某种意义上 我们试图压缩PRF的定义域

47
00:03:24,384 --> 00:03:29,576
使它与我们已有的数据相吻合 现在的问题是怎么做

48
00:03:29,576 --> 00:03:33,639
一旦我们有这样一个机制 就可以很容易的使用它去加密信用卡卡号了

49
00:03:33,639 --> 00:03:37,610
我们将取给定的信用卡卡号

50
00:03:37,610 --> 00:03:41,937
对它加密 使得它能用0到信用卡卡号总数之间的一个数字来表示

51
00:03:41,937 --> 00:03:47,312
接下来我们应用我们的PRP

52
00:03:47,312 --> 00:03:51,815
来加密信用卡卡号 使用确定性加密一节里的2号机制

53
00:03:51,815 --> 00:03:56,428
然后我们把最终的数字映射为一个正常的值

54
00:03:56,428 --> 00:04:00,656
一个看起来正常的有效信用卡卡号

55
00:04:00,656 --> 00:04:05,083
然后沿途传送 这也是非扩展加密

56
00:04:05,083 --> 00:04:09,442
我们最多 像前面所讲过的 只能使用PRF加密

57
00:04:09,442 --> 00:04:14,145
然而这里技术上的挑战在于 我们需要一个PRF 作用于这个看上去特别有趣的

58
00:04:14,145 --> 00:04:19,811
从0到s-1的集合 这里s的值是预先给定的 所以我的目标是教给大家如何去建立这个机制

59
00:04:19,811 --> 00:04:23,379
一旦我们知道了如何做 大家就会知道如何去加密信用卡卡号

60
00:04:23,379 --> 00:04:27,738
使得密文本身也是信用卡卡号

61
00:04:27,738 --> 00:04:33,176
这个机制分为两步工作 我们做的第一步是将PRF的定义域

62
00:04:33,176 --> 00:04:38,552
集合｛0，1｝的n次方 例如AES的｛0，1｝的128次方

63
00:04:38,552 --> 00:04:43,965
压缩到｛0，1｝的t次方 这里的t是最接近以2为底值为s的对数的数

64
00:04:44,580 --> 00:04:50,035
所以说s是一个接近于2的41次方的很大的数 那么t就是42

65
00:04:50,035 --> 00:04:55,338
因为那是最接近以2为底值不小于s的对数的数

66
00:04:55,338 --> 00:04:59,396
它使用了Luby-Rackoff机制

67
00:04:59,396 --> 00:05:05,157
我们需要一个PRF F' 作用于一个长度为t/2的分组

68
00:05:05,157 --> 00:05:10,103
在信用卡这个例子中 t将会是42 因为我们说过2的42次方

69
00:05:10,301 --> 00:05:15,132
是最接近以2为底值不小于s的对数的数 s是所有信用卡号的总和

70
00:05:15,132 --> 00:05:20,387
现在我们需要一个PRF作用于21位的输入

71
00:05:20,387 --> 00:05:25,828
一种方法是取AES分组密码

72
00:05:25,828 --> 00:05:30,437
把它当成128位输入的PRF 然后截断输出

73
00:05:30,437 --> 00:05:35,238
并取低21位 好的 我们得到了一个21位的值

74
00:05:35,238 --> 00:05:40,359
我们在它的末尾添加0得到128位的结果 我们对它应用AES

75
00:05:40,359 --> 00:05:45,016
然后截断得到21位结果 现在我要告诉大家

76
00:05:45,016 --> 00:05:48,722
这是一个简单的方式 但实际上它并不是最好的方式

77
00:05:48,722 --> 00:05:54,181
事实上有更好的方法来截断n位PRF得到t位PRF

78
00:05:54,181 --> 00:05:58,454
但是对于我们本节的目标 我刚刚所讲的截断方法以及足够好了

79
00:05:58,626 --> 00:06:03,113
所以我们先继续使用这个特别地方法 好的 那么现在

80
00:06:03,113 --> 00:06:09,279
我们已经把AES分组密码转换成了一个t/2位的PRF 例如 21位

81
00:06:09,279 --> 00:06:14,108
但我们其实想要的是一个PRP 所以我们要做的是

82
00:06:14,108 --> 00:06:17,937
把我们的PRF直接带入Luby-Rackoff机制中 如果大家还记得

83
00:06:17,937 --> 00:06:22,489
这是一个Feistel机制 我们讨论DES时大家见过它

84
00:06:22,489 --> 00:06:27,009
Luby-Rackoff用了3轮的Feistel网络 我们知道这将一个安全的PRF

85
00:06:27,009 --> 00:06:31,961
转换为一个安全的两倍大小的PRP 换句话说 我们从一个21位的安全PRF开始

86
00:06:31,961 --> 00:06:36,973
Luby-Rackoff会给我们一个安全的42位的PRF

87
00:06:36,973 --> 00:06:41,424
这正是我们想要的 现在 我应该告诉你们Luby-Rackoff机制

88
00:06:41,424 --> 00:06:45,531
的错误参数不像应有的那么好 事实上

89
00:06:45,531 --> 00:06:49,689
更好的方法是使用7轮Feistel 换句话说 我们应该重复7遍

90
00:06:49,689 --> 00:06:54,782
每次都用不同的密钥 你应该注意到

91
00:06:54,782 --> 00:06:59,318
这里我们用了3个密钥 而我们应该用7种不同的密钥重复7遍

92
00:06:59,318 --> 00:07:03,839
这样才会有一个好的结果 paratin证明

93
00:07:03,839 --> 00:07:06,998
7轮的机制基本上有一个最好情况的错误项

94
00:07:06,998 --> 00:07:11,312
所以在这个安全理论中错误项基本上为2^t

95
00:07:11,312 --> 00:07:15,978
所以我们有在接近2^s个值上操作的一个伪随机置换

96
00:07:15,978 --> 00:07:21,529
但这还不够好 事实上 我们想要得到一个

97
00:07:21,529 --> 00:07:26,701
在0到s-1个值上的伪随机置换

98
00:07:26,701 --> 00:07:30,772
第二步 取{0，1}^t中的值 映射到 我们真正感兴趣的集合{0，1，……s-1}

99
00:07:30,772 --> 00:07:35,135
这个机制真的真的非常有趣 让我来展示

100
00:07:35,135 --> 00:07:39,073
它是怎么工作的 我们有PRP可以置换t位集合中的元素

101
00:07:39,073 --> 00:07:44,360
我们想让这个PRP可以在更小的集合上工作

102
00:07:44,360 --> 00:07:49,239
这是这个机制的工作方式 我们给定输入X X属于集合{0,1……s}

103
00:07:49,239 --> 00:07:53,149
我们要做的是

104
00:07:53,149 --> 00:07:57,436
重复迭代以下流程 首先 我们把Ｘ映射到临时变量Y

105
00:07:57,436 --> 00:08:02,477
现在我们只要加密输入Ｘ把结果赋给Ｙ

106
00:08:02,477 --> 00:08:07,213
如果Ｙ在我们的目标设定中　我们结束并输出Ｙ

107
00:08:07,213 --> 00:08:12,460
不然　我们就再一次次迭代直到

108
00:08:12,460 --> 00:08:16,696
最后Ｙ落在我们的目标集合内　然后我们输出值　让我在一张图

109
00:08:16,696 --> 00:08:22,513
中解释它是怎么工作的　我们从目标集合中的一点开始

110
00:08:22,513 --> 00:08:27,272
我们用函数Ｅ我们可能会把这个点映射到目标集合以外

111
00:08:27,272 --> 00:08:30,871
所以我们不停下来而是再用一次函数Ｅ　我们可能

112
00:08:30,871 --> 00:08:35,050
映射到这个点　我们再应用一遍函数Ｅ　突然间我们

113
00:08:35,050 --> 00:08:39,118
映射到了这个点　然后我们停下来　这就是我们的输出

114
00:08:39,118 --> 00:08:44,199
这就是我们在｛０,１……ｓ－１｝间映射点的方法

115
00:08:44,199 --> 00:08:48,490
很显然　这是可逆的

116
00:08:48,490 --> 00:08:52,466
逆向　我将解密然后按相反的方向前进

117
00:08:52,466 --> 00:08:56,342
我会解密　解密　再解密　直到最后　值落在设定的范围内

118
00:08:56,342 --> 00:09:00,419
这就给我了我想得到的点的逆

119
00:09:00,419 --> 00:09:04,625
这其实就是ＰＲＰ　问题是什么时候这是安全的ＰＲＰ

120
00:09:04,625 --> 00:09:08,738
我们马上来讨论这个问题　但在此之前　我要问大家

121
00:09:08,738 --> 00:09:13,317
你估计要使用多少次迭代　在问这个问题前我再提醒大家一次

122
00:09:13,317 --> 00:09:19,635
事实上　ｓ小于２＾ｔ大于２＾ｔ－１

123
00:09:19,635 --> 00:09:25,092
特别的ｓ比2^t的一半大 那么我的问题

124
00:09:25,092 --> 00:09:29,661
现在变成 我们平均需要多少次迭代 使过程收敛

125
00:09:32,907 --> 00:09:35,075
答案是我们需要2次迭代

126
00:09:35,075 --> 00:09:38,984
这是一个很小的常数迭代次数 所以这

127
00:09:38,984 --> 00:09:43,159
将给我们一个很有效的机制

128
00:09:43,159 --> 00:09:48,567
让我们从{0,1}^t降到{0,……s-1} 现在我们讨论安全性

129
00:09:48,567 --> 00:09:53,210
实际上是这步是紧凑的 换句话说 这没有多余的安全消耗

130
00:09:53,210 --> 00:09:59,250
从{0,1}^t降到{0,……s-1} 原因是

131
00:09:59,250 --> 00:10:02,734
这又是一个有趣的理论 我在这里不做证明

132
00:10:02,734 --> 00:10:07,621
或许我将把它留作给你们讨论的练习 也就是说

133
00:10:07,621 --> 00:10:11,921
你给我任意设定的Y和X Y包含在X内 应用

134
00:10:11,921 --> 00:10:16,520
我们刚看到的转换 从一个X到X的随机转换出发

135
00:10:16,520 --> 00:10:21,340
我们得到一个从Y到Y的随机转换 这意味着 如果我们用一个真正的

136
00:10:21,340 --> 00:10:25,578
X上的随机转换 你最后得到一个Y上真正的随机转换

137
00:10:25,578 --> 00:10:29,445
既然 我们开始时的转换不能与X上的随机转换区分

138
00:10:29,445 --> 00:10:33,366
我们得到一个不能与Y上置换区分的置换

139
00:10:33,366 --> 00:10:37,763
正如我所说 这是一个非常紧凑的置换

140
00:10:37,763 --> 00:10:42,001
第一步其实是寄出的 其分析和Luby-Rackoff的分析相同

141
00:10:42,001 --> 00:10:46,187
事实上 就我来说这更好用 Patarin分析用了7轮

142
00:10:46,187 --> 00:10:50,425
事实上这里有一些安全的消耗 但总的来说我们

143
00:10:50,425 --> 00:10:55,558
得到一个安全PRP机制 虽然安全参数不太好

144
00:10:55,558 --> 00:10:59,992
但这是我们能构造的较好的安全的

145
00:10:59,992 --> 00:11:04,644
在0到s-1范围内操作的PRP 这反过来会允许我们

146
00:11:04,644 --> 00:11:08,968
加密信用卡号使密文形式与信用卡号相同

147
00:11:08,968 --> 00:11:13,183
再一次强调这里没有完整性

148
00:11:13,183 --> 00:11:17,124
我们能确定的最好的结果是CPA安全

149
00:11:17,124 --> 00:11:21,251
没有密文完整性 没有任何随机性 这是这块的总结

150
00:11:21,251 --> 00:11:25,620
照例 我想指出一些你们可以看的阅读材料

151
00:11:25,620 --> 00:11:29,990
如果你们有兴趣学习更多关于任何我们在这一章讨论的

152
00:11:29,990 --> 00:11:34,255
首先 我们讨论密钥推导时 HKDF机制在2010年Hugo Krawczyk 的文章里有描述


153
00:11:34,255 --> 00:11:38,950
HKDF机制在2010年Hugo Krawczyk 的文章里有描述

154
00:11:38,950 --> 00:11:44,477
确定性加密 SIV模式在这片论文里有讨论

155
00:11:44,477 --> 00:11:49,628
我们讨论的EME模式 让我们可以构建一个更宽的分组伪随机置换

156
00:11:49,628 --> 00:11:54,402
在这篇论文里被Halevi和Rogaway讨论

157
00:11:54,402 --> 00:11:59,239
微调分组密码 引入了用于硬盘加密的XTS模式

158
00:11:59,239 --> 00:12:04,704
在这片论文里讨论了 最后 格式保护加密在

159
00:12:04,704 --> 00:12:09,718
我点到的最后这篇论文论文里有讨论 这就是本章总结

160
00:12:09,718 --> 00:12:13,831
在下一章 我们将开始讨论密钥转换。【END】

