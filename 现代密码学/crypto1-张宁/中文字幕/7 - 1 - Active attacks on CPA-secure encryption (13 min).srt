1
00:00:00,000 --> 00:00:03,410
现在我们已经讲完了信息完整性 接下来我们将要回过头来讨论加密

2
00:00:03,410 --> 00:00:07,092
我们将展示出如何构建一个加密机制

3
00:00:07,092 --> 00:00:10,916
使其提供比我们之前见到的加密方案更为强大的安全保障 但是首先让我们

4
00:00:10,916 --> 00:00:15,323
简要回顾一下目前的情况 在之前的课程单元中 我们已经讨论了保密性

5
00:00:15,323 --> 00:00:20,125
特别是如何加密信息 使之对选择明文攻击

6
00:00:20,125 --> 00:00:24,814
具有语义安全性 现在我一再提到

7
00:00:24,814 --> 00:00:28,938
对选择明文攻击的安全性 它仅提供了对抗窃听的安全性

8
00:00:28,938 --> 00:00:33,571
换句话说 这仅提供了对抗窃听网路攻击的安全性

9
00:00:33,571 --> 00:00:37,638
但实际上并不会改变任何数据包

10
00:00:37,638 --> 00:00:41,729
也不会加入新的数据包 在本章中 我们的目的是

11
00:00:41,729 --> 00:00:46,318
设计加密机制 使之面对篡改特定数据包和

12
00:00:46,318 --> 00:00:50,641
伪造数据包来干扰网络的攻击具有安全性

13
00:00:50,641 --> 00:00:55,322
我们也看到了当信息本身不私密的时候

14
00:00:55,322 --> 00:00:59,889
如何保证信息完整性 我们只想保证信息在传输过程中

15
00:00:59,889 --> 00:01:04,223
没有被修改 我们讨论了信息验证码

16
00:01:04,223 --> 00:01:08,616
MAC算法对选择消息攻击提供了不可伪造性

17
00:01:08,616 --> 00:01:13,067
换句话说 尽管攻击者可以获取

18
00:01:13,067 --> 00:01:17,926
他想要的任何MAC信息 他也不能构建MAC中的其他信息

19
00:01:17,926 --> 00:01:23,593
我们看过了许多MAC结构 比如 CBC MAC, HMAC以及并行MAC结构

20
00:01:23,593 --> 00:01:28,050
有一个快速MAC结构叫做Carter-Wegman MAC

21
00:01:28,050 --> 00:01:32,420
在这一章中 我们会展示如何将私密性和完整性机制结合起来

22
00:01:32,420 --> 00:01:36,679
以获得能够安全对抗更强大攻击的加密机制

23
00:01:36,679 --> 00:01:41,386
比如能够篡改网路中信息量

24
00:01:41,386 --> 00:01:45,644
加入自己的数据包 封锁特定数据包等等

25
00:01:45,644 --> 00:01:50,015
我们的目标是尽管面对如此强大的敌手

26
00:01:50,015 --> 00:01:54,274
仍能保证私密性 换句话说 攻击者无法获得明文内容

27
00:01:54,274 --> 00:01:58,759
也不能篡改密文内容使接收方

28
00:01:58,759 --> 00:02:03,518
对修改过的明文信以为真 在那之前我想

29
00:02:03,518 --> 00:02:08,387
给出几个能够干扰网络的攻击者的例子

30
00:02:08,387 --> 00:02:12,974
他们完全破坏了CPA安全加密的安全性 这说明

31
00:02:12,974 --> 00:02:17,789
事实上 尽管那种方法提供了完整性 私密性依然可以被破坏

32
00:02:17,789 --> 00:02:22,363
换句话说 如果我们需要面对主动攻击具有安全性的话

33
00:02:22,363 --> 00:02:27,238
完整性和私密性缺一不可 让我们看一个来自

34
00:02:27,238 --> 00:02:31,581
网络领域的例子 特别地 让我们看一下TCP/IP

35
00:02:31,581 --> 00:02:36,776
我将使用一个高度简化TCP/IP的模型 这样我们可以快速地定位攻击

36
00:02:36,776 --> 00:02:41,738
而不至陷入细枝末节中 我们有两台相互通信的机器

37
00:02:41,738 --> 00:02:45,995
一台机器被用户使用 另一台是服务器

38
00:02:45,995 --> 00:02:50,732
当然 服务器端有一个TCP/IP协议栈 能够接收数据包

39
00:02:50,732 --> 00:02:55,529
然后 根据那些数据包的目标地址域 它将这些包发往

40
00:02:55,529 --> 00:03:00,146
合适的地址 所以 比如说 在这我们有两个进程在监听

41
00:03:00,146 --> 00:03:04,523
这些数据包 一个叫做web服务器 在这 另一个是用户 我们叫他Bob

42
00:03:04,523 --> 00:03:09,260
在这 web服务器在80端口监听 然后在这  用户Bob

43
00:03:09,260 --> 00:03:13,972
在25端口监听 现在 当一个数据包到来时TCP/IP协议栈查看目标端口

44
00:03:13,972 --> 00:03:18,323
在这个例子里 数据包的目的地是80端口 因此协议栈

45
00:03:18,323 --> 00:03:22,972
将这个包发往web服务器 如果目标端口是25

46
00:03:22,972 --> 00:03:27,443
那么TCP/IP协议栈将会把这个包发给Bob 他正在

47
00:03:27,443 --> 00:03:32,469
25端口监听 有一个广为人知的安全协议叫做IPsec 它加密

48
00:03:32,469 --> 00:03:36,957
发送方和接收方之间的IP数据包 在这 发送方

49
00:03:36,957 --> 00:03:41,694
和接收方使用共享密钥 当发送方发送IP数据包时

50
00:03:41,694 --> 00:03:46,687
这些IP数据包被私密密钥K加密 当一个数据包到达

51
00:03:46,687 --> 00:03:51,344
目的地时 我是说它到达服务器 TCP/IP协议栈会

52
00:03:51,344 --> 00:03:55,832
解密这个包 并查看目标端然后将它送往

53
00:03:55,832 --> 00:04:00,153
解密后得到的正确地点 你会注意到这里的数据是被加密了的

54
00:04:00,153 --> 00:04:04,585
所以在这种情况下 它将会被送往web服务器 因为它的目标端口是80端口

55
00:04:04,585 --> 00:04:09,074
如果目标端口恰好是25端口 TCP/IP协议栈会解密数据包

56
00:04:09,074 --> 00:04:13,675
查看目标端口 然后将明文数据发送到

57
00:04:13,675 --> 00:04:18,536
正在监听25端口的进程 现在我想向你们展示的是 在这个建立过程中 如果没有完整性


58
00:04:18,536 --> 00:04:23,463
我们不可能获得任何形式的保密性 让我们来看看为什么

59
00:04:23,463 --> 00:04:28,574
假设有一个攻击者窃听了一个将要发往web服务器的特定数据包

60
00:04:28,574 --> 00:04:33,380
换句话说 就是一个将要发往80端口的加密数据包 

61
00:04:33,380 --> 00:04:38,003
记住攻击者实际上可以接收到任何发往25端口的解密数据包

62
00:04:38,003 --> 00:04:42,809
因为TCP栈会乐意为25端口解密数据包

63
00:04:42,809 --> 00:04:47,872
并把它们发往正在此处监听的Bob Bob作为一个攻击者将

64
00:04:47,872 --> 00:04:52,754
将要做的是 将截获网络上的这个数据包

65
00:04:52,754 --> 00:04:57,278
阻止它到达原本的目标服务器 并且他将会

66
00:04:57,278 --> 00:05:02,099
修改这个数据包 所以现在目标端口将会是25端口

67
00:05:02,099 --> 00:05:06,980
这会在密文上完成 我们稍后将看到如何很快的做到这件事

68
00:05:06,980 --> 00:05:11,504
当这个数据包现在到达服务器的时候 目标端口是25

69
00:05:11,504 --> 00:05:16,445
服务器会解密数据包 看到目标端口是25 然后将数据发给Bob

70
00:05:16,445 --> 00:05:21,261
所以现在Bob仅通过修改目标端口

71
00:05:21,261 --> 00:05:26,388
就能够读取原本不是发给他而是web服务器的数据

72
00:05:26,388 --> 00:05:31,619
如果数据是由带随机变量的CBC加密的话

73
00:05:31,619 --> 00:05:37,067
记住这是一个CPA安全机制  不过如果情况是这样的话

74
00:05:37,067 --> 00:05:41,861
我将向你们展示 攻击者能够很容易地修改密文

75
00:05:41,861 --> 00:05:46,889
然后获得目标端口是25而不是80的新密文

76
00:05:46,889 --> 00:05:51,054
他所做的只不过是改变变量的域 事实上 其他的一切

77
00:05:51,054 --> 00:05:55,725
都会保持原样 让我们看到这是如何做到底 记住

78
00:05:55,725 --> 00:06:00,870
事实上 攻击者截获的是一个CBC加密包

79
00:06:00,870 --> 00:06:05,020
他知道其目标端口是80端口 但是不知道数据是什么

80
00:06:05,020 --> 00:06:08,920
但是他知道这个数据包是要发往web服务器的

81
00:06:08,920 --> 00:06:13,020
他的目标是建立一个新的

82
00:06:13,020 --> 00:06:17,600
目标端口为25的加密包。所以他要做的就是

83
00:06:17,600 --> 00:06:22,547
改变自变量，正如我们之前所说 再让我提醒你一下 解密由CBC加密的数据的方法

84
00:06:22,547 --> 00:06:27,434
第一个明文分组实际就是第一个密文分组和

85
00:06:27,434 --> 00:06:32,143
自变量异或得来的。并且我们还知道原始数据包中

86
00:06:32,143 --> 00:06:36,732
读入的目标端口是80。因为在原始数据包中的目标端口是80。

87
00:06:36,732 --> 00:06:41,619
所以我给你的问题就是，攻击者是如何改变自变量才让

88
00:06:41,619 --> 00:06:46,925
读入的目标端口为25。显而易见，

89
00:06:46,925 --> 00:06:52,101
如果攻击者使用原始自变量，用这个来异或它，这里有

90
00:06:52,101 --> 00:06:57,086
大串的0,并且这里也有大串的0。他会用这些0来异或这个原始自变量，

91
00:06:57,086 --> 00:07:02,135
用这些0来异或80以及25。说的就是

92
00:07:02,135 --> 00:07:07,186
这些端口加密包中的字节。那这就很容易看出来什么时候

93
00:07:07,186 --> 00:07:11,948
这个新的自变量会随着原始密码文本被发送，什么时候攻击者会解密。

94
00:07:11,948 --> 00:07:17,076
你可以看到原始密码文本将会被解密到80端口，但是新的自变量

95
00:07:17,076 --> 00:07:22,082
将会取消80，取消了在原始文本中的80

96
00:07:22,082 --> 00:07:26,661
然后再和25异或。实际上，目标端口现在

97
00:07:26,661 --> 00:07:31,558
变成了25。这有一个简单的例子，通过简单的改变自变量的域，

98
00:07:31,558 --> 00:07:36,106
攻击者可以转移数据包，那么解密之后，

99
00:07:36,106 --> 00:07:40,182
数据包将会传送给攻击者，而不是真正的网络服务器。

100
00:07:40,182 --> 00:07:44,730
结果就是攻击者可以直接读取本应传递给服务器的明文数据。

101
00:07:44,730 --> 00:07:49,396
这个简单的例子显示如果不具备完整性，

102
00:07:49,396 --> 00:07:53,737
那么CPA安全加密所提供的机密性在攻击者可以修改

103
00:07:53,737 --> 00:07:58,378
线路中的数据包时，就只是一纸空文。CPA安全加密仅在

104
00:07:58,378 --> 00:08:03,079
攻击者只能窃听数据而不能修改线路中的数据的情况下

105
00:08:03,079 --> 00:08:07,445
才能保证安全性。好吧你可以看到，如果你也可以修改密文数据，

106
00:08:07,445 --> 00:08:11,573
只是一个很小的改动，就可以完全得到明文数据。

107
00:08:11,573 --> 00:08:16,065
我来向你们展示另一个只需要接入网络的干预型攻击。

108
00:08:16,065 --> 00:08:20,503
实际上，它不需要攻击者处于解密机器上。

109
00:08:20,503 --> 00:08:25,105
让我们来看这里的一个远程终端应用的例子。

110
00:08:25,105 --> 00:08:29,707
每一次使用者敲击键盘时，都会把敲击的数据发送给服务器，

111
00:08:29,707 --> 00:08:33,706
我们假设键盘输入是用反模式加密的。

112
00:08:33,706 --> 00:08:38,342
这里你有一个TCP/IP包，D这里对应键盘输入的一个字节。

113
00:08:38,342 --> 00:08:43,269
正如我们所说，它使用反模式来加密的。

114
00:08:43,269 --> 00:08:48,376
你们也许还记得，每一个TCP/IP包都包含一个校验码。

115
00:08:48,376 --> 00:08:52,943
这个16位的校验码用来检查传输错误。假如，

116
00:08:52,943 --> 00:08:57,630
这个服务器收到含有一个错误的校验码的包，服务器可能

117
00:08:57,630 --> 00:09:02,076
只是简单的丢弃它。现在这个键盘输入的TCP报文头里包含了这个校验码，

118
00:09:02,076 --> 00:09:06,206
并且所有都是反模式加密，现在攻击者先要得知键盘输入的是什么

119
00:09:06,206 --> 00:09:09,973
让我告诉你们他会怎么做。攻击者会截获这个数据包

120
00:09:09,973 --> 00:09:13,739
并不打算修改它，他要先把数据包发送到服务器。

121
00:09:13,739 --> 00:09:18,208
但是攻击者会先记录这个包。稍后，他就会修改包，然后

122
00:09:18,208 --> 00:09:23,486
把修改后的包再发送给服务器。他要做的就是要把

123
00:09:23,486 --> 00:09:28,205
加密的校验码空间与T进行异或，然后再用

124
00:09:28,205 --> 00:09:33,360
加密数据空间和S进行异或。他会用大量的T和S来做这项工作。

125
00:09:33,360 --> 00:09:38,390
记住，计数器加密的一个性质就是，如果你用解密后的T和密文进行异或

126
00:09:38,390 --> 00:09:43,538
结果就是明文也要和T异或

127
00:09:43,646 --> 00:09:49,020
同理，如果你用解密过的S和加密数据进行异或，

128
00:09:49,020 --> 00:09:54,753
得出的解密数据也被s加密

129
00:09:54,753 --> 00:09:59,456
现在，服务器要解密这个被修改的包，得出的包中的

130
00:09:59,456 --> 00:10:03,527
校验码要和T进行异或，数据要和S进行异或。

131
00:10:03,527 --> 00:10:07,817
那么如果被修改包中的校验码是正确的，服务器就会发出一份回复

132
00:10:07,817 --> 00:10:12,107
如果被修改包中的校验码是错误的，服务器就会

133
00:10:12,107 --> 00:10:16,374
丢掉这个包，然后什么也不做。所以，

134
00:10:16,374 --> 00:10:20,937
攻击者就只观察，看有没有回复的ACK包。这样他就

135
00:10:20,937 --> 00:10:25,499
可以得知，这个特殊的T异或和S异或对是否对应一个真正的校验码

136
00:10:25,499 --> 00:10:30,061
攻击者会使用大量的T和S来重复这样做。

137
00:10:30,061 --> 00:10:34,508
你会注意到，他用特殊值S异或数据来修改数据，

138
00:10:34,508 --> 00:10:38,897
用特殊值T异或校验码来修改校验码。

139
00:10:38,897 --> 00:10:43,401
并且他这样做用很多很多的T、S对。所以

140
00:10:43,401 --> 00:10:47,912
通过查找一系列这种形式的方程，你可以得到一个确定的校验码。

141
00:10:47,912 --> 00:10:52,122
这样就可以算出D的值是多少了。我想要说的是，

142
00:10:52,122 --> 00:10:55,818
通过这种办法算出的TCP的校验码可能是不正确的。但要算出正确的

143
00:10:55,818 --> 00:11:00,376
校验码还是很容易的。所以通过大量的这种类型的等式

144
00:11:00,376 --> 00:11:04,977
攻击者就可以发现D。这里有一个非常好的例子

145
00:11:04,977 --> 00:11:09,521
叫做选择密文攻击。攻击者通常从

146
00:11:09,521 --> 00:11:14,236
他想要破解的密文中选择提取一部分

147
00:11:14,236 --> 00:11:18,497
然后通过服务器的回应来得知

148
00:11:18,497 --> 00:11:23,041
可能的明文。然后用大量不同的T和S重复这一过程，

149
00:11:23,041 --> 00:11:27,699
他最终可以发现他想要的全部明文是什么。

150
00:11:27,699 --> 00:11:32,186
接下来的课程中，我们将看到更多这种攻击的例子。

151
00:11:32,186 --> 00:11:36,225
它们都叫做主动攻击，因为攻击者通常会修改通信量。

152
00:11:36,225 --> 00:11:40,707
我希望这两个例子可以使你们相信

153
00:11:40,707 --> 00:11:45,079
CPA的安全性只能应对窃听，但是面对主动攻击

154
00:11:45,079 --> 00:11:49,561
不能保证安全性。

155
00:11:49,561 --> 00:11:53,545
不仅仅是密文不具有完整性，就是说

156
00:11:53,545 --> 00:11:58,275
发送方发送的消息和接受方获得的不一致，而且这种密码甚至也不具有保密性。

157
00:11:58,275 --> 00:12:03,146
并且我也给你们展示了两个不具备完整性的例子，告诉你们

158
00:12:03,146 --> 00:12:08,198
攻击者可以使用收到的包来破解数据。

159
00:12:08,198 --> 00:12:12,611
所以，这部分我一而再再而三的强调的就是，

160
00:12:12,611 --> 00:12:16,526
如果你想要完整性而不管安全性，就用MAC

161
00:12:16,526 --> 00:12:20,508
但是如果你既需要完整性也需要安全性的话，

162
00:12:20,508 --> 00:12:24,950
你就需要使用认证加密机制，

163
00:12:24,950 --> 00:12:29,278
这恰好也是我们这个模块的主题。所以，我们接下来要做的

164
00:12:29,278 --> 00:12:33,888
就是定义认证加密的含义，而且我们将构建一个认证加密系统。

165
00:12:33,888 --> 00:12:38,442
但是我还想提醒下你们的就是CPA安全机制

166
00:12:38,442 --> 00:12:42,658
不应该只通过他们自己来加密数据。

167
00:12:42,658 --> 00:12:46,987
所以，带有一个随机自变量的CBC就是朝着认证加密靠进

168
00:12:46,987 --> 00:12:51,212
的一款分组密码。但是也不应该单独使用。好吧，我们将会在

169
00:12:51,212 --> 00:12:53,851
下一小节中解释认证加密。【END】

