1
00:00:00,000 --> 00:00:03,762
这一节我们来学习另一种明文攻击的方法

2
00:00:03,762 --> 00:00:08,105
这种方法比CBC(密码分组链接模式)更高级，叫随机计数器模式。

3
00:00:08,105 --> 00:00:13,474
与CBC不同，随机计数模式使用的是更安全的PRF(伪随机函数)

4
00:00:13,474 --> 00:00:18,022
它不使用分组密码，对于计数器模式而言，PRF对它来说已经足够。

5
00:00:18,022 --> 00:00:22,934
因为我们从不求这个函数F的逆。我们设F为一个安全的PRF，

6
00:00:22,934 --> 00:00:27,664
它定义在N字节的分组上，如果我们用AES的话，N会是128。

7
00:00:27,664 --> 00:00:32,758
而这种加密算法插入计数器模式是从选择随机数IV开始的

8
00:00:32,758 --> 00:00:37,670
而在使用AES的情况下它会是一个128字节的随机数IV

9
00:00:37,670 --> 00:00:44,002
然后我们开始计数，从这个随机数IV开始，
你会发现编码会从IV到IV+1，一直到IV+L

10
00:00:44,002 --> 00:00:49,489
这样就可以生成一个随机数表，然后让结果和明文信息相异或

11
00:00:49,489 --> 00:00:53,432
就获得了密文。而且，通常情况下，

12
00:00:53,432 --> 00:00:57,744
IV已经连同密文包含在内了

13
00:00:57,744 --> 00:01:02,082
事实上，这样生成的密文会比原明文长一些

14
00:01:02,267 --> 00:01:07,260
而这样的话，加密算法会给每条明文重新选择一个新的IV

15
00:01:07,260 --> 00:01:11,821
因此，即使我对同一个明文加密了两次，我也会得到两个不同的密文

16
00:01:11,821 --> 00:01:16,198
需要注意的是，这个模式是完全可并行的，不像CBC，CBC是串行的。

17
00:01:16,198 --> 00:01:20,863
换句话说，就是你不可能做到在没有加密#1到#4的情况下对#5进行加密

18
00:01:20,863 --> 00:01:26,183
所以，对于那些可能有很多并行AES引擎的硬件公司来说

19
00:01:26,183 --> 00:01:31,173
当在使用CBC的时候，是很难使用AES引擎的，因为CBC本身是串行的。

20
00:01:31,173 --> 00:01:36,227
所以，即使你可能有两个三个或四个AES引擎

21
00:01:36,227 --> 00:01:40,865
当你在用CBC加密的时候，你也只能使用其中一个引擎

22
00:01:40,865 --> 00:01:45,622
用计数器模式时，一切都是完全可并行的。

23
00:01:45,622 --> 00:01:50,557
如果你有三个AES加密引擎，工作速度会快上三倍，这就是计数器模型的优点

24
00:01:50,557 --> 00:01:54,720
计数器模式还有一种叫做新鲜值(corresponding nonce)的计数器模式

25
00:01:54,720 --> 00:01:59,306
在这个区域里IV并不是一个真正的随机数，而是一个新鲜值

26
00:01:59,306 --> 00:02:03,716
要实现基于新鲜值的计数器模式

27
00:02:03,716 --> 00:02:08,830
也就相当于是在AES中获得一个128位分组，然后你可以把它分成两部分

28
00:02:08,830 --> 00:02:14,202
使用左边64位作为新鲜值，这样计数器的范围就是

29
00:02:14,202 --> 00:02:19,501
从0到2的64次方，这就是新鲜值部分

30
00:02:19,501 --> 00:02:24,341
而一旦你指定了新鲜值，低64位用于

31
00:02:24,341 --> 00:02:28,931
计数器模型加密过程内计数，然后新鲜值会停留在左边

32
00:02:28,931 --> 00:02:33,580
而计数器会在右边，倘若新鲜值是不可预知的话

33
00:02:33,580 --> 00:02:38,002
那这就已经是非常好的状态了，此时唯一可能限制的情况是

34
00:02:38,002 --> 00:02:42,708
你最多可以加密2的64次方个分组，使用一个新鲜值

35
00:02:42,708 --> 00:02:47,073
这个危险情况就是你此时不想将计数器重置为0，如果那样的话你会有两个分组

36
00:02:47,073 --> 00:02:51,495
这个和这个，而这个分组会被同一个一次一密加密。

37
00:02:51,495 --> 00:02:55,623
命名为这个和这个。现在让我们来简要的陈述一下随机计数器模型的安全定理

38
00:02:55,623 --> 00:02:59,425
到现在你们应该能熟练运用各种定理了才对

39
00:02:59,425 --> 00:03:03,790
基本上，只要我们有一个安全的PRF，那么我们仅需要做的就只有做出一个加密方案

40
00:03:03,790 --> 00:03:08,458
我们称之为E_CTR，CTR是计数器模式的意思。它在选择明文攻击下是语义安全的

41
00:03:08,458 --> 00:03:12,830
它加密L个分组长的明文信息，

42
00:03:12,830 --> 00:03:17,557
产生L+1个分组的密文，因为IV总是包含在密文当中的

43
00:03:17,557 --> 00:03:22,245
这是对于随机计数模式的，这是误差范围

44
00:03:22,245 --> 00:03:26,674
基本上和CBC的误差范围一样

45
00:03:26,674 --> 00:03:31,342
通常情况下，我们会把这个情况忽略不计

46
00:03:31,342 --> 00:03:36,250
因为PRF F是很安全的，我们可以推出这一项是可以忽略的

47
00:03:36,250 --> 00:03:41,098
因为E_CTR也是很安全的。不幸的是我们有这里的误差项

48
00:03:41,098 --> 00:03:45,946
所以我们不得不确保这个误差项是可忽略的。
而且我们要确保Q的L次方小于分组大小

49
00:03:45,946 --> 00:03:50,374
而且要记得，Q是使用一个秘钥加密的明文数

50
00:03:50,374 --> 00:03:55,467
而L是这些明文里的最大长度

51
00:03:55,467 --> 00:04:00,740
有趣的是，在CBC下，我们有Q的L的次方，不得不小于x。

52
00:04:00,740 --> 00:04:04,557
而我们的计数器模式要好一些

53
00:04:04,557 --> 00:04:08,728
换句话说，计数器模式实际上可以比CBC加密更多的分组，让我们来看个简单的例子

54
00:04:08,728 --> 00:04:13,545
这里是计数器模式的误差项

55
00:04:13,545 --> 00:04:18,177
记住Q是用同一秘钥加密的明文数，L是明文数分组

56
00:04:18,177 --> 00:04:23,056
和之前一样，设想我们希望

57
00:04:23,056 --> 00:04:28,059
攻击者的优势最多为1除以2的32次方

58
00:04:28,059 --> 00:04:33,000
要求Q^2*L除以|X|小于1除以2的32次方

59
00:04:33,000 --> 00:04:37,783
所以对于AES来说，如果带入|X|=2^128，128比特的分组。

60
00:04:37,783 --> 00:04:42,187
那么Q乘以L的平方根应当小于2的48次方

61
00:04:42,187 --> 00:04:46,485
这是带入2的128次方后得到的误差上界

62
00:04:46,485 --> 00:04:51,123
结果是，你能看见，如果加密的每条明文都是2的32次方个分组

63
00:04:51,123 --> 00:04:55,435
那么之后，你就不得不更改你的的秘钥

64
00:04:55,435 --> 00:05:00,424
否则随机计数模式不再是CPA安全的了。也就是说

65
00:05:00,424 --> 00:05:05,413
我们可以使用一个秘钥对所有从2的64次方个AES分组进行加密

66
00:05:05,413 --> 00:05:10,402
对于CBC来说，这个相关的变量可以是2的48次方个分组的，所以事实上

67
00:05:10,402 --> 00:05:15,453
因为计数器模式有一个更好的安全参数

68
00:05:15,453 --> 00:05:19,860
所以相比较CBC，我们可以用一个秘钥对计数模型进行更多分组的加密

69
00:05:19,860 --> 00:05:24,378
所以我想对计数模型和CBC做一个简单的比较。对于每一个方面来说

70
00:05:24,378 --> 00:05:28,338
计数器模式要比CBC高级。这也就是为什么现代的加密方案

71
00:05:28,338 --> 00:05:32,800
都开始转向计数器模式，而远离了CBC

72
00:05:32,800 --> 00:05:37,030
即使CBC依然广为应用。我们来比较一下

73
00:05:37,030 --> 00:05:41,250
首先，记得CBC必须使用分组密码。因为

74
00:05:41,250 --> 00:05:45,522
如果你观察译码回路，你会发现它是反向运行分组密码

75
00:05:45,522 --> 00:05:49,537
实际上它是使用了分组密码的解密功能

76
00:05:49,537 --> 00:05:53,243
而在计数器模式中，我们只需要使用一个PRF，我们永远都不会用分组密码的解密功能

77
00:05:53,243 --> 00:05:57,257
我们只使用正向加密功能

78
00:05:57,257 --> 00:06:01,478
因为这，计数器模式用的更为普遍

79
00:06:01,478 --> 00:06:05,390
你可以使用Salsa，比如Salsa20，你应该记得这是个PRF

80
00:06:05,390 --> 00:06:09,688
而不是PRP。所以计数模型可以用Salsa而CBC不行

81
00:06:09,688 --> 00:06:14,045
本质上，计数模型要比CBC更为一般化，就像我们刚说的

82
00:06:14,045 --> 00:06:18,991
他们是可并行的，CBC是一个非常串行化的过程。
所以我们说计数器模式更为安全

83
00:06:18,991 --> 00:06:23,467
计数器模式的安全上界和误差项比CBC好

84
00:06:23,467 --> 00:06:28,001
结果就是，你使用同一个秘钥进行加密的数目要比CBC多

85
00:06:28,001 --> 00:06:32,829
还有一件事就是，记得我们讨论过假的补齐分组。

86
00:06:32,829 --> 00:06:37,657
如果有一个明文信息，它的长度是分组长度的倍数的话

87
00:06:37,657 --> 00:06:42,993
在CBC里，我们必须要给它加上一个假的补齐分组，而在计数器模式里则不需要

88
00:06:42,993 --> 00:06:47,403
尽管我曾经想提到，有一个CBC变种叫做CBC密文偷窃，

89
00:06:47,403 --> 00:06:51,782
可以用来避免产生假的分组

90
00:06:51,782 --> 00:06:55,739
所以，对于标准的CBC来说，它是需要一个假的分组的

91
00:06:55,739 --> 00:06:59,854
但实际上确实有这么一种情况导致CBC的修改不需要假的分组，就像计数器模式一样

92
00:06:59,854 --> 00:07:04,021
最后，我们假设一下，你正在加密一个字节的信息流，

93
00:07:04,021 --> 00:07:08,136
使用隐藏的新鲜值进行新鲜值加密，因此新鲜值不包含在密文里

94
00:07:08,136 --> 00:07:12,723
这样说的话，每一个字节的信息都必须都必须被扩展成16字节的分组

95
00:07:12,723 --> 00:07:17,511
然后才能进行加密，结果就会生成一个16字节分组

96
00:07:17,511 --> 00:07:22,121
那再假设一下，如果你有100个一字节的信息流组成的流

97
00:07:22,121 --> 00:07:26,850
就需要单独将他们扩展为16字节的分组，然后，你就会累成狗了

98
00:07:26,850 --> 00:07:31,916
你最终得到的是一连串16字节的密文流，密文长度扩展16倍

99
00:07:31,916 --> 00:07:36,556
再与明文的长度比一下，就很清楚了

100
00:07:36,556 --> 00:07:41,257
而在计数器模式中，就不会存在这种问题，你可以加密一字节信息

101
00:07:41,257 --> 00:07:46,253
通过与计数器模式产生的流的第一个字节异或

102
00:07:46,253 --> 00:07:50,868
这样产生的密文都是1比特的，就像明文一样

103
00:07:50,868 --> 00:07:55,657
在计数器模式下，根本不会出现扩展。这也就在本质上说明了

104
00:07:55,657 --> 00:08:00,100
计数模型在各个方面都要优于CBC，以及为什么它能这么受欢迎

105
00:08:00,100 --> 00:08:05,179
以至于沿用至今。这也就结束了我们对选择明文攻击安全的讨论

106
00:08:05,179 --> 00:08:09,465
我们来简单的做个概述

107
00:08:09,465 --> 00:08:14,329
还有，我们接下来将会讨论如何运用PRP和PRF来进行实际操作

108
00:08:14,329 --> 00:08:18,673
这确实是使用分组密码的正确方式

109
00:08:18,673 --> 00:08:22,900
我们通常将他们视为双向伪随机置换或者伪随机置换函数

110
00:08:22,900 --> 00:08:27,192
我要再提醒一下，迄今为止，有两种安全思维模式

111
00:08:27,192 --> 00:08:31,163
这两者都是只针对窃听攻击提供的安全性。

112
00:08:31,163 --> 00:08:35,392
但是他们不能抵御密文干涉

113
00:08:35,392 --> 00:08:39,414
一个只用于加密单个密文，另一个只能用于

114
00:08:39,414 --> 00:08:43,539
秘钥被用来加密多个明文信息时，如我们所说，因为两个安全都不是

115
00:08:43,539 --> 00:08:47,588
为密文篡改而设计的，都不提供数据完整性保护，

116
00:08:47,588 --> 00:08:51,689
我们知道这确实是个真实且存在的问题，实际上，

117
00:08:51,689 --> 00:08:55,686
我想说在下节你会看到，这些模型其实永远都不会被用到

118
00:08:55,686 --> 00:08:59,998
而你需要做的就是使这些模型外加上完善机制，这也是我们下节课的话题

119
00:08:59,998 --> 00:09:03,731
迄今为止，如果你只需要使用一次秘钥

120
00:09:03,731 --> 00:09:07,714
那么使用流密码或者确定的计数器模式

121
00:09:07,714 --> 00:09:12,397
而如果你想使用同一秘钥多次的话，就需要使用随机化的CBC或者随机计数器模式

122
00:09:12,397 --> 00:09:16,918
我们将会讨论如何提供完整性和私密性

123
00:09:16,918 --> 00:09:20,013
而这是我们下章将要学习到的知识。【END】

