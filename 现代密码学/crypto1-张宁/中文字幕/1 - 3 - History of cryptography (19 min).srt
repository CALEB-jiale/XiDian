1
00:00:00,000 --> 00:00:04,194
在我开始讲技术内容之前，
我想讲一点密码学的历史

2
00:00:04,194 --> 00:00:09,012
关于密码学的历史，
David Kahn写了一本很棒的书

3
00:00:09,012 --> 00:00:13,490
叫《The Codebreakers》,
它完整的概括了密码学的历史

4
00:00:13,490 --> 00:00:17,742
从古巴比伦时代到现在，
我将给大家介绍

5
00:00:17,742 --> 00:00:22,146
一些历史上已经被完全破解的密码方案的例子

6
00:00:22,146 --> 00:00:26,830
谈论到密码，首先又要
介绍我们的朋友Alice和Bob

7
00:00:26,830 --> 00:00:31,243
他们将伴随我们所有余下的课程,
Alice与Bob试图安全的通信

8
00:00:31,243 --> 00:00:35,657
但有一个攻击者试图窃听他们的对话

9
00:00:35,657 --> 00:00:39,908
因此为了安全通信，
他们将分享一个密钥

10
00:00:39,908 --> 00:00:44,544
我将它记为k,
他们两个都知道这个密钥

11
00:00:44,544 --> 00:00:49,665
但攻击者不知道。
现在他们将使用加密方案

12
00:00:49,665 --> 00:00:53,749
其实是一对算法，
加密算法记为E

13
00:00:53,749 --> 00:00:58,870
解密算法记为D，
这些算法工作如下：

14
00:00:58,870 --> 00:01:03,930
加密算法E需要信息原文m
和密钥k作为输入

15
00:01:03,930 --> 00:01:08,807
我在k上面画一个楔形标记
是为了强调这个输入是密钥

16
00:01:08,807 --> 00:01:14,670
然后它输出加密文本，
即信息m通过k密钥算出的密文

17
00:01:14,670 --> 00:01:20,319
我总是将密钥写在前面。现在，

18
00:01:20,319 --> 00:01:24,486
当我写：= 
意味这个表达式是定义c，变量c代表什么

19
00:01:24,486 --> 00:01:29,437
现在密文通过网络传输给Bob

20
00:01:29,437 --> 00:01:34,231
事实上它可以是网络传输，也可以是

21
00:01:34,407 --> 00:01:39,156
使用加密文件系统传输，
这都没有多大关系。

22
00:01:39,156 --> 00:01:43,402
但是当密文发给Bob，
他可以把它放到解密算法中

23
00:01:43,402 --> 00:01:47,985
并给解密算法一个一样的密钥k，
我也做一个楔形标记

24
00:01:47,985 --> 00:01:53,191
来强调输入为密钥k，解密算法输出原始明文

25
00:01:53,191 --> 00:01:58,149
现在我想说明这里是对称加密，
即加密与解密

26
00:01:58,149 --> 00:02:03,169
事实上用的是同一个密钥k。
我们后面将看到

27
00:02:03,169 --> 00:02:08,312
有些加密中加密算法E使用一个密钥

27
00:02:08,312 --> 00:02:13,394
而解密算法D使用不同的密钥，
但在这里我们只关注对称密码

28
00:02:13,394 --> 00:02:18,280
它们使用的是同一个密钥，
接下来让你们看看一些历史上加密的例子

29
00:02:18,280 --> 00:02:23,159
第一个例子，也是最简单的，
被称作置换加密

30
00:02:23,159 --> 00:02:27,977
我确信你们在幼儿园就玩过置换加密

31
00:02:28,162 --> 00:02:33,165
根本来说，置换加密的密钥就是置换表

32
00:02:33,165 --> 00:02:38,230
最基本的来说就是如何置换值字母，
因此对于这个例子，A将被映射C

33
00:02:38,230 --> 00:02:43,232
B将被映射W，C将被映射N，
一直这样下去

34
00:02:43,232 --> 00:02:48,499
然后一直到Z被映射为A，
这就是一个单钥置换加密的例子

35
00:02:48,499 --> 00:02:54,922
为了练习我们之前介绍的标记

36
00:02:54,922 --> 00:03:00,775
加密一部分信息使用这个密钥，
假设就是

37
00:03:00,775 --> 00:03:07,197
信息BCZA，这个信息就是使用这个密钥加密

38
00:03:07,197 --> 00:03:13,782
一次转换一个字母，
B--W, C--N, Z--A, A--C

39
00:03:13,782 --> 00:03:20,530
因此BCZA就是对WNAC的加密，
这就是的密文

40
00:03:20,530 --> 00:03:25,654
同理的我们可以用这个密钥解密密文

41
00:03:25,654 --> 00:03:31,073
我们将得到它原始的信息

42
00:03:31,073 --> 00:03:35,763
因为历史原因，
这个有关置换密码的例子被叫做凯撒密码

43
00:03:35,763 --> 00:03:39,950
事实上凯撒密码根本不是真正的密码

44
00:03:39,950 --> 00:03:44,417
原因就是它不存在密钥

45
00:03:44,417 --> 00:03:48,772
凯撒密码根本上是一个固定的置换表

46
00:03:48,772 --> 00:03:56,796
也就是说它相当于一个变换，
就像A--D, B--E, C--F等等

47
00:03:56,796 --> 00:04:05,197
那它是什么呢，Y变成B，Z变成C，
它是一个应用于所有明文信息的固定置换

48
00:04:05,197 --> 00:04:10,931
重申一下，这不是加密，因为它没有密钥

49
00:04:10,931 --> 00:04:15,734
或者说密钥是固定的，
如果攻击者知道加密原理

50
00:04:15,734 --> 00:04:20,597
他可以很轻松的破解信息，
这个密钥不是随机的

51
00:04:20,597 --> 00:04:25,233
因此一旦知道工作原理破解是很容易的

52
00:04:25,233 --> 00:04:29,941
现在让我们回到置换加密，这种加密中密钥选择是随机的

53
00:04:29,941 --> 00:04:34,132
置换表选择也是随机的，
让我们看看如何打破这种置换密码

54
00:04:34,132 --> 00:04:38,724
其实这很简单。第一个问题是，

55
00:04:38,724 --> 00:04:43,030
密钥空间有多大，这里有多少种不同的密钥，
总共有26个英文字母

56
00:04:43,030 --> 00:04:48,367
因此我想你们会说密钥的数量是26的阶乘

57
00:04:48,367 --> 00:04:53,874
因为一个密钥，一个置换密钥，
就是26的排列组合

58
00:04:53,874 --> 00:05:00,115
26的排列组合就是26!

59
00:05:00,115 --> 00:05:05,769
26!大约是2^88

60
00:05:05,769 --> 00:05:11,422
这意味着描述置换加密的密钥需要花费88比特

61
00:05:11,422 --> 00:05:17,325
每种密钥被88比特表示，
这作为密码空间大小非常合适

62
00:05:17,325 --> 00:05:22,076
事实上我们将看到这一大小的
加密是非常安全。或许，你知道，

63
00:05:22,076 --> 00:05:26,710
（一般的密码算法）大致有这个大小的密码空间
是足够安全的，然而，即使

64
00:05:26,710 --> 00:05:31,461
置换密码的空间是2^88，它仍然

65
00:05:31,461 --> 00:05:36,330
非常不安全，让我们看看如何破解它。
破解它，我们

66
00:05:36,330 --> 00:05:40,523
将使用分析字母使用频率的方法，
那么第一个问题是

67
00:05:40,696 --> 00:05:45,099
英文中最常用的字母是什么呢，
我猜你们都知道

68
00:05:45,099 --> 00:05:49,617
E就是最常用的字母，
如果我们进行定量研究

69
00:05:49,617 --> 00:05:54,194
这将帮助我们破解置换加密，
从而仅已知密文

70
00:05:54,194 --> 00:05:59,012
我们就可以得到明文，
我们的方法是，首先

71
00:05:59,012 --> 00:06:04,094
利用英文字母的使用频率，
看这个怎么操作。

72
00:06:04,094 --> 00:06:09,737
那么你给我一个使用置换加密的密文，
我只知道原文使用的是英文，

73
00:06:09,737 --> 00:06:15,227
但我还知道E是最常用的字母

74
00:06:15,227 --> 00:06:19,846
事实上，在标准英语文章中
它出现的概率是12.7%

75
00:06:19,846 --> 00:06:25,202
所以我要做的就是观察你给我的密文，
我将

76
00:06:25,202 --> 00:06:30,692
统计出每个字母出现的次数，那么

77
00:06:30,692 --> 00:06:35,771
密文中出现最频繁的字母用很大可能就是字母E

78
00:06:35,771 --> 00:06:41,187
现在我们得到求解密钥表一个入口，基本上

79
00:06:41,187 --> 00:06:46,855
在这些字母中我已经知道了E所对应的，
第二常用的字母是T

80
00:06:46,855 --> 00:06:52,068
它占9.1%的概率，重复上面过程

81
00:06:52,068 --> 00:06:56,526
计算密文中每个字母出现次数

82
00:06:56,526 --> 00:07:01,269
那么密文中第二常用的很可能就是T了

83
00:07:01,269 --> 00:07:05,784
这样我们就找到了第二个入口，
然后继续这种方法

84
00:07:05,784 --> 00:07:09,841
接下来是字母A，出现概率8.1%

85
00:07:09,841 --> 00:07:14,642
我们就可以肯定密文中
第三常用对应的是A

86
00:07:14,642 --> 00:07:19,157
我们已经得到了密钥表中的三个入口

87
00:07:19,157 --> 00:07:23,543
现在我们要做什么呢，余下的字母在英语中出现次数很相近

88
00:07:23,543 --> 00:07:27,997
其他的几乎不出现像Q和X，
我们好像困在这一步了

89
00:07:27,997 --> 00:07:32,963
我们找到了密钥表中的三个入口，
接下来怎么办呢

90
00:07:32,963 --> 00:07:38,619
接下来我们使用成对字母的频率，
我们也称它们

91
00:07:38,619 --> 00:07:44,647
二连字，接下来我们需要数出
密文中连字出现的次数

92
00:07:44,647 --> 00:07:50,527
当然我知道这是英文写的，
最常用的成对字母

93
00:07:50,527 --> 00:07:55,973
有he，an，in，
th也是非常常用的字母对

94
00:07:55,973 --> 00:08:02,240
这样我们知道密文中最频繁的连字

95
00:08:02,240 --> 00:08:08,134
就是这四对中的一个，通过试验，

96
00:08:08,134 --> 00:08:13,257
我们可以找到找到密钥表的更多入口元素，
按照这种方法重复

97
00:08:13,257 --> 00:08:18,195
试验探错，我就可以得到整个的密钥表

98
00:08:18,195 --> 00:08:23,256
因此，置换密码是十分容易受到攻击的

99
00:08:23,256 --> 00:08:28,441
并且这可能是最差的加密方法

100
00:08:28,441 --> 00:08:33,440
只要已知密文，就能破解出解密密钥

101
00:08:33,440 --> 00:08:37,798
从而恢复出明文，因此，加密时使用置换加密

102
00:08:37,798 --> 00:08:41,949
是没有意义的，因为攻击者可以轻松

103
00:08:41,949 --> 00:08:46,100
地破译，这样如同清楚地发送明文效果一样。

104
00:08:46,100 --> 00:08:50,471
接下来我们将快进到文艺复兴时期

105
00:08:50,471 --> 00:08:55,073
也就是说，我们从罗马时代
跳到了文艺复兴时期，

106
00:08:55,073 --> 00:08:59,042
来看一个叫Vigener(维吉尼亚)
的哥们设计的密码，他生活在16世纪

107
00:08:59,042 --> 00:09:03,529
他设计了一系列密码，
现在我将展示其中一种的变体

108
00:09:03,529 --> 00:09:07,153
它也被称作Vigener加密，
在Vigener密码中，密钥是一个单词

109
00:09:07,153 --> 00:09:11,870
这一例子中这个单词是CRYPTO，
它由六个字母构成

110
00:09:11,870 --> 00:09:16,272
然后为了加密信息，
你要做的就是根据密钥重写信息

111
00:09:16,272 --> 00:09:22,041
如果消息是“WHAT A NICE DAY TODAY”，
按照需要重复地使用密钥来

112
00:09:22,041 --> 00:09:28,375
掩盖信息。这种加密就是基本上就是

113
00:09:28,375 --> 00:09:34,514
将密钥字母(的位序)加上
原文字母(的位序)然后模26。
这里给个例子说明一下

114
00:09:34,514 --> 00:09:41,125
比如，Y(25)加到A(1)就得到Z(26)

115
00:09:41,125 --> 00:09:47,263
T(20)加A(1)得到U(21)

116
00:09:47,263 --> 00:09:52,541
对所有的字母都这样

117
00:09:52,541 --> 00:09:56,159
记住加的时候一定要模26，
这样超过Z就会回到A

118
00:09:56,159 --> 00:10:00,512
这就是Vigener加密，
事实上解密和加密一样简单

119
00:10:00,512 --> 00:10:05,260
解密的方法就是在密钥下写出密文

120
00:10:05,260 --> 00:10:10,125
重复使用密钥，
密文减去密钥就可以得到原文

121
00:10:10,125 --> 00:10:15,112
因此破译Vigener加密是相当容易的。让我们看看怎么做

122
00:10:15,112 --> 00:10:20,038
首先我们假设知道密钥的长度

123
00:10:20,038 --> 00:10:24,842
假设这种情况下密钥长度是六个

124
00:10:24,842 --> 00:10:29,890
接下来我们就把明文6个6个分组

125
00:10:29,890 --> 00:10:35,789
我们得到一串串这样的组。
每一组都由六个字母组成

126
00:10:35,789 --> 00:10:41,698
然后看一看每一组的第一个字母

127
00:10:41,698 --> 00:10:47,680
是的，每六个字符的第一个字母

128
00:10:47,680 --> 00:10:53,514
关于这三个字母我们知道什么呢

129
00:10:53,514 --> 00:10:59,496
事实上，他们加密使用的是一样的字母

130
00:10:59,496 --> 00:11:09,170
都使用字母C(3)加密, Z(26)L(12) W(23)就是三个明文字母的转换

131
00:11:09,170 --> 00:11:14,782
如果我们收集了所有的第一个字母，
最常用的很可能是E(5)的加密

132
00:11:14,782 --> 00:11:20,394
E(5)是最常用的英文字母

133
00:11:20,394 --> 00:11:26,154
因此如果我们每寻找六个字母

134
00:11:26,154 --> 00:11:32,209
最常用的的就是字母E(5)的加密，
那么我们假设事实上

135
00:11:32,209 --> 00:11:38,009
最频繁的字母恰好还是H(8)

136
00:11:38,009 --> 00:11:43,624
就推出E(5)加密钥的第一个字母得到H(8)

137
00:11:43,624 --> 00:11:48,828
也就是说密钥第一个字母
等于H(8)减E(5)，就是C(3)

137
00:11:48,828 --> 00:11:54,275
这样我们得出了密钥的第一个字母，对第二个字母重复以上过程

138
00:11:54,275 --> 00:11:59,238
那么，我们看一下每六个字符中的第二个字母

139
00:11:59,238 --> 00:12:04,141
重复试验，找到密文中最常用的
和我们已知最常用的

140
00:12:04,141 --> 00:12:09,044
这个常用字母就是E的加密

141
00:12:09,044 --> 00:12:13,463
不管这个字母是什么

142
00:12:13,463 --> 00:12:18,666
减去E就可以得到密钥中的第二个字母

143
00:12:18,666 --> 00:12:23,418
重复这个过程，
我们就可以得到密码中的第三个字母

144
00:12:23,418 --> 00:12:27,900
这样依次就可以得到整个字母表，
就可以破译信息了

145
00:12:27,900 --> 00:12:32,496
唯一需要说明的是我们必须提前知道密钥的长度

146
00:12:32,496 --> 00:12:37,035
上面我们假设是6

147
00:12:37,035 --> 00:12:41,461
但如果我们不知道长度，那也不是问题

148
00:12:41,461 --> 00:12:45,629
我们要做的就是运行破译步骤，
假设是1，再假设是2

149
00:12:45,629 --> 00:12:49,423
再假设长度是3，依次下去

150
00:12:49,423 --> 00:12:53,319
直到我们最后能得到信息，
我们就得到有意义的破解

151
00:12:53,319 --> 00:12:57,771
那的确有意义，
一旦我们知道密钥的正确长度

152
00:12:57,771 --> 00:13:02,141
我们就可以得到正确的密钥

153
00:13:02,141 --> 00:13:06,348
然后就得到正确的信息，懂了吗

154
00:13:06,348 --> 00:13:10,571
非常快，你就可以破解Vigener加密，
这就是唯密文攻击

155
00:13:10,571 --> 00:13:14,954
这一例子中有趣的是
Vigener的确想到了很好的主意，模26

156
00:13:14,954 --> 00:13:19,123
的确是个好主意，以后我们会看到。
尽管在这里它被使用得非常糟糕

157
00:13:19,123 --> 00:13:23,307
这是我们将改正的一点，稍晚一点

158
00:13:23,307 --> 00:13:27,908
好吧，我们将从文艺复兴时期快进到19世纪

159
00:13:27,908 --> 00:13:32,738
这个时代很多东西开始用电，因此人们想设计使用电驱动的密码

160
00:13:32,738 --> 00:13:37,396
这些加密被称作转子机，因为他们使用转子

161
00:13:37,396 --> 00:13:42,111
一个较早的例子就是使用一个转子的Hibber机

162
00:13:42,111 --> 00:13:46,654
这里给你们一幅图片，这就是转子，我猜它在

163
00:13:46,654 --> 00:13:51,941
这儿，密钥被这里的磁盘捕获，
它被嵌入到磁盘的里面

164
00:13:51,941 --> 00:13:56,524
你每在键盘输入一个密钥
它就旋转一个刻痕

165
00:13:56,524 --> 00:14:01,687
所以你每敲一个键，盘转过一格

166
00:14:01,687 --> 00:14:06,722
那这个密钥怎么工作呢，
密钥实际上编码一个置换表

167
00:14:06,722 --> 00:14:11,950
因此，这个磁盘就是密钥

168
00:14:11,950 --> 00:14:17,049
正如我所说的，磁盘编码置换表，在这种情况下

169
00:14:17,049 --> 00:14:22,211
如果你恰好第一字母按C，输出将会是字母T

170
00:14:22,211 --> 00:14:27,242
然后磁盘旋转一格，
新的置换表就显示在这里

171
00:14:27,242 --> 00:14:31,693
你看到E移到上面去了

172
00:14:31,693 --> 00:14:36,531
余下的接在下面。想象一下这其实
是一个由一格控制的二维

173
00:14:36,531 --> 00:14:41,495
旋转磁盘。然后按下另一个字母。

174
00:14:41,495 --> 00:14:46,798
磁盘再次旋转 ，
你会注意到N上移而其它字母下移

175
00:14:46,798 --> 00:14:51,590
特别的，如果我们敲击3次C，第一次

176
00:14:51,590 --> 00:14:56,765
将会输出T，第二次输出S

177
00:14:56,765 --> 00:15:01,756
第三次将会是K，这就是简单的转子机的工作方式

178
00:15:01,756 --> 00:15:06,806
在它公布后很快就被使用字母频率

179
00:15:06,806 --> 00:15:11,136
和连字频率和三连字频率的方法破解了

180
00:15:11,136 --> 00:15:16,126
破译密钥，进而破译原文不是很难去

181
00:15:16,126 --> 00:15:20,756
再次说明这只是唯密文攻击

182
00:15:20,756 --> 00:15:25,326
因此为了抵抗频率攻击，这种统计攻击

183
00:15:25,326 --> 00:15:29,861
这些转子机变得而越来越复杂，
最终，你们肯定听过Enigma

184
00:15:29,861 --> 00:15:33,841
这是一种复杂的转子机

185
00:15:33,841 --> 00:15:37,991
它使用3到5个转子，
还有不同版本的Enigma机

186
00:15:37,991 --> 00:15:42,311
给你们看一下3个转子的Enigma机，

187
00:15:42,311 --> 00:15:47,086
Enigma机的密码是内置在转子里的。

188
00:15:47,086 --> 00:15:51,748
这种情况下，3个转子，
会有26^3种可能的不同密钥

189
00:15:51,748 --> 00:15:57,049
当你从键盘输入时，
转子就会以不同的速率旋转

190
00:15:57,049 --> 00:16:02,351
忘了说了这是4个转子的Enigma机图片

191
00:16:02,351 --> 00:16:07,463
当你在打字机上打字时，输出合适的密文字母

192
00:16:07,463 --> 00:16:12,576
这样密钥的数量就是26^4

193
00:16:12,576 --> 00:16:17,372
这大约2^18,这是一个相当小的密钥空间

194
00:16:17,562 --> 00:16:22,359
今天你可以简单粗暴
使用电脑检索2^88个不同的密钥

195
00:16:22,359 --> 00:16:26,723
这非常快，我的智能手表
都能在几秒内算出来

196
00:16:26,723 --> 00:16:31,010
我想这个Enigma机使用相当少的空间

197
00:16:31,010 --> 00:16:35,529
我确信你们听过英国的破译者们

198
00:16:35,529 --> 00:16:40,280
在布莱奇利公园通过
攻击了Enigma机匹配了密文

199
00:16:40,280 --> 00:16:44,915
他们在二战时破译了德军的密码

200
00:16:44,915 --> 00:16:49,377
他们在二战的不同战役中
都扮演了重要角色

201
00:16:49,377 --> 00:16:54,109
战争之后，那是机械时代的结束

202
00:16:54,109 --> 00:16:58,988
开启了数字时代，人们开始使用电脑

203
00:16:58,988 --> 00:17:
04,046
随着世界都开始使用电脑，
政府意识到他们在工业界购买了

204
00:17:04,046 --> 00:17:09,045
大量电子设备，因此政府希望从工业界购买设备时

205
00:17:09,045 --> 00:17:13,864
能预装有好的加密机制

206
00:17:13,864 --> 00:17:19,509
因此政府开始征集数据加密标准

207
00:17:19,509 --> 00:17:24,691
一个联邦的数据加密标准

208
00:17:24,691 --> 00:17:30,205
在今后的课上，我们将详细谈论这个的影响

209
00:17:30,205 --> 00:17:35,720
1974年，IBM的一个团队提出了一个密码，
这就是DES，数据加密标准

210
00:17:35,720 --> 00:17:41,633
它成为了联邦的数据加密标准。
DES的密钥空间

211
00:17:41,633 --> 00:17:46,616
是2^56，如今来说相当小，但在1974年

212
00:17:46,616 --> 00:17:51,553
它足够大了，关于DES，另一个有趣的是，

213
00:17:51,553 --> 00:17:56,683
它不像转子机一次只能加密一个字节，

214
00:17:56,683 --> 00:18:01,623
它能一次加密64比特，
也就是8个字节，在后面的

215
00:18:01,623 --> 00:18:06,563
课程我们将明白其中的意义。
因为DES使用

216
00:18:06,563 --> 00:18:11,440
如此小的密钥空间，
如今可以使用暴力检索来破译

217
00:18:11,440 --> 00:18:15,994
所以如今DES被认为是不安全的，
不允许在项目中使用

218
00:18:15,994 --> 00:18:20,798
不幸的是，它仍然被使用在一些遗留系统中

219
00:18:20,798 --> 00:18:25,787
但现在很明显，它已经被废弃了，
不会再用到新的项目上。

220
00:18:25,787 --> 00:18:30,529
如今已经有了新的加密方法，
比如使用128比特密钥的AES。

221
00:18:30,529 --> 00:18:35,579
后面我们将会详细地讨论高级加密标准

222
00:18:35,579 --> 00:18:40,383
这里有很多种其他的加密类型。
这里我提一下salsa20

223
00:18:40,383 --> 00:18:45,248
我们马上就会看到它们的原理。
这就是历史方面简短的介绍，

224
00:18:45,248 --> 00:18:49,560
现在我们就要开始学习技术知识了。【END】