1
00:00:00,000 --> 00:00:04,069
本节我们看Diffie-Hellman协议

2
00:00:04,069 --> 00:00:08,234
这是我们的第一个实用的密钥交换机制 让我来为大家讲一下目前的设定

3
00:00:08,234 --> 00:00:12,442
我们的朋友Alice和Bob素未谋面 却想要交换一个共享密钥

4
00:00:12,442 --> 00:00:16,445
然后他们可以使用这个密钥来用于相互安全通信

5
00:00:16,445 --> 00:00:20,088
这两节我们只看对窃听攻击的安全性

6
00:00:20,088 --> 00:00:23,937
换句话说 我们只关心窃听攻击

7
00:00:23,937 --> 00:00:27,992
攻击者不能篡改网络中的数据

8
00:00:27,992 --> 00:00:32,046
他们不能篡改数据 不能以任何方式改数据包

9
00:00:32,046 --> 00:00:36,336
他们只能窃听网络流量 在密钥协议的最后

10
00:00:36,336 --> 00:00:40,880
我们的朋友Alice和Bob应该有一个共享密钥

11
00:00:40,880 --> 00:00:45,031
但窃听攻击者无法知道交换的密钥是什么

12
00:00:45,031 --> 00:00:49,343
上一节我们看了所谓的Merkle谜题的协议

13
00:00:49,343 --> 00:00:53,708
只使用分组密码和哈希函数 我还告诉大家

14
00:00:53,708 --> 00:00:57,487
攻击者相比于通信双方有一个平方鸿沟 ，换句话说

15
00:00:57,487 --> 00:01:01,799
如果通信双方花了与N成正比的时间，那么攻击者

16
00:01:01,799 --> 00:01:06,163
能在与N的平方成正比的时间破解这个协议，因此这个协议从应用角度来看

17
00:01:06,163 --> 00:01:10,369
是不安全的。本节我们研究 我们能否做同样的事情

18
00:01:10,369 --> 00:01:14,733
但现在我们能获得一个指数鸿沟，即一个指数鸿沟横在

19
00:01:14,733 --> 00:01:19,051
攻击者和通信双方的工作之间 换句话说 Alice和Bob

20
00:01:19,051 --> 00:01:23,602
可以做与N成正比的工作 但为了破解这个协议

21
00:01:23,602 --> 00:01:27,876
攻击者必须做与N的某个指数级成正比的工作量

22
00:01:27,876 --> 00:01:32,702
现在，若要在通信双方和攻击者值的工作之间创造一条指数级鸿沟，那么如我上节所说

23
00:01:32,702 --> 00:01:37,985
我们仅凭像AES或SHA-256这样的分组密码技术是不能获得这个指数级鸿沟的

24
00:01:37,985 --> 00:01:43,143
我们必须使用拥有比对称原型更多结构的困难问题

25
00:01:43,143 --> 00:01:48,714
我们将使用一点代数知识，

26
00:01:48,714 --> 00:01:51,600
本节我将描述Diffie-Hellman协议

27
00:01:51,600 --> 00:01:55,769
以很具体的形式 不是很形式化 下周还是回到Diffie-Hellman协议

28
00:01:55,769 --> 00:02:00,090
我们将更为抽象的描述这个函数 对这个协议进行更为严格的安全分析

29
00:02:00,090 --> 00:02:04,198
那么Diiffie-Hellman协议是如何工作的呢？

30
00:02:04,198 --> 00:02:08,173
首先 我们选某个固定的大质数

31
00:02:08,334 --> 00:02:12,684
记之为p 我通常用p表示质数

32
00:02:12,684 --> 00:02:16,820
大家应该把它想象成非常大的质数 比如

33
00:02:16,820 --> 00:02:21,009
有600个十进制的质数 如果大家喜欢用二进制

34
00:02:21,009 --> 00:02:25,413
600个十进制大约相当于2000个二进制

35
00:02:25,413 --> 00:02:29,932
写下一个约2000位质数 然后我们选一个固定的质数g

36
00:02:29,932 --> 00:02:35,067
g正好在从1到p的范围中 这里的p和g

37
00:02:35,067 --> 00:02:40,014
是Diffie-Hellman协议的参数 它们一经选择就不再改变

38
00:02:40,014 --> 00:02:45,087
现在这个协议如下工作 我们的朋友Alice和Bob

39
00:02:45,087 --> 00:02:50,347
开始时Alice选择某个随机数 范围是从1到p-1

40
00:02:50,347 --> 00:02:55,420
然后她将计算g^a mod p

41
00:02:55,420 --> 00:02:59,802
她计算这个指数 然后将结果取质数p的模

42
00:02:59,802 --> 00:03:04,407
下一章中我们将看到如何有效地计算这个有限域上的指数

43
00:03:04,407 --> 00:03:07,817
现在请大家相信我 这是可以有效计算的

44
00:03:07,817 --> 00:03:13,118
现在我们计算这个结果

45
00:03:13,118 --> 00:03:17,501
Alice将这个结果传送给Bob 他将做同样的事情

46
00:03:17,501 --> 00:03:22,161
他选择一个随机数b 范围从1到p-1

47
00:03:22,161 --> 00:03:26,322
Bob计算g^b mod p 我们记结果为B

48
00:03:26,322 --> 00:03:31,114
然后Bob把B发送给Alice 那么Alice发送了A给Bob Bob发送了B给Alice

49
00:03:31,114 --> 00:03:36,848
现在他们宣布 他们已经共享了一个密钥 那么这个共享密钥是什么

50
00:03:36,848 --> 00:03:41,968
我们来定义它 记之为K_AB

51
00:03:41,968 --> 00:03:47,410
K_AB的定义为g^ab mod D 现在Diffie-hellman在1976年的一个惊人的观察结果是


52
00:03:47,410 --> 00:03:53,040
事实上双方都可以计算这个值g^ab mod p

53
00:03:53,040 --> 00:03:58,738
来看 Alice可以计算这个值 因为她可以取值B

54
00:03:58,738 --> 00:04:04,232
B是Bob给她的 她可以取值B 计算B^a mod p

55
00:04:04,232 --> 00:04:09,116
她会获得g^ab mod p

56
00:04:09,116 --> 00:04:14,935
根据指数规则 （g^b)^a=(g^a)^b mod p

57
00:04:14,935 --> 00:04:19,986
Bob实际可以做类似的事 那么他的目标是计算(g^a)^b mod p

58
00:04:19,986 --> 00:04:24,972
答案依然是g^ab mod p 所以Alice和Bob都可以计算K_AB

59
00:04:24,972 --> 00:04:32,567
我问大家 Bob是怎么计算g^ab mod p的？

60
00:04:32,567 --> 00:04:37,894
他取Alice给他的A

61
00:04:37,894 --> 00:04:43,412
计算A^b mod p 就得到了共享密钥g^ab mod p

62
00:04:43,412 --> 00:04:48,450
大家可以看到 尽管双方计算的值不一样

63
00:04:48,450 --> 00:04:53,495
事实上他们会得到同样的值g^ab mod p

64
00:04:53,495 --> 00:04:57,703
我应该顺便提到 Martin和Wig Diffie于1976年提出这一协议

65
00:04:57,703 --> 00:05:01,752
当时Matrin Hellman是斯坦福的教授 而Whg Diffie是他的研究生

66
00:05:01,752 --> 00:05:06,120
他们提出的这个协议真正改变了全世界

67
00:05:06,120 --> 00:05:10,541
它开创了密码学的新纪元

68
00:05:10,541 --> 00:05:14,536
现在不仅是关于开发分组密码 而且是关于

69
00:05:14,536 --> 00:05:19,293
设计基于代数的协议 使之拥有类似我们这里的性质

70
00:05:19,293 --> 00:05:24,336
大家注意，这个协议顺利工作的本质原因是指数的代数性质

71
00:05:24,525 --> 00:05:29,443
即（g^b）^a=(g^a)^b

72
00:05:29,443 --> 00:05:33,568
这些是指数的性质。现在当我描述

73
00:05:33,568 --> 00:05:38,041
一个像我刚才展示给大家的协议时，大家应该想到的真正问题

74
00:05:38,041 --> 00:05:41,941
不是这个协议为什么能工作。换句话说，很容易验证这点

75
00:05:41,941 --> 00:05:45,840
事实上，Alice和Bob最后会得到同样的密钥

76
00:05:45,840 --> 00:05:49,636
更重要的问题是，为什么这个协议是安全的？换句话说，为什么一个窃听者

77
00:05:49,636 --> 00:05:53,847
无法根据双方发出的A、B，解出共享密钥？

78
00:05:53,847 --> 00:05:57,902
让我们稍作分析，如我所说

79
00:05:57,902 --> 00:06:02,114
下周我们进行更进一步的分析

80
00:06:02,114 --> 00:06:06,221
现在我们先直观地看一下问什么这个协议是安全的

81
00:06:06,566 --> 00:06:11,106
窃听者能看到什么？他能看到质数p和生成元g

82
00:06:11,106 --> 00:06:15,876
这些值是永远固定不变的，每个人都知道它们。攻击者还能看到Alice发给Bob的值A

83
00:06:15,876 --> 00:06:20,531
他还能看到Bob发给Alice的值B

84
00:06:20,531 --> 00:06:25,187
问题是，窃听者能计算出g^ab mod p

85
00:06:25,187 --> 00:06:29,899
仅根据这四个值吗？更一般地

86
00:06:29,899 --> 00:06:34,497
我们可以定义这个Diffie-Hellman函数。我们说Diffie-Hellman函数

87
00:06:34,497 --> 00:06:39,373
定义在某个值g上，问题是，给定g^a和g^b

88
00:06:39,373 --> 00:06:44,743
能否计算g^ab?我们在问，计算这个

89
00:06:44,743 --> 00:06:49,580
很大的质数模p乘法群上的函数，有多困难？记得p大约有600个十进制位

90
00:06:49,580 --> 00:06:53,968
所以真正的问题是，这个Diffie-Hellman函数

91
00:06:53,968 --> 00:06:58,850
有多难解？我来告诉大家目前已知的事实。介绍这个质数正好有n位长

92
00:06:58,850 --> 00:07:04,406
在我们这里比如说n=2000位

93
00:07:04,406 --> 00:07:08,783
实际上计算Diffie-Hellman函数，已知最好的算法

94
00:07:08,783 --> 00:07:12,853
是一个更为一般的算法，用来计算离散对数函数

95
00:07:12,853 --> 00:07:16,822
我们下周讨论它。但现在，我们就说这个算法

96
00:07:16,822 --> 00:07:20,742
能计算Diffie-Hellman函数。这个算法叫做普通数域筛法

97
00:07:20,742 --> 00:07:24,912
我这里不描述它是如何工作的，不过大家想听一听它是如何工作的

98
00:07:24,912 --> 00:07:28,982
告诉我们，我们会在课程的最后开一个特殊专题

99
00:07:28,982 --> 00:07:33,002
有趣的是，这个算法的运行时间是指数级的

100
00:07:33,002 --> 00:07:36,771
指数大约是n的立方根。换句话说，运行时间

101
00:07:36,771 --> 00:07:41,028
大约是e的n的立方根次方。事实上这个算法的运行时间的严格表达式

102
00:07:41,028 --> 00:07:44,853
要比这个复杂得多

103
00:07:44,853 --> 00:07:49,035
我故意简化了，以求直击要点

104
00:07:49,035 --> 00:07:52,809
我想强调的一点是，事实上，这不是严格的指数时间的算法

105
00:07:52,809 --> 00:07:57,093
指数时间是指e^n。这个算法有事叫做亚指数算法

106
00:07:57,093 --> 00:08:01,377
因为这里的指数项正比于n的立方根

107
00:08:01,377 --> 00:08:05,847
而不是n。这说明即使这个问题很难

108
00:08:05,847 --> 00:08:10,360
他也不是真正的指数级时间的问题

109
00:08:10,360 --> 00:08:15,175
运行时间的指数是与n的立方根成正比的

110
00:08:15,175 --> 00:08:19,848
那么我们来看几个例子。假设我正好在看一个模

111
00:08:19,848 --> 00:08:23,879
有大于一千位长，这个算法是说

112
00:08:23,879 --> 00:08:28,436
我们可以解决Diffie-Hellman的问题，以时间大约是e的1024的立方根次方

113
00:08:28,436 --> 00:08:33,285
这不是很准确，事实上指数上有一些常数项

114
00:08:33,285 --> 00:08:38,192
但只看要点的话，我们可以说算法的运行时间

115
00:08:38,192 --> 00:08:42,866
大约是e的1024的立方根次方，这个值其实很小，大约是e的10次方(约22000)

116
00:08:42,866 --> 00:08:47,231
这个简单的例子告诉大家，如果你有一个亚指数级算法

117
00:08:47,231 --> 00:08:51,589
大家看到即使这个问题规模很大，比如1000位

118
00:08:51,589 --> 00:08:56,277
因为这个立方根的作用，其实总体并没有那么大

119
00:08:56,277 --> 00:09:00,849
说实话我就讲到这里了。普通数域筛法

120
00:09:00,849 --> 00:09:05,420
在指数上有很多其他常数，不过事实上这个根本不是10

121
00:09:05,420 --> 00:09:09,816
而是类似于80的样子。因为指数上的各种常数

122
00:09:09,816 --> 00:09:14,622
但是大家看到这个问题依然比2的1000次方简单

123
00:09:14,622 --> 00:09:19,428
尽管描述它需要1000位，但解决它

124
00:09:19,428 --> 00:09:23,587
不需要1000次方的时间。这里我把表往下拉

125
00:09:23,587 --> 00:09:27,309
给大家看大体上，比较一下破解Diffie-Hellman协议

126
00:09:27,309 --> 00:09:31,785
和破解分组密码的难度，给定合适的位数。例如

127
00:09:31,785 --> 00:09:36,261
如果你的密码有80位密钥，那么大概需要1000位的模

128
00:09:36,261 --> 00:09:40,792
换句话说，破解一个80位的密码，大约需要2的80次方的时间

129
00:09:40,792 --> 00:09:45,053
意味着如果你的Diffie-Hellman函数有1000位的模

130
00:09:45,053 --> 00:09:47,701
破解它需要2的80次方的时间

131
00:09:47,701 --> 00:09:53,989
如果你的密码使用128位密钥，比如AES，那么你应该使用3000位的模

132
00:09:53,989 --> 00:09:58,734
即时没有人真正这样做。实际中，人们使用2000位的模

133
00:09:58,734 --> 00:10:03,083
那么如果你的密钥非常大，比如说如果我们使用256位AES密钥

134
00:10:03,083 --> 00:10:07,715
那么实际上你的模需要非常大。大家可以看到

135
00:10:07,715 --> 00:10:12,346
这里的立方根的作用了。由于这个立方根的影响，我们将密钥大小翻倍时

136
00:10:12,346 --> 00:10:16,752
意味着我们必须增加模的大小，倍数为

137
00:10:16,752 --> 00:10:21,327
2的立方，也就是8的倍数，这个就是15000的由来

138
00:10:21,327 --> 00:10:25,952
我应该再提一下，这并不是严格的8倍

139
00:10:25,952 --> 00:10:30,251
因为指数上有其他常数项，这是一张很好的表。

140
00:10:30,251 --> 00:10:34,481
它告诉大家，如果大家使用Diffie-Hellman协议来交换会话密钥

141
00:10:34,481 --> 00:10:38,608
用于分组密码的会话密钥要有合适的密钥大小

142
00:10:38,608 --> 00:10:42,633
这张表为大家展示了，需要使用的模的大小，使得密钥交换协议的安全性

143
00:10:42,633 --> 00:10:46,709
和你之后使用的分组密码的安全性相当

144
00:10:46,709 --> 00:10:50,837
现在这个最后一行应该会困扰着大家

145
00:10:50,837 --> 00:10:54,913
我应该告诉大家，要使用如此之大的模很成问题

146
00:10:54,913 --> 00:10:59,040
速度会很慢，那么问题是，我们能否做得更好

147
00:10:59,040 --> 00:11:03,832
实际上是有的。事实上，我描述Diffie-Hellman函数的方法

148
00:11:03,832 --> 00:11:08,984
正式Diffie和Hellman在1976年描述的方法

149
00:11:08,984 --> 00:11:13,516
使用了质数模的算术。质数模算术的问题是

150
00:11:13,516 --> 00:11:17,539
Diffie-Hellman函数难以计算，但不如大家想的那么难

151
00:11:17,539 --> 00:11:21,611
有这个立方根的影响，使之比大家想的稍容易些

152
00:11:21,611 --> 00:11:26,158
那么问题是，我们能否在其他的设定下，运行Diffie-Hellman协议

153
00:11:26,158 --> 00:11:30,300
实际上答案是肯定的。事实上我们可以

154
00:11:30,300 --> 00:11:34,308
把Diffie-Hellman协议从质数模算术的设定

155
00:11:34,308 --> 00:11:38,752
翻译成不同类型的代数对象，然后在其它的

156
00:11:38,752 --> 00:11:43,196
代数对象上解Diffie-Hellman问题将是困难的多。这个其它的代数对象就是

157
00:11:43,196 --> 00:11:47,758
所谓的椭圆曲线。如我所说，计算定义在椭圆曲线域上的Diffie-Hellman函数

158
00:11:47,758 --> 00:11:52,735
要比计算质数模乘法群上的Diffie-Hellman问题困难得多

159
00:11:52,735 --> 00:11:57,476
因为问题更加困难，现在我们可以使用小得多的代数对象

160
00:11:57,476 --> 00:12:02,453
特别地，我们使用仅有160位或80位或

161
00:12:02,453 --> 00:12:06,780
512位的质数，用于256位的分组密钥。那么因为这些模

162
00:12:06,780 --> 00:12:10,914
在椭圆曲线上增长得不快，通常从使用模算术

163
00:12:10,914 --> 00:12:14,949
到使用椭圆曲线有一个缓慢的转换。我这里先不为大家描述椭圆曲线

164
00:12:14,949 --> 00:12:18,735
但如果这是大家想学习的

165
00:12:18,735 --> 00:12:22,421
我可以留到本课程的最后一周，届时讨论更多高级话题

166
00:12:22,421 --> 00:12:27,149
但事实上当我们下周回到Diffie-Hellman时

167
00:12:27,149 --> 00:12:31,933
我将更为抽象地描述它，这样你使用的代数结构就不重要了

168
00:12:31,933 --> 00:12:36,831
无论使用质数模算术，还是使用椭圆曲线域

169
00:12:36,831 --> 00:12:41,557
我们都可以将整个过程抽象出来，然后使用Diffie-Hellman这个概念

170
00:12:41,557 --> 00:12:46,109
进行密钥交换，以及一些其它事情。如我所说

171
00:12:46,109 --> 00:12:50,321
我们下周还会看到更多的抽象。通常我想展示这个漂亮的协议

172
00:12:50,321 --> 00:12:54,307
就像我刚刚展示给大家的，Diffie-Hellman协议对抗主动攻击时，是完全不安全的

173
00:12:54,307 --> 00:12:58,195
它是完全不安全的

174
00:12:58,195 --> 00:13:02,132
当存在所谓的中间人攻击。我们需要对这个协议

175
00:13:02,132 --> 00:13:06,019
做些补充，让它对中间人攻击也是安全的

176
00:13:06,019 --> 00:13:10,135
让它能安全地抵抗中间人攻击。好，那现在我们看

177
00:13:10,135 --> 00:13:14,649
为什么我刚才展示给大家的这个协议对主动攻击是不安全的

178
00:13:14,649 --> 00:13:18,767
假设我们有这个中间人，他试图窃听

179
00:13:18,767 --> 00:13:23,393
Alice和Bob之间的会话。协议开始时

180
00:13:23,563 --> 00:13:28,309
Alice发送g^a给Bob。那么中间人截获了这个g^a

181
00:13:28,309 --> 00:13:32,777
他将取Alice发出的信息，换成他自己的信息

182
00:13:32,777 --> 00:13:37,113
我们记为A'，写成g^a'

183
00:13:37,113 --> 00:13:41,939
所以中间人选择了他自己的a'

184
00:13:41,939 --> 00:13:46,588
把g^a'发送给Bob。现在可怜的Bob并不知道

185
00:13:46,588 --> 00:13:51,356
中间人对通信流量做了手脚，他只能获得A'

186
00:13:51,356 --> 00:13:55,946
他目前只知道，这个值来自Alice，那他怎么回复

187
00:13:55,946 --> 00:14:00,723
Bob会回复他的B=g^b给Alice

188
00:14:00,723 --> 00:14:05,457
中间人截获了这个B

189
00:14:05,457 --> 00:14:10,434
他可以生成自己的b'，然后发送B'=g^b'给Alice

190
00:14:10,434 --> 00:14:16,807
现在会怎么样呢？Alice计算她的密钥

191
00:14:16,807 --> 00:14:22,808
她会得到g^ab'。Bob计算他的密钥

192
00:14:22,808 --> 00:14:28,281
他会得到g^ba'

193
00:14:28,281 --> 00:14:33,592
现在大家要注意，这些密钥并不一样
但是对于中间人来讲

194
00:14:33,592 --> 00:14:38,903
他既知道A'又知道B'，他既可以计算g^ab'也可以计算g^ba'

195
00:14:38,903 --> 00:14:44,215
容易看出中间人可以知道这两个值

196
00:14:44,215 --> 00:14:49,526
这样的话，他可以扮演中间人，
当Alice给Bob发送一个加密的信息时

197
00:14:49,526 --> 00:14:54,711
中间人可以解密这个信息

198
00:14:54,711 --> 00:14:59,622
因为他知道Alice加密信息的密钥
然后中间人重新使用Bob的密钥加密这个信息

199
00:14:59,622 --> 00:15:04,105
然后把信息发送给Bob
这样Alice发送信息给Bob

200
00:15:04,105 --> 00:15:08,239
Bob接收到了信息。Bob认为这个信息是安全的

201
00:15:08,239 --> 00:15:12,605
但是实际上，这个信息经过了中间人。中间人解密信息

202
00:15:12,605 --> 00:15:17,146
然后为Bob重新加密了它。同时他可以完全知道信息内容。

203
00:15:17,146 --> 00:15:21,746
如果愿意的话，他可以修改它，等等。
所以这个协议是完全不安全的。

204
00:15:21,746 --> 00:15:26,531
如果有中间人的话。所以我说，我们必须加强

205
00:15:26,531 --> 00:15:30,697
这个协议来抵抗中间人攻击，

206
00:15:30,697 --> 00:15:34,915
实际上增强和防御中间人攻击并不是很难

207
00:15:34,915 --> 00:15:39,377
我们这两周还会回头看这里。
最后我想做的是

208
00:15:39,377 --> 00:15:43,658
给大家展示一个有趣的Diffie-Hellman协议的性质

209
00:15:43,658 --> 00:15:48,046
事实上我想给大家展示的是这个协议可以被视为一个
非互动协议

210
00:15:48,046 --> 00:15:52,487
这是什么意思呢？设想我们有一组用户

211
00:15:52,487 --> 00:15:56,340
几百万用户。我们叫他们Alice，Bob，Charlie，Dvaid等等

212
00:15:56,500 --> 00:16:00,567
他们中每个人都会选取一个随机的私密值

213
00:16:00,567 --> 00:16:04,419
然后在他们的Facebook页面上，写下他们

214
00:16:04,419 --> 00:16:08,486
对Diffie-Hellman协议的贡献。那么每个人写下了

215
00:16:08,486 --> 00:16:13,604
g^a,g^b,g^c...现在，有趣的是

216
00:16:13,604 --> 00:16:18,942
如果Alice和Charlie想建立一个共享密钥，他们无需相互通信

217
00:16:18,942 --> 00:16:24,360
Alice只要去Charlie的公共页面

218
00:16:24,360 --> 00:16:29,635
Charlie只要去Alice的公共页面。这样，他们就共享了一个密钥

219
00:16:29,635 --> 00:16:34,976
Alice只要了g^ca，Charlie知道了g^ac

220
00:16:34,976 --> 00:16:39,987
因此双方都能计算g^ac，某种意义上

221
00:16:39,987 --> 00:16:44,669
一旦他们在公共页面发布了他们对Diffie-Hellman的协议的共享

222
00:16:44,669 --> 00:16:50,076
他们根本不需要相互通信就能建立共享密钥

223
00:16:50,076 --> 00:16:53,919
他们立即就能有一个共享密钥，现在他们

224
00:16:53,919 --> 00:16:58,194
就能通过Facebook来安全地通信了，而不会是和别人

225
00:16:58,194 --> 00:17:02,121
注意这对所有Facebook用户都可以。只要我去访问某人的公共页面

226
00:17:02,121 --> 00:17:06,198
我就能迅速地得到一个共享密钥，无需相互通信

227
00:17:06,198 --> 00:17:09,967
这个性质有时称作Diffie-Hellman的非互动性

228
00:17:09,967 --> 00:17:14,716
让我给大家展示一个开放问题。这是一个开放问题

229
00:17:14,716 --> 00:17:19,407
各个时代都是这样。如果有人能解决它将是很好的

230
00:17:19,407 --> 00:17:24,041
问题是，我们能否对多于两方的用户做这些呢？换句话说

231
00:17:24,041 --> 00:17:28,559
比如说我们有四方，所有人都在他们的Facebook
公共页面上发布了他们的值

232
00:17:28,559 --> 00:17:33,366
现在我们想只通过阅读Facebook页面

233
00:17:33,366 --> 00:17:38,057
所有人就可以建立共享密钥，换句话说

234
00:17:38,057 --> 00:17:42,427
Alice会去访问其他三个人的公共页面

235
00:17:42,427 --> 00:17:47,650
她已经可以计算他们之间的共享密钥
类似的，David只需

236
00:17:47,650 --> 00:17:54,187
访问Charlie，Bob和Alice的公共页面

237
00:17:54,187 --> 00:17:58,716
他就有了他们四个的共享密钥。问题在于，
我们能否可以非互动地建立

238
00:17:58,885 --> 00:18:03,546
这些共享密钥，对于多于两个人的组来说

239
00:18:03,546 --> 00:18:07,986
如我所说，n-2就是Diffie-Hellman协议

240
00:18:07,986 --> 00:18:12,594
换句话说，如果只有双方想建立共享密钥

241
00:18:12,594 --> 00:18:16,696
且无需通信，那么使用Diffle-Hellman即可

242
00:18:16,696 --> 00:18:21,473
实际上对于n=3的情况，我们也知道如何去做
有一个已知的协议

243
00:18:21,473 --> 00:18:25,688
由Joux提出，它使用了非常高级的数学知识

244
00:18:25,688 --> 00:18:29,959
比我刚刚为大家展示的要复杂多的数学知识
对于n=4或5或任何更大的数

245
00:18:29,959 --> 00:18:34,455
大于4的，这个问题是完全开放的

246
00:18:34,455 --> 00:18:38,790
在这个情况下，4人在他们的公共页面上发布信息

247
00:18:38,790 --> 00:18:42,908
这样别人可以访问这些公共页面，然后他们就有了
一个公有的共享密钥

248
00:18:42,908 --> 00:18:47,459
即使只有4个人，我们也不知道怎么做

249
00:18:47,459 --> 00:18:52,010
这在各个时代都是一个开放的问题，是个有趣的问题

250
00:18:52,010 --> 00:18:56,073
值得去思考，如果你能解决它，就会立即在密码学界获得名气

251
00:18:56,073 --> 00:19:00,516
到此为止，下节我们会继续讲另一个密钥交换机制。【END】

