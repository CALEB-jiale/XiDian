1
00:00:00,000 --> 00:00:03,460
在上一节我们定义了认证加密 但是我并没有

2
00:00:03,460 --> 00:00:06,517
向你们展示为什么认证加密是一种安全概念

3
00:00:06,517 --> 00:00:09,818
在这一节中 我想向你们展示 认证加密事实上

4
00:00:09,818 --> 00:00:14,431
是一种很自然的安全概念 我将通过展示它如何抵抗

5
00:00:14,431 --> 00:00:19,358
强大的选择密文攻击来说明这一点 事实上我们

6
00:00:19,358 --> 00:00:23,320
已经看到一些选择密文攻击的例子了 想象

7
00:00:23,320 --> 00:00:27,552
敌手想破解某些密文C 他能做到的是

8
00:00:27,552 --> 00:00:31,921
比如 欺骗解密服务器来破解某些

9
00:00:31,923 --> 00:00:36,707
不是密文c的密文 我们已经看到过一些这样的例子

10
00:00:36,707 --> 00:00:41,551
如果你还记得 在第一节中 我们看到过能够提交任意

11
00:00:41,551 --> 00:00:46,394
密文的敌手  而且如果明文正好以目的端口25开头 那么

12
00:00:46,394 --> 00:00:50,664
敌手事实上就能清楚地获得这一明文

13
00:00:50,664 --> 00:00:55,672
这就是一个敌手可以获得特定密文解密结果的例子

14
00:00:55,672 --> 00:00:59,966
但他不能获得全部密文 我们看到的另一个例子是 敌手能够

15
00:00:59,966 --> 00:01:04,058
通过向解密者提交密文来获得有关明文的信息

16
00:01:04,058 --> 00:01:08,374
所以我们有这样的例子 敌手提交加密的TCP/IP数据包

17
00:01:08,374 --> 00:01:12,623
给解密服务器 如果解密服务器发回了一个ACK

18
00:01:12,623 --> 00:01:17,053
敌手就会知道这个解密明文的校验和有效 否则

19
00:01:17,053 --> 00:01:21,057
解密明文的校验和无效 这又是一个

20
00:01:21,057 --> 00:01:25,220
选择密文攻击的例子 在这个例子中 攻击者提交密文

21
00:01:25,220 --> 00:01:29,680
然后就能获得那个密文解密后的相关信息 为了解决

22
00:01:29,680 --> 00:01:34,457
这种威胁 我们将要定义一个非常广义的安全上的概念 叫做选择密文安全


23
00:01:34,457 --> 00:01:39,060
在这我们让攻击者有强大的能力

24
00:01:39,060 --> 00:01:43,376
他既可以进行选择明文攻击也可以进行选择密文攻击

25
00:01:43,376 --> 00:01:47,577
换句话说 他可以获得他选择的任何信息的加密结果

26
00:01:47,577 --> 00:01:52,648
他也可以解密任何他选择的密文 而不是挑战密文

27
00:01:52,648 --> 00:01:57,501
正如我之前向你们展示的一样 这其实是一个很保守的

28
00:01:57,501 --> 00:02:01,862
现实情况的模型 在真实世界中 经常地 攻击者可以欺骗

29
00:02:01,862 --> 00:02:06,961
解密者 使其为攻击者解密特定密文 但不能解密全部密文

30
00:02:06,961 --> 00:02:10,986
所以在这种情况下 攻击者有其想解密的特定密文

31
00:02:10,986 --> 00:02:14,992
他可以通过将所选密文的询问发送给解密者的方式

32
00:02:14,992 --> 00:02:18,749
与解密者互动  也就是说 解密各种密文

33
00:02:18,749 --> 00:02:22,706
而不是挑战密文 然后攻击者的目标就是破坏

34
00:02:22,706 --> 00:02:27,149
挑战密文的语义安全 你会注意到我们赋予敌手

35
00:02:27,149 --> 00:02:31,164
强大的能力 现在我们让你做的就是破坏语义安全

36
00:02:31,164 --> 00:02:35,036
所以设计能够对抗这种攻击者的系统

37
00:02:35,036 --> 00:02:38,663
将会变得非常困难 虽然如此 我们还是要设计出它来

38
00:02:38,663 --> 00:02:42,828
让我们更精确的定义下选择密文安全模型

39
00:02:42,828 --> 00:02:47,224
通常 我们有密码(E, D)  然后我们将要定义两个实验

40
00:02:47,224 --> 00:02:51,447
实验0和实验1 现在大家对这个应该挺熟悉了

41
00:02:51,447 --> 00:02:56,017
挑战者开始时选择一个随机密钥 现在敌手将

42
00:02:56,017 --> 00:03:00,587
提交询问给挑战者 每个询问可以是两种类型之一

43
00:03:00,587 --> 00:03:05,123
选择明文询问 或者选择密文询问

44
00:03:05,123 --> 00:03:09,851
我们知道 在一个选择明文询问中 敌手提交两个消息

45
00:03:09,851 --> 00:03:14,724
M0和M1 它们必须长度一样

46
00:03:14,724 --> 00:03:19,870
如果是在实验0中 敌手会收到M0的加密 如果是在实验1中

47
00:03:19,870 --> 00:03:23,991
则会收到M1 所以他收到的是左边或者右边

48
00:03:23,991 --> 00:03:27,845
取决于我们是在实验0中还是实验1中 第二种类型

49
00:03:27,845 --> 00:03:32,323
的询问更有趣 敌手提交他选择的任意密文

50
00:03:32,323 --> 00:03:37,026
然后得到那个密文的解密

51
00:03:37,026 --> 00:03:41,994
你会注意到敌手被允许解密他选择的任意密文

52
00:03:41,994 --> 00:03:47,237
唯一的限制是 他所选的密文不是

53
00:03:47,237 --> 00:03:52,318
在CPA攻击的询问中获得的密文之一 当然这在其他情况下不合理

54
00:03:52,318 --> 00:03:57,338
另外 因为攻击者可以轻松获得

55
00:03:57,338 --> 00:04:01,538
通过CPA询问得到的密文 那会是M0或者M1的加密结果

56
00:04:01,538 --> 00:04:06,604
如果他对那个特定的密文提交CCA询问

57
00:04:06,604 --> 00:04:12,024
他将会获得M0或者M1作为回复 然后他就会知道他是在实验0

58
00:04:12,024 --> 00:04:17,003
还是实验1中了 这不合理 所以我们说他收到的

59
00:04:17,003 --> 00:04:21,656
CPA密文是挑战密文 而且他被允许解密

60
00:04:21,656 --> 00:04:26,460
他所选的任何密文 除了这些挑战密文

61
00:04:26,460 --> 00:04:30,815
通常 他的目标是确定他是在实验0还是实验1中

62
00:04:30,815 --> 00:04:35,376
所以我再强调一遍 这是个极其强大的敌手

63
00:04:35,376 --> 00:04:39,878
他能解密任何密文 除了挑战密文

64
00:04:39,878 --> 00:04:44,029
但是依然不能分清他是处在实验0中

65
00:04:44,029 --> 00:04:48,806
还是实验1中 所以通常我们说一个密码CCA安全

66
00:04:48,806 --> 00:04:52,757
也就是选择密文安全 是指敌手在实验0和

67
00:04:52,757 --> 00:04:57,621
实验1中行为一致 也就是说他无法区分这两个实验

68
00:04:57,621 --> 00:05:02,075
让我们以一个简单的例子开始 证明事实上带随机IV的CBC

69
00:05:02,075 --> 00:05:06,763
不是CCA安全的 不是对选择密文攻击安全的 让我们看看

70
00:05:06,763 --> 00:05:10,173
为什么是这种情况 敌手刚开始要做的是

71
00:05:10,173 --> 00:05:15,553
提交两个不同的消息M0和M1 让我们假定

72
00:05:15,553 --> 00:05:20,055
这两个消息都是单个分组的 然后他会得到

73
00:05:20,055 --> 00:05:24,846
M0或者M1的CBC加密结果 你会注意密文仅有一个分组

74
00:05:24,846 --> 00:05:29,348
因为明文仅有一个分组的长度 现在

75
00:05:29,348 --> 00:05:34,685
攻击者将要做什么？他会修改他得到的密文C

76
00:05:34,685 --> 00:05:39,958
为C'仅通过变化IV域 他将IV与1异或

77
00:05:39,958 --> 00:05:44,910
就是这样 这就得到了一个与C不同的新密文C'

78
00:05:44,910 --> 00:05:49,989
因此攻击者完全可以提交C'作为他的

79
00:05:49,989 --> 00:05:55,134
选择密文询问 所以他请求挑战者为他解密这个C'

80
00:05:55,134 --> 00:05:59,727
因为C'不等于C 所以挑战者必须解密C'

81
00:05:59,727 --> 00:06:04,307
现在让我们看看 当他解密C'的时候发生了什么？

82
00:06:04,307 --> 00:06:09,497
让我来问你 C’的解密结果是什么 你可能记得在第一部分中

83
00:06:09,497 --> 00:06:14,657
如果我们将IV与1异或 这只是简单地将明文与1异或

84
00:06:14,657 --> 00:06:20,997
既然敌手收到了M0与1的异或 或是M1与1的异或 他完全可以知道

85
00:06:20,997 --> 00:06:25,435
自己是在实验0还是实验1中 所以这个敌手的的胜率

86
00:06:25,435 --> 00:06:30,075
基本上是1了 因为他可以很简单地知道他在哪个实验中

87
00:06:30,075 --> 00:06:34,922
而作为结果他可以赢得这个选择密文安全游戏 所以如果你

88
00:06:34,922 --> 00:06:39,337
稍微考虑一下 你会发现这种攻击游戏完全抓住了

89
00:06:39,337 --> 00:06:43,696
我们看到的第一个主动攻击的主要内容 在那里对手稍微改变了

90
00:06:43,696 --> 00:06:47,614
他所得到的密文 然后他得以让解密者为他解密

91
00:06:47,614 --> 00:06:51,918
因而 他能够窃听那些原本不向他公开的消息

92
00:06:51,918 --> 00:06:56,479
所以我想再次强调 这个选择密文游戏真的

93
00:06:56,479 --> 00:07:00,863
会在现实中发生 敌手可以向解密者提交密文

94
00:07:00,863 --> 00:07:05,193
然后解码者会披露有关明文的信息 或者他可以

95
00:07:05,193 --> 00:07:09,465
将那段密文的明文彻底地泄露给敌手 所以

96
00:07:09,465 --> 00:07:13,571
这是一个非常基本的安全概念 然而问题是 我们如何设计

97
00:07:13,571 --> 00:07:17,795
一个CCA安全的密码体系？ 所以我认为这个我们之前定义的

98
00:07:17,795 --> 00:07:21,875
认证加密的概念实际上意味着选择密文安全性

99
00:07:21,875 --> 00:07:25,887
这就是为什么认证加密是一种基本概念

100
00:07:25,887 --> 00:07:30,733
这个理论基本上说的是 如果你给我提供了经过认证加密的密码

101
00:07:30,733 --> 00:07:35,041
这个密码就可以抵御选择密文攻击

102
00:07:35,041 --> 00:07:39,767
更精确地说 这个理论的内容是 如果我们有个敌手正在做Q个询问

103
00:07:39,778 --> 00:07:44,374
换句话说 最多的情况下 q个CPA询问和q个选择密文询问

104
00:07:44,374 --> 00:07:49,160
这里有两个有实力的敌手 B1和B2 他们满足这个不等式

105
00:07:49,160 --> 00:07:53,328
所以由于该组合存在认证加密 我们知道

106
00:07:53,328 --> 00:07:58,052
这个量可以忽略不计 因为它是CPA安全的 然后我们也能知道

107
00:07:58,052 --> 00:08:02,072
这个量可以忽略不计 因为加密方案具有密文

108
00:08:02,072 --> 00:08:06,210
完整性 作为结果来说 由于二者皆可以忽略 我们可以得知

109
00:08:06,210 --> 00:08:10,857
敌手在这个CCA游戏中的胜率也可以忽略不计了 我们来证明

110
00:08:10,857 --> 00:08:14,947
这个定理 这事实上是个很容易证明的定理 所以我们可以仅仅

111
00:08:14,947 --> 00:08:20,581
通过画图来证明 我们这里有两个这个CCA游戏的副本

112
00:08:20,581 --> 00:08:25,190
这就是实验0 然后底下这个是实验1 你可以看到

113
00:08:25,190 --> 00:08:29,783
敌手正在进行CPA询问 还有CCA询问 然后在最后他

114
00:08:29,783 --> 00:08:34,954
输出了一个确认的猜想b 这里我们叫它b' 我们的目标是

115
00:08:34,954 --> 00:08:38,926
证明这个b'在两种情况下是不能被区分的 换句话说

116
00:08:38,926 --> 00:08:43,247
b'在上面的游戏中等于1的概率和

117
00:08:43,247 --> 00:08:47,586
b'在底下的游戏中等于1的概率相等 所以我们

118
00:08:47,586 --> 00:08:50,903
接下来这样做 首先 我们将对挑战者

119
00:08:50,903 --> 00:08:55,761
做一些改变 使得 挑战者将总是输出底下的部分

120
00:08:55,761 --> 00:09:01,128
而不是输出被解密的CCA询问 所以每次敌手

121
00:09:01,128 --> 00:09:05,652
提交一个CCA询问 敌手回复底部 而且我认为这两个

122
00:09:05,652 --> 00:09:08,773
游戏 事实上 是不可区分的 换句话说 敌手不能

123
00:09:08,773 --> 00:09:13,650
区分出这两个游戏 原因很简单 因为这个组合存在

124
00:09:13,650 --> 00:09:17,722
密文完整性 敌手就是不能写出一份不包含在

125
00:09:17,722 --> 00:09:24,197
C1到CI-1的密文 其解密后不是底下的内容 这就是

126
00:09:24,197 --> 00:09:28,777
密文完整性的定义 结果又因为密文

127
00:09:28,777 --> 00:09:33,019
完整性 敌手进行的每个选择密文询问必然

128
00:09:33,019 --> 00:09:37,430
只能获得底部的信息 如果敌手 事实上 可以区分

129
00:09:37,430 --> 00:09:41,898
左边的游戏和右边的游戏 这意味着在某一时刻他

130
00:09:41,898 --> 00:09:46,592
发出的询问解密出了不是底部的信息 然后我们可以用

131
00:09:46,592 --> 00:09:50,795
它来破坏这个组合的密文完整性 而且因为这个组合具有

132
00:09:50,795 --> 00:09:54,977
密文完整性 这左边和右边的游戏就是不可区分的

133
00:09:54,977 --> 00:09:59,324
这是种很聪明的论证 它证明如果你具有密文完整性

134
00:09:59,324 --> 00:10:03,836
你可以很容易地回复选择密文询问 然后同样的事情

135
00:10:03,836 --> 00:10:07,673
也适用于底部 在这里我们可以简单地将选择密文

136
00:10:07,673 --> 00:10:12,623
回复替换成⊥ 好的 但是现在 因为选择

137
00:10:12,623 --> 00:10:17,208
密文询问总是回复相同的结果 它们不会给敌手提供

138
00:10:17,208 --> 00:10:21,574
任何信息 敌手也知道我们总是回复⊥

139
00:10:21,574 --> 00:10:25,668
所以我们同样可以简单地移除这些询问 因为它们

140
00:10:25,668 --> 00:10:29,769
并不给敌手提供任何信息 但是现在 一旦我们移除了这些

141
00:10:29,769 --> 00:10:34,339
询问 由此产生的游戏我们应该相当熟悉 右上角的游戏 和

142
00:10:34,339 --> 00:10:39,144
（右下角）的游戏基本上就是两个我们在CPA安全定义中提出的游戏

143
00:10:39,144 --> 00:10:43,773
结果 因为这个组合是CPA安全的 我们可以知道

144
00:10:43,773 --> 00:10:48,508
敌手不能对上面和下面进行区分 然后 通过这种对回应的改变

145
00:10:48,508 --> 00:10:53,165
我们已经证明了所有这些游戏都是相同的 特别是

146
00:10:53,165 --> 00:10:57,022
最初我们提及的两个游戏也是相同的 因此

147
00:10:57,022 --> 00:11:02,364
敌手不能对左上和左下进行区分 因为

148
00:11:02,364 --> 00:11:06,896
这个组合是CCA安全的 所以这就使你对为什么认证

149
00:11:06,896 --> 00:11:11,236
加密是一种很棒的想法有了直观认识 因为基本上它意味着

150
00:11:11,236 --> 00:11:15,199
对选择密文攻击的安全 所以就像我们所说的认证加密

151
00:11:15,199 --> 00:11:19,094
确保了机密性 即使敌手可以破译密文的子集

152
00:11:19,094 --> 00:11:23,476
或者更广泛地讲 即使他可以他可以实施一般选择密文攻击

153
00:11:23,476 --> 00:11:27,965
他仍旧不能破坏系统的语义安全 然而

154
00:11:27,965 --> 00:11:31,914
记住两点局限性是很重要的 首先 它不能

155
00:11:31,914 --> 00:11:36,350
自己阻挡重放攻击 我们需要去做一些额外的事

156
00:11:36,350 --> 00:11:40,785
去抵御重放攻击 我们将会看到很多例子 如果

157
00:11:40,785 --> 00:11:45,221
解密系统透露了更多关于密文被拒绝的原因 它

158
00:11:45,221 --> 00:11:49,278
不仅仅只输出底层 但是它确实输出更多的信息 例如

159
00:11:49,278 --> 00:11:53,744
在时序攻击中 这解释了为什么密文被拒绝了 此外事实上它

160
00:11:53,744 --> 00:11:58,120
可以完全摧毁认证加密系统的安全性 所以

161
00:11:58,120 --> 00:12:02,245
我们将在后面的部分看到一些像这样聪明的攻击 在下一部分

162
00:12:02,245 --> 00:12:05,394
我们将会转而讨论如何构造认证加密系统

