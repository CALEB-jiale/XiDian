1
00:00:00,192 --> 00:00:04,510
为了完结本章，我想说几句关于如何应用RSA

2
00:00:06,033 --> 00:00:08,690
首先如果大家想加速RSA加密

3
00:00:08,690 --> 00:00:13,236
那么使用较小的公钥e是没有问题的

4
00:00:13,236 --> 00:00:17,178
可以不使用随机的e，而是选择一个小e

5
00:00:17,178 --> 00:00:20,944
事实上最小的可能值是e=3

6
00:00:20,944 --> 00:00:24,446
不难看出e的最小可能值

7
00:00:24,446 --> 00:00:27,608
事实上e=3.我们来看为什么

8
00:00:27,608 --> 00:00:33,327
e=3是一个不好的想法，因为e=1的逆不难去求

9
00:00:33,327 --> 00:00:38,217
e=2不是一个有效的RSA指数，因为记得在RSA的定义中

10
00:00:38,217 --> 00:00:45,602
e必须与Φ（N）互质。如果大家还记得，Φ（N）=（p-1）(q-1)

11
00:00:45,602 --> 00:00:48,484
是一个偶数。如果p和q都是奇数

12
00:00:48,484 --> 00:00:53,292
那么（p-1）(q-1)是一个偶数，但如果e是偶数，如果e=2

13
00:00:53,292 --> 00:00:58,832
e就不与Φ（N）互质，那么e=2也不是有效的

14
00:00:58,832 --> 00:01:02,007
那么e=3是第一个最小的可以使用的值

15
00:01:02,007 --> 00:01:06,904
然后我们必须确保事实上，p=2 mod 3

16
00:01:06,904 --> 00:01:13,016
q=2mod 3，这样（p-1）(q-1)就不会被3整除

17
00:01:13,847 --> 00:01:16,545
那么事实上这是一个可使用的很好的公钥指数

18
00:01:16,545 --> 00:01:21,931
不过推荐的值是2^16+1，即65537

19
00:01:21,931 --> 00:01:24,848
使用这个推荐的e值是个好点子

20
00:01:24,848 --> 00:01:29,601
计算x^3 mod N，你需要三步乘法

21
00:01:29,601 --> 00:01:36,987
而计算x^65537 mod N，使用重复平方算法，需要17步乘法

22
00:01:36,987 --> 00:01:41,111
你重复平方16次

23
00:01:41,111 --> 00:01:44,100
然后再乘一次x

24
00:01:44,100 --> 00:01:47,732
那么只要17次乘法，你就可以计算出这个指数

25
00:01:47,732 --> 00:01:50,867
那么这比使用一个随机e要好得多了

26
00:01:50,867 --> 00:01:53,735
随机e需要约2000次乘法

27
00:01:53,735 --> 00:01:57,125
那么这就让我们得到了RSA的非对称性

28
00:01:57,125 --> 00:02:01,773
事实上加密是很快的：加密只需要17次乘法

29
00:02:01,773 --> 00:02:04,107
但是解密要慢的多

30
00:02:04,107 --> 00:02:07,452
它需要约2000次乘法

31
00:02:08,898 --> 00:02:14,007
我应该指出，有一个标准的加速RSA解密的技巧

32
00:02:14,007 --> 00:02:18,676
叫做中国剩余定理

33
00:02:18,676 --> 00:02:22,775
这个方法可以让RSA解密加速4倍

34
00:02:22,775 --> 00:02:26,514
但不管如何这依然比加密慢很多

35
00:02:26,514 --> 00:02:31,484
RSA的加密与解密的速度比，差不多从10到30

36
00:02:31,484 --> 00:02:36,793
那么加密速度可以是解密的30倍，但取决于模的大小

37
00:02:37,531 --> 00:02:42,173
有趣的是，这是一个RSA的特殊性质，加密比解密快很多

38
00:02:42,173 --> 00:02:47,108
另一公钥系统，比如说，我们下一章要看到的EIGamal加密

39
00:02:47,108 --> 00:02:52,056
就没有这个性质，它的加密和解密用时差不多一样

40
00:02:54,518 --> 00:02:57,730
我们之前已经讨论了RSA的秘钥长度

41
00:02:57,730 --> 00:03:02,583
那么我只想展示一下这些数，以提醒大家，如果你使用128位AES秘钥

42
00:03:02,583 --> 00:03:05,334
你应该使用一个3000位的模

43
00:03:05,334 --> 00:03:08,799
尽管大家都用2048位模

44
00:03:08,799 --> 00:03:15,433
如果你真的使用一个长AES秘钥，比如256位，那么RSA模将会很大

45
00:03:17,802 --> 00:03:20,882
现在我想提醒一下众多的针对RSA实现的攻击

46
00:03:20,882 --> 00:03:23,648
这些攻击已将针对特定的

47
00:03:23,648 --> 00:03:28,715
RSA的数学上正确的实现成功展示了。但是这些实现

48
00:03:28,715 --> 00:03:34,068
对特定的旁道攻击是脆弱的，这使得这个实现是完全不安全的

49
00:03:34,068 --> 00:03:37,799
打一个例子是Paul Kocher 于1997年提出的

50
00:03:37,799 --> 00:03:42,479
他展示了一个计时攻击，你只需要测量RSA解密的时间

51
00:03:42,479 --> 00:03:47,799
通过简单的测量时间，你可以揭露密钥指数d

52
00:03:47,799 --> 00:03:52,168
那么，这是说你实现了RSA解密

53
00:03:52,168 --> 00:03:55,736
你最好确保解密时间和这些参数无关

54
00:03:57,659 --> 00:04:01,593
Pual Kocher两年后又提出了另一个攻击展示了

55
00:04:01,593 --> 00:04:04,166
如果你有一个智能卡，上面实现了RSA解密

56
00:04:04,166 --> 00:04:08,304
你能测量这张卡在做RSA解密时的功耗

57
00:04:08,304 --> 00:04:13,302
通过观察功耗峰谷，你可以读出d的各位

58
00:04:13,302 --> 00:04:18,486
一次读一位，当智能卡在运行重复平方算法时

59
00:04:18,486 --> 00:04:23,040
那么使用一个功耗分析的攻击，是容易获取密钥各位的

60
00:04:23,040 --> 00:04:28,038
除非智能卡能抵抗这些功耗攻击

61
00:04:28,038 --> 00:04:32,922
最后，另一种叫做错误攻击的展示了RSA对解密错误是脆弱的

62
00:04:32,922 --> 00:04:38,042
特别的，如果出于一些原因，RSA解密时发生了错误

63
00:04:38,042 --> 00:04:42,345
一个错误将完全泄露密钥

64
00:04:42,345 --> 00:04:47,098
所以如果这个攻击真的是很重要的，也就是说，一个错误将完全泄露你的密钥

65
00:04:47,098 --> 00:04:51,811
因此，许多密码学库都会检查RSA解密的结果

66
00:04:51,811 --> 00:04:55,451
在返回结果调用者之前。检查的方法是

67
00:04:55,451 --> 00:04:59,802
取出这个指数的输出，计算它的e次方

68
00:04:59,802 --> 00:05:03,750
检查是否又回到c mol N

69
00:05:04,488 --> 00:05:07,466
如果是这样，说明这个解密是正确的

70
00:05:07,466 --> 00:05:11,706
现在可以这么做的原因是，e比d小很多

71
00:05:11,706 --> 00:05:16,267
因此检测此比计算d次方要花的时间少得多

72
00:05:16,267 --> 00:05:21,156
不过，即使检查比实际解密快十倍

73
00:05:21,156 --> 00:05:25,724
这依然引入了一个10%的开销，所以有时这一功能实际上被关闭了

74
00:05:25,724 --> 00:05:30,505
不过，检查RSA输出的计算是否正确，的确是个好方法

75
00:05:30,505 --> 00:05:35,990
那么所以这些攻击再次说明了，如果你自己实现了一个RSA

76
00:05:35,990 --> 00:05:38,642
它在数学上是正确的，它能工作

77
00:05:38,642 --> 00:05:41,948
但是针对实现，依然会有这些潜在的攻击

78
00:05:41,948 --> 00:05:44,830
因此，你不应该自己去实现RSA

79
00:05:44,830 --> 00:05:49,910
始终使用标准密码库，始终使用已有的实现

80
00:05:51,125 --> 00:05:54,564
具体地说，我想给大家展示一个这些攻击的例子

81
00:05:54,564 --> 00:05:58,080
特别的，我会给大家展示RSA上的错误攻击

82
00:05:58,080 --> 00:06:01,779
这也是个错误攻击，是针对带中国剩余的RSA

83
00:06:01,779 --> 00:06:07,182
事实上，如我在本节开头所说，RSA解密经常是如下实现的

84
00:06:07,182 --> 00:06:14,416
解密密文c mol p，然后解密密文 c mol q

85
00:06:14,416 --> 00:06:18,184
然后结合两者得到模N的解密

86
00:06:18,184 --> 00:06:21,306
这个组合是通过中国剩余定理做到的

87
00:06:21,306 --> 00:06:25,035
我这里不解释细节，不难看出这是如何工作的

88
00:06:25,035 --> 00:06:28,895
一旦你有了模p和模q的解密的结果

89
00:06:28,895 --> 00:06:31,210
把它组合起来获得模N下的解密

90
00:06:31,210 --> 00:06:34,022
实际上这给出了一个4倍的加速

91
00:06:34,022 --> 00:06:38,612
比起直接使用模N指数的实现来说

92
00:06:39,535 --> 00:06:41,962
好了，那么我们看为什么这对错误是脆弱的

93
00:06:41,962 --> 00:06:48,783
假设当你的解密算法库在计算模q解密时

94
00:06:48,783 --> 00:06:51,631
出于某些原因，处理器犯了一个错误

95
00:06:51,631 --> 00:06:57,403
实际上这不是一个正确的xq，得到的是错误的xq

96
00:06:57,403 --> 00:07:01,817
那么我们叫这个为xq^，不过当它计算模q的解密时

97
00:07:01,817 --> 00:07:05,549
没有错误发生，那么这些错误很少

98
00:07:05,549 --> 00:07:09,952
我们只假设，计算一个质数模时，发生了一个错误

99
00:07:09,952 --> 00:07:13,706
但没有发生其他首相模。

100
00:07:13,706 --> 00:07:18,407
如果是这种情况：我们的计算是正确的模p和不正确的模q。

101
00:07:18,407 --> 00:07:22,608
这就是说当我们把两个结果合并到一起将得到一个输出，

102
00:07:22,608 --> 00:07:27,044
我会叫它基x，这样输出就是正确的模p。

103
00:07:27,044 --> 00:07:31,507
所以x是相当于c对d模p而不是模q。

104
00:07:31,507 --> 00:07:37,040
如果我们把这两个方程加到e上,我们获得的是以下两个关系。

105
00:07:37,040 --> 00:07:39,462
好，让我们来看看。我们把它加到e上。

106
00:07:39,462 --> 00:07:43,237
发生的是左手边将是x对e.

107
00:07:43,237 --> 00:07:45,801
右手边，它是c对d。

108
00:07:45,801 --> 00:07:50,194
如果我把c加到d到e-e,d,记得是相互的逆——

109
00:07:50,194 --> 00:07:56,177
因此，如果我把c加到d到e，都是指数抵消，我会简单地得到C。

110
00:07:56,177 --> 00:08:00,912
所以我知道x模e相当于模c.但模q，这里会出错。

111
00:08:00,912 --> 00:08:04,400
所以x模e不等于c模q.

112
00:08:04,400 --> 00:08:08,711
因此，如果我看到了这个不同，

113
00:08:08,711 --> 00:08:13,392
我们知道它是0模p，不是0模q

114
00:08:13,392 --> 00:08:17,108
所以现在如果我们计算出这个值和N的GCD，我们会得到什么呢？

115
00:08:19,370 --> 00:08:24,975
正如我说的，这是0模p，但不等于0模q。

116
00:08:24,975 --> 00:08:30,839
也就是说这个值可被p整除，但不能被q整除。

117
00:08:30,839 --> 00:08:35,333
因此当我计算GCD时，我将会得到的是p。

118
00:08:35,333 --> 00:08:41,102
这是因为P可以将这个值划分开，而q不能。

119
00:08:42,471 --> 00:08:45,262
所以我获得的是N的因子分解。

120
00:08:45,262 --> 00:08:48,946
一旦我有了我能算得的N的因子分解phi（N）

121
00:08:48,946 --> 00:08:55,623
然后鉴于φ(N)我可以自己计算出公钥的解密指数。

122
00:08:55,623 --> 00:08:58,276
所以现在我只要从公钥中恢复出私钥

123
00:08:58,276 --> 00:09:02,634
从一个在解密中发生的简单错误中。

124
00:09:02,634 --> 00:09:05,637
这就是为什么当你做RSA解密时它是一个很好的想法来检查结果

125
00:09:05,637 --> 00:09:09,728
当你用中国剩余定理来加速RSA解密。

126
00:09:10,866 --> 00:09:14,040
我想讨论的最后一个攻击是一个很近期的观察，

127
00:09:14,040 --> 00:09:17,169
被Heninger et al 和 Lenstra et al观察到的

128
00:09:17,169 --> 00:09:22,571
来展示RSA密钥生成模式会出问题当它被一个错的信息熵做的时候。

129
00:09:22,571 --> 00:09:27,968
这里就是事情怎么出错的。Open SSL生成RSA密钥如下。

130
00:09:27,968 --> 00:09:32,440
它是由伪随机数生成器的种子开始的。

131
00:09:32,440 --> 00:09:38,090
然后它使用随机比特从伪随机数生成器生成第一个数p。

132
00:09:38,090 --> 00:09:41,642
那么它将继续，生成更多的种子随机数生成器,

133
00:09:41,642 --> 00:09:45,784
并且将产生一些由伪随机数生成器生成的字符来生成q。

134
00:09:45,784 --> 00:09:48,745
最终，它会输出p和q的生成值。

135
00:09:48,745 --> 00:09:53,680
所以这两步，我们看到种子伪随机数生成器。

136
00:09:53,680 --> 00:09:57,652
现在假设这是被应用在某种形式的路由器或防火墙,

137
00:09:57,652 --> 00:10:02,299
假设密钥生成模式发生在防火墙开启之后。

138
00:10:02,299 --> 00:10:06,250
防火墙启动。在启动的时候，在伪随机数生成器中不会有很多熵。

139
00:10:06,250 --> 00:10:09,901
在伪随机数生成器中不会有很多熵。

140
00:10:09,901 --> 00:10:14,613
因此防火墙很可能生成一个数p，来自一个低熵池。

141
00:10:14,613 --> 00:10:19,004
也就是说这个p将是可能出现的一小组数中的一个。

142
00:10:19,004 --> 00:10:23,774
然而，在我们生成p之后，生成基数会花一点点时间，一些微秒。

143
00:10:23,774 --> 00:10:28,142
到时候防火墙会生成更多的熵

144
00:10:28,142 --> 00:10:31,670
所以当我们把更多的熵加到熵池之后，

145
00:10:31,670 --> 00:10:38,672
基数q会从一个更大的熵池中生成，而且对于这个防火墙是唯一的。

146
00:10:38,672 --> 00:10:44,811
现在的问题许多不同的防火墙都用这种方式生成RSA密钥

147
00:10:44,811 --> 00:10:51,247
导致它们使用了相同的素数p和不同的素数q

148
00:10:51,247 --> 00:10:57,812
如果我们来看两个不同防火墙的RSA模，N1和N2

149
00:10:57,812 --> 00:11:04,116
如果我们计算N1和N2的GCD，当两个都有不同的q和相同的p时

150
00:11:04,116 --> 00:11:08,648
如果我们计算GCD，我们就得到了N1和N2的因式分解

151
00:11:08,648 --> 00:11:14,482
然后我们就能找到N1和N2的私钥

152
00:11:14,482 --> 00:11:16,706
这已经在实践中被观察到了

153
00:11:16,706 --> 00:11:19,792
这两个团队通过扫描网络

154
00:11:19,792 --> 00:11:24,821
恢复了各种网络服务器使用的所有公钥

155
00:11:24,821 --> 00:11:29,069
然后他们计算大量的GCD，并使用了一些算法技巧

156
00:11:29,069 --> 00:11:34,551
使得他们能计算大量的公钥N1和N2对的GCD

157
00:11:34,551 --> 00:11:39,826
他们意识到有相当数量的密钥有相同的因子

158
00:11:39,826 --> 00:11:42,472
所以他们能够分解这些模

159
00:11:42,472 --> 00:11:48,578
在这个试验中，他们实际可以分解0.4%的ssl公钥

160
00:11:48,578 --> 00:11:54,247
这是一个惊人的事实

161
00:11:54,247 --> 00:11:59,367
如此多网络服务器由于碰巧使用低熵生成密钥而存在漏洞

162
00:11:59,367 --> 00:12:02,434
因此它们与其它服务器有相同的因子

163
00:12:02,434 --> 00:12:05,987
求这两个的GCD就得到了因式分解

164
00:12:05,987 --> 00:12:09,200
这给我们的教训是，当你生成密钥时

165
00:12:09,200 --> 00:12:13,535
无论是RSA密钥，或ElGamal密钥，还是对称密钥

166
00:12:13,535 --> 00:12:17,985
很重要的一点是生成器要适当给予种子

167
00:12:17,985 --> 00:12:23,019
所以不要启动后马上生成密钥

168
00:12:23,019 --> 00:12:27,155
你需要保证给予生成器种子有足够时间生成足够熵

169
00:12:27,155 --> 00:12:30,838
然后才开始生成密钥

170
00:12:30,838 --> 00:12:35,707
所以这是一个很好的例子，说明随机数产生器如何搞乱你的RSA公钥的

171
00:12:36,692 --> 00:12:40,316
好的，RSA公钥加密的讨论就结束了

172
00:12:40,316 --> 00:12:44,535
如果你想知道更多，我想提及几个拓展读物

173
00:12:44,535 --> 00:12:48,033
有一篇Victor Shoup的很好的论文讨论了

174
00:12:48,033 --> 00:12:51,318
为什么选择密文安全在公钥设置中如此重要

175
00:12:51,318 --> 00:12:56,737
如果Bleichenbacher攻击说服力不足

176
00:12:56,737 --> 00:13:00,172
如果不使用选择密文安全系统，这里还有一些其他类似可能攻击

177
00:13:00,172 --> 00:13:03,105
那么如果你想知道更多关于选择密文安全的知识

178
00:13:03,105 --> 00:13:05,689
请看Victor Shoup的论文

179
00:13:05,689 --> 00:13:11,439
这是我在几年前写的一个调查，研究了RSA系统的许多不同攻击

180
00:13:11,439 --> 00:13:14,772
我写的时候RSA有20年历史

181
00:13:14,772 --> 00:13:19,257
我需要更新到30年内的RSA系统攻击

182
00:13:19,257 --> 00:13:23,124
近十年来有了一些发展，但这仍然是个很好的调查

183
00:13:23,124 --> 00:13:26,760
可以了解更多的RSA攻击

184
00:13:26,760 --> 00:13:31,800
我在这里提到了OAEP，OAEP的再思考

185
00:13:31,800 --> 00:13:36,306
最后如果你对RSA和其他公钥系统的密钥长度分析感兴趣

186
00:13:36,306 --> 00:13:40,555
这份很好的Arjen Lenstra的论文讨论了如何为公钥系统选择密钥长度

187
00:13:40,555 --> 00:13:44,377
甚至为对称密码选择密钥长度

188
00:13:44,377 --> 00:13:47,739
好的，这就是4个参考资料。希望你有时间看看这些

189
00:13:47,739 --> 00:13:50,596
到这就结束了。下一节我们将会来看

190
00:13:50,596 --> 00:13:54,596
另一种基于离散对数公钥加密系统。【END】

