1
00:00:00,000 --> 00:00:04,528
我们接下来要看的是如何计算大整数的模

2
00:00:04,528 --> 00:00:09,023
首先我们要探讨如何在计算机中表示大整数

3
00:00:09,023 --> 00:00:13,615
这实际上相当简单 所以想象我们在操作64比特的机器

4
00:00:13,615 --> 00:00:18,361
我们要做的是去分解这个我们要表示的数 32位一组

5
00:00:18,361 --> 00:00:22,686
然后我们就会有n/32个组 它们将

6
00:00:22,686 --> 00:00:26,906
表示我们想要在计算机上储存的数 现在我要提到

7
00:00:26,906 --> 00:00:30,705
我只是给出一个64位寄存器作为例子 事实上 很多现代的

8
00:00:30,705 --> 00:00:34,977
处理器拥有128比特或更多比特的寄存器 你甚至可以用它们做乘法

9
00:00:34,977 --> 00:00:38,987
所以通常情况下你 会使用比32位更大的块

10
00:00:38,987 --> 00:00:42,943
原因是 顺便一说 你想要将你自己限制在32比特的块中这样你就可以将

11
00:00:42,943 --> 00:00:46,952
两个块相乘，结果仍然会小于64比特

12
00:00:46,952 --> 00:00:51,189
比机器的字长要短 所以让我们看看特定的算术运算

13
00:00:51,189 --> 00:00:54,788
然后看看每个需要多长 说到加法和减法

14
00:00:54,788 --> 00:00:58,742
基本上你要做的就是加法会进位或者减法会借位

15
00:00:58,742 --> 00:01:03,000
这些基本上是线性时间的操作 换句话说 如果你想要

16
00:01:03,000 --> 00:01:06,954
加或者减两个n比特整数 运算时间基本上

17
00:01:06,954 --> 00:01:12,626
是关于n线性的 乘法运算将需要平方级的时间 事实上

18
00:01:12,626 --> 00:01:16,676
这些算法被称为高中算法 这就是你在学校

19
00:01:16,676 --> 00:01:21,114
稍微学过的东西 如果你花时间考虑几分钟你会发现

20
00:01:21,114 --> 00:01:25,662
这个算法基本上就是两个乘数长度的二次方

21
00:01:25,662 --> 00:01:30,156
所以1960年代的一个大惊喜来是自Karatsuba的算法

22
00:01:30,156 --> 00:01:34,150
它能达到比二次时间更高的效率 事实上，它达到了

23
00:01:34,150 --> 00:01:38,567
n^1.585的运行时间 事实上我向你展示这个算法

24
00:01:38,567 --> 00:01:43,166
如何运作是没有意义的 我就提一下Karastuba的发现里的

25
00:01:43,166 --> 00:01:48,071
主要思想 就是如果你乘两个数 你可以

26
00:01:48,071 --> 00:01:52,976
把它们写作 你可以把第一个数字x 写作(2^b)*x2+x1

27
00:01:52,976 --> 00:01:57,882
x2和x1大约是x的平方根的大小

28
00:01:57,882 --> 00:02:02,910
我们可以把数x分成x的左半部分和x的右半部分

29
00:02:02,910 --> 00:02:07,654
基本上你 你写x就像是写2^b 所以

30
00:02:07,654 --> 00:02:12,398
这里有两个数字2^b 然后你对数字y做同样的操作 你用2^b表示y

31
00:02:12,398 --> 00:02:16,911
同样的 你应该把它写成 左半部分和右半部分的和

32
00:02:16,911 --> 00:02:21,540
然后通常情况下 如果你试着做这个乘法 如果你打开

33
00:02:21,540 --> 00:02:27,486
这个括号 你看它会需要四次乘法

34
00:02:27,486 --> 00:02:33,365
它需要x2*y2，x2*y1，x1*y2，和x1*y1

35
00:02:33,365 --> 00:02:39,879
Karatsuba发现有一种做这个乘法的方法只需要

36
00:02:39,879 --> 00:02:45,847
乘三次x1 x2 y1 y2 所以它只是一个x*y的大乘法

37
00:02:45,847 --> 00:02:50,214
只需要3次简单的乘法 你现在可以递归地

38
00:02:50,214 --> 00:02:55,087
应用相同的过程来乘x2和y2，还有x2和y1 等等

39
00:02:55,087 --> 00:02:59,960
你会得到这个递归算法 如果你

40
00:02:59,960 --> 00:03:05,087
做一下递归分析 你会发现基本上你会用到n^1.585的运行时间

41
00:03:05,087 --> 00:03:13,640
这个数基本上是 1.585基本上是以2为底3的对数

42
00:03:13,640 --> 00:03:17,836
令人惊讶的是 原来Karatsuba在这里也不是最好的乘法

43
00:03:17,836 --> 00:03:23,912
算法 事实证明 你可以在约为n*logn的时间内做乘法

44
00:03:23,912 --> 00:03:28,678
所以你几乎可以在线性时间里做乘法 然而,这是一个极其近似结果。

45
00:03:28,678 --> 00:03:31,477
这里的大写O隐藏着很大的常量 而且作为结果来说

46
00:03:31,477 --> 00:03:35,452
这个算法仅仅在数绝对庞大的时候有用

47
00:03:35,452 --> 00:03:39,152
所以实际上这种算法并不经常被使用

48
00:03:39,152 --> 00:03:43,183
但是Karatstba的算法就非常实用 事实上 很多密码类库

49
00:03:43,183 --> 00:03:47,885
使用Karatsuba的算法做乘法 然而 为了简单一些

50
00:03:47,885 --> 00:03:51,923
我准备忽略Karatsuba的算法 只是为了简单起见

51
00:03:51,923 --> 00:03:55,960
我要假设这乘法在平方级时间内运行 但是在你脑海里

52
00:03:55,960 --> 00:03:59,893
你要时刻记得所有乘法运算都是比平方级时间要快的

53
00:03:59,893 --> 00:04:04,794
然后乘法后的下一个问题是关于

54
00:04:04,794 --> 00:04:10,297
有余除法 原来这也是个平方级时间的运算

55
00:04:10,297 --> 00:04:15,420
所以主要操作不变 而且也是我们用过很多次的

56
00:04:15,420 --> 00:04:20,346
我从未 确实从未 曾经告诉你们该如何去计算它 这是

57
00:04:20,346 --> 00:04:26,339
一个有关幂运算的问题 所以让我们来更加抽象地解决这个幂运算的问题

58
00:04:26,339 --> 00:04:31,558
想象我们有一个有限循环群G 这意味着

59
00:04:31,558 --> 00:04:37,115
这个群由一些有限生成元g的幂产生 比如

60
00:04:37,115 --> 00:04:42,673
简单想象这个群Z*_p 想象小g作为大G的某个生成元

61
00:04:42,673 --> 00:04:48,886
我这样做的原因是 我希望你可以习惯

62
00:04:48,886 --> 00:04:54,023
这个抽象概念 我们在处理一般的群G 而ZP真的只是

63
00:04:54,023 --> 00:04:58,915
这种群的一个例子 但是 事实上 还有很多其他有限循环群的例子

64
00:04:58,915 --> 00:05:03,379
我还要重申基本上这个群G 只简单地

65
00:05:03,379 --> 00:05:08,087
是这个生成元的幂数排列到群的阶数组成的群

66
00:05:08,087 --> 00:05:15,153
我将它写成g的q次方 所以现在我们的目标是基于这种元素g 和一些

67
00:05:15,153 --> 00:05:20,797
指数x 我们的目标是计算g^x的值 所以通常

68
00:05:20,797 --> 00:05:24,810
你要说 你要想的是 如果 x=3

69
00:05:24,810 --> 00:05:28,898
然后我将去计算g立方 这真的没什么关系

70
00:05:28,898 --> 00:05:32,795
我要做的只是g乘g乘g 然后我得到了g的立方 这就是我要的

71
00:05:32,795 --> 00:05:36,790
所以这是很简单的 但是实际上 这不是我们感兴趣的东西

72
00:05:36,790 --> 00:05:40,638
对我们来说 我们的指数会是很大的 而且如果你去尝试

73
00:05:40,638 --> 00:05:45,644
想象一个500比特的数 如果你试着去计算g的一个五百比特数的次方

74
00:05:45,644 --> 00:05:50,710
只是简单地做乘法g乘g乘g乘g 这需要很长时间

75
00:05:50,710 --> 00:05:55,716
事实上它将花费指数级的时间 这不是我们想要的

76
00:05:55,897 --> 00:06:00,722
所以问题是尽管x非常大 我们是否依然能够比较快地计算出

77
00:06:00,722 --> 00:06:05,667
g^x 答案是可以的 相应的算法

78
00:06:05,667 --> 00:06:10,822
叫做重复平方算法 现在让我向你们展示下重复平方算法是如何工作的

79
00:06:10,822 --> 00:06:15,593
让我们看一个例子 x=53 你将要计算

80
00:06:15,593 --> 00:06:20,295
53个g的乘积 g*g*g... 直到第53个g 但是我想向你们

81
00:06:20,295 --> 00:06:25,275
展示如何能很快的完成它 我们要做的是 将53写成二进制

82
00:06:25,275 --> 00:06:30,497
所以这就是53的二进制表示 这意味着

83
00:06:30,497 --> 00:06:36,282
注意这个1代表32 这个1代表16

84
00:06:36,282 --> 00:06:41,292
这个1代表4 这个1代表1 所以事实上

85
00:06:41,292 --> 00:06:47,038
53=31+16+4+1 这意味着g^53=g^(32+16+4+1)

86
00:06:47,038 --> 00:06:51,801
我们可以把它分开 再一次使用指数的运算法则

87
00:06:51,801 --> 00:06:57,235
我们可以把那个分成(g^32)*(g^16)*(g^4)*(g^1)

88
00:06:57,235 --> 00:07:02,938
现在这应该能给你一个如何快速计算g^53的主意了

89
00:07:02,938 --> 00:07:07,141
我们要做的就是 简单地 将g平方

90
00:07:07,141 --> 00:07:11,459
得到g^2 再将它平方得到g^4

91
00:07:11,459 --> 00:07:15,778
再得到g^8 g^16 g^32

92
00:07:15,778 --> 00:07:20,607
所以我们已经计算完了所有对g的平方 现在我们要做的是

93
00:07:20,607 --> 00:07:25,719
将合适的幂相乘来得到g^53 也就是

94
00:07:25,719 --> 00:07:30,390
(g^1)*(g^4)*(g^16)*(g^32)

95
00:07:30,390 --> 00:07:35,376
这就得到了我们想要的值 也就是g^53 所以在这你看到

96
00:07:35,376 --> 00:07:40,173
我们所做的仅是计算 看一下 我们要做1 2 3 4

97
00:07:40,173 --> 00:07:49,343
5次平方 加上4次额外的乘法 所以通过9次乘法运算 我们计算出了

98
00:07:49,343 --> 00:07:53,726
g^53 这很有趣 而且这是一个普遍的现象

99
00:07:53,726 --> 00:07:58,253
我们能够很快地将g的幂数升到非常高

100
00:07:58,253 --> 00:08:02,509
让我给你们演示一下这个算法 正如我说过的 这叫做重复平方算法

101
00:08:02,509 --> 00:08:06,497
这个算法的输入是元素g

102
00:08:06,497 --> 00:08:10,858
和指数x 输出是g^x 我们要做的是

103
00:08:10,858 --> 00:08:15,415
将x写成二进制记法 让我们假设x有n位

104
00:08:15,415 --> 00:08:19,521
这就是x的二进制表示 然后我们做如下事情

105
00:08:19,521 --> 00:08:24,246
我们要使用两个寄存器 y是一个总做平方的寄存器

106
00:08:24,246 --> 00:08:28,127
z是一个累加器 它将所需的不同次幂的g相乘

107
00:08:28,127 --> 00:08:32,683
我们要做的就是按照x的位循环遍历

108
00:08:32,683 --> 00:08:36,526
从最低位开始 然后我们这样做

109
00:08:36,526 --> 00:08:41,414
在每次迭代中我们就将y平方 所以y在每次迭代中

110
00:08:41,414 --> 00:08:45,940
一直被平方 然后当指数x中相应位数为1时

111
00:08:45,940 --> 00:08:50,554
我们就将y的当前值累乘到

112
00:08:50,554 --> 00:08:55,173
累加器z中 最后输出z 就是这样

113
00:08:55,173 --> 00:08:59,558
这就是整个算法 这就是重复平方算法

114
00:08:59,558 --> 00:09:04,060
让我们看一个g^53的例子 大家看这两列

115
00:09:04,060 --> 00:09:08,387
每次迭代y的变化是一列 z是另一列

116
00:09:08,387 --> 00:09:13,064
表示它在迭代过程中的变化 y不是很有意思 基本上

117
00:09:13,064 --> 00:09:17,449
每轮迭代y的变化就是被平方

118
00:09:17,449 --> 00:09:22,299
所以它以2的次数为指数变化

119
00:09:22,299 --> 00:09:26,915
z是一个更有趣的寄存器 它所做的是 只要指数相应位为1

120
00:09:26,915 --> 00:09:31,882
就将相应幂的g指数累乘 比如

121
00:09:31,882 --> 00:09:36,031
指数的第一位是1 所以第一次迭代后

122
00:09:36,031 --> 00:09:41,219
z的值为g 指数的第二位为0

123
00:09:41,219 --> 00:09:46,473
所以第二次迭代后z的值不发生变化 第三次迭代后

124
00:09:46,473 --> 00:09:51,856
因为指数的第三位是1 所以我们将g^4乘进z

125
00:09:51,856 --> 00:09:56,662
指数的下一位是0 所以z不会变化

126
00:09:56,662 --> 00:10:02,109
指数的再下一位是1 所以我们应该将前面的y值

127
00:10:02,109 --> 00:10:07,491
乘进累加器z 让我来问你 z的值将会是多少

128
00:10:10,868 --> 00:10:14,245
我们将g^16累乘进z 计算出

129
00:10:14,245 --> 00:10:19,594
16+5 然后我们得到了g^21 最后一位也是1

130
00:10:19,594 --> 00:10:24,943
所以我们把它乘进z 计算32+21 就得到了最终的输出g^53

131
00:10:24,943 --> 00:10:30,022
这就是一个重复平方算法如何进行的思路

132
00:10:30,022 --> 00:10:35,777
这是一个挺有趣的算法 它允许我们以非常非常快的速度计算

133
00:10:35,777 --> 00:10:41,064
g的极高次幂 所以这里迭代的次数 本质上将会是

134
00:10:41,064 --> 00:10:46,456
以2为底x的对数 你会注意到迭代的次数仅取决于

135
00:10:46,456 --> 00:10:51,954
x的二进制位数 也就是log_2(x) 所以就算x有

136
00:10:51,954 --> 00:10:56,519
500位 要做500次乘法 也就是500迭代 实际上是1000乘法

137
00:10:56,519 --> 00:11:01,736
因为我们必须进行平方和累乘 所以通过1000次乘法运算

138
00:11:01,736 --> 00:11:06,627
我们能够将指数g的幂升到500位

139
00:11:06,627 --> 00:11:12,760
好 现在我们能够总结出它的运行时间 假设我们

140
00:11:12,760 --> 00:11:17,680
有一个n位模 正如我们说过的 zn上的加减法需要线性时间

141
00:11:17,680 --> 00:11:22,157
乘法 我说过 Karatsuba让乘法计算更有效

142
00:11:22,157 --> 00:11:26,897
但是为了简单起见 我们仅说乘法需要平方级时间

143
00:11:26,897 --> 00:11:31,579
然后指数运算 基本上需要logx次迭代

144
00:11:31,579 --> 00:11:35,509
在每一次迭代中 我们做两次乘法 所以是O(log (x)*T(x))

145
00:11:35,509 --> 00:11:40,307
让我们说乘法需要的是平方级时间

146
00:11:40,307 --> 00:11:44,758
所以运行时间将会是(n^2)logx 根据Fermat定理 x总是会比N小

147
00:11:44,758 --> 00:11:49,168
所以没有必要去计算g大于模数次的幂

148
00:11:49,168 --> 00:11:53,958
所以x会比N小 让我们假设

149
00:11:53,958 --> 00:11:58,570
x也是N位整数 那么 实际上指数运算是立方级时间算法

150
00:11:58,570 --> 00:12:02,970
这是我想让你们记住的 指数运算实际上速度

151
00:12:02,970 --> 00:12:07,163
比较慢 现在 它在现代计算机上实际需要几毫秒

152
00:12:07,163 --> 00:12:11,259
但是 毫秒对比如说一个4Ghz的处理器来说依然

153
00:12:11,259 --> 00:12:15,092
是很大的工作量 所以要记住所有我们讨论的

154
00:12:15,092 --> 00:12:19,556
指数运算操作 比如 判断一个数是否是二次剩余的

155
00:12:19,556 --> 00:12:23,600
所有这些 所有指数运算基本上都花费立方级时间

156
00:12:24,780 --> 00:12:29,677
好了 这就完成了我们对算术算法的讨论

157
00:12:29,677 --> 00:12:34,078
在下一节我们将开始讨论困难问题 模数运算 质数和合数。【END】

