1
00:00:00,000 --> 00:00:03,567
在接下来的三部分里，
我们稍微改变一下讨论内容

2
00:00:03,567 --> 00:00:07,224
来讨论一下PRG的定义。
这个定义真的是一种很好的理解PRG的方式

3
00:00:07,224 --> 00:00:10,784
并且我们能看到这个定义的很多应用。

4
00:00:10,784 --> 00:00:15,943
那么令PRG有秘钥空间K，输出N比特序列。
我们的目标是定义,

5
00:00:15,943 --> 00:00:20,592
什么叫做“无法区分出生成器的输出和随机序列”？

6
00:00:20,592 --> 00:00:25,687
换句话说，我们要定义一个分布

7
00:00:25,687 --> 00:00:30,781
从秘钥空间里随机选取秘钥。
记住上面那个带R的箭头意味着

8
00:00:30,781 --> 00:00:35,813
从集合K中随机地选取，
然后我们用这个生成器的输出。

9
00:00:35,813 --> 00:00:40,710
并且我们所说的就是这个分布

10
00:00:40,710 --> 00:00:44,757
这个伪随机序列分布和
真正的均匀分布没有区别

11
00:00:44,757 --> 00:00:49,927
换句话说，如果我们仅选择一个真正均匀的0，1

12
00:00:49,927 --> 00:00:55,096
N位序列并且输出这个序列，我们说这两个分布

13
00:00:55,096 --> 00:01:00,139
没有区别。大家现在想想，

14
00:01:00,139 --> 00:01:05,246
这真的很令人吃惊，
因为如果我们画一个圈表示所有n位0, 1序列，

15
00:01:05,246 --> 00:01:10,541
那么均匀分布能够等概率输出这些序列

16
00:01:10,541 --> 00:01:15,161
这就是均匀分布的定义。然而

17
00:01:15,161 --> 00:01:20,661
这个生成器G生成的伪随机分布，
由于种子空间很小，

18
00:01:20,661 --> 00:01:25,673
可能输出的集合是非常小的

19
00:01:25,673 --> 00:01:30,623
是N位0, 1序列集合中很小的子集。
这就是这个生成器能输出的全部。

20
00:01:30,623 --> 00:01:35,698
然而我们讨论，
攻击者看到了生成器的输出的

21
00:01:35,698 --> 00:01:40,836
小集合的元素，
却无法区分它和均匀分布输出的

22
00:01:40,836 --> 00:01:45,703
整个集合的元素，
我想这就是我们真正想要的性质

23
00:01:45,703 --> 00:01:50,026
因此要理解和定义这个无法区分的概念

24
00:01:50,026 --> 00:01:54,350
我们需要“统计测试”的概念。
因此让我来定义一下

25
00:01:54,350 --> 00:01:59,030
N位01序列的统计测试是什么。
我会用字母A来表示这些统计测试

26
00:01:59,030 --> 00:02:03,924
统计测试是一个算法，

27
00:02:03,924 --> 00:02:08,486
用N比特序列的输入，输出0或1。
现在我告诉大家0，

28
00:02:08,486 --> 00:02:13,110
我们认为作为统计测试的输出，它表示

29
00:02:13,110 --> 00:02:18,150
你的输入不是随机的。
而1，我们把它想象成统计测试说

30
00:02:18,150 --> 00:02:23,196
你的输入是随机的。好，统计测试所做的是

31
00:02:23,196 --> 00:02:27,939
用给它的输入：n比特序列x

32
00:02:27,939 --> 00:02:32,803
来判断它看起来是不是随机的。

33
00:02:32,803 --> 00:02:37,849
让我们看几个例子，
第一个例子会用一个事实：

34
00:02:37,849 --> 00:02:42,835
在一个随机序列中，
0的个数大致等于1的个数

35
00:02:42,835 --> 00:02:47,248
换句话说，统计测试输出1。

36
00:02:47,248 --> 00:02:54,514
当且仅当序列X中0的个数减去1的个数

37
00:02:54,514 --> 00:02:59,837
个数不会差太多，换句话说

38
00:02:59,837 --> 00:03:05,225
0的个数和1的个数的差别，

39
00:03:05,225 --> 00:03:10,614
我们说是小于10倍根号n的。
好，如果差别小于10倍的根号n

40
00:03:10,614 --> 00:03:15,082
统计测试认为X序列看起来是随机的。

41
00:03:15,082 --> 00:03:20,602
如果差别碰巧比10倍的根号n大得多

42
00:03:20,602 --> 00:03:25,991
那就看起来很可疑，
测试认为你给的序列不是

43
00:03:25,991 --> 00:03:31,403
随机的，这是一个统计测试。
让我们看另一个相似的例子

44
00:03:31,403 --> 00:03:36,785
在这里，统计测试说1，当且仅当

45
00:03:36,785 --> 00:03:41,838
X序列中出现连续两个0的次数，我们想一想

46
00:03:41,838 --> 00:03:46,766
数一数，n比特序列中，

47
00:03:46,766 --> 00:03:51,734
数一下00出现的次数。
连续的两个0

48
00:03:51,734 --> 00:03:56,804
对一个随机序列，我们期望看到00的概率是四分之一

49
00:03:56,804 --> 00:04:03,535
对于一个随机序列，我们期望四分之N个00。
是的，四分之N的00。

50
00:04:03,535 --> 00:04:08,133
那么，统计测试会做的是，它会说，

51
00:04:08,133 --> 00:04:12,604
如果00的个数近似等于四分之N，

52
00:04:12,604 --> 00:04:17,254
换句话说00的个数和四分之N
的差别小于10倍的根号n

53
00:04:17,254 --> 00:04:22,005
我们就说X看起来是随机的。
如果差别比四分之N大得多

54
00:04:22,005 --> 00:04:26,309
我们就说这个序列不是随机的。

55
00:04:26,309 --> 00:04:31,097
然后统计测试就会输出0，对吧？
这就是两个统计测试的例子

56
00:04:31,097 --> 00:04:35,703
对于随机序列，测试会以极大概率输出1

57
00:04:35,703 --> 00:04:40,067
但是对于一些序列，你懂得，
那些不随机的序列，比如

58
00:04:40,067 --> 00:04:44,856
全0序列。对于全0序列，这些测试

59
00:04:44,856 --> 00:04:49,986
没有一个会输出1。并且事实上，
全0序列看起来也不随机(好冷的笑话-_-!)

60
00:04:49,986 --> 00:04:55,098
让我们再看一个统计测试的例子

61
00:04:55,098 --> 00:05:00,993
来给大家展示统计测试
能够正确得出我们想要的结果

62
00:05:00,993 --> 00:05:06,745
这是第三个例子。
我们说统计测试输出1，

63
00:05:06,745 --> 00:05:12,497
当且仅当最大的块，
我们称之为x序列中0的最大游程

64
00:05:12,497 --> 00:05:17,950
是x序列中最长的0序列

65
00:05:17,950 --> 00:05:23,336
在随机序列中，你希望最长0序列近似等于

66
00:05:23,336 --> 00:05:28,449
log N(以2为底)。我们说如果最长0游程

67
00:05:28,449 --> 00:05:32,814
碰巧小于10倍log N，
测试就认为X序列是随机的。

68
00:05:32,814 --> 00:05:37,160
但是如果突然我们看到
一个0的游程比10倍log N大得多

69
00:05:37,160 --> 00:05:41,733
测试就认为X序列是不随机的，对吧？这是另一个

70
00:05:41,733 --> 00:05:46,192
统计测试的奇妙例子。顺便说一下，
大家注意到，如果你

71
00:05:46,192 --> 00:05:50,444
给定这个测试一个全1序列，就是11111。

72
00:05:50,444 --> 00:05:55,370
测试也会输出1。
换句话说测试认为全1序列是随机的

73
00:05:55,370 --> 00:05:59,735
即便它不是，即使全1序列不是随机的

74
00:05:59,735 --> 00:06:04,068
好，统计测试不一定是对的(-_-!)。
它们只是做它们想做的事

75
00:06:04,068 --> 00:06:08,149
它们能测试，能判断输出是是不是随机的。

76
00:06:08,149 --> 00:06:11,776
你知道不管是0或1，
类似的，这有很多其他统计测试

77
00:06:11,776 --> 00:06:15,857
一个人能做数百个统计测试来测试

78
00:06:15,857 --> 00:06:19,737
我能告诉大家在以前，

79
00:06:19,737 --> 00:06:23,663
你定义某物看起来随机的方法，
你会说有很多统计测试

80
00:06:23,663 --> 00:06:27,754
所有测试说这个序列像是随机的。

81
00:06:27,754 --> 00:06:31,896
因此我们认为生成这个序列的生成器很不错

82
00:06:31,896 --> 00:06:36,091
换句话说，这个用很多统计测试来定义的方法

83
00:06:36,091 --> 00:06:40,364
对更一般的密码学来说，
实际上在安全方面不是一个好定义。

84
00:06:40,364 --> 00:06:45,290
但是在我们谈论安全定义之前，
我们还需要讨论我们如何评估

85
00:06:45,290 --> 00:06:50,040
一个统计测试是好是坏？
为此，我们定义优势的概念。

86
00:06:50,040 --> 00:06:54,321
那么我来定义优势的意思。我们有一个

87
00:06:54,321 --> 00:06:59,188
输出N比特序列的生成器，
我们对这N比特序列做个统计测试。

88
00:06:59,188 --> 00:07:04,578
然后我们定义这个生成器的优势，
用优势子PRG来表示

89
00:07:04,578 --> 00:07:10,313
统计测试A相对于生成器g的优势

90
00:07:10,313 --> 00:07:16,121
我会像下面这样定义它，
定义为两个量之间的差距。

91
00:07:16,121 --> 00:07:21,679
第一个量是统计测试输出1的概率。

92
00:07:21,679 --> 00:07:27,007
当我们输入一个随机序列，
就比如从C空间里均匀选取的K

93
00:07:27,007 --> 00:07:32,403
我们考虑统计测试输出1的概率，当我们

94
00:07:32,403 --> 00:07:37,799
输入由生成器产生的伪随机序列

95
00:07:37,799 --> 00:07:43,532
同时我们要看当我们输入
真随机序列时统计测试输出1的概率

96
00:07:43,532 --> 00:07:48,174
那么这里是n位真随机的01序列，
好，我们来看

97
00:07:48,174 --> 00:07:52,447
这两个量之间的差。现在大家看到

98
00:07:52,447 --> 00:07:56,720
因为是概率的差，优势总是体现在

99
00:07:56,720 --> 00:08:00,733
[0,1]区间里。那么大家稍微想想
这个优势意味着什么

100
00:08:00,733 --> 00:08:05,138
首先，如果优势接近1

101
00:08:05,138 --> 00:08:09,580
什么意思呢？意思就是统计测试A

102
00:08:09,580 --> 00:08:14,620
会有不同的结果，
当我们输入伪随机序列

103
00:08:14,620 --> 00:08:19,175
和生成器产生的真随机序列时，对吧？

104
00:08:19,175 --> 00:08:23,790
它表现的不同。在一种情况下，
它以一定概率输出1

105
00:08:23,790 --> 00:08:28,344
另一种情况下，它会以完全不同的概率输出1，对吧？

106
00:08:28,344 --> 00:08:32,778
它就能表现地不同。这些真正想表达的是

107
00:08:32,778 --> 00:08:37,211
这个统计测试能将这个生成器的输出

108
00:08:37,211 --> 00:08:42,877
和随机序列区分开。好，在某种意义上，
我们认为这个统计测试

109
00:08:42,877 --> 00:08:47,053
破解了生成器G，
因为它能够区分生成序列和随机序列

110
00:08:47,053 --> 00:08:51,975
而这个优势和0很接近，又是什么意思？

111
00:08:51,975 --> 00:08:56,451
这意味着统计测试在伪随机输入

112
00:08:56,451 --> 00:09:01,222
和真随机输入两种情况下表现一致。
我们基本上可以说A

113
00:09:01,222 --> 00:09:05,773
不能区分生成器的输出和真随机的输出。
好，这个总结可以给大家

114
00:09:05,773 --> 00:09:10,289
一点直观感受，为什么优势这一概念如此重要

115
00:09:10,289 --> 00:09:15,222
它告诉我们A是否能够破解这个生成器，
即区分出随机性。

116
00:09:15,222 --> 00:09:19,917
否则就不能破解它。
那么我们首先再看一个很傻的例子

117
00:09:19,917 --> 00:09:24,671
设想我们有一个统计测试A，不管输入什么

118
00:09:24,671 --> 00:09:29,496
总是输出0。好的，总是输出0。大家认为

119
00:09:29,496 --> 00:09:33,742
这个相对于生成器G的统计测试的优势是什么？

120
00:09:33,742 --> 00:09:37,932
那么我希望大家都能认为优势是0，
让我来解释一下为什么是这种情况

121
00:09:37,932 --> 00:09:41,791
如果在统计测试中总是输出0

122
00:09:41,791 --> 00:09:45,982
这意味着，输入伪随机序列
是一定不会输出1的，所以

123
00:09:45,982 --> 00:09:50,282
输出1的概率是零。相似的，
当我们输入真随机序列时，它仍然

124
00:09:50,282 --> 00:09:54,527
不会输出1，并且输出1的概率还是0

125
00:09:54,527 --> 00:09:58,772
所以0减0等于0，它的优势也就是0。

126
00:09:58,772 --> 00:10:03,128
那么这个不看输入的统计测试明显不能区分

127
00:10:03,128 --> 00:10:07,441
真随机和伪随机序列。好，我们来看

128
00:10:07,441 --> 00:10:12,861
一个更有趣的例子。
假设我们有一个生成器G

129
00:10:12,861 --> 00:10:17,671
满足一个有趣的性质：
对于三分之二的秘钥

130
00:10:17,671 --> 00:10:22,892
生成器输出的第一位碰巧是1，对吧？
所以如果我选一个随机秘钥

131
00:10:22,892 --> 00:10:28,176
生成器会以三分之二的概率，第一位输出1，对吧？

132
00:10:28,176 --> 00:10:33,333
那么这就是我们看到的这个生成器的性质。
现在我们来看

133
00:10:33,333 --> 00:10:37,790
下面的统计测试。这个测试是这样的

134
00:10:37,790 --> 00:10:42,883
如果这个序列的最高位是1，就输出1

135
00:10:42,883 --> 00:10:48,167
我会认为它是随机的。
如果输入的最高位不是1

136
00:10:48,167 --> 00:10:53,969
而是0，就输出0。好那么问题来了

137
00:10:53,969 --> 00:10:59,625
对于生成器G的统计测试的优势是什么？

138
00:10:59,625 --> 00:11:04,552
我再在这里写一遍定义，
并且大家可以想一想

139
00:11:04,552 --> 00:11:09,933
那么我来解释一下，
假设我们对这个统计测试输入伪随机序列

140
00:11:09,933 --> 00:11:14,568
根据G的定义，我们知道有三分之二的概率

141
00:11:14,568 --> 00:11:19,625
输入的第一位是1。但如果以1开始

142
00:11:19,625 --> 00:11:24,320
那统计测试就会输出1。换句话说

143
00:11:24,320 --> 00:11:29,196
统计测试输出1的概率严格为三分之二。

144
00:11:29,196 --> 00:11:33,831
我们来看一下随机序列的情况。
如果我输入一个随机序列，

145
00:11:33,831 --> 00:11:38,346
最高位是1的概率是多少？
好，对于这个随机序列

146
00:11:38,346 --> 00:11:43,342
概率是约为一半，
并且这种情况下统计测试会输出1，

147
00:11:43,342 --> 00:11:47,918
概率是二分之一。所以总的优势是六分之一

148
00:11:47,918 --> 00:11:52,553
六分之一实际上是一个不可忽略的数字，
是一个相当大的数，

149
00:11:52,553 --> 00:11:57,490
这意味着生成器能够区分输出了。

150
00:11:57,490 --> 00:12:03,314
我们可以认为A以六分之一的优势破解了生成器G。

151
00:12:03,314 --> 00:12:08,292
这说明这个生成器不好，被破解了。
那么我们现在理解了

152
00:12:08,292 --> 00:12:13,521
统计测试是什么了，我们来更进一步定义，

153
00:12:13,521 --> 00:12:19,191
什么是一个安全伪随机生成器。
那么我们说生成器G是安全的

154
00:12:19,191 --> 00:12:24,935
如果本质上没有有效的统计测试

155
00:12:24,935 --> 00:12:30,311
能区分G的输出和随机序列。
更精确地说，所有有效的

156
00:12:30,311 --> 00:12:36,423
统计测试，A..统计测试，A..如果我看

157
00:12:36,423 --> 00:12:42,496
统计测试E对于生成器G的优势。

158
00:12:42,496 --> 00:12:47,246
这个优势是可以忽略的。换句话说，
它非常接近于0，作为结果来说

159
00:12:47,246 --> 00:12:52,103
这个统计测试不能区分生成器的输出序列和随机序列

160
00:12:52,103 --> 00:12:56,961
这对于所有统计测试都是对的。
因此这是一个非常非常完美

161
00:12:56,961 --> 00:13:01,211
优雅的定义，它说明了生成器是安全的，

162
00:13:01,211 --> 00:13:06,129
不仅一些特定的统计测试认为它的输出是随机的

163
00:13:06,129 --> 00:13:10,929
事实上所有有效的统计测试都认为输出是随机的，对吧？

164
00:13:10,929 --> 00:13:15,992
我想指出的一点是，有效统计测试的限制

165
00:13:15,992 --> 00:13:20,934
是必须的。如果我们考虑的所有的统计测试，

166
00:13:20,934 --> 00:13:25,836
不管是否是有效的，
它们就不能够区分生成器的输出序列和随机序列了。

167
00:13:25,836 --> 00:13:30,469
事实上，这是无法被满足的。
换句话说，如果我们

168
00:13:30,469 --> 00:13:34,826
去掉测试是有效的要求，那么这个定义

169
00:13:34,826 --> 00:13:39,484
无法被满足。我把这点留给大家
当做一个小问题思考一下

170
00:13:39,484 --> 00:13:43,851
但是实际上限制定义在有效的

171
00:13:43,851 --> 00:13:48,625
统计测试范围内是必要的，
这样定义才能被满足

172
00:13:48,625 --> 00:13:53,341
现在我们有了这个定义，
下一个问题就是我们能否构造一个生成器

173
00:13:53,341 --> 00:13:57,533
并且证明它实际上是安全的PRG。
换句话说，就是证明

174
00:13:57,533 --> 00:14:02,366
没有有效的统计测试能区分
生成器的输出序列和随机序列。

175
00:14:02,366 --> 00:14:07,022
而答案是我们不能，实际上不能知道

176
00:14:07,022 --> 00:14:12,627
是否有任何可能的安全PRG。
我来说一个简单的理由：

177
00:14:12,627 --> 00:14:18,301
如果你能证明一个特定的生成器是安全的，

178
00:14:18,301 --> 00:14:23,455
那意味着P不等于NP。我不想在这个地方纠结。
因为我不想

179
00:14:23,455 --> 00:14:28,706
假定大家都知道P和NP是什么。
但我会简单告诉大家

180
00:14:28,706 --> 00:14:33,420
事实是P是等于NP的。
显而易见的是没有安全的PRG。

181
00:14:33,420 --> 00:14:37,858
如果大家能够证明给我看看一个特定的PRG是安全的

182
00:14:37,858 --> 00:14:41,913
那意味着P不等于NP。我会把这个

183
00:14:41,913 --> 00:14:45,858
再当做一个问题留给大家思考。
但是尽管我们实际上不能

184
00:14:45,858 --> 00:14:50,297
严格证明一个特定的PRG是安全的，
我们任然有很多候选方案，

185
00:14:50,297 --> 00:14:54,406
我们之前甚至看到过一些

186
00:14:54,406 --> 00:14:59,289
好，现在我们理解了什么是一个安全的PRG。
我想稍微讨论一下

187
00:14:59,289 --> 00:15:03,558
这个定义的一些应用以及含义。那么

188
00:15:03,558 --> 00:15:08,308
我想给大家看的第一件事
实际上是一个安全的PRG

189
00:15:08,308 --> 00:15:12,884
是不可预测的。在前面一节，
我们讨论了一个生成器

190
00:15:12,884 --> 00:15:17,114
不可预测是什么意思。
我们说，这个意思是

191
00:15:17,114 --> 00:15:21,508
给定生成器输出的前一部分，
我们不能预测下一位输出

192
00:15:21,508 --> 00:15:25,902
好，我们想要表明一个生成器是否安全，

193
00:15:25,902 --> 00:15:30,176
必须意味着它是不可预测的。
唯一的方式就是使用逆否命题。

194
00:15:30,176 --> 00:15:34,254
也就是说，如果你给出一个可预测的生成器

195
00:15:34,254 --> 00:15:37,971
那么它是不安全的。换句话说

196
00:15:37,971 --> 00:15:42,050
我能区分生成器的输出和随机序列的输出。
我们来看看，这是一个简单的事实。

197
00:15:42,050 --> 00:15:46,077
我们看看我们怎么用这个事实。
假定你给出一个预测

198
00:15:46,077 --> 00:15:50,000
换句话说，假定你给出一个有效的算法，
像这样，事实上

199
00:15:50,000 --> 00:15:54,234
如果我把生成器的输出作为算法的输入，

200
00:15:54,234 --> 00:15:58,599
但我只输入输出序列的前i比特。
它能够预测下一比特的输出。

201
00:15:58,599 --> 00:16:03,664
换句话说，给定的前出i比特能够预测i+1位

202
00:16:03,664 --> 00:16:08,827
该算法能够以一定概率实现。
因此我们说如果我们从秘钥空间选择一个随机的k

203
00:16:08,827 --> 00:16:13,367
然后预测机就能够

204
00:16:13,367 --> 00:16:18,138
以一半的概率预测下一位。
简单地猜下这些比特，

205
00:16:18,138 --> 00:16:22,391
你能有一半的概率正确。
然而算法A也能够

206
00:16:22,391 --> 00:16:27,053
一以二分之一加ε的概率预测下一位。
因此它是被这样界定的。

207
00:16:27,053 --> 00:16:31,726
实际上，我们要求这对某些不能忽略的ε成立

208
00:16:31,726 --> 00:16:36,338
比如，ε=1/1000，这会是一个危险的预测机，

209
00:16:36,338 --> 00:16:40,949
因为它能在给定前缀时，
以不可忽略的优势预测下一位

210
00:16:40,949 --> 00:16:45,533
假定我们有这样一个算法，
我们来看我们能用这个算法

211
00:16:45,533 --> 00:16:50,010
来破解我们的生成器。
换句话说，是为了表明一个生成器是和

212
00:16:50,010 --> 00:16:54,146
随机序列可以区分的，因此是不安全的。
那么我们要做的是定义一个统计测试。

213
00:16:54,146 --> 00:16:59,463
我们按如下方式定义统计测试B：

214
00:16:59,463 --> 00:17:04,979
给定序列x，接下来要做的是

215
00:17:04,979 --> 00:17:10,711
对给定的x序列前i比特使用算法A。
而统计测试B简单地来检测

216
00:17:10,711 --> 00:17:16,662
算法A是否成功地预测了第i+1位？

217
00:17:16,662 --> 00:17:22,579
如果是成功的，它就会输出1。
如果不成功，它就会输出0。

218
00:17:22,579 --> 00:17:28,154
好，这就是我们的统计任务。
让我们把它放在一个盒子中，

219
00:17:28,154 --> 00:17:33,407
这样我们能随意得使用它。
并且我们能用任意N比特

220
00:17:33,407 --> 00:17:38,466
序列作为输入运行统计测试。
现在我们来看看发生了什么。

221
00:17:38,466 --> 00:17:43,524
假定我们在统计测试中输入真随机序列R

222
00:17:43,524 --> 00:17:48,583
我们想知道会有多大概率输出1？

223
00:17:51,112 --> 00:17:53,642
对于一个真随机序列，第i+1是独立于

224
00:17:53,642 --> 00:17:58,765
前I比特的。所以算法A的输出也是

225
00:17:58,765 --> 00:18:04,231
完全独立于序列R的i+1位的，
所以不管A输出什么，

226
00:18:07,162 --> 00:18:10,092
概率都是等于随机的第i+1位，
独立随机的第i+1位的概率为1/2.

227
00:18:10,092 --> 00:18:14,754
换句话说，算法A不提供

228
00:18:14,754 --> 00:18:19,620
第i+1位的任何信息。并且，

229
00:18:19,620 --> 00:18:24,254
能够预测第i+1位是什么的概率为1/2。
另一方面，我们来看

230
00:18:24,254 --> 00:18:28,946
当我们在统计测试输入伪随机序列会发生什么

231
00:18:28,946 --> 00:18:33,521
好，我们对生成器的输出进行统计测试

232
00:18:33,521 --> 00:18:37,866
我们想知道输出1的可能多大。
根据定义A，我们知道

233
00:18:37,866 --> 00:18:42,326
当我们把生成器的前i位作为输入时，

234
00:18:42,326 --> 00:18:46,851
它能以1/2+ε的概率预测。
因此这种情况下

235
00:18:46,851 --> 00:18:51,657
统计测试B会以大于1/2+ε的概率输出1

236
00:18:51,657 --> 00:18:57,700
这就意味着如果我们看

237
00:18:57,700 --> 00:19:04,207
统计测试对于生成器G的优势，

238
00:19:04,207 --> 00:19:09,648
就是两个量间的差别。
你能够看出来两者的差

239
00:19:09,648 --> 00:19:14,514
是大于ε的。这意味着如果算法A

240
00:19:14,514 --> 00:19:18,917
能够以ε的优势预测下一位，那么算法B

241
00:19:18,917 --> 00:19:23,533
能够以ε的优势区分生成器的输出，对吧？

242
00:19:23,533 --> 00:19:28,696
那么如果A是一个好的预测机，
B是一个破解了生成器的好统计测试

243
00:19:28,696 --> 00:19:33,859
就如我们说的，
这个逆否命题是如果生成器G安全，

244
00:19:33,859 --> 00:19:38,960
那么就没有好的统计测试，
同样，也没有好的预测机

245
00:19:38,960 --> 00:19:43,756
对吧？意思就是我们所说的生成器
是不可预测的。好，目前为止

246
00:19:43,756 --> 00:19:48,361
我们看到的是如果生成器是安全的

247
00:19:48,361 --> 00:19:53,030
就不可能在给定前i比特时预测第i+1比特。

248
00:19:53,030 --> 00:19:57,890
1982年，姚期智给出了一个优雅非凡的定理

249
00:19:57,890 --> 00:20:02,623
人们认同了这个定理。实际上逆命题也是成立的。
换句话说，如果我给出

250
00:20:02,623 --> 00:20:07,675
一个不可预测的生成器，
那么你就不能根据前i位预测第i+1位

251
00:20:07,675 --> 00:20:12,453
i取任何值都成立。
事实上这个生成器是安全的。

252
00:20:12,453 --> 00:20:17,021
我来吧这个定理阐述的更清楚点。

253
00:20:17,021 --> 00:20:21,949
我们使生成器输出n比特，
定理告诉我们

254
00:20:21,949 --> 00:20:26,517
对所有比特位，
都不可能根据前i位预测第i+1位输出

255
00:20:26,517 --> 00:20:30,905
这对于所有i均成立。换句话说

256
00:20:30,905 --> 00:20:35,181
生成器对于任何比特位都无法预测。
事实上这就意味着

257
00:20:35,181 --> 00:20:38,969
生成器是一个安全的PRG。
我想用英语解释这个

258
00:20:39,123 --> 00:20:43,321
并且组织下语言，这个结果就是这些

259
00:20:43,321 --> 00:20:47,570
下一位预测机能够在给定前i位时预测第i+1位

260
00:20:47,570 --> 00:20:51,410
如果他们不能区分G的输出和随机序列的输出，
那么事实上

261
00:20:51,410 --> 00:20:55,125
就没有统计测试能区分了。这些

262
00:20:55,125 --> 00:20:58,804
下一位预测机某种意义上是指普遍的预测机。

263
00:20:58,804 --> 00:21:02,334
当说到区分随机性时，顺便说下，
这个定理，不难证明，

264
00:21:02,334 --> 00:21:06,113
但是在这个证明背后有一个非常优雅的想法。

265
00:21:06,113 --> 00:21:10,090
在这里我不做证明，
但是我鼓励大家把它当做一个问题来思考

266
00:21:10,090 --> 00:21:14,017
尝试自己去证明它。
我来给大家展示一下

267
00:21:14,017 --> 00:21:19,101
这个定理的一个有趣的影响。
我要问大家下面几个问题，

268
00:21:19,101 --> 00:21:24,417
假定我给出一个生成器，
并且我告诉大家给定的输出的最后一位

269
00:21:24,417 --> 00:21:28,963
很容易就能预测输出的第一位，对吧？
那么给定最后一位，你可以计算第一位，

270
00:21:28,963 --> 00:21:33,627
这和预测正好相反，对吧？

271
00:21:33,627 --> 00:21:38,469
可预测性指的是给定第一位，
你能得到下一位。这里，

272
00:21:38,469 --> 00:21:43,133
给定最后一位，你能得到第一位。
那么我的问题是

273
00:21:43,133 --> 00:21:47,266
这意味着生成器是可预测的吗？
能否根据这个事实

274
00:21:47,266 --> 00:21:52,310
为生成器构造一个预测机呢？这是一个

275
00:21:52,310 --> 00:21:56,898
姚期智定理的简单应用。
我来给大家解释一下这个问题的答案是yes

276
00:21:56,898 --> 00:22:02,074
我解释一下怎样构造这个生成器，
实际上我们不需要构造它

277
00:22:02,074 --> 00:22:06,661
我会证明给大家这个生成器是存在的，
就是因为超过两字节

278
00:22:06,661 --> 00:22:11,661
首先超过两字节并不意味着生成器，
我这样写，这意味着

279
00:22:11,661 --> 00:22:16,613
G不安全。因为如之前所说

280
00:22:16,613 --> 00:22:22,043
容易构造一个统计测试来区分G的输出和

281
00:22:22,043 --> 00:22:27,156
均匀分布序列。但如果G不安全，
根据姚定理，那就是指G是可预测的。

282
00:22:27,156 --> 00:22:32,396
因此换句话说，存在某个i，
给定输出前i位，

283
00:22:32,396 --> 00:22:37,257
你能构造第i+1位的输出。好

284
00:22:37,257 --> 00:22:42,371
即使我不能为大家构造预测算法，
但我们知道预测算法一定存在

285
00:22:42,371 --> 00:22:46,529
那么这就是姚定理的一个简单应用(-_-!)。

286
00:22:46,693 --> 00:22:50,856
现在在我们结束这个部分之前，
我想对我们所做的进行一个归纳。

287
00:22:50,856 --> 00:22:54,964
引入一些一直都很有用的重要符号

288
00:22:54,964 --> 00:22:58,516
我们来归纳一下

289
00:22:58,516 --> 00:23:02,889
均匀分布不可区分的概念，
以及两个一般分布间的不可区分的概念。

290
00:23:02,889 --> 00:23:07,143
设想我给出p1和p2，
那么我们想知道

291
00:23:07,143 --> 00:23:11,636
这两个分布可区分吗？
我们说这些分布

292
00:23:11,636 --> 00:23:16,602
在计算上不可区分，
我们记为p1，约等于p,p2

293
00:23:16,602 --> 00:23:22,908
这意味着，在多项式时间里，
p1和p2无法区分

294
00:23:22,908 --> 00:23:28,582
我们说它们是不可区分的，与之前一样

295
00:23:28,582 --> 00:23:35,759
对所有有效的统计测试A

296
00:23:35,759 --> 00:23:44,160
如果我从分布p1里取样，并且把输出给A。作为对比

297
00:23:44,160 --> 00:23:51,208
若果我从p2中取样，也交给A。
那么基本上A对

298
00:23:51,208 --> 00:23:55,414
两种情况表现一致。换句话说，

299
00:23:55,414 --> 00:23:59,893
这两概率的差是可以忽略的。
这对所有统计测试都成立

300
00:23:59,893 --> 00:24:04,577
对所有的统计测试，对吧？
如果是这种情况，我们说

301
00:24:04,577 --> 00:24:09,530
A不能区分两个分布时，
这两个分布的优势

302
00:24:09,530 --> 00:24:14,240
是可以忽略的。
如果这对所有有效的统计测试都成立

303
00:24:14,240 --> 00:24:18,649
我们就说这些分布在计算上无法区分

304
00:24:18,649 --> 00:24:23,481
因为一个有效的算法都不能区分它们。
我是为了告诉大家

305
00:24:23,481 --> 00:24:28,372
这个符号很有用，
我们可以用它表示安全PRG的定义

306
00:24:28,372 --> 00:24:32,810
如果我给出一个伪随机分布，换句话说

307
00:24:32,810 --> 00:24:37,159
随机地选取K，然后输出相应的G。

308
00:24:37,159 --> 00:24:41,978
这个分布和均匀分布在计算上是不可区分的。
因此大家也看到了

309
00:24:41,978 --> 00:24:46,269
这个非常简单的符号表达了
伪随机生成器的整个定义

310
00:24:46,269 --> 00:24:50,795
好，我们后面会用到这个符号。在下一节中

311
00:24:50,795 --> 00:24:54,439
当我们定义密码时，它就代表安全。【END】

