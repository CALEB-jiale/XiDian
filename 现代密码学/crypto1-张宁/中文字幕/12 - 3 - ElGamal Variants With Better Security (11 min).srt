1
00:00:00,000 --> 00:00:03,570
上节课，我们学习了ElGamal公共密钥加密系统

2
00:00:03,570 --> 00:00:07,520
是在一个有点奇怪的假设下选择的密文安全。今天，我们将

3
00:00:07,520 --> 00:00:11,140
学习ElGamal的变体，方便我们可以选出更好的密码安全文本分析。

4
00:00:11,140 --> 00:00:14,900
在过去的十年里，

5
00:00:14,900 --> 00:00:18,760
科学家们在构造上进行了很多研究，也就是用来选择密文安全的公共密钥加密。

6
00:00:18,760 --> 00:00:22,380
事实上，我考虑了很久这里该怎么描述。

7
00:00:22,380 --> 00:00:26,190
最后，我决定在最近十年中展示一项调查的主要成果。

8
00:00:26,190 --> 00:00:29,960
具体来说，就是他们适用于ElGamal系统时。

9
00:00:29,960 --> 00:00:33,770
在今天课程的结尾，我会推荐给大家一些论文，大家可以进行更深层次的学习。

10
00:00:33,770 --> 00:00:38,330
那么我们今天的课程从回忆ElGamal加密系统的工作过程开始。

11
00:00:38,330 --> 00:00:42,780
我确定到现在为止你们还都记得ElGamal是如何工作的，保险起见，我帮助大家回忆

12
00:00:42,780 --> 00:00:47,620
ElGamal中的密钥生成挑选一个随机发生器，还有一个从ZN中产生的随机指数。

13
00:00:47,620 --> 00:00:51,960
并且公共密钥是一个简单的发生器，并且元素是g到a，

14
00:00:51,960 --> 00:00:56,330
即私密密钥是基为g的离散对数h。由这些可以计算出A。

15
00:00:56,330 --> 00:01:01,250
现在我们加密的方式是在ZN中挑选随机指数B。我们计算

16
00:01:01,250 --> 00:01:05,940
G到B和H到B的哈希函数。接下来，H到B是Diffie Hellman秘密，G到AB。

17
00:01:05,940 --> 00:01:10,230
这样，我们实际上是运用一个对称加密系统

18
00:01:10,230 --> 00:01:15,150
和一个从哈希函数中派生出的密钥K加密了一条信息。

19
00:01:15,150 --> 00:01:19,730
最终，输出密文是G到B，也就是对称密文。

20
00:01:19,730 --> 00:01:24,650
我们解密的方法也就是我们之前学过的，将U哈希并且Diffie Hellman 秘密，

21
00:01:24,650 --> 00:01:28,940
将对称系统进行解密，并且输出信息M。

22
00:01:28,940 --> 00:01:33,640
上节课的最后我们讲到ElGamal用来选择密文安全，

23
00:01:33,640 --> 00:01:37,880
基于这个可爱的Diffie Hellman交互式假设。那么这里的这个假设是什么呢。

24
00:01:37,880 --> 00:01:42,440
这里我还想提到，这个定理提出了两个很自然的问题。

25
00:01:42,440 --> 00:01:46,680
第一个问题是，我们能否只基于标准的计算Diffie Hellman假设

26
00:01:46,680 --> 00:01:50,860
证明ElGamal下CCA的安全性，

27
00:01:50,860 --> 00:01:55,010
即G到A，G到B，你不能计算G到AB。

28
00:01:55,010 --> 00:01:59,250
我们能不能仅仅基于此证明已选择的密文安全性呢？答案是有两种方式

29
00:01:59,250 --> 00:02:03,450
来做到。第一个选择是运用一个计算性DH假设用起来比较困难的组。

30
00:02:03,450 --> 00:02:07,300
但是可证明它和交互式DH假设是相当的。

31
00:02:07,300 --> 00:02:11,220
这说明了事实上构造这样的组不是很困难。

32
00:02:11,220 --> 00:02:15,140
这些组我们称为双线性组。

33
00:02:15,140 --> 00:02:19,540
在这些组里，我们知道ElGamal系统用来选择密文安全，

34
00:02:19,540 --> 00:02:23,780
是严格基于计算性DH假设的，至少也是在随机的订购模型中。

35
00:02:23,780 --> 00:02:28,980
这些双线性组事实上是从非常特殊的椭圆曲线中构造的。

36
00:02:28,980 --> 00:02:33,710
所以这几个代数结构帮助我们证明IDH和CDH的等价性。

37
00:02:33,710 --> 00:02:38,400
但是，通常情况下，

38
00:02:38,400 --> 00:02:42,920
我们并不想运用椭圆曲线组，可能我们由于某些原因更想用ZP star.

39
00:02:42,920 --> 00:02:47,810
因此这是一个自然提出来的问题。我们能不能改变ElGamal系统使得

40
00:02:47,810 --> 00:02:52,820
ElGamal下的选择密文安全性现在可以被证明，而且是直接基于CDH下，对于CDH使用困难时的组？


41
00:02:52,820 --> 00:02:57,840
假设这个组有一些附加的结构，

42
00:02:57,840 --> 00:03:02,130
那么答案就是可以。有一种精巧的构造叫做twin ElGamal.

43
00:03:02,130 --> 00:03:06,690
接下来我们介绍twin ElGamal是如何工作的 。

44
00:03:06,690 --> 00:03:10,600
这是个很简单的ElGamal的变体。再一次，在密钥生成模式中，

45
00:03:10,600 --> 00:03:14,950
我们选择一个随机的生成器。但是这一次，我们将选择两个指数，A1和A2来作为

46
00:03:14,950 --> 00:03:19,400
私密密钥。因此私密密钥也就有了两个指数，分别是A1和A2。

47
00:03:19,400 --> 00:03:23,780
公共密钥是由我们的生成器构成的。

48
00:03:23,780 --> 00:03:28,340
接下来我们要释放G到A1和G到A2.所以记住通常的ElGamal下，

49
00:03:28,340 --> 00:03:32,840
公共密钥就是简单的从G到A。我们有两个指数，

50
00:03:32,840 --> 00:03:37,340
A1和A2 ，因此我们释放G到A1和G到A2。

51
00:03:37,340 --> 00:03:42,290
现在我们加密的方式，你会注意到公共密钥在这里是一个比常规ElGamal长的元素。

52
00:03:42,290 --> 00:03:47,130
我们用这个公共密钥加密的方式事实上和常规ElGamal十分相似。

53
00:03:47,130 --> 00:03:51,850
我们选择一个随机的B，现在我们要做的哈希事实上不是

54
00:03:51,850 --> 00:03:56,520
从G到B，从H1到B，事实上是从G到B，从H1到B，从H2到B。

55
00:03:56,520 --> 00:04:01,690
我们事实上对三个而不是两个元素进行了哈希变换，

56
00:04:01,690 --> 00:04:06,640
我们运用派生的对称加密密钥加密了信息，

57
00:04:06,640 --> 00:04:11,410
并且输出G到B和C作为最终密文。那么我们如何解密呢？

58
00:04:11,410 --> 00:04:16,020
现在私密密钥由两个指数组成，A1和A2。

59
00:04:16,020 --> 00:04:20,580
密文包括U和对称密文C。这里我们提出一个问题，

60
00:04:20,580 --> 00:04:25,500
看看大家是否能找出仅仅运用给出的私密密钥和计算值U来

61
00:04:25,500 --> 00:04:31,930
派生出对称加密密钥K的方法。这是个很有趣的问题，

62
00:04:31,930 --> 00:04:37,250
我希望大家都能解开它。解决方法是

63
00:04:37,250 --> 00:04:42,560
我们用U乘以A1的幂，这就是G到B，A1，和U到A2，G到B A2。

64
00:04:42,560 --> 00:04:48,010
我们会得到完全相同的值，就像H1到B和H2到B。

65
00:04:48,010 --> 00:04:53,060
这种方式的解密我们得到了相同的对称密钥，

66
00:04:53,060 --> 00:04:58,510
正如加密中做到的。接着我们运用对称系统解密密文

67
00:04:58,510 --> 00:05:03,380
并最终输出信息M。因此你会发现这是一个对于常规ElGamal非常简单的改进。

68
00:05:03,380 --> 00:05:07,800
我们所做的只是在公共密钥中多选了一个元素。

69
00:05:07,800 --> 00:05:11,880
当我们做哈希变换时，多对一个元素进行，也就是不只两个元素，

70
00:05:11,880 --> 00:05:16,240
我们对三个元素进行了哈希变换。相似的，我们进行解密，其他的都没改变。

71
00:05:16,246 --> 00:05:20,491
密文长度也和之前相同。

72
00:05:20,491 --> 00:05:24,647
惊异的是这样简单的修改就能让我们证明

73
00:05:24,647 --> 00:05:28,640
直接选择密文安全，基于标准计算性Diffie-Hellman假设

74
00:05:28,640 --> 00:05:32,795
仍假设一个对称加密系统

75
00:05:32,795 --> 00:05:36,897
提供我们认证加密以及散列函数

76
00:05:36,897 --> 00:05:41,430
这里用的是理想的散列函数，我们称为随机的Oracle数据库

77
00:05:41,430 --> 00:05:45,747
但是考虑到要严格证明选择密文安全

78
00:05:45,747 --> 00:05:49,803
基于一个计算Diffie-Hellman的假设。现在的成本是什么？

79
00:05:49,803 --> 00:05:53,966
如果你去思考，在加密与加密之间，加密必须

80
00:05:53,966 --> 00:05:57,418
多做一个求幂运算，那么解密也得多做求幂运算

81
00:05:57,418 --> 00:06:01,581
现在加密机做三次求幂运算

82
00:06:01,581 --> 00:06:05,490
而解密机做两次求幂运算

83
00:06:05,490 --> 00:06:09,965
现在变成了哲学问题。这些额外的努力都值得吗？

84
00:06:09,965 --> 00:06:14,228
在加密和解密多做了工作。公开密钥变得更大

85
00:06:14,228 --> 00:06:18,331
但这并没关系。在加密和解密做的工作是更有意义的

86
00:06:18,331 --> 00:06:22,434
结果得到选择密文安全性基于一种

87
00:06:22,434 --> 00:06:26,644
更为自然的假设，也就是计算Diffie-Hellman与

88
00:06:26,644 --> 00:06:30,480
这些外形奇特的Diffie-Hellman假设。但是值得吗？

89
00:06:30,480 --> 00:06:34,743
问题是这些群CDH持有而IDH并不持有

90
00:06:34,743 --> 00:06:38,815
如果存在这些群，那么当然值得这么做

91
00:06:38,815 --> 00:06:43,050
因为这些群，这两个性能就会安全，但常规的性能

92
00:06:43,050 --> 00:06:47,508
就不再有CCA安全了。不幸的是我们并不清楚是否存在这样的群

93
00:06:47,508 --> 00:06:51,383
存在CDH与IDH同时持有的群当然是可能的

94
00:06:51,383 --> 00:06:55,307
但是却并不知道额外的花费值不值得

95
00:06:55,307 --> 00:06:59,530
不过这是个好玩的结果，说明如果想要

96
00:06:59,530 --> 00:07:03,256
直接从CDH得到选择密文安全

97
00:07:03,256 --> 00:07:08,051
你可以不通过对性能系统做过多的改变来完成。接下来的问题是

98
00:07:08,051 --> 00:07:12,230
我们能否摆脱这种假设，即哈希函数为理想的散列函数

99
00:07:12,230 --> 00:07:16,617
主要为一个随机Oracle数据库。这会是一个巨大的话题

100
00:07:16,617 --> 00:07:20,482
在如何建立高效的公共密钥加密系统上有很多工作需要完成

101
00:07:20,482 --> 00:07:24,922
这里的选择密文安全是不用随机Oracle函数的

102
00:07:24,922 --> 00:07:29,192
在过去十年或更长的时间里这是一个非常活跃的研究领域

103
00:07:29,192 --> 00:07:33,379
它适用于性能为两个群的结构

104
00:07:33,379 --> 00:07:37,515
第一个结构运用了这些特殊的群称作双线性组

105
00:07:37,515 --> 00:07:41,599
原来的双线性组结构

106
00:07:41,599 --> 00:07:45,682
允许我们建立非常有效的选择密文安全系统

107
00:07:45,682 --> 00:07:50,128
而并未使用随机Oracle数据库，而在结束时的模块

108
00:07:50,128 --> 00:07:54,367
我指出了大量的论文来解释做法。这是一个很有意思的结构

109
00:07:54,367 --> 00:07:58,876
但这需要几个小时来解释它是如何工作的

110
00:07:58,876 --> 00:08:03,434
其他替代方法实际上使用一个更强的决定Diffie-Hellman假设群

111
00:08:03,434 --> 00:08:07,830
再次，我并不证明这个假设

112
00:08:07,830 --> 00:08:11,798
我只告诉你这个假设实际上有ZP星号标记的子群

113
00:08:11,798 --> 00:08:16,141
特别是如果我们看ZP星号标记主要子群的阶

114
00:08:16,141 --> 00:08:19,812
选择Diffie-Hellman假设似乎在这些群中持有

115
00:08:19,812 --> 00:08:23,852
在这些群中我们可以建立一个变种的性能称作

116
00:08:23,852 --> 00:08:27,141
克莱默苏泊系统，为选择密文安全和

117
00:08:27,141 --> 00:08:30,665
没有随机Oracle数据库的选择Diffie-Hellman假设

118
00:08:30,665 --> 00:08:34,659
这是一个很好的结果但是需要几个小时来解释，所以我也不在这展示

119
00:08:34,659 --> 00:08:38,324
这可能是其中一件事我留下来

120
00:08:38,324 --> 00:08:42,083
并不是先进的主题或做一个先进的课题，所以我们在之后在解决

121
00:08:42,083 --> 00:08:46,335
但我还是提供一篇论文在结束时的模块以防

122
00:08:46,335 --> 00:08:50,626
你想了解更多相关内容。这里的论文目录提供了更多的阅读材料

123
00:08:50,626 --> 00:08:54,208
如果你想读Diffie Hellman假设

124
00:08:54,208 --> 00:08:58,036
我在早前写过一篇相关论文谈过各种关于Diffie Hellman的相关假设

125
00:08:58,036 --> 00:09:01,716
特别是对选择Diffie Hellman假设的研究

126
00:09:01,716 --> 00:09:05,685
如果你想学习如何建立选择密文安全系统

127
00:09:05,685 --> 00:09:10,098
通过选择Diffie-Hellman假设或类似的假设

128
00:09:10,098 --> 00:09:14,563
Kramer和Shoup在2002年写的论文就说明了如何解决

129
00:09:14,563 --> 00:09:18,618
这篇非常强烈推荐去看看。如果你想学习如何

130
00:09:18,618 --> 00:09:22,672
通过双线性组建立选择密文安全，那么推荐你读的论文

131
00:09:22,672 --> 00:09:26,983
就是引用在这里的，使用了一个叫做Identity Based Encryption的通用机制

132
00:09:26,983 --> 00:09:30,884
非常惊喜的是它给我们的选择密文安全几乎是免费的

133
00:09:30,884 --> 00:09:34,638
一旦我们建立身份加密

134
00:09:34,638 --> 00:09:38,486
选择密文安全就立即下降。这覆盖在我的这篇论文中

135
00:09:38,486 --> 00:09:42,283
双Diffie-Hellman结构在引用的论文中被证明

136
00:09:42,283 --> 00:09:46,381
最后，如果你想看最近的一篇论文

137
00:09:46,381 --> 00:09:50,135
它给了一个非常通用的框架

138
00:09:50,135 --> 00:09:54,345
来建立选择密文安全系统，使用了所谓可推断出的散列证明

139
00:09:54,345 --> 00:09:58,506
是Hoeteck Wee写的一篇论文，是最近才发表的

140
00:09:58,506 --> 00:10:02,416
我希望你们都能完整地阅读这一篇，有很多不错的想法在里面

141
00:10:02,416 --> 00:10:06,426
我希望我可以在基础课上涵盖所有内容，但是我不得不

142
00:10:06,426 --> 00:10:10,436
留出更多时间给更先进的课程或更课题在结课前

143
00:10:10,436 --> 00:10:14,446
这节课到这，下节课我将

144
00:10:14,446 --> 00:10:18,506
将性能和RSA加密结合，让你了解

145
00:10:18,506 --> 00:10:20,512
如何让这两者遵循更一般的原则。【END】

