1
00:00:00,348 --> 00:00:03,576
现在我们理解了DES攻击如何实现的，
接下来我们来看几个针对DES攻击的例子

2
00:00:03,576 --> 00:00:06,594
我们将以穷举攻击开始

3
00:00:06,594 --> 00:00:12,817
我们的目标是对给出的输入输出对(mi,ci)

4
00:00:12,817 --> 00:00:16,867
找到能够将m映射到c的密钥

5
00:00:16,867 --> 00:00:24,667
换句话说我们的目标是找到能将
m1, m2, m3映射到c1, c2, c3的密钥

6
00:00:24,667 --> 00:00:27,867
正如我说过的，我们要找到完成这个映射的密钥

7
00:00:27,867 --> 00:00:30,800
首先要解决的问题是，我们怎么能知道这个密钥是唯一的？

8
00:00:30,800 --> 00:00:34,467
所以，让我们做一些分析来证明

9
00:00:34,467 --> 00:00:38,267
事实上，一对输入输出就足以完全限制住一个DES密钥了

10
00:00:38,267 --> 00:00:40,800
所以这个问题可以解答

11
00:00:40,800 --> 00:00:43,352
让我们看如何证明这个简单的引理

12
00:00:43,352 --> 00:00:47,267
现在假设DES是理想密码

13
00:00:47,267 --> 00:00:52,245
什么是理想密码？我们假定DES由

14
00:00:52,245 --> 00:00:58,867
随机可逆函数组成。换句话说，对每一个密钥，
DES都应用了一个随机可逆函数

15
00:00:58,867 --> 00:01:04,528
由于DES中有2^56个密钥，我们假设DES是

16
00:01:04,528 --> 00:01:15,233
由2^56个函数组成的集合,
这些函数在64位字符串上可逆。当然，

17
00:01:15,233 --> 00:01:21,800
DES不是2^56个随机函数的集合，
但是我们可以将密码理想化，假设

18
00:01:21,800 --> 00:01:25,380
它是这样一个集合，这样我们能得到什么？

19
00:01:25,380 --> 00:01:31,115
这样事实上证明仅给出一个消息和密文，

20
00:01:31,115 --> 00:01:38,867
只给出一对消息和密文 这就已经使得仅有
一个密钥能将这个信息映射成那个密文

21
00:01:38,867 --> 00:01:46,467
所以对已给出的一对m,c，我问你，
如何找出将m映射成c的密钥

22
00:01:46,467 --> 00:01:53,000
而且结果很可能是唯一的，事实上，
这有大概99.5%的可能性

23
00:01:53,000 --> 00:01:58,467
我要说这对所有的m和c都成立，
而且这个可能性只在于

24
00:01:58,467 --> 00:02:02,467
如何选择组成密码的随机排列

25
00:02:02,467 --> 00:02:05,666
所以让我们写下一个证明 这是非常浅显易懂的
所以我们要问的是

26
00:02:05,666 --> 00:02:11,467
存在不为k的密钥使得…

27
00:02:11,467 --> 00:02:19,111
嗯，由c和m的定义已知c=DES(k,m) 

28
00:02:19,111 --> 00:02:24,103
我们要问存在其他密钥k' 
同样满足这个等式的可能性是多少？

29
00:02:24,103 --> 00:02:29,699
你意识到如果这为真，如果这样的k’存在，
那么仅给出m和c

30
00:02:29,699 --> 00:02:35,040
你不能决定正确的密钥是k还是k'，
因为它们都管用，对吧

31
00:02:35,040 --> 00:02:38,000
但是我想说明的是，这发生的概率很低

32
00:02:38,000 --> 00:02:42,467
那么存在密钥k’满足这个关系的意味着什么？

33
00:02:42,467 --> 00:02:48,133
我们要问，第一个密钥，
全0的密钥满足关系的可能性是多少？

34
00:02:48,133 --> 00:02:52,037
或者第二个密钥满足它的概率，或者第三个，以此类推

35
00:02:52,037 --> 00:02:58,979
所以根据集合上界，
我们可以用所有密钥k'的和界定这个概率

36
00:02:58,979 --> 00:03:10,102
用所有56位的密钥 界定DES(k,m)=DES(k',m)的概率

37
00:03:10,102 --> 00:03:15,600
对吧，所以我们问，对一个固定的密钥k’

38
00:03:15,600 --> 00:03:21,178
它与密钥k关于信息m碰撞的概率是多少？
嗯，让我们考虑一下。

39
00:03:21,178 --> 00:03:25,400
让我们确定它的值。假设它是确定的值，然后问

40
00:03:25,400 --> 00:03:31,348
随机序列πk'在m处恰好产生

41
00:03:31,348 --> 00:03:37,014
相同输出的概率是多少

42
00:03:37,014 --> 00:03:43,000
这不难解答 可以看出事实上对每一个单独的k’

43
00:03:43,000 --> 00:03:50,040
其概率最多是1/(2^64)，对吧？
对这个序列有2^64个可能的输出，

44
00:03:50,040 --> 00:03:55,822
它恰好出现这一个输出的概率就是1/(2^64)

45
00:03:55,822 --> 00:04:00,652
然后我们把所有2^56个密钥的都加起来，
仅需将这两个相乘

46
00:04:00,652 --> 00:04:06,758
我们得到1/(2^8)  也就是1/256 对吧 所以

47
00:04:06,758 --> 00:04:12,099
密钥不唯一的概率是1/256 因此它唯一的概率

48
00:04:12,099 --> 00:04:18,800
是1-1/256 也就是99.5%。
对吧？所以如果你给我一个明文-密文对

49
00:04:18,800 --> 00:04:23,430
密钥就已经被决定了 只有一个密钥会将那个明文

50
00:04:23,430 --> 00:04:26,774
映射成那个密文 问题是 你能找到那个密钥吗

51
00:04:26,774 --> 00:04:32,933
结果发现事实上如果你给我那样的两对 给出m1, m2

52
00:04:32,933 --> 00:04:37,780
和它们相关的输出c1和c2 基本的概率是

53
00:04:37,780 --> 00:04:41,821
做同样的分析 这个概率就是1

54
00:04:41,821 --> 00:04:46,766
就是仅有一个这样的密钥 好吧，
本质上是非常非常接近1

55
00:04:46,766 --> 00:04:51,248
基本可以说给出两对明文密文，
非常可能仅有一个密钥

56
00:04:51,248 --> 00:04:56,031
能够将这对信息映射成这对密文 因此

57
00:04:56,031 --> 00:05:00,559
我们可以问 找出那个唯一的密钥，
顺便一提，这对AES也是一样的

58
00:05:00,559 --> 00:05:05,226
如果是AES128的情况 只给出两对输入输出

59
00:05:05,226 --> 00:05:09,638
有很大的概率仅有一个密钥 所以本质上

60
00:05:09,638 --> 00:05:14,654
我们可以提出这个穷举搜索问题，
我给你两对或三对输入输出，然后问你

61
00:05:14,654 --> 00:05:19,228
找出这个密钥，那你要怎么做，
你将通过穷搜索来做到

62
00:05:19,228 --> 00:05:24,824
本质上是通过一个一个尝试所有可能的密钥，
直到你找到正确的那一个

63
00:05:24,824 --> 00:05:29,816
所以这被称作DES难题 让我解释一下它是如何做到的

64
00:05:29,816 --> 00:05:34,333
这个难题是被RSA公司放出的 他们做的事情基本上就是

65
00:05:34,333 --> 00:05:40,333
发布一些密文 但是其中三个密文有已知明文

66
00:05:40,333 --> 00:05:46,133
他们特别要做的是 将这里的信息 “未知信息是 ：XXXX...”

67
00:05:46,133 --> 00:05:50,867
拆分成组 如果你观察这些组 他们基本上都是

68
00:05:50,867 --> 00:05:57,267
8字节的分组，如你所知，
8个字节是64位，所以每个分组是64位

69
00:05:57,267 --> 00:06:01,651
然后他们用一个秘密密钥加密这些分组 他们用同样的密钥加密它们

70
00:06:01,651 --> 00:06:07,711
来得到三个密文 所以这就给我们提供了三个明文密文对

71
00:06:07,711 --> 00:06:12,239
而且也给了我们很多其他密文如c4，c5，c6

72
00:06:12,239 --> 00:06:16,372
现在面临的挑战是 用你通过对已给出的
前三个明文密文对进行穷举搜索找到的密钥

73
00:06:16,372 --> 00:06:20,784
解密这些东西

74
00:06:20,784 --> 00:06:25,683
所以这叫做DES难题 让我告诉你需要多长时间解决它

75
00:06:25,683 --> 00:06:31,467
有趣的是 在1997年 通过互联网搜索

76
00:06:31,467 --> 00:06:36,574
使用分布式网络 通过搜索足够的秘钥空间

77
00:06:36,574 --> 00:06:42,779
能在三个月内找到那个正确的密钥 密钥的大小是2^56

78
00:06:42,779 --> 00:06:47,487
但是平均来说 你只需搜索一半的密钥空间就能找到这个密钥

79
00:06:47,487 --> 00:06:51,574
所以这花费了他们3个月 然后不可思议的事情发生了

80
00:06:51,574 --> 00:06:57,890
EFF与Paul Kocher签订合约，为制造专用硬件来攻破DES

81
00:06:57,890 --> 00:07:03,416
这就是叫做Deep Crack的机器，它大概花费25万美元

82
00:07:03,416 --> 00:07:09,500
它仅用三天就攻破了下一个DES难题 顺便一提 有趣的是 RSA说

83
00:07:09,500 --> 00:07:14,120
他们将会为每个难题的解答支付1万美元 所以你会发现

84
00:07:14,120 --> 00:07:18,439
这并不是很经济合算，
他们花费25万美元而解决问题仅得到1万美元

85
00:07:18,439 --> 00:07:22,154
下一件事情发生在1999年

86
00:07:22,154 --> 00:07:27,286
RSA发布了另一个难题 而且他们说，
用之前解决方案一半时间就能解决

87
00:07:27,286 --> 00:07:32,600
所以在同时使用Deep Crack和互联网搜索的情况下

88
00:07:32,600 --> 00:07:35,622
他们仅用22小时就破解了DES

89
00:07:35,622 --> 00:07:40,498
所以底线是 事实上DES完全不起作用

90
00:07:40,498 --> 00:07:45,351
如果你忘记或者遗失了DES-56位的密钥 不要担心

91
00:07:45,351 --> 00:07:51,226
在22小时内 你就能恢复它而且事实上任何人都能做到

92
00:07:51,226 --> 00:07:56,467
所以DES并不起作用也不再安全 有点像棺材上最后一个钉子

93
00:07:56,467 --> 00:08:03,765
随着硬件技术发展，出现另外一个
使用FPGA的项目，叫做COPACABANA

94
00:08:03,765 --> 00:08:11,450
使用现货供应的FPGA 只用了120个，
仅花1万美元 他们就能破解

95
00:08:11,450 --> 00:08:16,768
在7天内完成穷举密钥搜索 所以非常非常廉价的硬件 刚刚上市

96
00:08:16,768 --> 00:08:21,365
你已经可以非常快速地破解DES 所以这一系列中的这一课很关键

97
00:08:21,365 --> 00:08:26,467
56位的密码完全不起作用 所以问题是该怎么做

98
00:08:26,467 --> 00:08:30,700
人们真的喜欢DES 它被使用在许多地方 许多的应用软件

99
00:08:30,700 --> 00:08:34,415
也有很多支持它的硬件 所以问题是该怎么办

100
00:08:34,415 --> 00:08:37,933
所以第一个进入我们脑海的想法是 也许我们可以将DES

101
00:08:37,933 --> 00:08:42,681
在某种程度上人工增大密钥的长度 所以我们加长它来抵御

102
00:08:42,681 --> 00:08:47,400
穷举搜索攻击 第一个想到的主意是

103
00:08:47,400 --> 00:08:51,900
多次迭代分组密码 这被称作三重DES

104
00:08:51,900 --> 00:08:56,200
所以三重DES是一个总体的结构 它的具体如下

105
00:08:56,200 --> 00:08:59,957
如果你给我一个分组密码E 在这 有一个密钥空间K

106
00:08:59,957 --> 00:09:03,974
和消息空间M 当然也有输出空间M

107
00:09:03,974 --> 00:09:10,429
让我们定义这个三重结构 它现在使用三个密钥 定义如下

108
00:09:10,429 --> 00:09:15,561
这个三重结构使用三个独立的密钥，
加密同样的分组消息

109
00:09:15,561 --> 00:09:21,412
正如之前一样，它做的工作是，使用密钥K3加密分组消息

110
00:09:21,412 --> 00:09:29,098
然后用密钥K2解密 再用密钥K1加密

111
00:09:29,098 --> 00:09:33,881
所以基本上是加密三次 使用三个独立的密钥

112
00:09:33,881 --> 00:09:40,104
你可能会疑惑 为什么是加密-解密-加密的顺序 而不是三次加密

113
00:09:40,104 --> 00:09:43,843
为什么我们在中间要解密一次 这是为了防止某种意义上的相撞

114
00:09:43,843 --> 00:09:50,019
注意观察如果你将k1k2k3都设成相等会发生什么 如果三个密钥

115
00:09:50,019 --> 00:09:57,200
都相等会是什么情况呢 会发生一次加密和解密相抵消

116
00:09:57,200 --> 00:10:02,419
然后你将仅得到一般DES加密的结果 所以这就是一种碰撞，
如果你有一个实现三重DES的硬件设施

117
00:10:02,419 --> 00:10:07,504
你可以将所有三个密钥设成一样，
然后你就得到了实现单一DES的硬件

118
00:10:07,504 --> 00:10:12,101
当然它的速度会是常规单一DES实现的三分之一罢了

119
00:10:12,101 --> 00:10:17,094
然而 这也是一种选择 对于三重DES我们得到的密钥长度是

120
00:10:17,094 --> 00:10:25,499
3*56也就是168位 ，
168位长到了无法实施穷举搜索的程度

121
00:10:25,499 --> 00:10:31,420
穷搜索将花费是时间是2^168 地球上所有机器运行10年也不能

122
00:10:31,420 --> 00:10:36,800
完成的工作 不幸的是 当然这个密码也会比DES慢两倍

123
00:10:36,800 --> 00:10:40,964
所以这才是三重DES真正的问题 现在我想说得是 你也许认为

124
00:10:40,964 --> 00:10:49,160
三重DES在2^168的时间内是安全的 但事实上 有一个简单攻击运行时间为2^118

125
00:10:49,160 --> 00:10:55,800
我们来看那个攻击是如何做到的 实际上2^118依然是一个很大的数

126
00:10:55,800 --> 00:11:02,814
事实上 任何大于2^90的时间都可以认为足够安全

127
00:11:02,814 --> 00:11:06,668
2^118当然对穷举搜索来说足够安全

128
00:11:06,668 --> 00:11:09,933
而且一般被认为是足够高的安全等级

129
00:11:09,933 --> 00:11:14,447
所以明显三重DES的速度是DES的三分之一 问题是

130
00:11:14,447 --> 00:11:18,467
为什么将密码重复三次 为什么不仅将密码重复两次

131
00:11:18,467 --> 00:11:21,297
更具体地说 二重DES存在什么问题呢

132
00:11:21,297 --> 00:11:25,546
我们来看这个二重DES 可以看到只用两个密钥 只需要

133
00:11:25,546 --> 00:11:30,979
两次运用分组密码 结果速度只会比DES慢一倍

134
00:11:30,979 --> 00:11:36,067
而不是两倍 二重DES的密钥长度是2*56

135
00:11:36,067 --> 00:11:42,613
也就是112比特 事实上112位秘钥空间对穷举搜索也太长了

136
00:11:42,613 --> 00:11:47,400
穷举搜索无法在2^112如此大的空间中进行

137
00:11:47,400 --> 00:11:51,227
因而问题变成 这个结构有什么问题

138
00:11:51,227 --> 00:11:54,687
事实上 这个结构完全不安全 我给你们看一个攻击实例

139
00:11:54,687 --> 00:12:01,200
假设我有一些输入 m1到m10 和对应的输出c1到c10

140
00:12:01,200 --> 00:12:09,060
我的目标是什么，我的目标是找出密钥，
也就是一对密钥k1,k2

141
00:12:09,060 --> 00:12:17,559
如果我用这两个密钥加密消息M 换句话说如果我对消息

142
00:12:17,559 --> 00:12:23,248
进行二重DES加密 我将会得到已给出的密文向量

143
00:12:23,248 --> 00:12:28,067
所以我们的目标是解决这里的等式，
你们看一会这个等式

144
00:12:28,067 --> 00:12:32,267
过一会儿，我可以用一种有意思的方式重写它

145
00:12:32,267 --> 00:12:36,483
我可以使用解密算法，
然后我将得到我期望的密钥k1,k2，

146
00:12:36,483 --> 00:12:43,960
它们满足这里的等式 我所做的就是

147
00:12:43,960 --> 00:12:51,400
使用k1对两边进行解密，好的，
无论什么时候你看到像这样的等式

148
00:12:51,400 --> 00:12:55,918
需要做的事情是 我们将变量分割成两部分

149
00:12:55,918 --> 00:13:00,098
现在变量单独出现在等式两边 这意味着

150
00:13:00,098 --> 00:13:04,579
有一个比穷举搜索更快的攻击，
事实上这个攻击被叫做中间人攻击。

151
00:13:04,579 --> 00:13:09,107
而这种攻击将以某种方式

152
00:13:09,107 --> 00:13:14,169
就这一点来攻击这个结构，好的，
我们尝试找出一个密钥

153
00:13:14,169 --> 00:13:18,533
能将m映射成这里的一个特定值 而且将c映射成相同的值

154
00:13:18,533 --> 00:13:22,969
我们来看这个攻击是如何做到的 首先

155
00:13:22,969 --> 00:13:26,220
我们要建一个表 在这 让我清理出一些空间

156
00:13:26,220 --> 00:13:31,096
第一步是建一个表 写出k2所有可能的值

157
00:13:31,096 --> 00:13:35,647
用其加密m得到的值记在表上，
所以在我们这有了这张表

158
00:13:35,647 --> 00:13:45,600
这里是所有2^56个一重DES的密钥 所以这个表有2^56项

159
00:13:45,600 --> 00:13:50,800
我们要做的是计算每一项 在用相应密钥加密m得到的结果

160
00:13:50,800 --> 00:13:54,641
所以这是用全0密钥加密m的结果

161
00:13:54,641 --> 00:13:59,494
在一个密钥下加密m的结果，在底部是

162
00:13:59,494 --> 00:14:04,933
用全1的密钥加密m的结果，所以这有2^56个项，
然后我们根据第二列对这个表进行排序

163
00:14:04,933 --> 00:14:10,083
目前一切良好 顺便一说建立这张表需要2^56的时间

164
00:14:10,083 --> 00:14:17,733
我们也需要排序，排序需要nlogn的时间，
所以就是 2^56*log2^56

165
00:14:17,733 --> 00:14:21,733
现在我们得到了这张表 我们本质上得到了

166
00:14:21,733 --> 00:14:24,618
第一重加密的所有可能的值

167
00:14:24,618 --> 00:14:28,533
现在我们要做的就是中间人攻击

168
00:14:28,533 --> 00:14:33,094
现在我们尝试用所有可能的密钥k向前推

169
00:14:33,094 --> 00:14:37,761
本质上我们就是计算 所有可能的密钥k1对c解密的结果

170
00:14:37,761 --> 00:14:43,333
好了 所以现在记下每一个潜在的解密结果，
记住这张表里的在中间点上所有可能的值

171
00:14:43,333 --> 00:14:49,580
然后对每一个可能的解密结果 我们检查它是否在表格中

172
00:14:49,580 --> 00:14:53,248
是否在表格的第二列中，如果是的话，
哈，我们找到了这个配对

173
00:14:53,248 --> 00:14:58,055
现在我们知道了什么？我们知道，
本质上我们找到了这个配对

174
00:14:58,055 --> 00:15:04,557
举例来说 用特定的密钥k1解密的情况下，
正好与表格中的这项相匹配

175
00:15:04,557 --> 00:15:11,151
对k2或者更一般的情况下的ki，
我们知道用ki加密m的结果

176
00:15:11,151 --> 00:15:17,513
等于用k加密c的结果，好的，
所以我们差不多已经建立了中间相遇模型

177
00:15:17,513 --> 00:15:25,896
这两边，分别是用ki加密m的结果和用k加密c的结果

178
00:15:25,896 --> 00:15:32,490
如果它们碰撞了 我们就知道 事实上这一对ki和k

179
00:15:32,490 --> 00:15:36,089
就是我们要找的那一对秘钥，
所以我们解决了这一难题

180
00:15:36,089 --> 00:15:40,965
现在让我们来看一下这个的运行时间是多少，
我们需要做一个表格

181
00:15:40,965 --> 00:15:47,867
然后排序，然后对所有可能的解密结果，
在表格中搜索

182
00:15:47,867 --> 00:15:53,690
所以有2^56个可能的解密结果，
每次在已排序的表格中搜素需要log(2^56)的时间

183
00:15:53,690 --> 00:15:59,400
如果你把它算出来就是2^63，
这比2^112小得多

184
00:15:59,400 --> 00:16:07,413
所以这是一个糟糕的攻击，在今天是可行的，
完全可以接受 2^63的时间

185
00:16:07,413 --> 00:16:12,359
用时差不多和DES穷举搜索攻击一样

186
00:16:12,359 --> 00:16:16,446
所以二重DES不能解决穷举搜素问题

187
00:16:16,446 --> 00:16:19,650
因为对此有一个攻击 其运行时间差不多

188
00:16:19,650 --> 00:16:23,086
跟一次DES的穷举搜索攻击相等 有些人可能会抱怨

189
00:16:23,086 --> 00:16:26,895
因为事实上这个算法 必须要存储这张大表

190
00:16:26,895 --> 00:16:31,283
需要占用很大的空间 那又怎样 无论如何 运行时间

191
00:16:31,283 --> 00:16:35,439
还是很小 或者说比2^112小很多

192
00:16:35,439 --> 00:16:39,248
顺便说一句 现在你应该注意到了，
一样的攻击可以应用在三重DES上

193
00:16:39,248 --> 00:16:42,267
你所要做的就是对这一点实现中间人攻击

194
00:16:42,267 --> 00:16:47,867
你要建立一张2^56大的表，
包含m所有可能的加密结果，

195
00:16:47,867 --> 00:16:53,000
然后你尝试用2^112个密钥进行解密，
直到你找到碰撞的那一个

196
00:16:53,000 --> 00:16:56,639
当遇到碰撞时 你就已经发现了k1,k2,k3

197
00:16:56,639 --> 00:17:03,333
所以即使是三重DES也存在穷举搜索
2^112个可能的密钥就能实现的攻击

198
00:17:03,333 --> 00:17:08,087
但是2^112是一个足够大的数，
所以三重DES在目前来说

199
00:17:08,087 --> 00:17:13,706
是足够安全的 我应该提醒的是，
三重DES实际上是NIST的标准

200
00:17:13,706 --> 00:17:19,859
所以三重DES应用广泛，而且事实上，
DES从来就不应该被使用

201
00:17:19,859 --> 00:17:24,867
如果因为某些原因你必须使用DES的某些版本，
使用三重DES而不是DES

202
00:17:24,867 --> 00:17:29,310
我还想再多说一个扩展DES以抵抗穷举搜索攻击的方法

203
00:17:29,310 --> 00:17:33,118
这个方法实际上没有被NIST标准化，
因为它不能抵抗

204
00:17:33,118 --> 00:17:37,692
更精妙的对DES的攻击，
然而你所要担心的就是穷举搜索

205
00:17:37,692 --> 00:17:43,010
而且你不想付出使用三重DES的代价，
那么这个方法就是一个有趣的主意

206
00:17:43,010 --> 00:17:47,630
让我向你展示它是如何做到的，
假设E是在n位分组上操作的分组密码

207
00:17:47,630 --> 00:17:53,319
我们将接下来要定义EX结构，
对DES来说，我们将得到DESX如下

208
00:17:53,319 --> 00:17:59,733
所以我们使用三个密钥k1k2k3，
在加密之前与K3异或

209
00:17:59,733 --> 00:18:05,231
然后用K2加密，加密之后再与k1异或，就是这样

210
00:18:05,231 --> 00:18:09,387
这就是整个结构 所以你会看到，
它不会拖慢分组密码多少

211
00:18:09,387 --> 00:18:14,403
因为我们做的仅是使用这个密码再加上两个额外的异或，
异或的速度非常快

212
00:18:14,403 --> 00:18:20,092
这里密钥的长度实际上，嗯，
我们有两个跟分组一样大小的密钥

213
00:18:20,092 --> 00:18:25,038
还有一个跟密钥大小一样的，
所以一共是184位

214
00:18:25,038 --> 00:18:31,446
事实证明已知的最好攻击耗时2^120

215
00:18:31,446 --> 00:18:37,158
and this is actually fairly simple. So it's a generic attack on EX, it will always take time basically

216
00:18:31,446 --> 00:18:37,158
那其实很简单，所以这是一个一般EX攻击，
它所需的时间是

217
00:18:37,158 --> 00:18:41,222
分组大小加上密钥大小，这是一个简单的家庭作业

218
00:18:41,222 --> 00:18:43,892
为了让你们弄懂这个攻击，我想这是一个很好的练习

219
00:18:43,892 --> 00:18:48,867
好了事实上有分析表明没有穷举搜索攻击

220
00:18:48,867 --> 00:18:53,041
可以破解这种结构，
所以这是可以抵抗穷举搜索的很好的结构

221
00:18:53,041 --> 00:18:56,600
但是还有一些更精妙的DES攻击，
我们将在下一节讨论

222
00:18:56,600 --> 00:18:59,566
但这种结构无法防范某些特定攻击

223
00:18:59,566 --> 00:19:05,789
我想指出的一点是，很不幸，
我在很多产品中发现这个错误

224
00:19:05,789 --> 00:19:12,383
那就是如果你决定在外部或者内部进行异或

225
00:19:12,383 --> 00:19:13,985
相对比与DESX那样在两边异或的情况

226
00:19:13,985 --> 00:19:18,165
你会注意到DESX在内部和外部都进行异或

227
00:19:18,165 --> 00:19:22,067
如果你只做其中一个，
那么这个结构对保证你密码的安全性

228
00:19:22,067 --> 00:19:26,780
将毫无用处，它将在穷举搜索面前

229
00:19:26,780 --> 00:19:30,518
脆弱得像原本的分组密码E一样，好了，
所以这就是另一个家庭作业中的另一个问题

230
00:19:30,518 --> 00:19:34,094
实际上你会在我们的作业中看到那个问题

231
00:19:34,094 --> 00:19:37,809
这基本上就总结了我们对穷举搜索的讨论

232
00:19:37,809 --> 00:19:41,292
下一次我们将讨论更复杂的DES攻击。【END】

