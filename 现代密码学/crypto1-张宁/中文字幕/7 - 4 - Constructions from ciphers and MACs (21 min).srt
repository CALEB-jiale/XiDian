1
00:00:00,000 --> 00:00:03,837
在这一部分，我们将要来创建认证加密系统。

2
00:00:03,837 --> 00:00:08,250
由于我们已经有了CPA安全的加密和安全的MAC，随之而来的问题就是

3
00:00:08,250 --> 00:00:12,824
我们是否可以通过某种方式来将两者结合起来从而得到认证加密系统

4
00:00:12,824 --> 00:00:15,721
事实上，这正是我们本节将要做的。认证加密

5
00:00:15,721 --> 00:00:20,447
于2000年在两篇独立的文章里被提出，本章的最后我会讲到

6
00:00:20,447 --> 00:00:25,915
在这之前，许多密码学库都提供了

7
00:00:25,915 --> 00:00:31,215
一个分开支持CPA安全加密和MAC的API。因此存在一个

8
00:00:31,215 --> 00:00:36,175
执行CPA安全加密的函数。例如，带随机IV的CBC

9
00:00:36,175 --> 00:00:41,136
还有另一个执行MAC的函数。之后每一个想要执行加密的开发者

10
00:00:41,136 --> 00:00:45,646
都必须分别调用CPA安全加密体系和

11
00:00:45,646 --> 00:00:50,552
MAC体系。特别的，每一个开发者都必须发明

12
00:00:50,552 --> 00:00:55,697
他们自己结合加密和MAC体系的方式，从而提供一种

13
00:00:55,697 --> 00:00:59,376
认证加密系统。但是认证加密还没有被定义导致将CPA加密和MAC体系

14
00:00:59,376 --> 00:01:03,690
结合的目标不是很明确，因而

15
00:01:03,690 --> 00:01:08,497
我们很难区分哪种结合是正确的，哪种是错误的

16
00:01:08,497 --> 00:01:13,243
并且像我说的每个项目都要开发它自己的结合方式

17
00:01:13,243 --> 00:01:17,202
事实上并不是所有的结合方式都是正确的。并且我可以告诉你

18
00:01:17,202 --> 00:01:22,556
软件开发的大部分普遍错误基本上就是错误地

19
00:01:22,556 --> 00:01:27,025
将加密和诚信机制结合起来。所以希望在本章的最后，大家可以

20
00:01:27,025 --> 00:01:31,260
明白如何正确地结合它们，而且自己不会犯这种错误

21
00:01:31,260 --> 00:01:35,174
那么让我们来看一些CPA安全加密和MAC结合实例

22
00:01:35,174 --> 00:01:39,303
这些是出自不同的项目提出。这有三个例子。

23
00:01:39,303 --> 00:01:43,816
首先，在这三个例子中，有一个单独的密钥来加密，还有

24
00:01:43,816 --> 00:01:47,774
一个单独的密钥来MAC。这两的密钥相互是独立的

25
00:01:47,774 --> 00:01:52,224
并且都是在会话建立阶段生成的。我们将会在之后的课程学习

26
00:01:52,224 --> 00:01:57,071
如何生成这两个密钥。那么，第一个例子呢是SSL协议。

27
00:01:57,071 --> 00:02:02,681
以下是为了实现认证加密,SSL将加密和MAC结合起来的方式

28
00:02:02,681 --> 00:02:07,656
取明文m，然后计算明文m的MAC

29
00:02:07,656 --> 00:02:13,415
因此你用你的MAC的密钥k1来计算这个明文的标签

30
00:02:13,415 --> 00:02:17,787
然后你可以将标签和明文联系起来，然后加密

31
00:02:17,787 --> 00:02:22,580
明文和标签的联接，随后就会得出最终的密文

32
00:02:22,580 --> 00:02:26,710
这是方案一。方案二就是IPsec的原理。

33
00:02:26,710 --> 00:02:31,160
现在，取明文，首先要做的就是加密明文

34
00:02:31,160 --> 00:02:35,692
然后，计算在结果密文上的标签。然后大家可以注意到

35
00:02:35,692 --> 00:02:40,238
这个明文是基于密文结果。第三个方案是

36
00:02:40,238 --> 00:02:45,429
SSH协议。那么这里，SSH取明文，用CPA安全加密体系进行加密

37
00:02:45,429 --> 00:02:50,944
之后，将明文和标签联系起来。

38
00:02:50,944 --> 00:02:55,567
IPsec和SSH的不同在于，在IPsec中，标签的计算在密文之上，

39
00:02:55,567 --> 00:02:59,988
然而，在SSH里，标签的计算基于明文。

40
00:02:59,988 --> 00:03:04,536
那么这就是结合加密和MAC的三种完全不同的方式

41
00:03:04,536 --> 00:03:09,090
那么问题来了，呢一种方式是安全的？我想让大家先思考一下

42
00:03:09,090 --> 00:03:12,105
然后我们一起来分析

43
00:03:13,197 --> 00:03:17,164
让我们先从SSH方式开始。在SSH方式中大家注意到

44
00:03:17,164 --> 00:03:21,629
标签的计算基于明文，然后将标签附在密文后面。

45
00:03:21,629 --> 00:03:26,407
事实上这存在这很大的问题，因为MAC并不是

46
00:03:26,407 --> 00:03:30,784
为了提供保密性而设计的。它只是为了完整性而设计的。并且事实上

47
00:03:30,784 --> 00:03:36,008
MAC作为标签的一部分输出明文中的几位是没有任何问题的

48
00:03:36,008 --> 00:03:41,458
输出明文m中的几位。可以说这是一个很好的标签

49
00:03:41,458 --> 00:03:46,667
但是如果我们这么做了，将会完全破坏CPA的安全性，因为明文中的

50
00:03:46,667 --> 00:03:51,815
的某几位会在密文中泄露。因此即使SSH的

51
00:03:51,815 --> 00:03:56,595
特性很好并且协议本身没有因这种特定

52
00:03:56,595 --> 00:04:00,818
的结合而妥协，还是不建议使用这种SSH方式

53
00:04:00,818 --> 00:04:05,928
因为MAC这种签名算法可能会泄露明文中的几位。

54
00:04:05,928 --> 00:04:11,481
因此让我们看一下SSL和IPsec方式。事实证明，被推荐的方式

55
00:04:11,481 --> 00:04:16,556
事实上是IPsec方式。因为结果表明，无论你使用CPA安全系统还是MAC密钥

56
00:04:16,556 --> 00:04:21,134
结合的结果总是能提供一个认证加密

57
00:04:21,134 --> 00:04:26,070
现在让我非常简明扼要的解释一下原因。基本上，一旦我们加密明文

58
00:04:26,070 --> 00:04:31,005
那么明文的内容就藏在了密文中

59
00:04:31,005 --> 00:04:35,761
现在当我们计算密文中的标签时这个标签给密文上了锁

60
00:04:35,761 --> 00:04:40,815
并且保证没有人能够再去产生一个看起来正当的与之不同的密文

61
00:04:40,815 --> 00:04:45,314
因此，这个方法确保任何对密文的修改

62
00:04:45,314 --> 00:04:49,555
将会被解密者轻易地发现，因为MAC

63
00:04:49,555 --> 00:04:54,026
无法验证。结果表明，对于SSL方式来说，事实上存在

64
00:04:54,026 --> 00:04:59,348
病态的事例，当你将CPA安全加密系统和安全MAC结合时

65
00:04:59,348 --> 00:05:03,542
结果对于选择密文攻击是脆弱的，因此

66
00:05:03,542 --> 00:05:07,978
它事实上并没有提供认证加密。基本上，这个可能发生的原因是

67
00:05:07,978 --> 00:05:12,824
在加密体系和MAC算法之间存在某种

68
00:05:12,824 --> 00:05:17,319
不好的联系。事实上，会有一个选择密文攻击

69
00:05:17,319 --> 00:05:21,752
如果你设计了一个新的项目，现在总是推荐先加密

70
00:05:21,752 --> 00:05:26,162
然后计算MAC，因为无论你组合了什么样的CPA安全加密和MAC算法

71
00:05:26,162 --> 00:05:30,607
得到的总和总是安全的。现在看个术语

72
00:05:30,607 --> 00:05:37,995
这个SSL方法有时叫做“先MAC后加密”

73
00:05:37,995 --> 00:05:45,039
IPsec方法叫做“先加密后MAC”。尽管我们不应该使用SSH方法

74
00:05:45,039 --> 00:05:51,898
但它也被叫做“先加密后MAC”。所以我会经常提到

75
00:05:51,898 --> 00:05:57,002
“先加密后MAC”和“先MAC后加密”来区分SSL和IPsec

76
00:05:57,002 --> 00:06:02,112
重复一下我刚才所讲，IPsec方法“先加密后MAC”

77
00:06:02,112 --> 00:06:07,160
总是提供认证加密。如果你从一个CPA安全密码和一个安全MAC出发

78
00:06:07,160 --> 00:06:11,110
你将总是得到认证加密。就像我所说的，事实上

79
00:06:11,110 --> 00:06:15,737
先MAC后加密有一些病态的情况，结果对CCA攻击是脆弱的

80
00:06:15,737 --> 00:06:20,308
因此它并不提供认证加密。然而，实际上

81
00:06:20,308 --> 00:06:24,653
比这要有趣。如果你使用随机计数器模式

82
00:06:24,653 --> 00:06:29,224
或随机CBC，那么对那些CPA安全的加密机制

83
00:06:29,224 --> 00:06:33,625
先MAC后加密确实提供了认证加密

84
00:06:33,625 --> 00:06:38,028
因此是安全的。事实上，更有趣的是

85
00:06:38,028 --> 00:06:42,334
如果你使用了随机计数器模式

86
00:06:42,334 --> 00:06:46,804
那么你的MAC算法只要是一次性安全的就够了，不需要是完全安全的MAC

87
00:06:46,804 --> 00:06:51,561
只需要当密钥只用于加密单个信息时是安全的即可

88
00:06:51,561 --> 00:06:56,088
我们讨论信息完整性时，看到过有一些

89
00:06:56,088 --> 00:07:00,575
快得多的MAC算法，它们是一次性安全的，而非完全安全的MAC

90
00:07:00,575 --> 00:07:04,454
因此如果你使用随机计数器模式，先MAC后加密

91
00:07:04,454 --> 00:07:08,187
实际上可以构造一个更有效率的加密机制。但我还要重复一遍

92
00:07:08,187 --> 00:07:12,213
推荐使用先加密后MAC

93
00:07:12,213 --> 00:07:16,093
我们将看到许多针对未使用先加密后MAC的系统的攻击

94
00:07:16,093 --> 00:07:20,120
为了确保安全，同时不必思考太多

95
00:07:20,120 --> 00:07:24,118
我推荐大家始终使用先加密后MAC

96
00:07:24,118 --> 00:07:27,759
现在一旦认证加密的观念变得更流行

97
00:07:27,759 --> 00:07:31,609
很多组合加密和MAC的标准方法便涌现出来

98
00:07:31,609 --> 00:07:35,978
还有些是国家标准局（NIST）的标准方法。我们将讨论其中三个标准

99
00:07:35,978 --> 00:07:41,031
其中两个是由NIST标准化的

100
00:07:41,031 --> 00:07:46,138
分别叫做Galois计数器模式（GCM）和CBC计数器模式（CCM）我来解释一下它们的工作过程

101
00:07:46,138 --> 00:07:51,245
Galois计数器模式使用了计数器模式加密

102
00:07:51,245 --> 00:07:56,164
即使用Carter-Wegman MAC的随机计数器模式，一个非常快速的Carter-Wegman MAC


103
00:07:56,164 --> 00:08:01,146
GCM的Carter-Wegman MAC如下工作：它是待求MAC的信息的一个哈希函数

104
00:08:01,146 --> 00:08:06,311
然后用一个PRF加密哈希的结果

105
00:08:06,311 --> 00:08:11,562
现在GCM里的这个哈希函数已经很快了

106
00:08:11,562 --> 00:08:15,845
GCM的运行时间受制于计数器模式

107
00:08:15,845 --> 00:08:22,371
为了更快，Intel引入了一个特殊指令PCLMULQDQ

108
00:08:22,371 --> 00:08:27,432
特别为此设计，目标是让GCM的这个哈希函数跑的尽可能的快

109
00:08:27,432 --> 00:08:32,950
现在CCM计数器模式是另一个NIST标准，它使用CBC MAC

110
00:08:32,950 --> 00:08:37,276
然后用计数器模式加密。这个机制使用MAC

111
00:08:37,276 --> 00:08:40,906
然后加密，就像SSL那样。这并不是推荐的方法

112
00:08:40,906 --> 00:08:44,023
但因为使用的是计数器模式，这实际上

113
00:08:44,023 --> 00:08:47,945
是一个很好的加密机制。关于CCM我要指出一点

114
00:08:47,945 --> 00:08:53,799
一切都是基于AES的。大家注意，它的CBC-MAC使用了AES

115
00:08:53,799 --> 00:08:58,778
它的计数器模式也是使用的AES

116
00:08:58,778 --> 00:09:03,084
因此CCM可以用相对少的代码实现，因为需要的仅为AES引擎

117
00:09:03,084 --> 00:09:08,343
其他都不需要，因为这点，CCM被Wi-Fi所采用

118
00:09:08,343 --> 00:09:13,963
事实上，你很有可能每天都在使用CCM

119
00:09:13,963 --> 00:09:19,093
如果你使用加密的Wi-Fi 802.11i，那么你就在使用CCM来加密

120
00:09:19,093 --> 00:09:23,450
你的笔记本和接入点之间的通信。还有一个模式叫做EAX

121
00:09:23,450 --> 00:09:28,922
使用的计数器模式加密，然后是CMAC，大家注意，这次是先加密后MAC

122
00:09:28,922 --> 00:09:31,906
这是另一个很好的模式。我们待会来对这些模式做个比较

123
00:09:31,906 --> 00:09:36,806
现在我想提一下，首先，所有的这些模式都是基于新鲜值的

124
00:09:36,806 --> 00:09:41,190
换句话说它们不使用任何随机性，但它们取新鲜值为输入

125
00:09:41,190 --> 00:09:46,360
而且每个密钥的新鲜值是唯一的，换句话说

126
00:09:46,360 --> 00:09:50,600
大家记得，有序对（密钥，新鲜值）永远不该重复使用

127
00:09:50,600 --> 00:09:53,851
但新鲜值本身不一定是随机的，所以完全可以使用一个计数器

128
00:09:53,851 --> 00:09:57,520
比如新鲜值。另一个重要的地方是，事实上

129
00:09:57,520 --> 00:10:01,384
所有的这些模式被称为带相关数据的认证加密（AEAD）

130
00:10:01,384 --> 00:10:04,936
这是一个认证加密的扩展

131
00:10:04,936 --> 00:10:10,884
这在网络协议中经常出现，AEAD的想法是

132
00:10:10,884 --> 00:10:15,223
提供给加密模式的信息不被完全

133
00:10:15,223 --> 00:10:19,924
加密 只有部分信息是被加密的

134
00:10:19,924 --> 00:10:24,157
但所有信息是被认证的 这里有一个好例子是网络数据包只有部分信息是被加密的

135
00:10:24,157 --> 00:10:29,408
考虑一个IP包 有报文头 然后是封装数据

136
00:10:29,408 --> 00:10:33,157
一般来说 报文头不会被加密 例如报文头可能包含

137
00:10:33,157 --> 00:10:36,905
数据包的目标地址 那么报文头最好不要被加密

138
00:10:36,905 --> 00:10:40,950
免得图中的路由器不知道如何路由

139
00:10:40,950 --> 00:10:45,225
一般来说 报文头以明文形式发送 但当然

140
00:10:45,225 --> 00:10:49,500
封装数据总是被加密的 不过你还是希望报文头被认证

141
00:10:49,500 --> 00:10:55,907
不用加密 但需认证 那么这就是这些AED模式的工作

142
00:10:55,907 --> 00:11:00,033
他们会认证报文头 然后加密封装数据

143
00:11:00,033 --> 00:11:04,177
但在认证中 报文头和封装数据是被绑定在一起的

144
00:11:04,177 --> 00:11:07,803
这样它们不能分开 这不能做到

145
00:11:07,803 --> 00:11:14,170
在这三种模式GCM CCM和EAX中 MAC应用到整个报头文数据上

146
00:11:14,170 --> 00:11:18,852
不过加密只被应用到部分需要加密的数据上

147
00:11:18,852 --> 00:11:22,983
所以我想为大家展示一个带相关数据的认证加密的API

148
00:11:22,983 --> 00:11:28,716
长什么样 它在OpenSSL中长这样

149
00:11:28,716 --> 00:11:33,609
例如 这是一个GCM的API 你可以调用init函数

150
00:11:33,609 --> 00:11:37,404
来初始化这个加密模式 然后注意到它一个密钥和新鲜值

151
00:11:37,404 --> 00:11:40,609
这个新鲜值也不必是随机的 但它必须是唯一的

152
00:11:40,609 --> 00:11:44,402
初始化后 调用这个加密函数

153
00:11:44,402 --> 00:11:48,169
给它需要认证 但不需要加密的相关数据

154
00:11:48,169 --> 00:11:51,794
然后给它需要认证和加密的数据

155
00:11:51,794 --> 00:11:55,752
函数就会返回整个数据加密后的密文

156
00:11:55,752 --> 00:11:59,582
不过当然 不包括AED 因为AED需要以明文形式发送

157
00:11:59,582 --> 00:12:04,535
那么我们现在理解了这个“先加密后MAC”的机制

158
00:12:04,535 --> 00:12:09,951
我们可以回到MAC的安全性定义 我可以为大家解释

159
00:12:09,951 --> 00:12:13,970
定义里一些看起来略难懂的地方 如果大家还记得

160
00:12:13,970 --> 00:12:18,570
安全MAC定义的要求之一是 如果大家还记得

161
00:12:18,570 --> 00:12:25,689
给定信息M的信息 MAC对 攻击者不能产生

162
00:12:25,689 --> 00:12:30,386
同样的信息M的另一个标签 换句话说 即使攻击者已经有了信息M的一个标签

163
00:12:30,386 --> 00:12:34,771
他也不能产生同样信息M的一个新标签

164
00:12:34,771 --> 00:12:39,382
还不太清楚为什么这点很要紧 谁在乎这点呢 如果攻击者已经

165
00:12:39,382 --> 00:12:44,038
有了信息M的一个标签 谁在乎他是否能产生另一个标签？

166
00:12:44,038 --> 00:12:48,828
实际上如果MAC没有这一性质 换句话说 给定一对信息和MAC

167
00:12:48,828 --> 00:12:53,618
你能产生同样信息的另一个MAC 那么这个MAC会造成一个不安全的“先加密后MAC”

168
00:12:53,618 --> 00:12:58,694
的模式 如果我们想让我们的“先加密后MAC”

169
00:12:58,694 --> 00:13:03,961
具有密文完整性 很重要的一点是 我们的MAC的安全性

170
00:13:03,961 --> 00:13:08,910
蕴含着这个安全观点 当然这是因为我们定义的正确

171
00:13:08,910 --> 00:13:13,613
那么我们看会出错的 事实上容易产生这种伪造

172
00:13:13,613 --> 00:13:18,081
我会告诉大家一种在“先加密后MAC”系统上的选择密文攻击

173
00:13:18,081 --> 00:13:22,784
由于这个系统有一种选择密文攻击

174
00:13:22,784 --> 00:13:27,193
这就意味着它不提供认证加密

175
00:13:27,193 --> 00:13:31,458
我们来看看 一开始 攻击者发送两个信息

176
00:13:31,458 --> 00:13:35,861
M0和M1 通常他会收到

177
00:13:35,861 --> 00:13:39,522
M0或M1的加密结果 由于我们使用“先加密后MAC”

178
00:13:39,522 --> 00:13:44,907
攻击者收到的密文我们记为C0

179
00:13:44,907 --> 00:13:49,883
C0上有一MAC 我们说过 给定信息的MAC

180
00:13:49,883 --> 00:13:53,827
攻击者可以产生同样信息的另一个MAC

181
00:13:53,827 --> 00:13:57,994
这样他将产生信息C0的另一个MAC

182
00:13:57,994 --> 00:14:03,532
现在他有了一个新的密文（C0，T') 是一个完全有效的密文

183
00:14:03,532 --> 00:14:09,558
T'是C0的一个有效MAC 所以 攻击者可以提交

184
00:14:09,558 --> 00:14:14,492
C'和一个选择密文的询问 这是一个有效的选择密文的询问

185
00:14:14,492 --> 00:14:19,288
因为它和C不同 它是一个新的密文 可怜的挑战者

186
00:14:19,288 --> 00:14:23,278
被迫去解密这个密文C' 然后发送C'的解密

187
00:14:23,278 --> 00:14:29,093
它是一个有效的密文 所以C'的解密是信息Mb

188
00:14:29,093 --> 00:14:32,318
但现在攻击者就学得了b的值 因为他可以测试

189
00:14:32,318 --> 00:14:37,371
Mb等于M0还是M1 因此他能输出b

190
00:14:37,371 --> 00:14:43,468
以优势1赢得这个机制 如果我们的MAC的安全性不蕴含这里的性质

191
00:14:43,468 --> 00:14:48,471
那么在这个“先加密后MAC”的系统上有一个选择密文攻击

192
00:14:48,471 --> 00:14:53,181
因此 它将是不安全的 所以我们正确定义了MAC的安全性

193
00:14:53,181 --> 00:14:57,241
意味着“先加密后MAC”的确提供了认证加密

194
00:14:57,241 --> 00:15:01,728
我们讨论过的所有MAC都满足这一很强的不可伪造的观点

195
00:15:01,728 --> 00:15:06,146
有趣的是 故事还没有结束

196
00:15:06,146 --> 00:15:10,385
我们在引入认证加密的概念之前曾经说过

197
00:15:10,385 --> 00:15:15,295
人们以不同的方式组合MAC和加密 以获得认证加密

198
00:15:15,295 --> 00:15:19,201
在认证加密的观点被严格地形式化后

199
00:15:19,201 --> 00:15:23,553
人们开始搔脑袋 说

200
00:15:23,553 --> 00:15:28,130
嘿 等一下 或许我们可以获取到

201
00:15:28,130 --> 00:15:32,722
更加有效的获得认证加密。事实上

202
00:15:32,722 --> 00:15:37,366
如果考虑MAC和加密的组合是如何工作的，比如说组合计数器模式和CMAC

203
00:15:37,366 --> 00:15:42,134
那么对每个明文分组，首先必须使用

204
00:15:42,134 --> 00:15:46,419
你的分组密码以计数器模式，然后必须再次使用分组密码

205
00:15:46,419 --> 00:15:51,357
运行CBC-MAC。这意味着如果你把CPA安全的加密

206
00:15:51,357 --> 00:15:55,943
和一个MAC组合起来，对每个明文分组，你必须计算你的分组密码两次

207
00:15:55,943 --> 00:16:00,535
一次计算MAC，一次计算加密机制

208
00:16:00,535 --> 00:16:05,396
自然问题就来了，我们能否由一个PRP直接构建一个认证加密机制

209
00:16:05,396 --> 00:16:10,345
这样一来我们可以对每个分组，只计算PRP一次

210
00:16:10,345 --> 00:16:14,117
实际上答案是肯定的，有这个漂亮的构造叫做OCB

211
00:16:14,117 --> 00:16:18,343
它能做你想要的一切，而且比从加密和MAC分别构造的机

212
00:16:18,343 --> 00:16:22,467
快很多。那么我写下了OCB的机制

213
00:16:22,467 --> 00:16:26,290
我不想解释太多细节。我从高层次来解释一下

214
00:16:26,290 --> 00:16:30,025
这里有我们的输入明文，在这上面

215
00:16:30,025 --> 00:16:34,540
大家注意，首先，OCB是可并行的，完全可并行的

216
00:16:34,540 --> 00:16:39,700
所以每个分组可以被单独加密

217
00:16:39,700 --> 00:16:44,338
另一件事是，如我所保证的，对每个明文分组，你只需计算一次分组密码

218
00:16:44,338 --> 00:16:49,318
然后在最后再计算一次分组密码，以构建

219
00:16:49,318 --> 00:16:53,887
认证标签，那么除去分组密码部分，OCB的开销是最小的

220
00:16:53,887 --> 00:16:58,749
你只需计算一个非常简单的函数P

221
00:16:58,749 --> 00:17:02,844
新鲜值交给了P，密钥也给了P

222
00:17:02,844 --> 00:17:08,238
然后还有一个分组计数器交给了P。所以你只需计算这个函数P

223
00:17:08,238 --> 00:17:12,748
每个分组两次，然后与之前的结果异或

224
00:17:12,748 --> 00:17:17,553
使用分组密码加密之后，就结束了。你获得了

225
00:17:17,553 --> 00:17:22,241
一个快速有效的，由分组密码构建的认证加密机制

226
00:17:22,241 --> 00:17:26,065
所以OCB有一个附带的很好的安全性定理

227
00:17:26,065 --> 00:17:29,567
在本章末，我要指出一篇关于OCB的论文

228
00:17:29,567 --> 00:17:34,457
届时我会列出一些大家可进一步阅读的论文。大家可能想知道

229
00:17:34,457 --> 00:17:40,168
如果OCB比目前看到过的其他机制都好，包括CCM,GCM

230
00:17:40,168 --> 00:17:46,037
以及EAX，为什么OCB没怎么被使用？为什么OCB不是标准？

231
00:17:46,037 --> 00:17:50,729
这是个令人悲伤的答案。OCB没被应用的主要原因

232
00:17:50,729 --> 00:17:54,567
是因为各种各样的专利。我这里就不提了。

233
00:17:54,567 --> 00:17:58,216
总结一下本书，我想给大家一些性能参数

234
00:17:58,216 --> 00:18:02,368
右边我列了这些大家不该用的模式的性能参数

235
00:18:02,368 --> 00:18:07,879
这是随机计数器模式，这是随机CBC

236
00:18:07,879 --> 00:18:12,460
大家还可以看到CBC-MAC的性能和CBC加密的性能基本一样

237
00:18:12,460 --> 00:18:16,221
现在这里是认证加密模式

238
00:18:16,221 --> 00:18:20,083
所以这些是大家应当使用的模式了，右边的大家不要用

239
00:18:20,083 --> 00:18:23,795
这两个，大家永远不应该使用这两个

240
00:18:23,795 --> 00:18:27,858
因为它们只提供CPA安全它们不提供对抗主动攻击的安全性

241
00:18:27,858 --> 00:18:31,669
大家只应该使用认证加密来进行加密

242
00:18:31,669 --> 00:18:35,509
所以我列了这三个标准的性能参数

243
00:18:35,509 --> 00:18:40,109
让我提醒大家，GCM使用了非常快速的哈希函数。然后它在加密中使用了计数器模式

244
00:18:40,109 --> 00:18:43,770
你可以看到，计数器模式的GCM的开销

245
00:18:43,770 --> 00:18:49,554
相对是很小的。CCM和EAX都使用了一个基于分组密码的加密

246
00:18:49,554 --> 00:18:54,627
和一个基于分组密码的MAC。因此它们的运行时间大约是计数器模式的两倍

247
00:18:54,627 --> 00:18:59,196
大家看到，OCB是这些当中最快的

248
00:18:59,196 --> 00:19:03,820
主要是因为它对每个明文只使用一次分组密码

249
00:19:03,820 --> 00:19:08,328
根据这些性能参数，大家会认为GCM正是应该一直使用的正确模式

250
00:19:08,328 --> 00:19:12,659
但实际上，如果你在空间有限的硬件设备上，GCM并不理想

251
00:19:12,659 --> 00:19:16,709
主要是因为它的实现需要比其他两个模式更多的代码

252
00:19:16,709 --> 00:19:21,323
但是，如我所说，Intel特地加了指令

253
00:19:21,323 --> 00:19:26,064
来加速GCM模式。因此在Intel体系结构上实现GCM

254
00:19:26,064 --> 00:19:30,315
只需要很少的代码。但在其他硬件平台上，比如说智能卡或其他受限的硬件环境

255
00:19:30,315 --> 00:19:34,745
实现GCM的代码大小会比其他两个模式

256
00:19:34,745 --> 00:19:39,387
大得多。但如果代码大小不受限制的话

257
00:19:39,387 --> 00:19:43,928
那么GCM是正确的选择。总结一下本节，我想再说一次

258
00:19:43,928 --> 00:19:48,267
当你想加密信息时，你必须使用认证加密模式

259
00:19:48,267 --> 00:19:52,716
推荐的方法是使用这些标准中的一个

260
00:19:52,716 --> 00:19:57,037
这三个标准中的一个，以提供认证加密

261
00:19:57,037 --> 00:19:59,846
不要自己实现加密机制。换句话说

262
00:19:59,846 --> 00:20:05,842
不要自己先加密后MAC，就使用三个标准中的一个

263
00:20:05,842 --> 00:20:10,513
现在许多密码学库提供了这三种模式的标准API

264
00:20:10,513 --> 00:20:14,347
你应该使用这些，而不是别的。下一节，我们要看

265
00:20:14,347 --> 00:20:17,500
当你试图自己实现认证加密时，还会发生什么错误

