1
00:00:00,000 --> 00:00:03,416
现在我们理解了什么是确定性加密，让我们看一些

2
00:00:03,416 --> 00:00:07,025
针对确定性选择明文攻击提供安全性的构式。

3
00:00:07,025 --> 00:00:11,297
首先让我提醒你下确定性加密是必需的，

4
00:00:11,297 --> 00:00:15,733
例如，当加密数据库索引,然后我们想要查找用加密的索引的记录。

5
00:00:15,733 --> 00:00:19,675
因为加密是确定性的，我们保证

6
00:00:19,675 --> 00:00:24,275
我们所查找的加密索引

7
00:00:24,275 --> 00:00:28,491
跟被送入数据库的加密索引是一样的，

8
00:00:28,491 --> 00:00:33,145
当记录被写进数据库时。所以确定性加密允许我们通过一个非常简单或者

9
00:00:33,145 --> 00:00:37,363
快速的方式在加密索引中查找。

10
00:00:37,363 --> 00:00:41,506
问题是我们所说的确定性加密可能是不安全的对于一般的选择性明文攻击

11
00:00:41,506 --> 00:00:46,075
因为如果攻击者看到两个相等的密文

12
00:00:46,075 --> 00:00:50,377
则它们所加密的消息也是一样的。

13
00:00:50,377 --> 00:00:54,734
所以我们定义了这个确定性选择性明文安全性的概念

14
00:00:54,734 --> 00:00:58,983
也就是我们拥有这样的安全保证：加密者绝不会用一个给定的密钥来加密相同的消息多次。

15
00:00:58,983 --> 00:01:03,468
特别地，密钥，消息对只会被用一次，对每一次加密。

16
00:01:03,468 --> 00:01:08,152
要么密钥改变，要么消息改变。

17
00:01:08,152 --> 00:01:12,775
正如我说的，通常我们定义这个CPA,确定性CPA安全游戏，

18
00:01:12,775 --> 00:01:17,764
我们在这一节中的目标就是给出确定性CPA安全的构式。

19
00:01:17,764 --> 00:01:22,463
所以我们将看到的第一个构式是什么叫做SIV，合成的IV

20
00:01:22,463 --> 00:01:26,552
这个构式工作的方式如下。

21
00:01:26,552 --> 00:01:30,873
假如我们有个一般的CPA安全加密系统。有密钥和消息

22
00:01:30,873 --> 00:01:35,302
我们用R表示加密算法所使用的随机性。

23
00:01:35,302 --> 00:01:39,623
切记一个CPA安全系统，没用一个多余词，必须是随机的

24
00:01:39,623 --> 00:01:44,051
我们要明确地写下这个随机数R来表示随机字符串，

25
00:01:44,051 --> 00:01:47,940
加密算法所用到的，正在做的加密。

26
00:01:47,940 --> 00:01:52,045
例如如果我们正在用随机的计数器模式，R将会是随机IV。

27
00:01:52,045 --> 00:01:56,664
当然C是生成的密文。

28
00:01:56,664 --> 00:02:01,904
另外，我们也将需要一个伪随机函数，F，

29
00:02:01,904 --> 00:02:06,691
它要做的就是，给我们一个任意的消息，

30
00:02:06,691 --> 00:02:11,477
并输出一个字符串，R，能作为随机数被用在CPA安全加密方案中的。

31
00:02:11,477 --> 00:02:16,502
r,只是R组中的一个。好的。

32
00:02:16,502 --> 00:02:21,592
我们假定这是a,f是伪随机函数，映射消息给随机字符串的。

33
00:02:21,592 --> 00:02:26,500
现在SIV工作方式如下。它用两个密钥K1和K2来加密消息M。

34
00:02:26,500 --> 00:02:31,348
它所做的就是，

35
00:02:31,348 --> 00:02:36,437
首先应用伪随机函数f为消息M引出用于CPA安全加密方案E的随机数。

36
00:02:36,437 --> 00:02:41,406
然后用这个随机数来加密消息M。

37
00:02:41,406 --> 00:02:46,253
它将会给我们一个密文C，然后输出C。

38
00:02:46,253 --> 00:02:51,273
好的。这就是SIV模式是如何工作的。

39
00:02:51,273 --> 00:02:56,342
基本上就是它先从已加密的消息中导出随机数，

40
00:02:56,342 --> 00:03:01,049
然后用这个随机数来加密消息从而获得相应的密文。

41
00:03:01,049 --> 00:03:05,696
现我想指出一个例子，如果加密方案E恰好是随机计数器模式，

42
00:03:05,696 --> 00:03:10,173
随机数R将只是随机数IV，

43
00:03:10,173 --> 00:03:14,525
将与密文一同被输出。

44
00:03:14,525 --> 00:03:18,665
这就意味着密文比明文长点。

45
00:03:18,665 --> 00:03:22,698
但是关键不是生成一个短密文，而是要确保

46
00:03:22,698 --> 00:03:26,679
加密方案是确定性的，这样如果我们加密相同的消息多次，

47
00:03:26,679 --> 00:03:30,713
每次我们都应该得到相同的密文。

48
00:03:30,713 --> 00:03:34,959
的确每次，我们将获得相应的随机数R，因此，

49
00:03:34,959 --> 00:03:39,050
每次我们也会得到相同的密文C。这是相当容易的来表明

50
00:03:39,050 --> 00:03:43,584
这个加密方案语义上是安全的在确定性选择明文攻击下。

51
00:03:43,584 --> 00:03:48,060
原因是因为我们用伪随机函数F来区别消息。

52
00:03:48,060 --> 00:03:52,708
如果我们用F来区别消息

53
00:03:52,708 --> 00:03:57,357
然后F生成的随机字符串看起来是真的随机字符串。

54
00:03:57,357 --> 00:04:02,177
对每个消息都是不同的随机字符串。因此CPA安全加密模式E

55
00:04:02,177 --> 00:04:06,596
总是用真的随机字符串。

56
00:04:06,596 --> 00:04:10,463
这正是CPA安全环境。因为这些R只是随机的，不能和全新字符串区分的，

57
00:04:10,463 --> 00:04:14,838
因此生成的系统事实上是CPA安全的。

58
00:04:14,838 --> 00:04:18,999
所以这只是直观上为什么这么工作，

59
00:04:18,999 --> 00:04:23,040
它实际上是相当简单的形式化到一个完整的证明。

60
00:04:23,040 --> 00:04:27,057
我应该着重说他实际上非常适合于多于一个AES块的消息。

61
00:04:27,057 --> 00:04:30,722
事实上，对于短消息，我们来看一个稍微不同的加密方案，

62
00:04:30,722 --> 00:04:34,438
总是能更好地适用于这些短消息。

63
00:04:34,438 --> 00:04:38,505
好的，现在真的很酷的事情关于SIV的是，事实上，

64
00:04:38,505 --> 00:04:42,803
我们免费地得到完整密文。事实上我们不必用特殊的MAC，如果我们想增加完整性的话。

65
00:04:42,803 --> 00:04:47,307
在某种意义上SIV早有内建在完整性机制上。

66
00:04:47,307 --> 00:04:51,486
让我来解释下我说的意思。首先，我们的目标是建立

67
00:04:51,486 --> 00:04:55,340
确定性的已认证的加密。

68
00:04:55,340 --> 00:04:59,681
这表示确定性CPA安全和密文完整性

69
00:04:59,681 --> 00:05:04,023
记住，完整性表示

70
00:05:04,023 --> 00:05:08,527
攻击者得到他所选择请求的消息的加密

71
00:05:08,527 --> 00:05:12,831
但不能生成其他密文，使之解密出一个有效的消息

72
00:05:12,831 --> 00:05:17,892
好的，事实上SIV自动提供了密文完整性

73
00:05:17,892 --> 00:05:22,831
而不需要内嵌MAC或其他。我们来看看为什么

74
00:05:22,831 --> 00:05:27,769
我们来看一种特殊的SIV，即加密机制是随机计数器模式

75
00:05:27,769 --> 00:05:32,398
我们称之为SIV-CTR，表示SIV使用随机计数器

76
00:05:32,398 --> 00:05:37,388
回想SIV是如何工作的

77
00:05:37,388 --> 00:05:42,189
我们得到一个消息

78
00:05:42,189 --> 00:05:46,682
把它传给PRF，得到IV

79
00:05:46,682 --> 00:05:51,122
然后IV用来在随机计数器模式加密消息

80
00:05:51,122 --> 00:05:55,890
我们将使用这个PRF，FCTR，随机计数器模式

81
00:05:55,890 --> 00:06:00,659
计算FCTR在IV，IV加1，直到IV加L的值

82
00:06:00,659 --> 00:06:05,613
我们得到最后的密文

83
00:06:05,613 --> 00:06:10,258
那么这是随机计数器模式SIV

84
00:06:10,258 --> 00:06:15,139
现在我们来看如何解密。解密时有一个额外的检查

85
00:06:15,139 --> 00:06:20,859
这提供了密文完整性，那么我们来看如何解密

86
00:06:20,859 --> 00:06:25,420
这里我们的输入含有IV和密文

87
00:06:25,420 --> 00:06:30,514
首先我们使用给出的IV解密密文

88
00:06:30,514 --> 00:06:35,252
得到候选明文

89
00:06:35,252 --> 00:06:39,813
我们再用SIV定义的PRF F对消息处理

90
00:06:39,813 --> 00:06:44,492
如果消息有效，那么得到的IV和密文中给出的IV相同

91
00:06:44,492 --> 00:06:48,994
如果得到了不同的IV，那么我们知道消息无效

92
00:06:48,994 --> 00:06:53,863
我们拒绝这个密文。这很聪明。

93
00:06:53,863 --> 00:06:58,838
这是个简单的内部机制来检查密文是否有效

94
00:06:58,838 --> 00:07:03,875
我们简单地检查解密后得到的IV是不是正确的IV

95
00:07:03,875 --> 00:07:08,425
如果不是，我们拒绝消息

96
00:07:08,425 --> 00:07:12,461
这个解密时的简单的检查足以提供密文完整性

97
00:07:12,461 --> 00:07:17,095
因此也提供确定性认证加密。我来表示成一个简单的定理

98
00:07:17,095 --> 00:07:22,100
如果F是安全的PRF，计数器模式下的FCTR是CPA安全

99
00:07:22,100 --> 00:07:27,560
那么结果得到的是确定性安全加密的系统

100
00:07:27,560 --> 00:07:32,231
这个的证明不是很难

101
00:07:32,231 --> 00:07:36,707
接下来从直觉来看为什么是对的

102
00:07:36,707 --> 00:07:41,471
我们要证明密文完整性，以前证明过系统具有确定性CPA安全

103
00:07:41,471 --> 00:07:46,235
现在只需要证明密文完整性

104
00:07:46,235 --> 00:07:50,425
因此来证系统具有密文完整性

105
00:07:50,425 --> 00:07:54,442
想想密文完整性游戏是怎样的。敌手请求所选的一组消息的加密

106
00:07:54,442 --> 00:07:58,919
然后得到密文

107
00:07:58,919 --> 00:08:03,807
他的目标是产生一个新的有效的密文

108
00:08:03,807 --> 00:08:09,712
如果对这个有效的密文解密，那么得到完整的新消息

109
00:08:09,712 --> 00:08:14,978
然后当我们把这个新消息传递给PRF F，我们就得到随机IV

110
00:08:14,978 --> 00:08:20,181
这个随机IV不太可能等于敌手密文所提供的

111
00:08:20,181 --> 00:08:25,070
因此当敌手输出伪造的密文

112
00:08:25,070 --> 00:08:29,772
密文中的消息应该等于他选择的询问消息

113
00:08:29,772 --> 00:08:34,770
否则得到的IV

114
00:08:34,770 --> 00:08:39,623
很大概率不等于伪造的消息

115
00:08:39,623 --> 00:08:44,262
但是如果消息等于敌手进行询问的消息

116
00:08:44,262 --> 00:08:48,577
得到的密文

117
00:08:48,577 --> 00:08:53,003
也等于我们提供给敌手的密文

118
00:08:53,003 --> 00:08:57,484
但是他伪造的消息就和我们给他的消息相同

119
00:08:57,484 --> 00:09:02,021
因此这不是一个有效的伪造。他必须给我们一个新的密文来赢得密文完整性游戏

120
00:09:02,021 --> 00:09:06,332
但是他给我们的是旧消息中的一个

121
00:09:06,332 --> 00:09:10,530
因此这是直观的证明。我希望这有意义

122
00:09:10,530 --> 00:09:14,781
我在这节的最后将参考描述SIV的论文

123
00:09:14,781 --> 00:09:18,980
如果你想了解更多细节

124
00:09:18,980 --> 00:09:22,916
你可以去读这篇论文

125
00:09:22,916 --> 00:09:27,167
这是一个很聪明的想法

126
00:09:27,167 --> 00:09:31,418
我们使用PRF为确定性计数器模式提供随机性

127
00:09:31,418 --> 00:09:35,999
解密时提供完整性检验

128
00:09:35,999 --> 00:09:40,800
因此SIV是确定性加密的一个好模式，如果消息很长

129
00:09:40,800 --> 00:09:45,542
如果消息很短，小于16个字节

130
00:09:45,542 --> 00:09:50,285
事实上有更好的方式，这就是我现在要讲的

131
00:09:50,285 --> 00:09:54,739
第二种构造实际是不重要的，我们只需要直接使用一个PRP

132
00:09:54,739 --> 00:09:59,482
我们将这么做。假设(E,D)是一个安全PRP

133
00:09:59,482 --> 00:10:06,052
如果我们直接使用E的话 那么我们就已经保证了CPA安全性

134
00:10:06,052 --> 00:10:11,642
让我来快速解释一下这是为什么 假设F是一个从X映射到X的真随机可逆函数

135
00:10:11,642 --> 00:10:15,642
记住 我们无法区分PRP与一个真的随机可逆函数

136
00:10:15,642 --> 00:10:20,106
假设我们真的有一个真随机可逆函数

137
00:10:20,106 --> 00:10:24,801
在实验0中 攻击者在提交一堆信息时所会看到的

138
00:10:24,801 --> 00:10:29,470
你们都知道左侧的信息 而他所看到的

139
00:10:29,470 --> 00:10:34,550
就是函数f在他所提供的左侧的信息出的取值

140
00:10:34,550 --> 00:10:39,694
在一个确定性CPA游戏中 所有的信息都是不同的

141
00:10:39,694 --> 00:10:44,838
而他得到的仅仅是q个属于X且互不相同的随机值 这就是他能看到的全部

142
00:10:44,838 --> 00:10:50,006
我们有q个属于X的且互不相同的随机值 现在让我们来考虑一下实验一

143
00:10:50,006 --> 00:10:55,989
在实验一中 他将会看到右侧信息的加密

144
00:10:55,989 --> 00:11:01,757
也就是从m(1,1)到m(q,1) 再强调一次 所有的的信息都不同的

145
00:11:01,757 --> 00:11:07,227
所以他能看到的只是q个属于X的不同的随机值 所以 在实验0和实验1中

146
00:11:07,227 --> 00:11:11,308
的这组分布是完全相同的

147
00:11:11,308 --> 00:11:15,606
基本上 在两种情况下他能看到的都仅仅只是q个属于X的且互不相同的随机值

148
00:11:15,606 --> 00:11:19,795
所以 他不能够区分出实验0和实验1来

149
00:11:19,795 --> 00:11:24,251
既然对于一个真随机函数来说 攻击者不能区分 那么对于一个PRP来说他也不能区分

150
00:11:24,251 --> 00:11:29,529
这就解释了什么用PRP直接加密能给我们提供一个具有CPA安全的

151
00:11:29,529 --> 00:11:34,485
且很容易使用的系统 这就是说如果我们只是要加密短的信息

152
00:11:34,485 --> 00:11:39,441
比如 小于16比特大小的信息 那么我们需要做的就是

153
00:11:39,441 --> 00:11:44,655
用AES来直接机密它 结果自然就是确定性CPA安全的

154
00:11:44,655 --> 00:11:49,997
所以 如果你的指数是小于16比特的话 那么直接使用AES是一个不错的方法

155
00:11:49,997 --> 00:11:53,821
然而我们注意到 这并不能给我们提供任何完整性

156
00:11:53,821 --> 00:11:57,989
我们将要看到如何加入完整性 但现在给你们的问题是

157
00:11:57,989 --> 00:12:02,544
当我们有一个超过16比特的信息时该怎么做 一个选择是使用SIV

158
00:12:02,544 --> 00:12:07,157
但如果我们继续要使用这样的结构 该怎么做 这是一个

159
00:12:07,157 --> 00:12:11,598
很有意思的问题 我们能不能构建一个信息空间超过16比特的PRP

160
00:12:11,598 --> 00:12:16,154
如果你还记得我们曾经讲过的

161
00:12:16,154 --> 00:12:20,652
我们可以用一个小信息空间的PRF构建一个大信息空间的PRF

162
00:12:20,652 --> 00:12:25,436
所以在这里 我们要用一个小信息空间的PRP构建一个大信息空间的PRP

163
00:12:25,436 --> 00:12:30,172
接下来就是如何构建这样一个PRP 假设（E,D）是一个安全的

164
00:12:30,172 --> 00:12:35,611
在n比特分组上执行的PRP 这里有一种被称作EME的标准模式

165
00:12:35,611 --> 00:12:41,491
这种模式能够构建出一个在N比特分组上执行的PRP 在这里

166
00:12:41,491 --> 00:12:46,284
N要远远大于n 这就允许我们在比16比特更大的信息空间上做确定性加密

167
00:12:46,284 --> 00:12:50,866
实际上这样做可以让信息空间达到任何长度

168
00:12:50,866 --> 00:12:55,262
让我们来看以EME是如何工作的 一开始的是看有一点困难

169
00:12:55,262 --> 00:12:59,698
但这并不是一个复杂的结构 来看一下它是如何工作的

170
00:12:59,698 --> 00:13:04,484
EME使用两个密钥 K和L 实际上在真实的EME中 L源于K 但是为了我们的目的


171
00:13:04,484 --> 00:13:09,096
我们假设K和L是两个不同的密钥 首先

172
00:13:09,096 --> 00:13:13,840
我们选取信息X 把它分成几个分组 然后我们把每个分组同一个确定的填充函数做异或

173
00:13:13,840 --> 00:13:18,730
我们用密钥L导出填充

174
00:13:18,913 --> 00:13:23,681
使用这个函数P 你们都已经了解这个函数 我不打算再解释了

175
00:13:23,681 --> 00:13:28,949
我们对每一个不同的分组都导出一个不同的填充 然后我们将分组与填充做异或

176
00:13:28,949 --> 00:13:35,348
接下来要做的就是 我们将密钥K输入到PRP E中 对于每一个分组

177
00:13:35,348 --> 00:13:41,230
我们将它们的输出称为PP0 PP1 PP2 然后

178
00:13:41,230 --> 00:13:46,350
我们将所有的PP做异或到一起并把结构叫做MP

179
00:13:46,350 --> 00:13:51,341
实际上这个地方并不需要做异或 我们将异或的结果成为MP 然后

180
00:13:51,341 --> 00:13:56,591
然后我们将所有的PPP异或到一起并把结果称作MP 我们将MP

181
00:13:56,591 --> 00:14:01,781
用E和密钥K加密 我们将这个加密的输出称为MC

182
00:14:01,781 --> 00:14:06,792
之后我们将MP和MC做异或 我们就得到了另一个被我们用来导出填充的PM

183
00:14:06,792 --> 00:14:12,064
然后我们把这个填充的输出和所有PPP做异或 就得到了这些CCC

184
00:14:12,064 --> 00:14:17,205
我们再将这些CCC做异或 就得到了CCC0的值

185
00:14:17,205 --> 00:14:22,411
我们将用这个值同所有的这些E做加密

186
00:14:22,411 --> 00:14:27,878
我们再用所有的P做一次填充 最终我们就得到了EME的输出

187
00:14:27,878 --> 00:14:32,975
正如我所说的 这个看上去可能有一点困难 但实际上

188
00:14:32,975 --> 00:14:38,483
这里有一个理论 是说如果划线的密文E是一个安全的PRP

189
00:14:38,483 --> 00:14:42,971
那么 这个结构--EME在这个大的分组上是一个安全的PRP

190
00:14:42,971 --> 00:14:47,140
你们知道 从0 1 一直到N 这个结构好的一点时

191
00:14:47,140 --> 00:14:50,877
你们会注意到它们是并行的 这也就是为什么有一点复杂

192
00:14:50,877 --> 00:14:55,082
每一个计数的分组 都是被并行加密的 所以如果你

193
00:14:55,082 --> 00:14:59,577
有一个多核处理器 你就能用所有的核在同一时间加密所有的分组

194
00:14:59,577 --> 00:15:04,635
然后就会一些串行的步骤来计算

195
00:15:04,635 --> 00:15:09,242
然后就会一些串行的步骤来计算检查所有输出的和 然后再并行加密一次

196
00:15:09,242 --> 00:15:13,232
最终得到输出 这些生成填充的函数都是一些

197
00:15:13,232 --> 00:15:17,503
十分简单的函数 它们占用连续的时间

198
00:15:17,503 --> 00:15:22,130
所以我们只用在性能方面忽略它们

199
00:15:22,130 --> 00:15:27,661
注意到每次输入需要用到两次E

200
00:15:27,661 --> 00:15:33,362
事实证明这比SIV慢

201
00:15:33,362 --> 00:15:38,711
如果用快速PRF产生随机性并合理使用SIV

202
00:15:38,711 --> 00:15:43,790
这种特殊的方式下 事实上SIV速度可加倍

203
00:15:43,790 --> 00:15:48,234
因此我认为PRP非常适合短消息 但即便SIV很好

204
00:15:48,234 --> 00:15:52,892
如果要用确定性加密模式加密长消息

205
00:15:52,892 --> 00:15:57,320
我们要怎样给以PRP为基础的机制加入完整性

206
00:15:57,320 --> 00:16:02,635
使用PRP机制加密 采用PRP直接加密信息的地方

207
00:16:02,635 --> 00:16:06,971
我们能实现确定性可靠加密吗 如果答案是肯定的

208
00:16:06,971 --> 00:16:10,587
这又一次证明 这是一个你应该了解的非常简单的加密机制

209
00:16:10,587 --> 00:16:14,637
我们主要要获取消息

210
00:16:14,637 --> 00:16:18,639
在消息内插入一连串的0

211
00:16:18,639 --> 00:16:22,304
然后运用PRP就好了 那样我们就能得到密文

212
00:16:22,304 --> 00:16:26,017
非常简单吧 只需要插入0还有用PRP加密

213
00:16:26,017 --> 00:16:30,018
如果要解密 就看合成明文的最低有效字节

214
00:16:30,018 --> 00:16:33,731
如果不是0 就丢弃这个密文

215
00:16:33,731 --> 00:16:37,430
如果是0 就输出有效信息

216
00:16:37,430 --> 00:16:41,074
好了 这就是整个系统 非常简单吧

217
00:16:41,074 --> 00:16:45,511
加上加密的时候加0 解密的时候相应地查0

218
00:16:45,511 --> 00:16:49,630
我认为实际上就是这个简单的机制提供了确定性可靠性加密

219
00:16:49,630 --> 00:16:53,433
当然了 假设插入足够的0

220
00:16:53,433 --> 00:16:57,183
更确切些 假设就是插入N个0 需要忽略一个2到N的数

221
00:16:57,183 --> 00:17:01,144
事实上这样就将使用PRP加密

222
00:17:01,144 --> 00:17:05,146
也就是确定性可靠性加密 来看看为什么

223
00:17:05,146 --> 00:17:10,310
我们确定系统具有CPA安全性

224
00:17:10,310 --> 00:17:15,352
我们要确定的就是它能提供密文完整性 这也很容易看到

225
00:17:15,352 --> 00:17:20,619
我们来看看密文游戏 窃听者会选择我们熟知的随机数列

226
00:17:20,619 --> 00:17:25,700
输入的随机数列也是一个可逆函数

227
00:17:25,700 --> 00:17:30,348
这样输入就由消息和N个0字节组成

228
00:17:30,348 --> 00:17:34,995
窃听者会怎样做 他需要提交q个消息

229
00:17:34,995 --> 00:17:40,138
然后会收到这q个加密后的消息

230
00:17:40,138 --> 00:17:45,516
大体上他收到的是特定点上N个0串起来的PRP

231
00:17:45,733 --> 00:17:50,355
如果是随机数列

232
00:17:50,355 --> 00:17:54,829
他可以看到所选q点上的数列值 但是只是由N个0串起来

233
00:17:54,829 --> 00:17:59,193
那么密文完整是为了什么

234
00:17:59,193 --> 00:18:03,888
为了得到区别于已给密文的新密文

235
00:18:03,888 --> 00:18:08,087
用来恰当地解密

236
00:18:08,087 --> 00:18:12,935
什么叫恰当地解密 意思就是如果我们在密文C中应用Pi相反数

237
00:18:12,935 --> 00:18:17,568
最好是C的N个最低有效字节都是0

238
00:18:17,568 --> 00:18:22,141
问题就在于这怎么可能实现 让我们想一想

239
00:18:22,141 --> 00:18:26,774
我们有一个随机数列 窃听者想知道q点上随机数列的值

240
00:18:26,774 --> 00:18:31,707
他怎么可能产生一个新的点使得逆向时取得N个作为最低有效字节

241
00:18:31,707 --> 00:18:36,643
我们主要要做的就是

242
00:18:36,643 --> 00:18:41,646
估计数列Pi在c点逆向的值

243
00:18:41,646 --> 00:18:46,108
既然逆向Pi是随机数列

244
00:18:46,108 --> 00:18:52,206
N个最低有效字节怎么可能为0

245
00:18:52,206 --> 00:18:56,137
很难看出答案 最大可能性是一个2到N的数

246
00:18:56,137 --> 00:19:00,967
因为数列会输出一个属于X的随机数

247
00:19:00,967 --> 00:19:05,459
X由1叠乘至N 这个随机数将以N个0结束

248
00:19:05,459 --> 00:19:10,065
概率是1/2^n 结果窃听者用可以忽略的概率成功窃听

249
00:19:10,065 --> 00:19:14,707
因为值是可以忽略的 这就是这段的结尾

250
00:19:14,707 --> 00:19:18,761
我想你看看这两个很聪明的确定性可靠性加密机制

251
00:19:18,761 --> 00:19:23,145
第一个是SIV 要用随机计算模式 要使用随机计数的机制

252
00:19:23,145 --> 00:19:27,803
只需要依靠用于消息的PRF来达到随机性 得到随机计数模式

253
00:19:27,803 --> 00:19:32,077
关键在于

254
00:19:32,077 --> 00:19:36,241
解密时很容易从解密得到的消息验算IV

255
00:19:36,241 --> 00:19:40,789
并确定IV是给你的密文

256
00:19:40,789 --> 00:19:44,789
简单的检查就足够保证确定性加密

257
00:19:44,789 --> 00:19:49,198
乃至确定性可靠性加密

258
00:19:49,198 --> 00:19:54,046
这就是加密数据库长指针的方式

259
00:19:54,046 --> 00:19:59,209
如果是短指针 假设是使用ID的8字节的

260
00:19:59,209 --> 00:20:04,246
你就可以直接使用PRP

261
00:20:04,246 --> 00:20:09,026
你要做的就是在这8字节中插入0

262
00:20:09,026 --> 00:20:13,642
解密时这些0作为整体检查出来

263
00:20:13,813 --> 00:20:17,915
如果插入了足够的0 实际上也能完成确定性加密

264
00:20:17,915 --> 00:20:22,758
另外提一下 已经介绍了一种方式能够从窄PRP构造宽PRP

265
00:20:22,758 --> 00:20:26,843
这种方式被称为EME

266
00:20:26,843 --> 00:20:28,355
在下一节我们要学习EME。【END】

