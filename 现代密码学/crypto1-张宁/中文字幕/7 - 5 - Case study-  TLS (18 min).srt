1
00:00:00,000 --> 00:00:04,450
我想演示如何在现实生活中运用认证加密技术

2
00:00:04,450 --> 00:00:08,844
让我们以TLS做为例子 并看看它是如何工作的 TLS中的数据加密

3
00:00:08,844 --> 00:00:13,183
是通过使用TLS记录协议完成的 该协议中 每个TLS

4
00:00:13,183 --> 00:00:17,800
记录以一数据头开头 不久我们就会看到这个数据头的结构

5
00:00:17,800 --> 00:00:22,250
紧接着是从一端到另一端的加密数据 TLS中

6
00:00:22,250 --> 00:00:26,534
记录的长度至多为16KB 如果需要

7
00:00:26,534 --> 00:00:30,984
发送多于16KB数据 那么该记录就会分割成

8
00:00:30,984 --> 00:00:35,401
多个记录 TLS运用的是单向密钥

9
00:00:35,401 --> 00:00:40,087
即一密钥从浏览器到服务器用 另一个密钥从服务器到浏览器使用

10
00:00:40,087 --> 00:00:44,774
所以 一密钥供浏览器到服务器发送消息使用

11
00:00:44,774 --> 00:00:49,113
另一密钥用于服务器到浏览器发送消息

12
00:00:49,113 --> 00:00:53,800
当然 浏览器端与服务器端相互知道这两个密钥

13
00:00:53,800 --> 00:00:58,026
为了更好理解 我这样假设 浏览器使用这个密钥发送数据给

14
00:00:58,026 --> 00:01:02,464
服务器 那我们使用该密钥从服务器读取数据 这里服务器也

15
00:01:02,464 --> 00:01:06,638
使用另一个密钥做相同操作 而这些

16
00:01:06,638 --> 00:01:10,811
供两端使用的密钥都是由TLS密钥交换协议产生的

17
00:01:10,811 --> 00:01:15,143
该协议将在本节的第二部分讲到 现假设

18
00:01:15,143 --> 00:01:19,529
已创建了这些密钥 且服务器端与浏览器端都知道这些密钥

19
00:01:19,529 --> 00:01:23,859
现在服务器和浏览器试图使用这些密钥交换数据

20
00:01:23,859 --> 00:01:27,591
那么TLS记录协议就会使用状态性加密 也就是

21
00:01:27,591 --> 00:01:31,693
每一数据包都是使用由浏览器和服务器内部维护的

22
00:01:31,693 --> 00:01:36,575
特定状态来加密的 特别地 更能吸引我们的是

23
00:01:36,575 --> 00:01:41,368
64比特计数器 再次强调 有两个64比特计数器

24
00:01:41,368 --> 00:01:45,483
一个用于浏览器到服务器的信息流 另一个用于服务器到浏览器的信息流

25
00:01:45,483 --> 00:01:49,286
当这些计数器第一次初始化时值为0

26
00:01:49,286 --> 00:01:53,558
并且每次发送记录后 计数器的值都会增加 所以每当

27
00:01:53,558 --> 00:01:57,830
浏览器发送一记录给服务器 浏览器都会增加计数器的值

28
00:01:57,830 --> 00:02:01,893
而当服务器接收记录后 它也会增加

29
00:02:01,893 --> 00:02:06,086
它这边的计数器值 而当服务器发送一记录给浏览器 它就会

30
00:02:06,086 --> 00:02:10,454
增加第二个计数器的值 此外 当浏览器接收到这个记录后

31
00:02:10,454 --> 00:02:14,931
它就会增加它的计数器的值 这个状态即两个计数器

32
00:02:14,931 --> 00:02:19,463
既存在于浏览器上也存在于服务器上

33
00:02:19,463 --> 00:02:23,940
此外它随记录从一端发送到另一端而更新 并且

34
00:02:23,940 --> 00:02:28,363
被适当的接收方接收 这些计数器存在的目的是

35
00:02:28,363 --> 00:02:32,840
防止重放攻击 这样攻击者就不能记录消息

36
00:02:32,840 --> 00:02:37,044
并在之后的时间内重放 因为这时计数器将不得不增加

37
00:02:37,044 --> 00:02:41,990
现在我们来看记录协议的工作细节

38
00:02:41,990 --> 00:02:47,304
特别地 我会演示强制密码组 也就是加密使用AES—CBC

39
00:02:47,304 --> 00:02:52,508
杂凑使用HMAC—SHA1 记住 TLS使用杂凑算法 然后加密

40
00:02:52,508 --> 00:02:56,825
而这个杂凑算法就是HMAC-SHA1 而加密算法

41
00:02:56,825 --> 00:03:02,043
是使用AES128的CBC码 现让我们看看浏览器如何发送数据给

42
00:03:02,043 --> 00:03:07,068
服务器 前面说过 它是通过使用浏览器到服务器的密钥实现的

43
00:03:07,068 --> 00:03:12,218
而这个浏览器到服务器密钥是由一杂凑密钥与一加密密钥组成而成

44
00:03:12,218 --> 00:03:18,436
两不同的密钥均是在会话建立时协商的 为了使你们

45
00:03:18,436 --> 00:03:22,889
完全明白 解说如下 一独立密钥供浏览器到服务器使用

46
00:03:22,889 --> 00:03:27,176
另一密钥供服务器到浏览器使用 所以2*2共4个密钥

47
00:03:27,176 --> 00:03:31,406
两个杂凑密钥和两个加密密钥 每个密钥都在合适的地方使用

48
00:03:31,406 --> 00:03:36,026
然后 这里我图示出了一TLS数据包的结构 它以一数据头打头

49
00:03:36,026 --> 00:03:40,368
该数据头包含有数据包类型、协议版本号

50
00:03:40,368 --> 00:03:44,766
数据包长度等信息 注意数据包长度以明文发送

51
00:03:44,766 --> 00:03:49,316
而当要加密数据也就是一特定记录时 加密步骤如下

52
00:03:49,316 --> 00:03:54,083
当然 它以密钥、当前状态等做为输入

53
00:03:54,083 --> 00:03:59,139
接着 它首先

54
00:03:59,139 --> 00:04:03,851
对这个数据进行散列计算 这个是要计算散列值的实际有效载荷

55
00:04:03,851 --> 00:04:08,679
而数据头也需要进行散列计算 此外 计数器 也就是计数器的当前值

56
00:04:08,679 --> 00:04:12,926
也需要进行散列计算 当然计数器的值会随着

57
00:04:12,926 --> 00:04:17,754
发送一记录而增加 这里有趣的是

58
00:04:17,754 --> 00:04:22,271
虽然计数器的值包含在特征值中 但可以注意到

59
00:04:22,271 --> 00:04:26,356
计数器值不会包含在记录中被发送

60
00:04:26,356 --> 00:04:30,593
而不需要包含在记录中被发送的原因是在另一端的服务器已经

61
00:04:30,593 --> 00:04:34,729
知道计数器的值 所以不需要再次告诉

62
00:04:34,729 --> 00:04:38,814
服务器端计数器的值 服务器私底下是知道它的值的

63
00:04:38,814 --> 00:04:42,949
并且当服务器想要认证杂凑值时 它可以用它自己认为的

64
00:04:42,949 --> 00:04:47,072
计数器值然后完成认证 比较有趣过程是

65
00:04:47,072 --> 00:04:51,315
即使两端都保存有作为临时数的计数器的值

66
00:04:51,315 --> 00:04:55,406
两端依然不需要将临时值包含在记录中发送

67
00:04:55,406 --> 00:04:59,397
因为两端都知道它们所接收的记录的计数器值

68
00:04:59,397 --> 00:05:04,024
所以这个就是特征值 它是通过这三重数据计算出来的

69
00:05:04,024 --> 00:05:09,320
接下来 特征值会串联在这些数据上

70
00:05:09,320 --> 00:05:13,930
记住是先计算散列值后加密 这个是计算的散列

71
00:05:13,930 --> 00:05:18,852
接下来将数据与特征值一起加密 所以数据头、数据、和特征值

72
00:05:18,852 --> 00:05:23,649
会被填加到AES数据分组上 我想我们前面已经讲过这个填充

73
00:05:23,649 --> 00:05:28,696
如果填充长度为5 那么填充就是将字节5重复写5次

74
00:05:28,696 --> 00:05:34,032
如果填充的是5那么整个填充就是55555 接着我们使用密钥

75
00:05:34,032 --> 00:05:39,477
利用CBC加密方法加密数据与特征值 加密过程中

76
00:05:39,477 --> 00:05:44,715
使用一个新随机数IV 该数之后会被嵌于密文中

77
00:05:44,715 --> 00:05:50,367
接着 我们来考虑数据头 也就是类型、版本、长度

78
00:05:50,367 --> 00:05:55,802
以上就是整个TLS记录 最后被送给服务器 

79
00:05:55,802 --> 00:06:00,231
整个图中蓝色区域表示加密数据 白色区域

80
00:06:00,231 --> 00:06:05,146
表示未加密明文 以上就是TLS应用的

81
00:06:05,146 --> 00:06:10,121
散列与加密计算 与普通MAC不同的唯一之处是

82
00:06:10,121 --> 00:06:14,915
它含一个状态值 也就是MAC值中包含的计数器值

83
00:06:14,915 --> 00:06:19,852
这是为了防止重放攻击 为什么这样能防止重放攻击

84
00:06:19,852 --> 00:06:24,430
我们来看记录协议是如何解密记录的

85
00:06:24,430 --> 00:06:28,829
假设这里有一个加密记录 当然 服务器会

86
00:06:28,829 --> 00:06:33,763
使用从浏览器到服务器的秘钥得到对应的数据

87
00:06:33,763 --> 00:06:38,222
并启动从浏览器到服务器的计数器 然后 服务器首先会

88
00:06:38,222 --> 00:06:42,681
使用加密密钥来解密这个记录 解密后 服务器会

89
00:06:42,681 --> 00:06:47,318
检查填充的格式 如果填充长度是5字节

90
00:06:47,318 --> 00:06:51,826
它就会检查填充是否是55555 如果不是

91
00:06:51,826 --> 00:06:56,124
服务器就会发送错误警告消息并终止链接

92
00:06:56,124 --> 00:07:01,061
如果想要另发送记录 就需要协商新的会话密钥

93
00:07:01,061 --> 00:07:05,935
如果填充格式是正确的 那么移除填充就很简单

94
00:07:05,935 --> 00:07:10,595
由服务器观察填充的最后几字节 如果最后几字节等于5

95
00:07:10,595 --> 00:07:15,254
然后服务器移除最后5字节的记录

96
00:07:15,254 --> 00:07:20,216
这样就可以移除填充 接下来 服务器会取出

97
00:07:20,216 --> 00:07:25,117
记录中的特征值 在记录中后面的字节

98
00:07:25,117 --> 00:07:30,079
它在我们移除填充后的最后的字节

99
00:07:30,079 --> 00:07:34,860
接着服务器检查特征值中的数据头、数据、计数器值等

100
00:07:34,860 --> 00:07:39,809
如果这个散列值不能通过认证 服务器会发送警告和错误散列值记录并

101
00:07:39,809 --> 00:07:44,634
中断链接 如果特征值通过了认证 服务器会移除特征值

102
00:07:44,634 --> 00:07:49,460
移除数据头 留下来的记录部分就是数据明文

103
00:07:49,460 --> 00:07:54,693
这部分就是待发送给应用的数据 现在你应该了解到 如果记录被重放

104
00:07:54,693 --> 00:07:59,980
换句话说 如果一攻击者记录了一个特定记录并在之后的时间

105
00:07:59,980 --> 00:08:05,402
将其重放给服务器 那时计数器的值已经被改变

106
00:08:05,402 --> 00:08:11,028
结果就是 重放记录的特征值就不会通过认证

107
00:08:11,028 --> 00:08:16,451
因为特征值是使用计数器计算出来的 但当重放记录被服务器接收时

108
00:08:16,451 --> 00:08:21,285
服务器的计数器值与上次用来计算特征值的

109
00:08:21,285 --> 00:08:25,996
计数值不同 结果通不过认证

110
00:08:25,996 --> 00:08:30,536
所以这些计数器是非常简便的防止重放攻击的方法 而且

111
00:08:30,536 --> 00:08:35,018
由于两端均知道计数器的值

112
00:08:35,018 --> 00:08:39,499
所以没有必要将计数器包含在记录中发送 所以

113
00:08:39,499 --> 00:08:43,787
计时器不会随着密文的长度L增加 现在我们已经

114
00:08:43,787 --> 00:08:48,692
提到这种特殊的方法，认证加密，即 先做MAC

115
00:08:48,692 --> 00:08:53,358
后加密，使用CBC加密方式 实际上 就是认证加密 但是

116
00:08:53,358 --> 00:08:57,904
它仅仅是在加密时没有信息泄露的情况下是认证加密

117
00:08:57,904 --> 00:09:02,211
泄露。我们讲一种对TLS严重攻击，如果在

118
00:09:02,211 --> 00:09:06,398
解密过程中有信息泄露。这个

119
00:09:06,398 --> 00:09:11,363
错误记录的MAC警告相当于解密算法中输出的拒绝符号也就是⊥符号

120
00:09:11,363 --> 00:09:16,058
这就意味着密文是无效的

121
00:09:16,058 --> 00:09:20,550
只要没有办法区分密文为何被拒绝

122
00:09:20,550 --> 00:09:25,152
即解密者只暴露了发生了拒绝这样一个事实但又

123
00:09:25,152 --> 00:09:29,311
没说明拒绝为什么发生 这其实就是一个认证加密系统

124
00:09:29,311 --> 00:09:33,300
然而 如果你区分并暴露了密文

125
00:09:33,304 --> 00:09:37,907
为何被拒绝 不管是因为错误的填充或者是因为错误的MAC

126
00:09:37,907 --> 00:09:42,510
那么这就是将在下一部分讲到的一个十分严重的攻击

127
00:09:42,510 --> 00:09:47,402
到目前我所展现的是1.1版本的TLS 实际上

128
00:09:47,402 --> 00:09:52,231
更早版本的TLS存在重大的错误 结果就导致

129
00:09:52,231 --> 00:09:57,441
先前的记录协议容易受到各种攻击 它的第一个错误是

130
00:09:57,441 --> 00:10:02,397
CBC加密算法中的IV是可预测的 我们之前说过在CBC中

131
00:10:02,397 --> 00:10:07,099
如果IV是可预测的 那么将导致CBC加密算法不是CPA安全的

132
00:10:07,099 --> 00:10:11,928
在旧版本的TLS 比如在TLS1.0或者是更早的版本中

133
00:10:11,928 --> 00:10:16,921
下一个记录的IV就是当前记录的最后一个密文分组

134
00:10:16,921 --> 00:10:21,200
这就导致如果攻击者能够观察出当前记录 那么他就知道下一个记录的IV

135
00:10:21,200 --> 00:10:25,426
这就让他能够破坏下一个记录的语义安全

136
00:10:25,426 --> 00:10:29,866
于是最终的方案不是CPA安全的 这样的方案不仅不是CPA安全的

137
00:10:29,866 --> 00:10:34,146
而且  还有一种能够解密TLS记录起始部分的被称为BEAST的攻击方式

138
00:10:34,146 --> 00:10:38,425
就是因为这个系统不是语义安全的

139
00:10:38,425 --> 00:10:43,206
这种选IV来做前一个记录的最后一个分组的方法

140
00:10:43,206 --> 00:10:47,999
被称为链IV

141
00:10:47,999 --> 00:10:53,095
你们应当记住这种方法不应该被用于实践 因为它总是

142
00:10:53,095 --> 00:10:57,948
被攻击 由于TLS从版本1.1发展到了被称为外显IV

143
00:10:57,948 --> 00:11:02,801
每一个TLS记录都有自己的随机不可预测的IV的版本

144
00:11:02,801 --> 00:11:07,776
只要浏览器和服务器使用TLS1.1 问题就能被解决 而且这永远不会出现问题

145
00:11:07,776 --> 00:11:11,993
另一个TLS1.0和更早版本的错误就是

146
00:11:11,993 --> 00:11:15,954
启用了一个被称作Oracle填充的的东西 我们将在下一部分来讨论Oracle填充


147
00:11:15,954 --> 00:11:20,182
Oracle填充就是如果密文

148
00:11:20,182 --> 00:11:24,683
因为无效填充而被拒绝的话 服务器就会收到一条

149
00:11:24,683 --> 00:11:29,113
解密无效的信息 然而 如果密文是因为无效的MAC而被拒绝的话 服务器就会回复

150
00:11:29,113 --> 00:11:33,267
一个无效记录的MAC的警告 所以

151
00:11:33,267 --> 00:11:37,753
观察服务器回复警告的攻击者能够分辨出密文中的填充是有效还是无效的

152
00:11:37,753 --> 00:11:42,184
这就引入了一种十分重要的被称为填充攻击的攻击方式

153
00:11:42,184 --> 00:11:46,670
我们将在下一部分讨论这种攻击 对于这种攻击和TSL1.1的解决方案

154
00:11:46,670 --> 00:11:50,713
基本上就是 即使填充是错误的

155
00:11:50,713 --> 00:11:55,092
也只报告一个错误记录的MAC 而不报告一个失败的解密

156
00:11:55,092 --> 00:11:59,445
所以 仅仅观察服务器送回的警告

157
00:11:59,445 --> 00:12:04,121
攻击者是不能分辨出密文是由于错误的填充还是错误的MAC而被拒绝的

158
00:12:04,121 --> 00:12:09,354
这就是说 我们从中汲取的教训就是当解密失败时

159
00:12:09,354 --> 00:12:14,156
你永远不要去解释为什么  我想这是一种源自于网络协议中的东西

160
00:12:14,156 --> 00:12:19,135
如果出现了一个错故障 你就想对你的伙伴解释故障出现的原因

161
00:12:19,135 --> 00:12:24,114
而在密码学中 解释故障出现的原因常常会导致被攻击

162
00:12:24,114 --> 00:12:28,797
换句话说 当解密失败时直接输出拒绝

163
00:12:28,797 --> 00:12:33,540
不要去解释拒绝为什么会发生 直接拒绝密文就可以

164
00:12:33,860 --> 00:12:38,462
我们讨论过了TLS1.1 现在来看一个被破解的协议

165
00:12:38,462 --> 00:12:43,363
当然我挑基本上什么都是有问题的802.11b WEP来做例子

166
00:12:43,363 --> 00:12:48,086
让我们来看一下如何不要提供认证加密 先让我提醒下你们802.11b WEP

167
00:12:48,086 --> 00:12:52,808
是如何工作的，一个笔记本电脑想要给

168
00:12:52,808 --> 00:12:57,410
一个接入点发送一条信息 首先 笔记本电脑会计算

169
00:12:57,410 --> 00:13:02,371
一条信息的循环冗余校验和并且把CRC校验和与这条信息连接在一起

170
00:13:02,371 --> 00:13:06,937
然后结果用流密码加密 例如RC4

171
00:13:06,937 --> 00:13:12,067
如果你还记得的话  使用的密钥是

172
00:13:12,067 --> 00:13:17,263
每一个包都会变化初始值IV的连接和一个长效密钥K 然后IV和密文一同

173
00:13:17,263 --> 00:13:21,506
被传输到了另一端 我们之前已经讨论过了

174
00:13:21,506 --> 00:13:26,089
这种方法的两个问题 一是如果IV被重复使用的话

175
00:13:26,089 --> 00:13:30,954
你就会受到两次一个两次填充攻击 另一个问题是

176
00:13:30,954 --> 00:13:35,310
使用关联紧密的密钥 换句话说 密钥是

177
00:13:35,310 --> 00:13:39,949
IV与K的串接 唯一发生改变的就是IV 所以

178
00:13:39,949 --> 00:13:44,475
密钥一直都是固定的 这意味着 这些PRG密钥互相之间

179
00:13:44,475 --> 00:13:48,831
联系很紧密 像我们前面说的 这里用了PRG RC4 不是设计来这么用的

180
00:13:48,831 --> 00:13:53,524
如果你用相关密钥的话 它就完全被攻破

181
00:13:53,524 --> 00:13:58,110
因此 WEP根本不安全 我想证明给大家的是

182
00:13:58,110 --> 00:14:02,332
即使这里用到了CRC机制 试图提供完整性 防止

183
00:14:02,332 --> 00:14:05,872
敌手篡改密文 即便这种机制

184
00:14:05,872 --> 00:14:09,960
被完全攻破 实际上在传输中是很容易篡改密文的

185
00:14:09,960 --> 00:14:14,935
让我们看看这个怎么做 攻击利用了CRC校验的的一种性质

186
00:14:14,935 --> 00:14:20,399
主因是CRC是线性的 这意味着如果我给你m的CRC校验码 我

187
00:14:20,399 --> 00:14:25,525
要求你计算m异或p的CRC，很容易 基本上你户

188
00:14:25,525 --> 00:14:30,989
计算公开的函数F(p)你先异或这两个

189
00:14:30,989 --> 00:14:35,976
这样就会给你m和p异或的CRC校验 所以异或

190
00:14:35,976 --> 00:14:40,380
就从这个括号里出来了，意味着CRC是线性的 现在我们看看

191
00:14:40,380 --> 00:14:44,727
攻击是怎么进行得 假设敌手截获了一个特定的包

192
00:14:44,727 --> 00:14:48,841
这个包是发往接入点的 现在这个包，令其目的

193
00:14:48,841 --> 00:14:53,535
是80端口 攻击者知道它要发往

194
00:14:53,535 --> 00:14:58,114
80端口而且他想篡改这个密文使得目的端口

195
00:14:58,114 --> 00:15:02,550
变成25而不是80 攻击者可能能够读

196
00:15:02,550 --> 00:15:06,922
25端口的信息 这样他实际上就得到了这个包中的数据

197
00:15:06,922 --> 00:15:11,405
回忆CRC校验在这里是为了保证

198
00:15:11,405 --> 00:15:15,943
攻击者不能改变密文中的数据 但是我想说明 实际上

199
00:15:15,943 --> 00:15:20,702
想改变密文中的数据十分容易 CRC

200
00:15:20,702 --> 00:15:25,611
实际上根本不能对篡改提供安全性 让我们看看如何进行

201
00:15:25,611 --> 00:15:31,549
好，攻击者 基本上就是一些特定的值XX

202
00:15:31,549 --> 00:15:37,130
和代表密文中的8个0的字节异或 现在 他就是

203
00:15:37,130 --> 00:15:43,497
把25和80进行异或 再与密文中特定的串XX进行异或

204
00:15:43,497 --> 00:15:48,890
这个是用来做流密码的 当密文

205
00:15:48,890 --> 00:15:54,653
被解密 这个位置的明文将被XX异或

206
00:15:54,653 --> 00:16:00,176
结果就是解密后这个位置的明文就是

207
00:16:00,176 --> 00:16:05,767
原始的80异或25异或25，结果就是25，对吧？

208
00:16:05,767 --> 00:16:11,152
所以解密后这个位置的明文将是25 问题是 如果我们就这么做

209
00:16:11,152 --> 00:16:16,537
这个攻击不会成功 因为CRC校验在这里就不成立了

210
00:16:16,537 --> 00:16:21,672
CRC校验 是对80这个明文建立的，25是

211
00:16:21,672 --> 00:16:26,883
另一个明文需要另外一个CRC校验 但是这也不是问题 因为我们能做的是

212
00:16:26,883 --> 00:16:31,969
仅仅校正一下校验和 CRC校验和 虽然CRC校验和

213
00:16:31,969 --> 00:16:37,180
是被加密了。我们就是异或F(xx)到密文的这个位置

214
00:16:37,180 --> 00:16:42,266
这里应该是那个CRC 结果就是 密文被解密的时候

215
00:16:42,266 --> 00:16:47,271
在解密后我们就能得到正确的CRC校验和

216
00:16:47,271 --> 00:16:52,275
这里有意思的是 即便攻击者不知道

217
00:16:52,275 --> 00:16:57,157
CRC值是什么 他可以利用线性性质校对是的

218
00:16:57,157 --> 00:17:01,738
密文被解密为明文时，能得到正确的CRC值

219
00:17:01,738 --> 00:17:06,671
所以，CRC的线性性质在这个攻击中起到了重要的

220
00:17:06,671 --> 00:17:11,483
作用 这里最终的结论是CRC校验绝对不能提供

221
00:17:11,483 --> 00:17:16,235
完整性，在针对主动攻击的情况下 因此永远

222
00:17:16,235 --> 00:17:20,686
不要用它作为一种完整性机制 所以为了提供完整性

223
00:17:20,686 --> 00:17:25,318
你应该用一种密码MAC体制而不是随便什么机制

224
00:17:25,318 --> 00:17:29,353
比如CRC 好，现在我们了解了在现实世界中的协议中认证

225
00:17:29,353 --> 00:17:33,145
加密是怎样使用的，比如TLS 下一节 我们将讨论

226
00:17:33,145 --> 00:17:37,287
一下现实的攻击，尤其是在认证加密在没有被正确使用

227
00:17:37,287 --> 00:17:39,134
的情况下，对认证加密的攻击。【END】

