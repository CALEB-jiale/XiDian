1
00:00:00,000 --> 00:00:03,911
下面几节我将说明，
如果我们使用一个安全的PRG

2
00:00:03,911 --> 00:00:07,892
我们将得到一个安全的流密码。
首先我们必须要定义,

3
00:00:07,892 --> 00:00:11,679
流密码的安全性是指什么。
无论何时我们定义安全

4
00:00:11,679 --> 00:00:15,174
我们总是根据攻击者能干什么或者企图干什么来定义

5
00:00:15,174 --> 00:00:18,670
记住在流密码的情况下，只使用一次性密钥

6
00:00:18,670 --> 00:00:22,737
因此攻击者最多只看到

7
00:00:22,737 --> 00:00:26,754
当前我们使用的密钥加密后的密文

8
00:00:26,754 --> 00:00:30,772
那么我们将要限制攻击者只能获得一个密文

9
00:00:30,772 --> 00:00:34,641
事实上稍后我们将允许攻击者做更多事情

10
00:00:34,641 --> 00:00:38,460
但现在我们只给他一个密文  我们想探究

11
00:00:38,460 --> 00:00:42,560
密码的安全性到底指什么？
那么首先想到的第一个定义

12
00:00:42,560 --> 00:00:46,892
就是我们会要求攻击者

13
00:00:46,892 --> 00:00:50,718
无法还原密钥。给定密文

14
00:00:50,718 --> 00:00:54,609
你应该是无法还原密钥的。
但这是一个糟糕的定义

15
00:00:54,609 --> 00:00:58,717
因为想想这个聪明但失败了的密码

16
00:00:58,717 --> 00:01:02,855
我们使用密钥K加密消息的方式只是输出消息

17
00:01:02,855 --> 00:01:07,427
这是一个聪明的密码，当然，
它没有做任何事情

18
00:01:07,427 --> 00:01:12,000
只是输出明文当做密文。
这并不是一个特别好的加密机制

19
00:01:12,000 --> 00:01:16,029
然而给定密文，弱攻击者无法还原密钥

20
00:01:16,029 --> 00:01:20,493
因为他不知道密钥

21
00:01:20,493 --> 00:01:24,630
因此这个明显不安全的密码，
只在这个安全要求下被认为是安全的

22
00:01:24,793 --> 00:01:28,636
所以这个定义不好

23
00:01:28,636 --> 00:01:32,317
所以从还原密钥的角度定义安全是错误的

24
00:01:32,317 --> 00:01:35,999
下一步我们要尝试的是，
或许攻击者并不在意密钥

25
00:01:35,999 --> 00:01:39,680
他真正在乎的是明文

26
00:01:39,680 --> 00:01:43,518
因此对攻击者来说
还原整个明文可能比较困难

27
00:01:43,518 --> 00:01:48,223
然而这样也没有用。想一想下面的加密机制

28
00:01:48,223 --> 00:01:53,436
假设这个加密机制是取两个信息

29
00:01:53,436 --> 00:01:58,014
我用双竖线来表示两个信息的串联，
M0||M1表示M0串上M1

30
00:01:58,014 --> 00:02:03,100
这个加密机制输出M0的明文

31
00:02:03,100 --> 00:02:08,060
串上M1的加密后的密文

32
00:02:08,060 --> 00:02:13,337
可能使用了一次一密，怎么样?
这里攻击者得到了密文

33
00:02:13,337 --> 00:02:17,478
他的目标是还原整个明文

34
00:02:17,478 --> 00:02:21,702
但弱攻击者做不到，
因为这里我们可以用一次一密加密M1

35
00:02:21,702 --> 00:02:25,872
这样攻击者无法还原M1

36
00:02:25,872 --> 00:02:30,043
因为只给一个密文的话，
一次一密是安全的

37
00:02:30,043 --> 00:02:34,055
所以这个结构会符合这个定义。
但不幸的是，这明显不是安全的加密机制

38
00:02:34,055 --> 00:02:37,962
因为我们泄露了一半的明文内容

39
00:02:37,962 --> 00:02:42,185
攻击者完全知道M0，
即使他无法完全还原出所有的明文

40
00:02:42,185 --> 00:02:46,462
他也能还原出大部分明文了，这明显是不安全的

41
00:02:46,462 --> 00:02:50,658
我们已经知道了这个问题的解决方案

42
00:02:50,658 --> 00:02:54,747
我们讨论过香农对完善保密性的定义

43
00:02:54,747 --> 00:02:58,835
香农的想法是，当攻击者截获密文时

44
00:02:58,835 --> 00:03:02,818
他得不到关于明文的任何信息，
甚至得不到明文一个比特的信息

45
00:03:02,818 --> 00:03:07,221
预测不到明文一个比特的信息

46
00:03:07,221 --> 00:03:11,205
完全没有关于明文的任何信息

47
00:03:11,205 --> 00:03:14,926
我们简要回顾一下香农的完善保密性的概念

48
00:03:14,926 --> 00:03:19,442
我们说一个密码具备完善保密性

49
00:03:19,442 --> 00:03:25,069
只有当给定两个长度相同的消息

50
00:03:25,069 --> 00:03:30,167
和随机选择的一个密钥

51
00:03:30,167 --> 00:03:34,838
M0的密文与M1的密文具有完全相同的分布时成立

52
00:03:34,838 --> 00:03:39,257
直观地看，如果攻击者观察密文

53
00:03:39,257 --> 00:03:43,839
那么他无法得知密文的分布

54
00:03:43,839 --> 00:03:48,203
是加密M0的结果还是加密M1的结果

55
00:03:48,203 --> 00:03:52,513
于是他无法判断我们加密的是M0还是M1

56
00:03:52,513 --> 00:03:56,877
这一点对所有等长的消息都成立。
弱攻击者无法得知

57
00:03:56,877 --> 00:04:01,212
我们加密的是什么消息。
当然从某种意义上

58
00:04:01,212 --> 00:04:05,400
这个定义太强了，它需要很长的密钥

59
00:04:05,400 --> 00:04:09,535
如果密钥太短，不可能满足这一定义

60
00:04:09,535 --> 00:04:14,328
特别地，流密码不能满足这个定义。
好的，我们试图削弱这个定义

61
00:04:14,328 --> 00:04:19,114
想一想上节的内容

62
00:04:19,114 --> 00:04:23,841
我们不是要求两个分布绝对相同

63
00:04:23,841 --> 00:04:28,686
而是要求两个分布只在计算上不可区分

64
00:04:28,863 --> 00:04:33,353
换句话说，高效的弱攻击者
无法区分两个分布

65
00:04:33,353 --> 00:04:37,815
即使这两个分布非常不同。
仅仅给一个分布的样本

66
00:04:37,815 --> 00:04:42,580
和另一分布的样本，攻击者无法区分

67
00:04:42,580 --> 00:04:47,120
他得到的样本来自哪一个分布。
实际上这个定义基本上是正确的

68
00:04:47,120 --> 00:04:51,716
但它还是有点太强了，仍然无法满足

69
00:04:51,716 --> 00:04:56,200
所以我们不得不再加一条限制，
那就是不要求这个定义

70
00:04:56,200 --> 00:05:00,797
对所有的和M0和M1都成立，而只要求对攻击者

71
00:05:00,797 --> 00:05:05,208
实际能建立的一对明文（M0，M1）成立

72
00:05:05,208 --> 00:05:10,038
好，那么我们来定义语义安全

73
00:05:10,038 --> 00:05:15,050
这里指一次性密钥的语义安全。
换句话说，这是当攻击者只得到一个密文的情况

74
00:05:15,050 --> 00:05:19,819
我们通过定义两个实验来定义语义安全

75
00:05:19,819 --> 00:05:24,562
分别是实验0和实验1

76
00:05:24,562 --> 00:05:29,230
更一般地，我们可以把这些实验
当做实验B，B可以是0或1

77
00:05:29,230 --> 00:05:32,890
所以实验如下定义：
有一敌人A试图攻破加密系统，

78
00:05:32,890 --> 00:05:37,161
就像伪随机数发生器的统计测试那样

79
00:05:37,161 --> 00:05:41,279
然后挑战者这样做

80
00:05:41,279 --> 00:05:45,093
事实上我们有两个挑战者

81
00:05:45,093 --> 00:05:49,414
但这两个挑战者很相似，
所以我们可以把他们想象成一个挑战者

82
00:05:49,414 --> 00:05:53,634
在一种情况下输入比特为0，
在另一种情况下输入比特为1

83
00:05:53,634 --> 00:05:57,193
我们来看这些挑战者做了什么

84
00:05:57,193 --> 00:06:01,349
首先，挑战者选取一个随机密钥

85
00:06:01,349 --> 00:06:06,076
然后攻击者输出两个消息M0和M1

86
00:06:06,076 --> 00:06:11,039
那么这是攻击者希望被挑战的一对信息

87
00:06:11,039 --> 00:06:15,766
与往常一样，我们不试图隐藏信息长度，我们要求两个信息的长度一致

88
00:06:15,766 --> 00:06:21,643
然后挑战者输出M0的加密结果
或M1的加密结果

89
00:06:21,643 --> 00:06:25,890
在实验0里挑战者会输出M0的加密

90
00:06:25,890 --> 00:06:30,301
在实验1里挑战者会输出M1的加密

91
00:06:30,301 --> 00:06:34,385
这就是两个实验之间的差别

92
00:06:34,385 --> 00:06:38,796
然后攻击者试图猜测，
他得到的是M0的加密？

93
00:06:38,796 --> 00:06:44,051
还是M1的加密？这里引入一些记号

94
00:06:44,051 --> 00:06:50,260
我们定义事件Wb为在实验B中
攻击者输出1的所有事件

95
00:06:50,260 --> 00:06:55,084
事件W0意思是在实验0中攻击者输出1

96
00:06:55,084 --> 00:07:00,342
W1意思是在实验1中输出1

97
00:07:00,342 --> 00:07:05,291
现在我们可以定义攻击者的优势

98
00:07:05,291 --> 00:07:10,425
即攻击者A对加密机制E的语义安全的优势

99
00:07:10,425 --> 00:07:15,497
定义为两个事件概率的差

100
00:07:15,497 --> 00:07:20,136
换句话说，我们关注的是
攻击者得到M0的加密和M1的加密时

101
00:07:20,136 --> 00:07:24,818
他的行为有何不同

102
00:07:24,818 --> 00:07:29,201
为确保这点讲清楚我再说一遍

103
00:07:29,201 --> 00:07:33,530
在实验0中给攻击者M0的加密，
在实验1中则给他M1的加密

104
00:07:33,530 --> 00:07:37,700
现在我们感兴趣的是攻击者是否输出1

105
00:07:37,700 --> 00:07:42,356
如果两个实验中攻击者以同样的概率输出1

106
00:07:42,356 --> 00:07:47,013
就意味着攻击者无法区分两个实验

107
00:07:47,013 --> 00:07:51,549
对攻击者而言实验0与实验1相同

108
00:07:51,549 --> 00:07:56,206
因为两种情况都以同样概率输出1

109
00:07:56,206 --> 00:08:01,286
然而如果攻击者在两个实验中
输出1的概率差别很大

110
00:08:01,286 --> 00:08:05,761
那么攻击者是可以区分两个实验的

111
00:08:05,761 --> 00:08:10,266
更正式地说

112
00:08:10,266 --> 00:08:14,455
就用优势来表示。
因为优势是两概率之差，值在0到1之间

113
00:08:14,455 --> 00:08:18,918
如果优势接近0

114
00:08:18,918 --> 00:08:22,886
意味着攻击者无法区分实验0和1

115
00:08:22,886 --> 00:08:27,129
但如果优势接近1

116
00:08:27,129 --> 00:08:31,538
意味着攻击者能很好地区分实验0和1

117
00:08:31,538 --> 00:08:36,112
也就是他能很好地区分M0和M1的加密

118
00:08:36,112 --> 00:08:40,299
那么这就是我们的定义

119
00:08:40,299 --> 00:08:44,055
实际上这就是优势的定义

120
00:08:44,055 --> 00:08:47,714
我们说，一个对称加密机制

121
00:08:47,714 --> 00:08:52,346
是语义安全的，如果对于所有有效的攻击者。
这里要加上双引号

122
00:08:52,346 --> 00:08:56,932
“对所有有效攻击者，优势可忽略”

123
00:08:56,982 --> 00:09:01,808
换句话说，没有有效攻击者
可以区分M0和M1的加密

124
00:09:01,808 --> 00:09:06,103
这一定义反复在说

125
00:09:06,103 --> 00:09:10,759
对这两个给定的明文
攻击者无法区分这两种分布

126
00:09:10,759 --> 00:09:15,064
这是一个优雅的定义

127
00:09:15,064 --> 00:09:19,595
可能不是很直观，
但我想说明这个定义的一些含义

128
00:09:19,595 --> 00:09:24,410
然后你们会清楚地看到为何这么定义

129
00:09:24,410 --> 00:09:28,601
好的，我们来看一些例子。第一个例子

130
00:09:28,601 --> 00:09:33,190
假设我们有一个被破解的加密机制。
也就是说，我们有一个攻击者A

131
00:09:33,190 --> 00:09:38,285
给定密文，他总能推断出明文的最低有效位

132
00:09:38,285 --> 00:09:44,149
那么给定明文M0的加密

133
00:09:44,149 --> 00:09:48,799
攻击者可以推断出M0的最低有效位

134
00:09:48,799 --> 00:09:52,911
那么这是个糟糕的加密机制

135
00:09:52,911 --> 00:09:57,128
因为给定密文的话，
它泄露了明文的最低位

136
00:09:57,128 --> 00:10:01,609
如果加密系统是语义安全的话

137
00:10:01,609 --> 00:10:05,931
是不会有这样的攻击者的

138
00:10:05,931 --> 00:10:10,254
我们看为什么这个系统不是语义安全的。
我们要做的就是利用这个攻击者

139
00:10:10,254 --> 00:10:14,366
他可以获得我们的有效位

140
00:10:14,366 --> 00:10:18,372
我们就利用他来破坏语义安全，
利用他来区分实验0和实验1。

141
00:10:18,372 --> 00:10:22,755
这就是我们要做的

142
00:10:22,755 --> 00:10:26,987
我们是算法B，算法B里面将会用到算法A

143
00:10:26,987 --> 00:10:31,165
所以在一开始

144
00:10:31,165 --> 00:10:35,608
挑战者选择一个随机密钥

145
00:10:35,608 --> 00:10:39,762
我们首先需要输出两个消息

146
00:10:39,762 --> 00:10:43,493
具有不同的有效位

147
00:10:43,493 --> 00:10:47,727
一个消息以0结尾，一个消息以1结尾

148
00:10:47,727 --> 00:10:51,205
现在挑战者要干什么？他将为我们

149
00:10:51,205 --> 00:10:55,238
加密M0或M1，这取决于是实验0还是1

150
00:10:55,238 --> 00:10:59,120
然后我们就把得到的密文给攻击者

151
00:10:59,120 --> 00:11:03,871
现在攻击者A有什么特性？

152
00:11:03,871 --> 00:11:08,505
给定密文，攻击者A可以算出明文的最低有效位

153
00:11:08,505 --> 00:11:13,374
换句话说，攻击者会输出M0或M1的最低位

154
00:11:13,374 --> 00:11:17,892
现在注意到那是位B

155
00:11:17,892 --> 00:11:23,050
然后把它当作我们的猜测输出，记为B'

156
00:11:23,050 --> 00:11:28,376
这就是语义安全攻击者的描述。现在你们说

157
00:11:28,376 --> 00:11:33,593
这个攻击者语义安全的优势是多少？
我们看一下，在实验0中

158
00:11:33,593 --> 00:11:38,775
攻击者B输出1的概率是多少？

159
00:11:38,775 --> 00:11:43,704
在实验0中总是得到M0的加密，
因此攻击者A

160
00:11:43,704 --> 00:11:48,633
总是输出M0的最低位0

161
00:11:48,633 --> 00:11:53,120
在实验0中，B总是输出0，
所以输出1的概率是0

162
00:11:53,120 --> 00:11:57,827
但在实验1中，我们得到M1的加密

163
00:11:57,827 --> 00:12:02,783
那么攻击者B在实验1中输出1的概率是多少？

164
00:12:02,783 --> 00:12:07,428
根据算法A的性质，概率总是1，因此优势为1

165
00:12:07,428 --> 00:12:12,384
所以这是个很大的优势，取到了最大值

166
00:12:12,384 --> 00:12:17,091
这意味着攻击者完全破解了这个系统。
那么我们认为，在语义安全下

167
00:12:17,091 --> 00:12:22,295
能推导出最低位就足以完全破解系统

168
00:12:22,295 --> 00:12:27,187
这是根据语义安全的定义来的

169
00:12:27,187 --> 00:12:32,388
有趣的是，不仅仅是最低位

170
00:12:32,388 --> 00:12:37,117
事实上，例如消息的最有效高位即第七位

171
00:12:37,117 --> 00:12:42,040
或者明文所有位的异或，等等

172
00:12:42,040 --> 00:12:46,552
任何一种信息，明文的任一位

173
00:12:46,552 --> 00:12:50,814
如果它们能被获得，
都意味着系统不是语义安全的

174
00:12:50,814 --> 00:12:55,532
攻击者要做的就是用两个消息M0和M1

175
00:12:55,532 --> 00:13:00,249
一种情况下能够得到值0，
另一种能得到值1

176
00:13:00,249 --> 00:13:04,626
例如如果A知道明文所有位的异或，

177
00:13:04,626 --> 00:13:08,775
而M0和M1所有位的异或刚好不同，

178
00:13:08,775 --> 00:13:13,265
这样攻击者A就可以

179
00:13:13,265 --> 00:13:18,174
破解语义安全了。

180
00:13:18,174 --> 00:13:23,203
对于语义安全的密码，任一有效攻击者

181
00:13:23,203 --> 00:13:27,392
都无法得知明文一个比特的信息。这就是完善保密性的概念

182
00:13:27,392 --> 00:13:31,318
只针对有效的攻击者，而不是所有的攻击者

183
00:13:31,318 --> 00:13:35,045
下面我想说的是，事实上

184
00:13:35,045 --> 00:13:38,821
一次一密是语义安全的，
它比语义安全还要好

185
00:13:38,821 --> 00:13:42,773
因为它不仅仅是完善保密的。
那么我们来看看这是为什么

186
00:13:42,773 --> 00:13:47,010
再来看看这个实验，设想我们有一攻击者

187
00:13:47,010 --> 00:13:51,449
他声称破解了一次一密的语义安全

188
00:13:51,449 --> 00:13:55,874
首先攻击者输出两个等长明文M0和M1

189
00:13:55,874 --> 00:13:59,667
作为挑战他能得到什么呢？

190
00:13:59,667 --> 00:14:03,988
他能得到用一次一密加密的M0或M1

191
00:14:03,988 --> 00:14:07,886
他试图区分这两个可能的密文

192
00:14:07,886 --> 00:14:12,259
在实验0中，他获得了M0的加密，
在实验1中，他获得了M1的加密

193
00:14:12,259 --> 00:14:16,579
那么攻击者对一次一密的优势是多少？

194
00:14:16,579 --> 00:14:21,297
一次一密的性质是

195
00:14:21,297 --> 00:14:26,208
K异或M0的分布和K异或M1的分布是一样的

196
00:14:26,208 --> 00:14:31,187
也就是说，这些分布是完全相同的分布

197
00:14:31,187 --> 00:14:36,026
这是异或的性质。
如果我们把随机密钥K与任何消息异或

198
00:14:36,026 --> 00:14:40,674
不管是M0还是M1，
我们都得到均匀分布

199
00:14:40,674 --> 00:14:45,382
所以在两种情况下，
算法A的输入都是是严格的同分布

200
00:14:45,382 --> 00:14:50,209
密文都是均匀分布。
所以两种情况下攻击者表现相同

201
00:14:50,209 --> 00:14:55,036
因为它得到了相同的分布作为输入

202
00:14:55,036 --> 00:14:59,699
因此它的优势是0，
即一次一密是语义安全的

203
00:14:59,723 --> 00:15:04,148
有趣的是它不仅是语义安全的

204
00:15:04,148 --> 00:15:08,244
它对任何攻击者都是语义安全的，
我们甚至不必限制

205
00:15:08,244 --> 00:15:12,450
攻击者是有效的，无论多聪明的攻击者

206
00:15:12,450 --> 00:15:16,875
都无法区分K异或M0和K异或M1

207
00:15:16,875 --> 00:15:21,299
因为它们同分布。
所以一次性密码本是语义安全的

208
00:15:21,299 --> 00:15:25,559
这就完善了语义安全的定义

209
00:15:25,559 --> 00:15:30,093
下面我们要证明，安全的PRG意味着流密码

210
00:15:30,093 --> 00:15:31,186
是语义安全的。【END】

