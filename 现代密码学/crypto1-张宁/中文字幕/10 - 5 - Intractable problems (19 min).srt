1
00:00:00,350 --> 00:00:02,601
在这个模块，我们来看看一些

2
00:00:02,601 --> 00:00:04,919
在模运算下提出来的困难问题

3
00:00:04,919 --> 00:00:08,867
这些问题是下周我们建立密码系统的基础

4
00:00:08,867 --> 00:00:12,867
因此我们首先来讲讲模运算下的简单问题

5
00:00:12,867 --> 00:00:17,301
举个例子 你给我一个整数N 和一个属于Zn的元素x

6
00:00:17,301 --> 00:00:21,368
则使用欧几里得算法很容易找到x的逆

7
00:00:21,368 --> 00:00:25,234
类似地，如果给出一个素数p和多项式f

8
00:00:25,234 --> 00:00:31,150
那么找到使多项式f(x)=0的根是非常容易的,这个根是属于Zp的元素

9
00:00:31,150 --> 00:00:37,334
其实有一个高效算法能够使用多项式线性时间完成计算deg(f)的阶

10
00:00:37,334 --> 00:00:41,900
因此，至少在低阶多项式，

11
00:00:41,900 --> 00:00:44,518
求这些多项式模素数的根是很简单的

12
00:00:44,518 --> 00:00:48,051
然而，许多模运算问题实际上非常困难

13
00:00:48,051 --> 00:00:54,501
正如我所说，这些困难问题构成了许多公钥密码体制的基础。

14
00:00:54,501 --> 00:00:58,135
让我们来看看一些模素数的经典困难问题

15
00:00:58,135 --> 00:01:02,867
选定一个大素数p，假设p为大约600位数的素数，

16
00:01:02,867 --> 00:01:05,988
确定g为集合Zp的一个元素

17
00:01:05,988 --> 00:01:10,258
假设这个元素g的阶刚好是数字q

18
00:01:10,258 --> 00:01:16,656
现在，考虑幂函数，它就是将x映射为g^x

19
00:01:16,656 --> 00:01:21,473
我们将在最后一部分说明这个函数是很容易计算的

20
00:01:21,473 --> 00:01:26,789
通过使用重复平方算法，实际上计算g^x是很高效的

21
00:01:26,789 --> 00:01:29,257
但是现在我们来看求逆的问题

22
00:01:29,257 --> 00:01:35,590
求逆问题，基本上是，给定g^x的值，需要你找到它的对数。

23
00:01:35,590 --> 00:01:43,957
就是求x的值，正如我所说的，在实数域，给定g^x的值来求x正是对数函数的定义

24
00:01:43,957 --> 00:01:48,973
但在这里我需要你求出这个对数模素数p的值

25
00:01:48,973 --> 00:01:53,029
因此这个问题被称为离散对数问题-Dlog

26
00:01:53,029 --> 00:02:00,338
我要说离散对数g^x的基数是g,指数是x

27
00:02:00,338 --> 00:02:08,090
所以g^x的离散对数为x,我们的目标是要输出一些在0到（q-2)间

28
00:02:08,090 --> 00:02:12,071
刚好为g^x的对数的指数

29
00:02:12,071 --> 00:02:17,973
让我们来看一个例子。假设整数模素数11

30
00:02:17,973 --> 00:02:23,039
在这里我写下在Za，a下的离散对数，基数为2

31
00:02:23,039 --> 00:02:25,856
让我们来看看这个函数如何工作

32
00:02:25,856 --> 00:02:31,106
首先，1的离散对数是0，因为2^0=1

33
00:02:31,106 --> 00:02:39,039
类似地，2的离散对数是1，因为2^1=2

34
00:02:39,039 --> 00:02:44,223
4的离散对数是2，因为2^2=4

35
00:02:44,223 --> 00:02:48,141
8的离散对数是3，因为2^3=8

36
00:02:48,141 --> 00:02:52,989
如此一直计算下去。在这里我已经为你们写下这些离散对数的值

37
00:02:52,989 --> 00:02:57,540
让我来问一个难题：什么是5模11的离散对数？

38
00:02:57,540 --> 00:03:01,890
看看你能不能自己计算出来

39
00:03:01,890 --> 00:03:10,590
答案是4，因为2^4=16,16模11等于5

40
00:03:10,590 --> 00:03:15,897
这就是说，基底为2、模11结果为5的离散对数是4

41
00:03:15,897 --> 00:03:21,621
但是大多的离散对数函数实际上是非常难以计算的

42
00:03:21,621 --> 00:03:24,757
当然，对于小素数来说很简单。你可以制作一个表

43
00:03:24,757 --> 00:03:29,789
然后就可以看到离散对数的值。但是当素数p是一个很大的数时

44
00:03:29,789 --> 00:03:34,206
假设p有2000位数，这时计算离散对数实际上相当困难

45
00:03:34,206 --> 00:03:37,300
而且我们没有好的算法来计算

46
00:03:37,300 --> 00:03:40,257
因此，让我们定义一个更加普遍的离散对数问题

47
00:03:40,257 --> 00:03:46,312
与其专注于群(Zp)，不如抽象地来看一个普通群G

48
00:03:46,312 --> 00:03:49,196
现在我们有一个有限循环群及它的生成元g

49
00:03:49,196 --> 00:03:54,214
这意味着这个群是由g的0到(q-1)次幂构成

50
00:03:54,214 --> 00:03:59,246
因此我们采用g的所有次幂直到阶数，在这种情况下G的阶恰好是q

51
00:03:59,246 --> 00:04:07,279
所以我们采用g的所有次幂，这些幂实际上组成了主群G

52
00:04:07,279 --> 00:04:11,347
现在我们来讲在群G中求离散函数是困难的

53
00:04:11,347 --> 00:04:15,547
因为实际上没有有效算法来计算离散对数函数

54
00:04:15,547 --> 00:04:19,130
那么我们的意思是什么呢 就是说如果你选择了一个随机元素g

55
00:04:19,130 --> 00:04:23,659
从主群G中选择 然后再选择一个指数x

56
00:04:23,659 --> 00:04:28,550
如果我给出了算法g和g的x次方 当然我也要给出这个群的描述

57
00:04:28,550 --> 00:04:32,749
所以我给出了群G的描述以及这个群的阶

58
00:04:32,749 --> 00:04:35,485
不过最原始的元素是g及g的x次方

59
00:04:35,485 --> 00:04:40,667
可以计算出离散对数的可能性是非常微小的

60
00:04:40,667 --> 00:04:44,299
好吧 如果所有的有效算法都是这样

61
00:04:44,299 --> 00:04:49,035
我们就可以说在主群G中离散对数问题是困难的

62
00:04:49,035 --> 00:04:54,068
原因就是 没有一个有效的算法

63
00:04:54,068 --> 00:04:58,036
能够以不可忽略的概率来真正有效的计算出离散对数。

64
00:04:58,036 --> 00:05:01,217
正如我所说 我们有千千万的例子可以说明

65
00:05:01,217 --> 00:05:03,535
求群中的离散对数是很难的

66
00:05:03,535 --> 00:05:07,368
最具权威的例子就是Zp，其实也就是

67
00:05:07,368 --> 00:05:12,600
Diffie和Hellman在1974年提出的 它证明了

68
00:05:12,600 --> 00:05:16,423
其他群里离散对数问题是困难的 但是我想说就是

69
00:05:16,423 --> 00:05:19,319
一个叫做椭圆曲线群的候补群

70
00:05:19,319 --> 00:05:23,751
或者说一个椭圆曲线上的一个点集 我现在并不打算定义这个

71
00:05:23,751 --> 00:05:27,568
但我想说 如果你对我所说的椭圆曲线密码感兴趣的话

72
00:05:27,568 --> 00:05:31,634
我会在最后一周的课上讲一下

73
00:05:31,634 --> 00:05:35,868
所以现在有两个群被认为求离散对数问题是困难的

74
00:05:35,868 --> 00:05:40,917
但如我们所知的 一个在椭圆曲线上的离散对数问题比在Zp上的

75
00:05:40,917 --> 00:05:46,235
更加难求 换句话说 如果你给我两个难度相当的问题

76
00:05:46,235 --> 00:05:50,186
一个在群Zp中 一个在椭圆曲线群中

77
00:05:50,186 --> 00:05:53,517
椭圆曲线群中的离散对数问题要比在群Zp中的离散对数问题更难

78
00:05:53,517 --> 00:05:58,417
又假设两个问题难度是一样的

79
00:05:58,417 --> 00:06:04,202
由于求椭圆曲线问题中的离散对数问题更加困难

80
00:06:04,202 --> 00:06:08,267
这就意味着当我们在选取椭圆曲线参数时要使用比Zp更小的参数

81
00:06:08,267 --> 00:06:12,451
结果就是 用椭圆曲线产生的系统

82
00:06:12,451 --> 00:06:15,702
会更加高效 因为参数更小

83
00:06:15,702 --> 00:06:22,867
等价于攻击者用相同的工作量 来攻击一个比所选素数大得多的Zp问题

84
00:06:22,867 --> 00:06:26,355
具体地说 当离散对数问题在Zp中时 我们把它叫做

85
00:06:26,355 --> 00:06:30,703
亚指数算法 我想我已经提到过

86
00:06:30,703 --> 00:06:38,720
如果你有一个n比特的素数 这个算法会运行n的立方根次

87
00:06:38,720 --> 00:06:42,375
事实上在这个算法运行的时候有许多术语

88
00:06:42,375 --> 00:06:46,272
最权威的术语是就是这个素数二进制长度的立方根

89
00:06:46,272 --> 00:06:49,254
就是n的立方根 并且根据这个算法 你可以看到

90
00:06:49,254 --> 00:06:52,538
如果你想要离散对数问题变得困难

91
00:06:52,538 --> 00:06:55,377
像要破解对称密钥一样困难的话

92
00:06:55,377 --> 00:06:59,953
我们就得选一个相对较大的模数p

93
00:06:59,953 --> 00:07:03,987
现在对比下 如果你看到一个椭圆曲线群 数字看起来不大

94
00:07:03,987 --> 00:07:08,421
并且事实上在椭圆曲线群上 最好的求解离散对数算法我们需要

95
00:07:08,421 --> 00:07:11,984
运算e的n/2次方次 所以这就是我们称之为的

96
00:07:11,984 --> 00:07:16,269
一个合适的指数次幂算法 由于n的大小问题

97
00:07:16,269 --> 00:07:21,620
需要运行e的n次方次　指数是n 而不是n的立方根

98
00:07:21,620 --> 00:07:25,819
而且由于这个问题更难 最好的算法是

99
00:07:25,819 --> 00:07:29,601
我们也要算指数次 你会注意到在椭圆曲线中即使我们用了

100
00:07:29,601 --> 00:07:33,301
更小的参数依旧可以保证安全性

101
00:07:33,301 --> 00:07:38,920
顺便说一下 椭圆曲线是对称密钥大小的两倍的原因

102
00:07:38,920 --> 00:07:42,303
是因为指数中有2的原因

103
00:07:42,303 --> 00:07:48,385
那么 我们得把椭圆曲线问题中e的n次方的大小翻倍

104
00:07:48,385 --> 00:07:52,734
事实上我这里有一个小的错误 这应该是2的n/2次方

105
00:07:52,734 --> 00:07:56,101
不过基于算法这并无关紧要

106
00:07:56,101 --> 00:07:59,368
然后我想说的是由于椭圆曲线的参数比Zp中的

107
00:07:59,368 --> 00:08:04,635
更加小 所以在椭圆曲线中 模数p的

108
00:08:04,635 --> 00:08:08,471
加密运算是很慢的

109
00:08:08,471 --> 00:08:11,818
我再说一下 如果你想让我描述下椭圆曲线的更多细节

110
00:08:11,818 --> 00:08:14,867
我会在最后一节课讲

111
00:08:14,867 --> 00:08:17,702
现在让我们来理解什么是离散对数问题

112
00:08:17,702 --> 00:08:20,836
我来给你一个离散对数难度的一个直观的例子

113
00:08:20,836 --> 00:08:25,386
特别地，我们从离散对数问题中构建一个抗碰撞HASH函数

114
00:08:25,386 --> 00:08:29,434
我们选择一些包含离散对数问题的群G

115
00:08:29,434 --> 00:08:34,408
只要你愿意 你可以把群G想象成群Zp

116
00:08:34,408 --> 00:08:41,452
然后我们假设G有素数阶q 那么q是正好等于G的阶的素数

117
00:08:41,452 --> 00:08:45,368
G中的元素的个数

118
00:08:45,368 --> 00:08:50,267
现在我们定义HASH函数 我们选两个G中的元素

119
00:08:50,267 --> 00:08:54,651
并且称它们为g和h 然后我们这样定义HASH函数

120
00:08:54,651 --> 00:09:02,420
HASH函数就是输入一个x和y，然后用g的x次方乘h的y次方

121
00:09:02,420 --> 00:09:08,103
这是一个非常简单的HASH函数 如果你能想起来的话 我们见过这个函数

122
00:09:08,103 --> 00:09:11,523
当时我们在讲压缩函数

123
00:09:11,523 --> 00:09:15,351
我想说的是这个函数H实际是一个抗碰撞函数

124
00:09:15,351 --> 00:09:22,568
就某种意义上而言 找到一个H的碰撞就跟计算G中的离散对数一样难

125
00:09:22,568 --> 00:09:25,802
那么 如果你找到了一个H的碰撞

126
00:09:25,802 --> 00:09:30,951
你就可以计算以g为底 h的离散对数

127
00:09:30,951 --> 00:09:34,320
并且我们说过 如果要计算群G中的离散对数是困难的

128
00:09:34,320 --> 00:09:36,906
应当是非常困难的 因此

129
00:09:36,906 --> 00:09:39,774
找到H的碰撞也是很困难的

130
00:09:39,774 --> 00:09:44,918
我们来看一下 事实上这有一个很巧妙的证明 我们这么做：

131
00:09:44,918 --> 00:09:47,985
假设我们有一个函数H的碰撞

132
00:09:47,985 --> 00:09:55,585
并且我们有两对不同的(x0,y0) (x1,y1) 它们正好是H函数的碰撞

133
00:09:55,585 --> 00:09:58,702
这就意味着它们碰撞了函数H 那就是说

134
00:09:58,702 --> 00:10:04,621
如果我要求函数H在（x0,y0)和（x1,y1）处的值 就会发生碰撞

135
00:10:04,621 --> 00:10:08,836
就是说我会得到一个等式 所以我可以做一些修改

136
00:10:08,836 --> 00:10:11,835
你可以看到我只是把g移动到一边

137
00:10:11,835 --> 00:10:14,169
然后把h移动到另一边 这就意味着

138
00:10:14,169 --> 00:10:21,035
g的（x0-x1）次方是等于h的（y0-y1）次方的 这只是一个简单的变动

139
00:10:21,035 --> 00:10:29,469
现在我再把两边的幂都乘以1/（y1-y0） 就是说我把两边都

140
00:10:29,469 --> 00:10:34,001
开（y0-y1）次方根 一边就会变成h

141
00:10:34,001 --> 00:10:42,268
另一边就会变成g的（x0-x1）/(y0-y1)次方

142
00:10:42,268 --> 00:10:47,518
现在来看下我们得到了什么 我们得到一个用g来表达h的表达式

143
00:10:47,518 --> 00:10:52,003
基本上我们只是做了一些除法就完了

144
00:10:52,003 --> 00:10:58,934
我们用g的幂次表示了h 这样我们得到一个离散对数h的表达式

145
00:10:58,934 --> 00:11:01,819
那么你可能想要知道在指数上这个除法有什么意义

146
00:11:01,819 --> 00:11:06,304
指数中除以（y1-y0）有什么意义

147
00:11:06,304 --> 00:11:13,903
这意味着我们计算了y1-y0模q的值的逆

148
00:11:13,903 --> 00:11:19,436
然后我们用x0-x1来乘以结果 然后就得出了这个指数

149
00:11:19,436 --> 00:11:25,187
并且我们得到了这个基于g的离散对数h

150
00:11:25,187 --> 00:11:31,103
这里会告诉你为什么我们会需要一个素数q 因为我们需要确保

151
00:11:31,103 --> 00:11:36,036
y1-y0是可逆的 事实上 当我们模一个素数时

152
00:11:36,036 --> 00:11:39,336
所有的数除了0都是可逆的

153
00:11:39,336 --> 00:11:45,803
那么这有一个很特殊的点 如果y1-y0恰好等于0呢

154
00:11:45,803 --> 00:11:48,585
如果发生这种情况 我们就无法得到这个离散对数了

155
00:11:48,585 --> 00:11:52,707
因为我们不能把0作为分母

156
00:11:52,707 --> 00:11:56,420
不过如果你再想一下

157
00:11:56,420 --> 00:12:03,770
如果y1-y0等于0 那就意味着y1=y0

158
00:12:03,770 --> 00:12:08,570
你再看下等式 但是如果y1=y0

159
00:12:08,570 --> 00:12:13,759
就意味着x0=x1

160
00:12:13,759 --> 00:12:17,669
这需要花费你一分钟来证明下 如果y0=y1

161
00:12:17,669 --> 00:12:24,002
那么这两个项就会抵消 我们可以得到x0=x1

162
00:12:24,002 --> 00:12:29,402
但是如果x0=x1 y0=y1的话 那么我们得到的就不是一个碰撞

163
00:12:29,402 --> 00:12:34,585
我们只是得到了相同的一对两次 所以 这并不是碰撞

164
00:12:34,585 --> 00:12:39,587
并且我就不需要找到一个碰撞了 但是如果你给了我一个碰撞的话

165
00:12:39,587 --> 00:12:43,435
那么y0必然不等于y1 并且我就会得到一个

166
00:12:43,435 --> 00:12:46,102
基于h的离散对数g

167
00:12:46,102 --> 00:12:50,220
正如我们所说 因为离散对数问题在群大G中是困难的

168
00:12:50,220 --> 00:12:56,002
这就意味着H这个简单的函数是抗碰撞的

169
00:12:56,002 --> 00:13:04,240
这是一个关于减少离散对数计算中发生碰撞的次数的非常简单的例子

170
00:13:04,240 --> 00:13:06,721
不过这个函数事实上并没有被使用

171
00:13:06,721 --> 00:13:10,073
即使这个函数被证明是抗碰撞的

172
00:13:10,073 --> 00:13:13,961
它也不会被使用因为它实在是太慢了

173
00:13:20,355 --> 00:13:26,004
的随意抗碰撞HASH函数来说 是非常非常慢的

174
00:13:26,004 --> 00:13:30,189
那就是我想说的关于模素数的难解问题

175
00:13:30,189 --> 00:13:33,511
现在让我们来看一些模合数的分解问题的困难性

176
00:13:33,511 --> 00:13:42,024
我们看下一个1024位的数 我们定义下集合Z2(n)

177
00:13:42,024 --> 00:13:47,075
这是一个集合 其中所有的整数都由两个素数相乘得到的

178
00:13:47,075 --> 00:13:51,392
这两个素数是n比特的素数

179
00:13:51,392 --> 00:13:55,984
这个2的意思就是集合中的数字

180
00:13:55,984 --> 00:14:00,659
有两个素数因子 并且这两个素数因子位数相同

181
00:14:00,659 --> 00:14:02,875
他们都是n比特的素数

182
00:14:02,875 --> 00:14:06,292
有两个经典的难解难题在这个集合中

183
00:14:06,292 --> 00:14:12,242
第一个难题就是 如果我在集合Z(2)(n)中随机选择一个整数 求它的因子

184
00:14:12,242 --> 00:14:15,326
在1024位上这是一个非常难的难题

185
00:14:15,326 --> 00:14:18,992
尽管到现在还没有办法被解出来 但这个量级的数字

186
00:14:18,992 --> 00:14:25,042
已经很快就可以被分解因子 所以现在我们一般都使用2048比特的数字

187
00:14:25,042 --> 00:14:30,308
这远远超出了我们的能力范围 而这些数字我们现在无法分解

188
00:14:30,308 --> 00:14:36,151
另外一个难解的模合数问题是 如果你有一个非线性多项式

189
00:14:36,151 --> 00:14:41,076
并且大于1阶 然后你从Z(2)(n)中随机选择合数

190
00:14:41,076 --> 00:14:44,544
然后你的目标就是找到这个多项式的根

191
00:14:44,544 --> 00:14:47,542
找到一个x正好是这个多项式的根

192
00:14:47,542 --> 00:14:50,411
同样我们不知道如何做 当然如果阶等于1的话

193
00:14:50,411 --> 00:14:54,379
就相当于解决一个线性问题了

194
00:14:54,379 --> 00:14:58,729
但是如果阶不是线性的话 我们就不知道怎么求模N了

195
00:14:58,729 --> 00:15:04,895
如果没有首先分解模 然后才会是求根

196
00:15:04,895 --> 00:15:08,495
有一些系统 例如RSA 都是依赖于这个

197
00:15:08,495 --> 00:15:14,694
特殊的多项式难题建立的 我们下周会讲到这里

198
00:15:14,694 --> 00:15:18,312
在这个例子中 我想提醒下 对这个Z(2)(n)中的随机合数使用

199
00:15:18,312 --> 00:15:24,961
平方根或者立方根都是很难求解的

200
00:15:24,961 --> 00:15:27,413
这里有一个广为人知的分解问题

201
00:15:27,413 --> 00:15:31,329
这也是一个非常老的问题 虽然希腊人对因式分解很感兴趣

202
00:15:31,329 --> 00:15:34,961
但高斯有一个非常非常厉害的举证

203
00:15:34,961 --> 00:15:38,295
关于这个因式分解问题和这个素性测试问题

204
00:15:38,295 --> 00:15:42,233
在他1805年的论文里 这么写道

205
00:15:42,233 --> 00:15:45,228
从合数中区分素数的问题

206
00:15:45,228 --> 00:15:48,062
（这个叫做素性测试）

207
00:15:48,062 --> 00:15:51,361
和后者的分解问题（即合数）

208
00:15:51,361 --> 00:15:57,461
将他们分解为两个素数因子 在算术中会是非常重要的问题

209
00:15:57,461 --> 00:16:01,408
他当时就预见了这些难题是很有趣的

210
00:16:01,408 --> 00:16:05,424
本质上 这些事计算机科学的难题 怎么样检测一个数是不是素数？

211
00:16:05,424 --> 00:16:09,856
如果是合数的话怎么样进行因子分解

212
00:16:09,856 --> 00:16:13,925
高斯已经察觉到了这些是非常非常重要和有趣的问题

213
00:16:13,925 --> 00:16:19,208
并且现在 这些难题被应用到了网络上的任何一个角落

214
00:16:19,208 --> 00:16:24,175
我们来看下 事实上 检查一个数是否是素数已经被完全解决了

215
00:16:24,175 --> 00:16:29,024
如今我们已经可以通过使用一个随机化算法完全解决它

216
00:16:29,024 --> 00:16:31,793
甚至我们知道用一个确定化算法来求得

217
00:16:31,793 --> 00:16:35,675
因数分解 就是把合数分解成它的素数因子

218
00:16:35,675 --> 00:16:39,542
现在仍然是一个难题 我也会鼓励你们去思考这个问题

219
00:16:39,542 --> 00:16:42,875
这是一个非常值得探究的问题 如果你们中有人能解决它

220
00:16:42,875 --> 00:16:47,208
如果你们可以提出一个算法来解决合数的因数分解问题

221
00:16:47,208 --> 00:16:51,724
这会立马在密码学领域里闻名的 这将会是一个惊人的成果

222
00:16:51,724 --> 00:16:56,657
在网络安全领域中 所以这是一个非常值得思考的问题

223
00:16:56,657 --> 00:16:59,342
我来告诉你们一些关于因式分解的问题

224
00:16:59,342 --> 00:17:02,624
我们现有的最好的算法就是数域筛法

225
00:17:02,624 --> 00:17:07,764
它的运行时间是指数的立方根级

226
00:17:07,764 --> 00:17:13,042
这就是为什么合数要非常大的而难以求解

227
00:17:13,042 --> 00:17:18,657
尽管目前的世界纪录是可以分解768位的数字

228
00:17:18,657 --> 00:17:24,008
我们把它叫做RSA-768数字 这是一个我们最近已经可以分解的数字

229
00:17:24,008 --> 00:17:28,842
这个数字大概有两百位 分解这个数字需要非常巨大的工作量

230
00:17:28,842 --> 00:17:34,265
用一百台机器花费了两年时间 最终他们分解了这个数字

231
00:17:34,265 --> 00:17:39,214
并且估计分解一个1024位的数字的难度是分解RSA-768难度的一千倍

232
00:17:39,214 --> 00:17:45,102
所以说 需要花费2000年的世界才能求出

233
00:17:45,102 --> 00:17:50,064
不过计算机也是在变得越来越快 我们有越来越多的核在处理器中

234
00:17:50,064 --> 00:17:55,332
我们有更多的计算机 所以根据摩尔定理

235
00:17:55,332 --> 00:17:59,039
我们大概需要十年吧 计算机就可以

236
00:17:59,039 --> 00:18:02,308
计算上千位的因子 很可能在下一个十年之内

237
00:18:02,308 --> 00:18:07,475
我们就可以看到1024位数字分解出的因数 这将会是1024位数字

238
00:18:07,475 --> 00:18:11,630
作为公钥密码的终结

239
00:18:11,630 --> 00:18:16,026
那么这就是因式分解世界的艺术 我们这个模块就以此结束

240
00:18:16,026 --> 00:18:19,392
我想说 如果你想要知道更多关于今天我们讨论的东西

241
00:18:19,392 --> 00:18:23,474
网上有一个本非常好的书提供免费下载

242
00:18:23,474 --> 00:18:27,109
作者是Victor Shoup 我们讨论的主题就在

243
00:18:27,109 --> 00:18:30,375
1-4 11 12章

244
00:18:30,375 --> 00:18:33,557
我希望你们可以去看一看 希望可以对你们

245
00:18:33,557 --> 00:18:35,993
理解这些东西起到帮助

246
00:18:35,993 --> 00:18:39,000
下一周 我们将开始用我们学过的这些概念构建密码系统。【END】

