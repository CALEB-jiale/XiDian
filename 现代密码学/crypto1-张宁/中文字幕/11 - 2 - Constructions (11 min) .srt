1
00:00:00,000 --> 00:00:03,827
在这一小节中 我们来讲下什么是公钥加密系统

2
00:00:03,827 --> 00:00:07,557
并且我们来定义下公钥加密系统的安全性

3
00:00:07,557 --> 00:00:11,142
如果你还记得的话 我们需要针对主动攻击的安全性

4
00:00:11,142 --> 00:00:15,211
而且我们要特别定义下选择密文攻击的安全性 这一周

5
00:00:15,211 --> 00:00:19,281
我们要构建两个具有选择密文攻击安全性的公钥加密系统

6
00:00:19,281 --> 00:00:22,914
并且在这一小节 我们要从陷门置换来

7
00:00:23,059 --> 00:00:27,124
构建一个公钥加密系统 所以我们先来

8
00:00:27,124 --> 00:00:31,064
定义一下什么是陷门函数

9
00:00:31,064 --> 00:00:35,484
一个陷门函数就是一个集合X到集合Y的函数

10
00:00:35,484 --> 00:00:39,585
它是由三个算法定义而成的,

11
00:00:39,585 --> 00:00:43,685
一个是密钥生成算法, 一个是函数f,还有一个是函数f的逆.

12
00:00:43,685 --> 00:00:47,892
当你运行密钥生成算法时就会生成一个密钥对,

13
00:00:47,892 --> 00:00:52,098
就是一个公钥和一个私钥, 公钥会确定一个特殊的

14
00:00:52,098 --> 00:00:56,869
从集合X到集合Y的函数 并且密钥将会确定一个

15
00:00:56,869 --> 00:01:01,639
从集合Y到集合X的逆函数 所以你可以用公钥Pk来求这个函数值

16
00:01:01,639 --> 00:01:06,588
并且可以用私钥Sk来求这个函数的逆,

17
00:01:06,588 --> 00:01:12,443
那么我说逆的意思是什么呢 详细来说就是

18
00:01:12,443 --> 00:01:17,255
如果我们看到密钥生成算法生成的任何密钥对

19
00:01:17,255 --> 00:01:21,727
假如我求得了在点X的函数值

20
00:01:21,727 --> 00:01:26,142
然后我想要求这个点的值的逆, 我就可以得到原始的X的值

21
00:01:26,142 --> 00:01:30,670
你们可以想象下 有一个大集合X和一个大集合Y

22
00:01:30,670 --> 00:01:35,857
这个函数从X中的一些点映射到Y中的一个点

23
00:01:35,857 --> 00:01:41,508
并且都这是用公钥来实现的 所以X中的点可以映射

24
00:01:41,508 --> 00:01:46,897
Y中的点 那么如果有人拥有这个私钥 那么他们就可以

25
00:01:46,897 --> 00:01:53,758
用Sk来颠倒这个过程 那么现在

26
00:01:53,758 --> 00:01:58,289
我们已经理解了陷门函数的意思 我们再来定义下

27
00:01:58,289 --> 00:02:02,652
陷门函数的安全性 我们可以说 这三个函数(G,F,F的逆)

28
00:02:02,652 --> 00:02:06,903
他们整体是单向函数的话就是安全的

29
00:02:06,903 --> 00:02:10,986
我来解释下什么是单向函数 就是说一个函数在

30
00:02:10,986 --> 00:02:15,516
任意一点可以求值, 但是如果没有私钥的话就难以求得它的逆函数

31
00:02:15,516 --> 00:02:19,639
那么我们再用一个比赛来详细定义下吧

32
00:02:19,639 --> 00:02:23,764
这里我们有一个挑战者和敌手之间的比赛

33
00:02:23,764 --> 00:02:27,496
挑战者先生成一个公钥和一个私钥

34
00:02:27,496 --> 00:02:31,622
然后他会生成一个随机数X并把公钥发送给敌方,

35
00:02:31,622 --> 00:02:36,116
再用公钥求得函数在点X的值Y

36
00:02:36,116 --> 00:02:40,160
并将它也发送给敌方 那么敌方得到的就是

37
00:02:40,160 --> 00:02:44,653
一个定义了这个函数的公钥,

38
00:02:44,653 --> 00:02:49,483
以及这个函数使用公钥之后在X处的值Y,

39
00:02:49,483 --> 00:02:54,097
然后他尝试来求解函数的逆,

40
00:02:54,097 --> 00:02:58,507
前面我们说过 如果对手用Y求得这个函数的逆的概率非常小的话

41
00:02:58,507 --> 00:03:03,143
那这个陷门函数就是安全的 就是说 通过给定Y,

42
00:03:03,143 --> 00:03:07,271
无论使用哪种算法

43
00:03:07,271 --> 00:03:11,907
求得它的原象的概率都非常低的话

44
00:03:11,907 --> 00:03:17,882
那么这个陷门函数就是安全的 这是一个很有趣的概念

45
00:03:17,882 --> 00:03:21,885
你可以非常简单从一个方向求得这个函数

46
00:03:21,885 --> 00:03:26,150
但是没人能从另一个方向求得这个陷门函数

47
00:03:26,150 --> 00:03:30,311
如果没有私钥SK的话 但是私钥SK可以让求逆变得非常

48
00:03:30,311 --> 00:03:35,424
非常的简单 所以 通过使用陷门函数

49
00:03:35,424 --> 00:03:39,552
建立一个公钥加密系统就不难了 我们来看看怎么做

50
00:03:39,552 --> 00:03:43,528
这里我们有一个陷门函数(G,F,F的逆)

51
00:03:43,528 --> 00:03:47,605
另一个我们需要的工具就是对称加密体制

52
00:03:47,605 --> 00:03:51,531
我们先假设这个加密体制面对主动攻击是安全的

53
00:03:51,531 --> 00:03:55,350
那么 我需要一个认证加密技术

54
00:03:55,350 --> 00:04:00,726
注意一下, 对称加密系统用密钥来加密K 陷门函数用输入来加密X

55
00:04:00,726 --> 00:04:05,790
有两个不同的集合 同时我们也需要一个从X映射到K的

56
00:04:05,790 --> 00:04:09,937
杂凑函数 换句话说 就是它把集合X中的元素映射到对称加密系统的密钥中

57
00:04:09,937 --> 00:04:14,033
现在我们有了这三个部分

58
00:04:14,033 --> 00:04:17,821
我们就可以构建一个这样的公钥加密系统

59
00:04:17,821 --> 00:04:21,764
公钥加密系统中的密钥生成器和陷门函数中的

60
00:04:21,764 --> 00:04:25,655
密钥生成器一样 那么我们运行陷门函数中的G函数

61
00:04:25,655 --> 00:04:29,956
得到一个公钥私钥对 并且这将会作为公钥加密系统的

62
00:04:29,956 --> 00:04:34,171
公钥和私钥 那么我们如果来加密和解密呢

63
00:04:34,171 --> 00:04:38,978
我们先从加密说起, 加密算法需要一个公钥和一个消息作为输入

64
00:04:38,978 --> 00:04:43,898
然后它会从集合X中生成一个随机数X

65
00:04:43,898 --> 00:04:48,545
然后把X代入到陷门函数中生成Y

66
00:04:48,545 --> 00:04:53,130
那么Y就是X在陷门函数下的映射

67
00:04:53,130 --> 00:04:58,272
然后它会把X代入杂凑函数来产生一个对称密钥

68
00:04:58,272 --> 00:05:03,290
即对称密钥系统的对称密钥, 最终, 在加密对称加密系统中的消息M时

69
00:05:03,290 --> 00:05:08,123
它用这个密钥来加密明文消息M


70
00:05:08,123 --> 00:05:13,260
然后它就会输出Y的值 也就是X的映射.

71
00:05:13,260 --> 00:05:18,366
这就是加密过程如何工作的 我要再一次强调的是陷门函数

72
00:05:18,366 --> 00:05:23,112
仅仅是适用于这个随机值X 而这个消息本身,

73
00:05:23,112 --> 00:05:28,098
是用我们刚才选择的对称加密系统加密的

74
00:05:28,098 --> 00:05:32,959
至此我们明白了加密过程 现在来看如何解密

75
00:05:32,959 --> 00:05:37,366
解密算法使用一个私钥和一个密文作为输入

76
00:05:37,366 --> 00:05:41,551
密文本身包含两个部分 y值和c值

77
00:05:41,551 --> 00:05:46,070
所以第一步我们要做的是 我们要使用逆变换

78
00:05:46,070 --> 00:05:50,366
对y值使用逆陷门函数 那会让我们得到

79
00:05:50,366 --> 00:05:54,495
加密时最原始的x的值 那么

80
00:05:54,495 --> 00:06:00,042
 我们怎么从我们刚得到的x推导出对称解密密钥k呢?

81
00:06:00,042 --> 00:06:04,736
这个问题很简单 我们再次HASH(x) 得到

82
00:06:04,736 --> 00:06:09,372
加密时的那个k 现在我们有对称加密密钥 我们可以

83
00:06:09,372 --> 00:06:13,783
对应这个对称解密密钥到解密密文c 我们得到

84
00:06:13,783 --> 00:06:17,741
原始消息m 这就是我们得到的输出 这就是公钥

85
00:06:17,741 --> 00:06:22,321
加密系统的工作过程 这个陷门函数只是用于加密

86
00:06:22,321 --> 00:06:26,788
一些随机值x 真正的消息是用对称系统加密的

87
00:06:26,788 --> 00:06:31,244
在这张图片里 我们有消息m 显然

88
00:06:31,244 --> 00:06:35,545
纯文本的可能会相当大 这里我们有解密文本的内容

89
00:06:35,545 --> 00:06:39,953
这会有相当长的一部分是用对称系统加密的 再次强调

90
00:06:39,953 --> 00:06:44,039
对称系统的密钥仅仅是对x的HASH的函数

91
00:06:44,039 --> 00:06:48,232
密文的开头仅仅是陷门函数对

92
00:06:48,232 --> 00:06:52,641
我们得到的随机值x的应用 在解密期间会发生的是

93
00:06:52,641 --> 00:06:56,888
我们首先解密开头以得到x 然后用

94
00:06:56,888 --> 00:07:01,829
对称系统解密消息体以得到原始明文消息m 像往常一样

95
00:07:01,829 --> 00:07:06,542
我为你们介绍一个类似的系统 显然你们想验证这个解密过程其实是

96
00:07:06,542 --> 00:07:10,605
加密过程的逆运算 但是更重要的是这个系统的安全性

97
00:07:10,605 --> 00:07:14,963
其实这里有一个好的安全定理 就是

98
00:07:14,963 --> 00:07:18,900
如果我们使用的陷门函数安全 换句话说 

99
00:07:18,900 --> 00:07:22,634
有一个单向函数 如果对手没有密钥 对称

100
00:07:22,634 --> 00:07:26,621
加密系统提供身份验证的加密 HASH函数是一个

101
00:07:26,621 --> 00:07:30,558
随机预言 它仅仅意味着它是来自集合x到密钥集k的

102
00:07:30,558 --> 00:07:34,696
随机函数 所以一个随机预言是某种理想化的函数

103
00:07:34,696 --> 00:07:38,280
跟HASH函数应该很像 当然在实践中 当你去

104
00:07:38,280 --> 00:07:42,317
实现这样一个系统的时候 你可能会用SHA-256，或者其他

105
00:07:42,317 --> 00:07:47,252
任何我们在课堂上讲过的HASH函数 所以 在那三种情况下

106
00:07:47,252 --> 00:07:51,863
事实上我们刚才讨论的系统是选择密文安全的 所以它是CCA安全的

107
00:07:51,863 --> 00:07:56,416
这个随机预言只表示了随机预言模型中的集合的安全性

108
00:07:56,416 --> 00:08:00,572
但是 这里还有一个不太重要的细节

109
00:08:00,572 --> 00:08:05,012
你们要记住的是 如果陷门函数

110
00:08:05,012 --> 00:08:09,000
是一个安全的陷门函数 对称加密系统

111
00:08:09,000 --> 00:08:13,017
对应于篡改是安全的 则它提供经过身份验证的加密

112
00:08:13,017 --> 00:08:17,468
h在某种程度上是一个好HASH函数 那个练习中的随机函数

113
00:08:17,468 --> 00:08:22,245
你们只用SHA-256 其实我们刚才讲的系统是

114
00:08:22,245 --> 00:08:27,615
CCA安全的 是选择密文安全的 我要告诉你们 其实有

115
00:08:27,615 --> 00:08:31,752
ISO标准 定义了这种加密 称为公开加密

116
00:08:31,752 --> 00:08:35,781
ISO标准化组织 所以其实这个特殊的

117
00:08:35,781 --> 00:08:40,456
系统事实上被标准化了 这用起来是个好东西 我要提一下这个

118
00:08:40,456 --> 00:08:44,947
作为下面几节课的ISO加密 总结下这一节课

119
00:08:44,947 --> 00:08:48,925
我要警告你们关于一个使用陷门函数去建立

120
00:08:48,925 --> 00:08:53,328
公钥加密系统的错误点 其实这个方法可能是第一个

121
00:08:53,328 --> 00:08:57,572
能想到的 目前它是完全不安全的 我来讲解下怎样才能

122
00:08:57,572 --> 00:09:01,762
不用陷门函数加密 第一件事我们能想到的是

123
00:09:01,762 --> 00:09:05,696
我们直接对这个消息m应用陷门函数 所以我们

124
00:09:05,696 --> 00:09:10,047
仅仅使用函数计算去加密消息m 那我们解密也仅仅是

125
00:09:10,047 --> 00:09:14,180
使用f对密文c求逆去恢复原始消息m

126
00:09:14,180 --> 00:09:18,639
这个其实函数的解密就是对加密的逆运算 目前

127
00:09:18,639 --> 00:09:22,881
这有很多很多理由不安全 最简单的方法去看

128
00:09:22,881 --> 00:09:26,960
这个不安全因素 就是它太简单 它是确定加密

129
00:09:26,960 --> 00:09:30,944
你会注意到这里没有用到随机性 当我们加密一个消息m

130
00:09:30,944 --> 00:09:34,154
由于它是确定的 就不可能

131
00:09:34,154 --> 00:09:37,948
在语义上是安全的 但其实如我所说 当我们用特定的实现

132
00:09:37,948 --> 00:09:41,644
去实例化这个陷门函数 以这个RSA陷门函数为例

133
00:09:41,644 --> 00:09:44,951
有很多很多可能的攻击

134
00:09:44,951 --> 00:09:48,794
对这个特定的结构 所以你们以后千万不要用它 

135
00:09:48,794 --> 00:09:52,830
我会多次重复这个案例,  并且在下一节课, 我会给你们

136
00:09:52,830 --> 00:09:56,699
讲一些对这个特定实现的攻击 好 我希望你们记住

137
00:09:56,699 --> 00:10:00,717
你们要按照ISO标准去应用加密系统

138
00:10:00,717 --> 00:10:04,992
永远不要直接将陷门函数应用于消息m

139
00:10:04,992 --> 00:10:09,010
即使下一节课我们会学习使用陷门函数加密的其他方法

140
00:10:09,010 --> 00:10:13,233
那些是正确的, 但是这个特定的模型是明显

141
00:10:13,233 --> 00:10:17,560
明显不正确的, 好的, 现在我们明白了如何使用给定的陷门函数

142
00:10:17,560 --> 00:10:21,423
建立公钥加密, 下一个问题就是如何建立

143
00:10:21,423 --> 00:10:24,360
陷门函数 我们下节课再讲。【END】

