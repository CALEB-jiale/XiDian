1
00:00:00,000 --> 00:00:04,616
这一节，我们将构造两个经典的MAC，CBC-MAC和

2
00:00:04,616 --> 00:00:09,233
NMAC。回忆上一节，我们说如果你给我一个安全的PRF，那么

3
00:00:09,233 --> 00:00:14,087
这个安全的PRF可以用来构造一个安全的MAC，就是简单

4
00:00:14,087 --> 00:00:18,763
地定义对消息m的签名是这个消息m的函数

5
00:00:18,763 --> 00:00:23,203
唯一的需要注意的是PEF的F函数输出必须足够大 比如 它

6
00:00:23,203 --> 00:00:27,947
必须是80或者128比特的，可以生成一个安全的MAC 现在我们

7
00:00:27,947 --> 00:00:33,220
说因为AES是一个安全的PRF，基本上AES已经给我们安全的

8
00:00:33,220 --> 00:00:37,899
MAC了，除了它只能处理16字节的消息。现在问题

9
00:00:37,899 --> 00:00:42,889
是，给出一个像AES这样有16字节的短消息PRF，我们

10
00:00:42,889 --> 00:00:48,005
能构造出一个PRF可以处理可能G比特的数据吗？

11
00:00:48,005 --> 00:00:53,245
把这个作为简写 我在这里用X表示，集合01n其中n是

12
00:00:53,245 --> 00:00:58,485
内在PRF的分组大小 因为我们总是要考虑AES

13
00:00:58,485 --> 00:01:03,247
作为内在PRF，你可以认为n就是128比特

14
00:01:03,247 --> 00:01:08,296
第一种构造称为加密的CBC-MAC，或者简写为ECBC

15
00:01:08,296 --> 00:01:13,967
加密的CBC MAC。因此ECBC以01n集合X中的消息为输入

16
00:01:13,967 --> 00:01:19,500
输出消息也在集合X中。我们将要构造的

17
00:01:19,500 --> 00:01:24,687
PRF基本上需要成对的密钥 消息很长 实际上

18
00:01:24,687 --> 00:01:29,667
是任意长的消息 后面我会解释

19
00:01:29,667 --> 00:01:34,596
它的输出也是01n集合中的元素 也就是我们的结果 现在问题是

20
00:01:34,596 --> 00:01:39,478
X和L比是短了还是相等？这里的关键是 实际上CBC MAC可以取最多

21
00:01:39,478 --> 00:01:44,118
L块长度的消息 L 可能是一百万或一兆,也有可能

22
00:01:44,118 --> 00:01:49,063
以变化长度的消息作为输入 换句话说 X是小于等于L的

23
00:01:49,063 --> 00:01:53,825
意味着我们允许的消息有任意长的分组，

24
00:01:53,825 --> 00:01:58,709
在1和L之间。每一个CBC可以处理消息的长度可以使1个分组

25
00:01:58,709 --> 00:02:03,349
2个分组，10个分组或100个分组等等 输入大小完全没问题

26
00:02:03,349 --> 00:02:07,826
但是为了讨论简单起见，我们把上限定为

27
00:02:07,826 --> 00:02:12,301
大写L。现在我们看看ECBC是怎么工作的，好

28
00:02:12,301 --> 00:02:16,886
我们从消息开始，把消息分组，每组的长度就是内置函数F的

29
00:02:16,886 --> 00:02:21,250
分组长度，接着我们把CBC链过一遍

30
00:02:21,250 --> 00:02:25,835
但我们不输出中间值 你会注意到 我们基本上就是加密了

31
00:02:25,835 --> 00:02:30,309
第一个分组，把加密结果与第二个分组进行异或后

32
00:02:30,309 --> 00:02:34,784
然后再用F处理，我们一遍接一遍的做，直到最后我们

33
00:02:34,784 --> 00:02:39,302
得到这个结果，称作CBC这个长链输出

34
00:02:39,302 --> 00:02:44,235
接着，我想让大家注意一下，我们实际上进行了另一个

35
00:02:44,235 --> 00:02:48,927
加密步骤，这个步骤实际上使用了一个独立的密钥k1，这个密钥

36
00:02:48,927 --> 00:02:53,756
和密钥k的选取互相独立，最后这个输出是标签

37
00:02:53,756 --> 00:02:58,183
这种情况下，标签式N比特长的，但是我们在前面的章节也提到了

38
00:02:58,183 --> 00:03:02,956
把标签截断短至N比特以下而N比特之后的数据

39
00:03:02,956 --> 00:03:07,555
是可以忽略的。所以我们现在看到Fecbc以一对密钥

40
00:03:07,555 --> 00:03:11,867
作为输入，它可以处理长度为变量的消息生成

41
00:03:11,867 --> 00:03:16,206
的输出属于集合X。所以你现在可能会疑惑这个最后一个加密

42
00:03:16,206 --> 00:03:20,228
是为什么 我告诉你这个函数，如果没有最后这个

43
00:03:20,228 --> 00:03:24,196
加密步骤，称之为 raw CBC（简化）函数。换句话说，如果我们

44
00:03:24,196 --> 00:03:28,377
仅在这里就停了，以这个作为输出，就称为简化CBC

45
00:03:28,377 --> 00:03:32,852
等一下我们会看到，这个简化CBC不是一个安全的MAC 所以这个最后一步

46
00:03:32,852 --> 00:03:37,120
实际上对构造一个安全的MAC是很重要的。另外一种把小规模

47
00:03:37,120 --> 00:03:41,511
PRF转换为大规模PRF构造MAC的方式称为NMAC

48
00:03:41,511 --> 00:03:46,264
是为网状MAC。NMAC也是从PRF开始，像前面一样

49
00:03:46,264 --> 00:03:50,977
输入为集合X重元素，但是输出是在密钥空间K。回忆前面的CBC

50
00:03:50,977 --> 00:03:56,136
输出必须在集合X中。这里输出在密钥空间K

51
00:03:56,136 --> 00:04:01,167
这个基本上就是我们的FNMAC PRF了，它以两对密钥为输入

52
00:04:01,167 --> 00:04:06,008
也能处理长度为L组以下的消息，输出是

53
00:04:06,008 --> 00:04:11,167
密钥空间的一个元素，NMAC工作的方式，和

54
00:04:11,167 --> 00:04:16,313
前面的类似。我们把消息分组，每个分组，和前面一样

55
00:04:16,313 --> 00:04:21,890
和内置PRF的分组长度一样，现在我们把密钥作为函数

56
00:04:21,890 --> 00:04:27,171
F的密钥输入 这个消息分组也作为这个函数F

57
00:04:27,171 --> 00:04:32,515
的输入 输出作为下一组NMAC的密钥

58
00:04:32,515 --> 00:04:37,414
所以现在对这个PRF的下一组消息我们有了个新密钥，以此类推

59
00:04:37,414 --> 00:04:42,376
对下一个消息进行函数变换，直到

60
00:04:42,376 --> 00:04:47,707
我们得到最后的输出，最后的输出会是一个K中的元素，对吧？

61
00:04:47,707 --> 00:04:52,959
和前面一样，实际上，如果我们这里就停了。这个函数我们称为

62
00:04:52,959 --> 00:04:57,938
级联函数，我们再回来看一下这个级联

63
00:04:57,938 --> 00:05:02,734
级联函数会输出一个K中的元素，但是，我们会看到，这不是

64
00:05:02,734 --> 00:05:07,529
一个安全的MAC。为了获得安全的MAC，我们需要把这个

65
00:05:07,529 --> 00:05:12,679
K中的元素t，映射到X中。基本上，我们会看到，NMAC

66
00:05:12,679 --> 00:05:18,495
用到这些PRF，分组长度X要比密钥长度长得多。

67
00:05:18,495 --> 00:05:24,239
就简单的固定填充就行。fpad称为固定填充，

68
00:05:24,239 --> 00:05:29,209
就是对标签T附加些信息。然后这里，这个输入这里，这个分组

69
00:05:29,209 --> 00:05:33,885
成了了X中的元素，我们把这个输入给函数，再一次，

70
00:05:33,885 --> 00:05:38,334
注意到这里是一个独立的密钥，在最后一次加密中使用

71
00:05:38,334 --> 00:05:42,782
最后，最后这个标签式一个K中的一个元素，我们作为NMAC的输出

72
00:05:42,782 --> 00:05:47,059
记住，如果没有最后这个加密步骤，这个函数称为

73
00:05:47,059 --> 00:05:51,393
级联函数。有这个步骤，后面我们会看到对安全性来说是必要的，我们

74
00:05:51,393 --> 00:05:55,884
得到了一个PRF，输出是K中的元素，可以处理变长度

75
00:05:55,884 --> 00:06:00,034
的消息，长度最长可到L个分组。好了，这就是NMAC

76
00:06:00,034 --> 00:06:06,587
的构造。现在我们有了两个MAC。我们可以用AES来构造大型的PRF

77
00:06:06,587 --> 00:06:11,023
前面，我分析过了MAC的安全性，我希望

78
00:06:11,023 --> 00:06:15,170
你们能更好地理解最后一步加密是为了什么。好，让我们从NMAC开始。

79
00:06:15,170 --> 00:06:19,533
这个我解释起来实际上很容易知道，如果我们

80
00:06:19,533 --> 00:06:23,573
省掉了最后一步加密，换句话说，如果我们只用这个

81
00:06:23,573 --> 00:06:27,936
级联函数，MAC就完全不安全了，好，现在假设我们来

82
00:06:27,936 --> 00:06:32,298
看一下这个MAC的问题。也就是说，我们做的就是直接从这个级联

83
00:06:32,298 --> 00:06:36,661
输出m的结果，不用最后一步加密。我问一下，你怎么能复制出一个标签？

84
00:06:36,661 --> 00:06:40,809
在这个MAC中。我想我基本上帮你把这个答案排除掉

85
00:06:40,809 --> 00:06:45,360
正确。我希望每个人都选这个答案，实际上，给定一个

86
00:06:45,360 --> 00:06:49,203
选择消息质询，你可以构造一个存在伪造。原因是

87
00:06:49,203 --> 00:06:53,769
在这个图里我会给你解释一下，但是让我先用符号把它写出来

88
00:06:53,769 --> 00:06:58,113
原因是，如果你有这个消息m的级联函数的的输出

89
00:06:58,113 --> 00:07:02,918
我可以从它推导出，我作为敌手，我可以从它推导出

90
00:07:02,918 --> 00:07:07,541
消息m和任意消息w串接的级联函数值，任意w。

91
00:07:07,541 --> 00:07:11,851
首先，应该清楚，这个足以让我们推导出一个

92
00:07:11,851 --> 00:07:17,287
存在伪造，因为基本上，有这个消息的标签，我

93
00:07:17,287 --> 00:07:22,472
就可以得到这个长消息的标签，那我就能得到我的伪造了。

94
00:07:22,472 --> 00:07:27,720
好，所以这个MAC是不安全的，因为给出一个消息的MAC，我可以构造出另一个

95
00:07:27,720 --> 00:07:32,259
消息的MAC。但是让我们回来看一下这个描述级联的图，看一下为什么会这样

96
00:07:32,259 --> 00:07:36,243
让我们看一下如果这里没有这个最后一步会怎样。作为一个

97
00:07:36,243 --> 00:07:40,451
攻击者，我能做的是，我可以在这里加一个分组，我称它为w，接着

98
00:07:40,451 --> 00:07:44,660
我用级联的输出这个值T

99
00:07:44,660 --> 00:07:49,731
输入到函数F中，所以我把这个T输入到

100
00:07:49,731 --> 00:07:54,995
F，把我最后一个分组w也输入，这样我得到t'，

101
00:07:54,995 --> 00:08:00,520
T'是消息m串接w的级联输出，

102
00:08:00,520 --> 00:08:04,661
计算t',我就得到我的存在伪造。好

103
00:08:04,661 --> 00:08:08,753
这个大概给你说明了，为什么级联是有漏洞的，这个称为

104
00:08:08,753 --> 00:08:12,945
延展攻击，有消息m的标签，我可以推导出m的延伸消息的标签。

105
00:08:12,945 --> 00:08:16,728
实际上，我可以随我所愿进行延展。所以，本质上，级联函数式

106
00:08:16,728 --> 00:08:20,917
完全不安全的。如果我们不做最后的这一步加密。最后的这一步

107
00:08:20,917 --> 00:08:25,420
加密就是为了防止这种延展攻击的。我可以告诉大家

108
00:08:25,420 --> 00:08:29,349
用这种方法延展攻击时级联方式的唯一攻击

109
00:08:29,349 --> 00:08:33,706
可确定的。但是这里我就不说了。

110
00:08:33,706 --> 00:08:38,091
那接下来的问题是 我们为什么要在ECBC里面构造额外加密块呢

111
00:08:38,091 --> 00:08:42,312
让我再一次向你们说明 没有额外加密块的ECBC是不安全的

112
00:08:42,312 --> 00:08:46,752
我们用简化CBC定义一个映射 也就是说 跟CBC MAC一样

113
00:08:46,752 --> 00:08:51,028
但是没有最后的加密步骤 我们来看 这个MAC依然不安全

114
00:08:51,028 --> 00:08:55,249
除此之外，这是一个比扩展攻击复杂一点的攻击

115
00:08:55,249 --> 00:08:59,360
假设攻击者给定这个值 简化CBC M值为

116
00:08:59,360 --> 00:09:03,592
特定的消息 现在攻击者想要就一些

117
00:09:03,592 --> 00:09:08,692
与w串接的消息m对MAC进行扩展和计算 这是我们的w

118
00:09:08,692 --> 00:09:13,377
而核心攻击者可以得到这个值 然后试图将它们两个异或到一起

119
00:09:13,377 --> 00:09:18,046
但是你会意识到 他必须计算这个函数 此时他并不知道

120
00:09:18,046 --> 00:09:22,814
密钥k是什么 因此 他也无法知道函数的输出是什么

121
00:09:22,814 --> 00:09:27,112
所以 他不能简单地依靠分组w  计算出简化CBC

122
00:09:27,112 --> 00:09:31,763
对n串接w的值 最终他不能计算这个函数

123
00:09:31,763 --> 00:09:36,234
如果使用选择消息攻击 我来告诉你们怎么做

124
00:09:36,234 --> 00:09:40,600
我们说 我们的目标是说明简化CBC是不安全的

125
00:09:40,600 --> 00:09:45,298
我们来看一个典型的攻击 在这个攻击里 对手将从

126
00:09:45,298 --> 00:09:49,810
对一个特殊消息m请求标签开始 这是一个单分组消息

127
00:09:49,810 --> 00:09:54,755
那把CBC应用到一个单分组消息是什么意思呢 事实上

128
00:09:54,755 --> 00:09:59,701
你们所做的仅仅是直接应用这个函数f 所以你们可以得到一个标签

129
00:09:59,701 --> 00:10:04,421
刚好是f直接到单分组消息m的应用 好

130f
00:10:04,421 --> 00:10:09,586
现在对手得到了t的值 我申明他可以定义这个消息为

131
00:10:09,586 --> 00:10:14,487
m' 它包含两个分组 第一个分组是m 第二个

132
00:10:14,487 --> 00:10:19,917
分组是t异或m 我申明他刚得到的t值是对m'的这两个

133
00:10:19,917 --> 00:10:24,726
分组消息的有效标记 我们来看这为什么是正确的

134
00:10:24,726 --> 00:10:29,782
假设我们我们把这个简化CBC构造应用到这个消息m' 如果

135
00:10:29,782 --> 00:10:34,296
你把它直接加进去 它将计算第一个

136
00:10:34,296 --> 00:10:39,213
消息m是直接用函数f进行加密的 然后

137
00:10:39,213 --> 00:10:44,774
我们将结果与第二个分组进行异或 然后我们

138
00:10:44,774 --> 00:10:49,984
把f应用到刚才的结果上 这是简化CBC的定义 那现在

139
00:10:49,984 --> 00:10:55,052
我们对F(k,m)了解多少呢 F(k,m)仅仅是定义中的t值 下一步

140
00:10:55,052 --> 00:11:00,542
我们要做的是t异或t异或m 但是这个t异或t没有作用

141
00:11:00,542 --> 00:11:06,134
我们将得到F(k,m) 也就是t 因此t是这个双分组消息的

142
00:11:06,134 --> 00:11:11,505
一个有效MAC (M, T-XOR-M) 所以对手可以为这个

143
00:11:11,505 --> 00:11:16,553
双分组消息制作一个标签 他不用查询 因此

144
00:11:16,553 --> 00:11:20,195
他就能够成功攻击这个MAC 我们看一下这个ECBC图

145
00:11:20,195 --> 00:11:24,071
我要指出的是 如果你们在MAC的计算中不使用

146
00:11:24,071 --> 00:11:27,806
最后这一步的加密 事实上 这个MAC将因为我们

147
00:11:27,806 --> 00:11:31,728
刚才讲到的攻击而不安全 我要说的是这样会有很多

148
00:11:31,728 --> 00:11:35,323
不正确的结果 事实上甚至有标准 这样做不正确

149
00:11:35,323 --> 00:11:39,012
这就是MAC不安全的原因 你们现在知道要做这个

150
00:11:39,012 --> 00:11:43,080
并且你们自己不会犯这样的错误 我要声明CBC

151
00:11:43,080 --> 00:11:47,817
和NMAC安全定理 这个声明同样对可以应用

152
00:11:47,988 --> 00:11:52,269
这个MAC的任何消息长度有效 事实上对每个PRF对手A

153
00:11:52,269 --> 00:11:56,778
有一个非常高效的对手B 你知道这有点像常用语句

154
00:11:56,778 --> 00:12:01,458
事实上你要知道的是这些错误项在这两种情况下很相似

155
00:12:01,458 --> 00:12:06,139
另外 我要指出的是对CBC的分析其实本质是

156
00:12:06,139 --> 00:12:10,938
f是PRF 即使我们在计算ECBC时不会逆用f

157
00:12:10,938 --> 00:12:16,279
但是如果你假设f是PRF 这个分析会更好 也就是说

158
00:12:16,279 --> 00:12:21,489
它是可逆的 而不仅仅是一个函数 对一个MAC PRF不需要是可逆的

159
00:12:21,489 --> 00:12:26,829
所以这些错误项本质上是说明这些MACs是安全的 就像

160
00:12:26,829 --> 00:12:32,330
密钥不像平方根的X或K消息的平方根那样多用于MAC

161
00:12:32,330 --> 00:12:36,714
所以对AES过程 这是2的64次方 我要给你们一个例子

162
00:12:36,714 --> 00:12:40,937
关于你们怎么运用这些边界 这里我要再一次声明

163
00:12:40,937 --> 00:12:45,321
关于CBC MAC的安全协议 这里的Q是被特定密钥MACed

164
00:12:45,321 --> 00:12:49,598
的消息数量 假设我们要像所有的对手验证

165
00:12:49,598 --> 00:12:53,875
敌手区分一个prf和真正随机函数的优势（可能性）

166
00:12:53,875 --> 00:12:57,781
少于2的32次方分之一 假设这就是我们要做的

167
00:12:57,781 --> 00:13:01,673
根据安全定理 那意味着我们要证明 x绝对值分之q的平方

168
00:13:01,673 --> 00:13:05,515
少于2的32次方分之一 是的 我们希望这一项

169
00:13:05,515 --> 00:13:09,210
我准备忽略这两个以示讲解简略 我们要证明这一项比

170
00:13:09,210 --> 00:13:13,201
2的32次方分之一少 当然 这一项是可以忽略不计的 所以

171
00:13:13,201 --> 00:13:17,914
我们只好忽略它 这就意味着它也比2的32次方分之一少

172
00:13:17,914 --> 00:13:22,683
好 如果我们要证明其优势少于2的32次方分之一

173
00:13:22,683 --> 00:13:27,396
那就是要证明x绝对值分之q的平方少于2的32次方分之一

174
00:13:27,396 --> 00:13:31,881
对AES 这就意味着对2的48次方个消息做MAC后

175
00:13:31,881 --> 00:13:35,970
你必须更换你的密钥 否则的话 你将无法达到安全水平

176
00:13:35,970 --> 00:13:40,412
因此你最多只能MAC2的48次方个消息 你注意到如果我用三重DES

177
00:13:40,412 --> 00:13:44,526
它有很多短分组 仅仅64比特 结果同意告诉你

178
00:13:44,526 --> 00:13:48,592
必须每65000个消息换一次密钥 然而 很麻烦的是

179
00:13:48,592 --> 00:13:52,202
这没有关系 这其实是一个相当巨大对的数目了

180
00:13:52,202 --> 00:13:56,117
对AES来说 你每160亿个消息只换一次密钥

181
00:13:56,117 --> 00:14:00,000
是相当合理的 这就是AES具有比三重DES

182
00:14:00,000 --> 00:14:03,657
大的分组的原因之一 三重DES中的一些模式

183
00:14:03,657 --> 00:14:07,410
依然安全 你不必那样频繁的更换你的密钥

184
00:14:07,410 --> 00:14:12,076
所以我要告诉你们的是 事实上攻击者们在安全理论中

185
00:14:12,076 --> 00:14:16,876
不仅是这样的状态 其实真的存在真实的攻击者

186
00:14:16,876 --> 00:14:21,616
他们对应使用这些值 那这些MAC在你对x的平方根

187
00:14:21,616 --> 00:14:26,474
或者k的平方根个消息签名之后将不再安全 我要

188
00:14:26,474 --> 00:14:30,688
给你讲一个对PRF的攻击 是ECBC或者NMAC 假设

189
00:14:30,688 --> 00:14:35,195
这个下面的函数是个PRP 这其实就像是AES一样的分组加密 我们叫它F big

190
00:14:35,195 --> 00:14:40,053
我们说F big是F ECBC或F NMAC 所以F big是一个大消息的PRF

191
00:14:40,053 --> 00:14:44,293
结果这两种构造都具有以下扩展属性

192
00:14:44,293 --> 00:14:49,859
也就是 如果你给我一个碰撞 向消息x和y

193
00:14:49,859 --> 00:14:54,669
事实上 这也意味着对消息x和y的扩展的碰撞 换句话说

194
00:14:54,669 --> 00:14:59,480
如果我吧w同时附加在x和y上 我将完成一个对结果字的碰撞

195
00:14:59,480 --> 00:15:04,349
所以这相当容易使你自己坚信对扩展属性的持有 你

196
00:15:04,349 --> 00:15:08,925
只是看了这个图表几秒钟就做到了 想象我给你的

197
00:15:08,925 --> 00:15:13,559
两个消息在这一点上发生碰撞 记住我假设f是一个PRP

198
00:15:13,559 --> 00:15:18,018
所以一旦你固定k1 这就是一个1对1函数 如果这两个消息

199
00:15:18,018 --> 00:15:23,023
在输出映射到同一个集合 这意味着它们在简化CBC里

200
00:15:23,023 --> 00:15:27,457
输出也是映射到同一个集合 但是如果它们在raw CBC里

201
00:15:27,457 --> 00:15:32,198
输出也映射到同一个集合 那就意味着如果我添加其他的分组

202
00:15:32,198 --> 00:15:37,584
姑且称之为w 然后我将输出放在这儿，对这两个消息

203
00:15:37,584 --> 00:15:43,162
我计算出了相同的值，也就是说，在这点上，我得到了

204
00:15:43,162 --> 00:15:47,991
相同的值。当我再一次用k1加密时 我也会得到，你知道的，

205
00:15:47,991 --> 00:15:53,501
这儿有多个F，我将得到相同的值，最终的输出，

206
00:15:53,501 --> 00:15:58,123
在我附加了分组w之后 如果对两个不同的消息我能

207
00:15:58,123 --> 00:16:02,741
得到相同的值。如果我同时对两个消息附加了分组w 

208
00:16:02,741 --> 00:16:07,189
我同样会得到相同的输出 我想你能相信对于NMAC来说结果是一样的

209
00:16:07,189 --> 00:16:12,144
这些PRP同时具有扩展属性 基于此

210
00:16:12,144 --> 00:16:17,347
我们可以定义一个攻击 又是一个具有扩展属性的状态

211
00:16:17,347 --> 00:16:22,350
这个攻击工作如下 假设我选择以y的二分之一次方

212
00:16:22,350 --> 00:16:27,567
发布信息的查询 对AES 要记得y的值是{0,1}的128次方

213
00:16:27,567 --> 00:16:33,178
这意味着我要回应2的64次方的信息查询

214
00:16:33,178 --> 00:16:38,142
对在输入空间中任意的消息 会发生的是 我会得到

215
00:16:38,142 --> 00:16:42,975
我会得到2的64次方个MAC消息对 我们来看下一个模块

216
00:16:42,975 --> 00:16:48,126
事实上有一个理论称作生日悖论 你们中有人可能

217
00:16:48,126 --> 00:16:53,150
已经听说过了 它讲的是如果你有2的64次方个随机元素

218
00:16:53,150 --> 00:16:58,046
存在于大小为2的128次方的空间 则其中两个元素相同

219
00:16:58,046 --> 00:17:02,879
的概率会很大 我要找两个不同的消息 分别是Mu和Mv

220
00:17:02,879 --> 00:17:08,120
它们相对应的MAC相同 如我所讲 给予生日悖论

221
00:17:08,120 --> 00:17:14,070
这些很有可能存在 一旦我有了这些 就会发现

222
00:17:14,070 --> 00:17:19,947
Mu和Mv有相同的MAC 因此 我可以根据生日悖论

223
00:17:19,947 --> 00:17:25,810
用w来扩展Mu 为Mu||w索要标签
注明：||符号在这里意味着连接两个数据

224
00:17:25,810 --> 00:17:31,631
但是由于Mu和Mv也有相同的输出 那我可以得到Mu||w

225
00:17:31,631 --> 00:17:37,312
同Mv||w也有相同输出 因此我得到了Mu||w的值

226
00:17:37,312 --> 00:17:42,953
同时也得到了Mv||w的值 因此我得到了

227
00:17:42,953 --> 00:17:47,564
我的伪码 现在t也是Mv||w的一个伪码

228
00:17:47,564 --> 00:17:52,695
这是我之前从来没有要求过的 所以这跟潜在的

229
00:17:52,695 --> 00:17:57,890
伪码一样有效 这是比较严重的攻击 最后一行

230
00:18:00,520 --> 00:18:03,151
事实上是继y的平方根之后的查询 我可以

231
00:18:03,151 --> 00:18:07,605
以相当大的概率打造一个MAC 那y的平方根有什么意义

232
00:18:07,605 --> 00:18:12,055
我们回到安全定理 这意味着对于ECBC后x的平方根

233
00:18:12,055 --> 00:18:16,129
或者NMAC后k的平方根 消息已被MAC MAC变得

234
00:18:16,129 --> 00:18:20,365
不安全 攻击者可以伪造一个新消息的MAC

235
00:18:20,365 --> 00:18:24,707
因此，再一次的，这个聪明的攻击说明

236
00:18:24,707 --> 00:18:29,507
定理的边界是真实的 因此这个例子里面的波动

237
00:18:29,507 --> 00:18:34,688
也是真实的，所以这个例子告诉我们你一定不要用一个密匙去对

238
00:18:34,688 --> 00:18:39,398
超过2的48次方个消息的基于CBC的AES使用MAC。总结来看 我只提我们讲过的

239
00:18:39,398 --> 00:18:44,705
两个例子 来看ECBC和NMAC ECBC是一种常用的MAC

240
00:18:44,705 --> 00:18:49,481
是从AES衍生而来 举个例子 80211t 使用ECBC和AES的完整性

241
00:18:49,481 --> 00:18:54,921
还有一个NIST标准叫做CMAC 我们下一节课会讲

242
00:18:54,921 --> 00:19:00,095
也是基于ECBC的。NMAC在分组加密中

243
00:19:00,095 --> 00:19:05,270
并不常用，主要原因是：对于NMAC的结构，

244
00:19:05,270 --> 00:19:10,766
密匙从一个分组到另一个分组不断更换，这意味着AES

245
00:19:10,766 --> 00:19:15,710
的密匙扩展对于每一个分组都要重新计算， AES在频繁的密匙更换方面

246
00:19:15,710 --> 00:19:20,777
设计的并不好 所以 当你使用NMAC的时候 用分组加密

247
00:19:20,777 --> 00:19:25,446
比对每个分组更改密钥要好一些 因此

248
00:19:25,446 --> 00:19:29,489
NMAC通常不跟AES一起用 不过 其实NMAC是一个

249
00:19:29,489 --> 00:19:33,688
非常流行的MAC的基础 我们称其为HMAC 也会在下节课讲

250
00:19:33,688 --> 00:19:37,835
你会清楚地看到 NAMC下面的HMAC的构造是怎样的

251
00:19:37,835 --> 00:19:41,309
好 这节课就到这里 我们下节课再讲更多的MAC。【END】

