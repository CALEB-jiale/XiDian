1
00:00:00,000 --> 00:00:04,006
本章，我们讨论一个新概念：抗碰撞

2
00:00:04,006 --> 00:00:08,007
这在提供信息完整性中扮演着重要角色

3
00:00:08,007 --> 00:00:11,078
我们的最终目标是描述一个非常流行的MAC算法，叫做HMAC

4
00:00:11,078 --> 00:00:15,090
HMAC在因特网协议中使用很广。HMAC本身是基于抗碰撞的哈希函数构建的

5
00:00:15,090 --> 00:00:20,014
在这之前，我们简要回顾一下。上一章节

6
00:00:20,014 --> 00:00:25,019
我们讨论了信息完整性，我们说MAC系统是安全的

7
00:00:25,019 --> 00:00:30,007
如果它在选择信息攻击下，是不可被存在性伪造的

8
00:00:30,007 --> 00:00:35,025
这意味着即使一个攻击者有了他选择的任意信息的标签，他也无法构建

9
00:00:35,025 --> 00:00:39,064
新的信息标签。然后我们证明了事实上

10
00:00:39,064 --> 00:00:44,076
任何安全PRF都能立即给我们一个安全MAC

11
00:00:44,076 --> 00:00:49,040
我们转而问，能否构建安全PRF，以长信息为输入呢？

12
00:00:49,040 --> 00:00:54,008
我们看了四种MAC机制。第一种是基于CBC的

13
00:00:54,008 --> 00:00:58,079
我们看了它的两种变体，一个叫做加密CBC，一个叫做CMAC

14
00:00:58,079 --> 00:01:04,016
我们说过，它们常与AES一起使用。事实上在802.11i标准里

15
00:01:04,016 --> 00:01:09,034
CBC-MAC被用于信息完整性。特别的，配合AES算法

16
00:01:09,034 --> 00:01:14,045
我们看另一种模式叫做NMAC，也能把处理短输入的PRF

17
00:01:14,045 --> 00:01:19,081
转变成一个能处理很长信息输入的PRF

18
00:01:19,081 --> 00:01:24,047
两个都是串行的MAC。之后我们看可并行的MAC，叫做PMAC

19
00:01:24,047 --> 00:01:29,014
它也可以将处理短输入的PRF，转变成一个能处理很长输入的PRF

20
00:01:29,014 --> 00:01:33,052
但是它可以并行处理，所以一个多处理器的系统

21
00:01:33,052 --> 00:01:37,074
使用PMAC的话比使用CBC-MAC更有效。所有这些构建长信息的MAC

22
00:01:37,074 --> 00:01:42,036
都是基于长信息的PRF的。然后我们看了Carter-Wegman MAC

23
00:01:42,036 --> 00:01:46,063
一个并非基于PRF的MAC。它是一个随机MAC

24
00:01:46,063 --> 00:01:51,025
所以单个信息可以有很多不同的有效标签

25
00:01:51,025 --> 00:01:56,000
所以Carter-Wegman MAC不是PRF。如果大家还记得

26
00:01:56,000 --> 00:02:00,087
首先Carter-Wegman MAC取大量的信息，计算哈希值，得到一个小标签

27
00:02:00,087 --> 00:02:05,061
计算是用了快速的一次性MAC，然后用PRF加密

28
00:02:05,061 --> 00:02:10,009
Carter-Wegman MAC的好处是，我们说过，大量信息的哈希值计算使用了

29
00:02:10,009 --> 00:02:13,085
一个快速的一次性MAC。在本章中，我们将

30
00:02:13,085 --> 00:02:17,052
从抗碰撞这一概念出发，构建MAC

31
00:02:17,052 --> 00:02:21,050
首先我们要构建抗碰撞的哈希函数

32
00:02:21,050 --> 00:02:25,081
我们首先来定义什么是抗碰撞的哈希函数

33
00:02:25,081 --> 00:02:29,086
考虑一个哈希函数，能将某个信息空间映射到一个标签空间T

34
00:02:29,086 --> 00:02:34,017
信息空间应当比标签空间大得多

35
00:02:34,017 --> 00:02:38,055
信息可以是几个G长，但标签只能约160位

36
00:02:38,055 --> 00:02:42,082
函数H的一个碰撞是一对信息（m0,m1）,它们不一样

37
00:02:42,082 --> 00:02:46,097
但是你应用函数H时，你会得到同样的输出

38
00:02:46,097 --> 00:02:51,058
所以大家应当记住，有两个输入

39
00:02:51,058 --> 00:02:56,001
m0和m1，它们同属这个大信息空间。但是

40
00:02:56,001 --> 00:03:00,045
当我们应用这个哈希函数时，它们发生碰撞

41
00:03:00,045 --> 00:03:04,094
同被映射到标签空间中的同一个输出。现在我们说这个函数H是抗碰撞的

42
00:03:04,094 --> 00:03:09,038
如果很难找到这个函数的碰撞

43
00:03:09,038 --> 00:03:13,080
这有点违背直觉，因为我们知道与输入空间相比

44
00:03:13,080 --> 00:03:17,071
输出空间是非常小的。所以根据鸽巢原理，一定有

45
00:03:17,071 --> 00:03:21,060
很多的信息被映射到同样的输出。因为输出空间中

46
00:03:21,060 --> 00:03:25,048
没有足够的空间来不碰撞的容纳所有信息

47
00:03:25,048 --> 00:03:29,025
所以我们知道有很多碰撞，而问题是

48
00:03:29,025 --> 00:03:33,058
有没有一个能直接找出这些碰撞的有效算法

49
00:03:33,058 --> 00:03:38,008
我们说这个函数H是抗碰撞的，如果对所有的有效算法A

50
00:03:38,008 --> 00:03:42,087
这些算法都不能输出函数H的碰撞

51
00:03:42,087 --> 00:03:47,049
通常，我们用算法A能够输出一个碰撞的概率

52
00:03:47,049 --> 00:03:51,048
来定义这个优势。现在我形式化地描述一下

53
00:03:51,048 --> 00:03:55,027
我说，仅仅说这种算法是存在的，还远远不够

54
00:03:55,027 --> 00:03:58,092
输出碰撞的算法。以为我们知道有很多碰撞

55
00:03:58,092 --> 00:04:02,085
我们想要一个直接的算法，可以写下来的算法

56
00:04:02,085 --> 00:04:06,074
并能在计算机上运行，生成碰撞的算法。有一些形式化表述的方法

57
00:04:06,074 --> 00:04:10,074
但我这里不展开说它们。现在一个抗碰撞的哈希函数的例子是SHA-256

58
00:04:10,074 --> 00:04:15,002
SHA-256输出256位，但可以输入任意长的信息

59
00:04:15,002 --> 00:04:19,058
例如，它可以取几个G的数据

60
00:04:19,058 --> 00:04:24,003
并把输入映射到256位字符串。目前还没有人

61
00:04:24,003 --> 00:04:28,026
能为这个函数找出碰撞。这里仅仅是为大家证明

62
00:04:28,026 --> 00:04:32,020
这个碰撞的概念是非常有用的，我们看一个简单应用

63
00:04:32,020 --> 00:04:36,077
特别地，给定一个抗碰撞的哈希函数，我们看如何简单地构建一个MAC

64
00:04:36,077 --> 00:04:41,029
假设我们对短信息有一个MAC

65
00:04:41,029 --> 00:04:46,027
大家应该想到了类似于AES的算法，AES可以计算16字节信息的MAC

66
00:04:46,027 --> 00:04:51,007
假设我们有一个哈希函数，是抗碰撞的，它从一个很大的信息空间里取值

67
00:04:51,007 --> 00:04:55,074
将几个G的信息映射到小的信息空间里

68
00:04:55,074 --> 00:05:00,060
映射到16字节输出。然后我们定义一个新MAC

69
00:05:00,060 --> 00:05:05,027
为长信息的MAC。我们用哈希函数输出值的MAC

70
00:05:05,027 --> 00:05:10,044
来定义它。那如何验证MAC呢？

71
00:05:10,044 --> 00:05:15,067
给定一个标签，我们通过重新计算给定信息的哈希值

72
00:05:15,067 --> 00:05:19,095
来验证，检查小MAC值是否能验证给定的标签

73
00:05:19,095 --> 00:05:24,012
这是一个非常简单的方法，来为大家证明，抗碰撞可以取一个原型

74
00:05:24,012 --> 00:05:28,019
这个原型设置为短输入，把这个原型扩大成一个可以输入非常多位的原型

75
00:05:28,019 --> 00:05:32,021
事实上，我们将看到的并不是MAC所特有的，

76
00:05:32,021 --> 00:05:36,028
一会我们会讨论数字签名时，我们将做同样的证明

77
00:05:36,028 --> 00:05:40,015
我们将建立一个短输入的数字签名机制

78
00:05:40,015 --> 00:05:44,025
然后我们将用抗碰撞来扩大输入空间，并把它扩大成我们想要的大小

79
00:05:44,025 --> 00:05:48,087
所以这个安全性定理的证明并不繁琐

80
00:05:48,087 --> 00:05:53,056
这个定理说明了如果在底层MAC之下是安全的，并且H就是抗碰撞的

81
00:05:53,056 --> 00:05:58,060
那么这个组合可以计算长信息的MAC，并且MAC是安全的

82
00:05:58,060 --> 00:06:03,022
举个简单的例子，我们把这个应用到AES，用一个我们之前说到过的关于SHA-256的例子

83
00:06:03,022 --> 00:06:09,003
在AES-256中，输出256比特，也就是32字节

84
00:06:09,003 --> 00:06:15,022
所以我们需要建立一个可以处理32字节的MAC

85
00:06:15,022 --> 00:06:20,083
我们可以应用16字节的AES

86
00:06:20,083 --> 00:06:26,024
把它带入到一个两个分组的CBC，两个分组的CBC可以把16字节的PRF扩展成32字节的


87
00:06:26,024 --> 00:06:32,000
然后取SHA-256的输出，并带入到

88
00:06:32,000 --> 00:06:37,090
基于AES的这两个分组，然后我们得到一个非常简单的MAC

89
00:06:37,090 --> 00:06:43,036
当AES是个PRF并且SHA-256是抗碰撞的

90
00:06:43,036 --> 00:06:47,078
我想说明的是抗碰撞是这个机制正常工作的必要条件

91
00:06:47,078 --> 00:06:51,097
事实上，抗碰撞比不只是一个人造术语

92
00:06:51,097 --> 00:06:56,067
抗碰撞是这个组合MAC是安全的本质

93
00:06:56,067 --> 00:07:00,081
让我们暂时假设我们正使用的哈希函数H

94
00:07:00,081 --> 00:07:05,000
H不是一个抗碰撞的，换句话说

95
00:07:05,000 --> 00:07:09,031
存在一个算法，可以找到两个不同的信息可以有相同的输出

96
00:07:09,031 --> 00:07:14,007
在这种情况下，组合MAC是不安全的

97
00:07:14,007 --> 00:07:19,009
因为攻击者简单的使用一个人选择信息攻击来获得m0的标签

98
00:07:19,009 --> 00:07:25,074
然后输出m1它的标签是伪造的，确实，T是m1的一个有效MAC

99
00:07:25,074 --> 00:07:30,088
因为H（m1）=H（m0），只需要选择一个信息攻击，

100
00:07:30,088 --> 00:07:35,039
攻击则就可以简单的破解组合MAC

101
00:07:35,039 --> 00:07:39,097
因为哈希函数是非抗碰撞的 。我想强调一下

102
00:07:39,097 --> 00:07:43,083
如果有人宣布哪怕只有一个SHA-256的碰撞

103
00:07:43,083 --> 00:07:48,002
只要有两个信息，只要有一对信息在SHA-256有相同的输出

104
00:07:48,002 --> 00:07:52,010
就会使这个机制不安全

105
00:07:52,010 --> 00:07:56,072
因为攻击者可以访问一个信息的标签，同时他也将获得另一个信息的标签

106
00:07:56,072 --> 00:08:01,017
这将会形成一个存在性伪证

107
00:08:01,017 --> 00:08:05,081
我们已经知道抗碰撞是一个非常有用的原型

108
00:08:05,081 --> 00:08:10,027
它使我们可以扩展密码学原型的输入空间

109
00:08:10,027 --> 00:08:14,097
我要向你们再展示一个应用，在这个应用中抗碰撞被直接的应用于信息的完整性

110
00:08:14,097 --> 00:08:19,079
想象一下，我们有要保护的文件

111
00:08:19,079 --> 00:08:24,066
假设这些文件是软件包，我们想把它们安装在系统里

112
00:08:24,066 --> 00:08:29,024
这里有三个不同的软件包。一个也许是GCC，一个是Emacs

113
00:08:29,024 --> 00:08:33,079
还有一个，我不确定。现在用户想下载软件包

114
00:08:33,079 --> 00:08:38,078
他想要确保他下载的软件包的版本

115
00:08:38,078 --> 00:08:43,051
不是被攻击者篡改过内容的版本

116
00:08:43,051 --> 00:08:48,044
那么用户可以参考一个比较小的只读公共空间

117
00:08:48,044 --> 00:08:53,061
这个公共空间只需要保存这些软件包的哈希值

118
00:08:53,061 --> 00:08:58,078
不需要很多这样的空间，唯一的要求就是这个空间是只读的

119
00:08:58,078 --> 00:09:03,059
换句话说，攻击者不能篡改在这个空间里的哈希函数值

120
00:09:03,059 --> 00:09:08,088
然后一旦用户参考了公共空间，

121
00:09:08,088 --> 00:09:13,094
他就可以非常容易的计算出他下载的包的哈希值，将这个值与公共空间的值相比较

122
00:09:13,094 --> 00:09:18,098
如果这两者相等，则他下载包的版本是正确的

123
00:09:18,098 --> 00:09:23,034
为什么?

124
00:09:23,034 --> 00:09:29,015
因为函数H是抗碰撞的，攻击者找不到F1的路径

125
00:09:29,015 --> 00:09:35,027
可以让它拥有和F1相同的哈希函数

126
00:09:35,027 --> 00:09:40,005
因为攻击者无法在不被监测出来的情况下篡改F1的值

127
00:09:40,005 --> 00:09:45,000
因为没有办法使F1映射成存储在公共空间里的值

128
00:09:45,000 --> 00:09:49,072
我将这个例子的原因是，我想把它和MAC的例子作比较

129
00:09:49,072 --> 00:09:54,062
我们看一个MAC的类似情况，在这个MAC的例子里

130
00:09:54,062 --> 00:09:59,020
我们需要你个密钥来验证单个文件的标签，但我们不需要一个只读的公共空间资源

131
00:09:59,020 --> 00:10:02,072
利用抗碰撞的函数

132
00:10:02,072 --> 00:10:06,090
我们就可以不用一个密钥来验证。任何人都可以验证

133
00:10:06,090 --> 00:10:11,013
你不需要你一个密码要验证，但是，我们突然需要这个额外的资源

134
00:10:11,013 --> 00:10:15,040
这个资源是攻击者无法篡改的空间

135
00:10:15,040 --> 00:10:19,063
事实上，我们稍后将看到数字签名

136
00:10:19,063 --> 00:10:23,076
我们可以在完整性和资源两方面达到最优，并且不需要只读空间

137
00:10:23,076 --> 00:10:27,090
但是，只有MAC或者抗碰撞，我们只能达成单方面的要求

138
00:10:27,090 --> 00:10:32,003
我将告诉大家的是，事实上，这种机制很流行

139
00:10:32,003 --> 00:10:35,080
实际上，Linux发行版通常使用公共空间

140
00:10:35,080 --> 00:10:39,062
来发布软件包的哈希值

141
00:10:39,062 --> 00:10:44,001
在装入电脑之前，任何人可以确保他们下载的软件包的值是正确的

142
00:10:44,001 --> 00:10:48,002
这是在现实中广泛应用的

143
00:10:48,002 --> 00:10:51,018
下一节我们将讨论对抗碰撞的通用攻击

144
00:10:51,018 --> 00:10:53,092
我们还会继续构建抗碰撞哈希函数。【END】

