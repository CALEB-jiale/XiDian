1
00:00:00,000 --> 00:00:03,819
上一节课我们讨论了CBC-MAC和NMAC

2
00:00:03,819 --> 00:00:07,688
但是在那一节里我们总是假定明文长度是分组长度的倍数

3
00:00:07,738 --> 00:00:12,234
在这节里 我们来看看当明文长度不是分组长度的倍数时该怎么做

4
00:00:12,284 --> 00:00:16,817
因此回忆一下 加密CBC-MAC或者简称为ECBC-MAC

5
00:00:16,817 --> 00:00:21,401
使用伪随机置换F来计算CBC函数

6
00:00:21,401 --> 00:00:25,928
这是我们上节讨论的 但是在上节里 我们总是假定

7
00:00:25,928 --> 00:00:30,288
明文本身可以分解成分组密码分组的整数倍

8
00:00:30,288 --> 00:00:34,689
那么问题就是当明文长度不是分组长度的整数倍是我们要怎么做

9
00:00:34,689 --> 00:00:38,919
这里有一个明文信息 它的最后一个分组

10
00:00:38,919 --> 00:00:43,258
比满的分组要短 那么问题就是在这种情况下怎么计算ECBC-MAC

11
00:00:43,258 --> 00:00:47,707
答案就是填充明文 第一个想到的填充方法

12
00:00:47,707 --> 00:00:52,376
就是用全0来填充 换句话说

13
00:00:52,376 --> 00:00:57,045
我们取最后一个分组 填充0直到它的长度等于满分组的长度

14
00:00:57,045 --> 00:01:02,071
那么我给大家的问题是这样产生MAC是否是安全的

15
00:01:02,071 --> 00:01:06,911
答案是否 这个MAC不安全 我来解释下为什么

16
00:01:06,911 --> 00:01:12,324
我们很可能找出一个明文m

17
00:01:12,324 --> 00:01:17,738
明文m联结0之后恰巧有有同样的填充 结果

18
00:01:17,738 --> 00:01:22,833
一旦我们向ECBC-MAC里插入m和m||0 我们就会输出同样的标签 这就意味着


19
00:01:22,833 --> 00:01:27,928
m和m||0有同样的标签 因此攻击者能够

20
00:01:27,928 --> 00:01:33,194
实施一个存在性伪造 他会询问明文m的标签

21
00:01:33,194 --> 00:01:38,344
然后他会输出伪造标签和明文m||0

22
00:01:38,344 --> 00:01:43,432
这是很容易就能明白为什么是这样 更清楚地来说

23
00:01:43,432 --> 00:01:48,272
我们有明文m m在填充之后变成了m000.因此我们必须加三个0

24
00:01:48,272 --> 00:01:53,298
另外我们有明文m||0 以0结尾的m

25
00:01:53,298 --> 00:01:58,324
在填充后 我们必须再加两个0 大家看

26
00:01:58,324 --> 00:02:03,118
它们就有了同样的填充 那么它们也会有同样的标签

27
00:02:03,118 --> 00:02:07,866
这就使得敌手实施存在性伪造攻击 那么这就不是一个好方法

28
00:02:07,866 --> 00:02:12,801
事实上附加全0是一个糟糕的方法 如果大家想想具体的情况

29
00:02:12,801 --> 00:02:17,222
就会有问题 想想自动清扫房间系统

30
00:02:17,222 --> 00:02:21,794
被用来处理支票 我有一张100美元的支票 上面有标签 那么现在

31
00:02:21,794 --> 00:02:25,943
攻击者能在我的支票上附加0 使它变成1000美元的支票

32
00:02:25,943 --> 00:02:30,093
实际上这不会改变标签 这种扩展明文

33
00:02:30,093 --> 00:02:34,294
而不改变标签的能力实际上有非常灾难性的后果

34
00:02:34,294 --> 00:02:38,547
所以我希望这个例子能使大家明白填充函数本身必须是一个一一映射的函数

35
00:02:38,547 --> 00:02:42,904
换句话说 应该是这种情况 两个不同的明文

36
00:02:42,904 --> 00:02:47,157
映射到不同的两个填充的明文 我们不应该在填充函数上有碰撞

37
00:02:47,157 --> 00:02:51,254
或者说 填充函数必须是可逆的

38
00:02:51,254 --> 00:02:55,033
这就保证了填充函数是一一映射的

39
00:02:55,033 --> 00:02:59,945
因此一种标准的实现方法被国际标准化组织ISO提出

40
00:02:59,945 --> 00:03:04,736
他们提议把字符创100000附在明文后面

41
00:03:04,736 --> 00:03:09,587
是明文长度变成分组长度的倍数 现在来看

42
00:03:09,587 --> 00:03:14,439
这个填充就是可逆的 我们要做的就是描述这个可逆算法

43
00:03:14,489 --> 00:03:19,230
就是简单地从右到左扫描明文 直到找到

44
00:03:19,280 --> 00:03:23,778
第一个1 然后移除这个1右面的所有比特

45
00:03:23,828 --> 00:03:27,929
包括这个1 并且你能看到一旦我们按这种方式移除一部分

46
00:03:27,929 --> 00:03:32,355
我们就能得到原始的明文 这有一个例子 我们有一个明文

47
00:03:32,355 --> 00:03:36,726
它的最后一个分组比分组长度短

48
00:03:36,726 --> 00:03:40,878
我们就把1 0 0字符串附加在它后面 很容易就能看出来填充位是什么

49
00:03:40,878 --> 00:03:45,249
从右边看 找到第一个1 我们可以移除这些填充位

50
00:03:45,249 --> 00:03:49,666
然后我们就恢复了原始明文 现在有一种极端情况 实际上挺重要的

51
00:03:49,666 --> 00:03:54,401
那是如果原始明文已经是分组长度的倍数 我们该怎么办

52
00:03:54,401 --> 00:03:59,440
那种情况下 这么做非常非常重要的

53
00:03:59,440 --> 00:04:04,143
加一个假的分组 包括填充1000 我都不知道

54
00:04:04,143 --> 00:04:08,279
有多少产品和标准犯过这种错误

55
00:04:08,279 --> 00:04:12,691
他们没有加一个假分组 结果MAC就不安全了

56
00:04:12,691 --> 00:04:17,159
因为这有一个很简单的存在性伪造攻击 我来给大家说明原因 假定这种情况下

57
00:04:17,159 --> 00:04:21,736
明文长度是分组长度的倍数 我们没有附加假分组

58
00:04:21,736 --> 00:04:26,202
我们计算这个信息的MAC 结果是

59
00:04:26,202 --> 00:04:31,120
如果你看这个信息长度是分组的倍数

60
00:04:31,120 --> 00:04:35,915
还有一个信息的长度不是分组长度的倍数 但它被补齐到分组的大小了

61
00:04:35,915 --> 00:04:40,782
想象一下 这个信息m以100结尾

62
00:04:40,782 --> 00:04:45,321
这里大家发现 这个原信息 我这样画

63
00:04:45,321 --> 00:04:50,133
你发现原信息补齐之后

64
00:04:50,133 --> 00:04:55,028
与第二个没补齐的相同

65
00:04:55,028 --> 00:04:59,806
因此 如果我问这个信息的标签 我也获得了第二个以100结尾的信息的标签

66
00:04:59,806 --> 00:05:04,288
好 如果我们不加假的分组

67
00:05:04,288 --> 00:05:08,594
补齐将不是可逆的 因为两个不同的信息

68
00:05:08,594 --> 00:05:13,135
正好被映射到了相同的补齐结果

69
00:05:13,135 --> 00:05:17,893
这样MAC就不安全了 总结一下 这个ISO标准是完美的补齐方法

70
00:05:17,893 --> 00:05:22,535
但大家要记住也要加假的分组

71
00:05:22,535 --> 00:05:26,749
当信息长度是分组长度的倍数时 现在也许有人想知道

72
00:05:26,749 --> 00:05:30,919
是否有一种补齐方式 从不需要加假的分组

73
00:05:30,919 --> 00:05:35,139
答案是 如果你看确定的补齐函数

74
00:05:35,139 --> 00:05:39,054
容易证明所有情况下我们都需要补齐

75
00:05:39,054 --> 00:05:43,815
原因是长度为分组倍数的信息数

76
00:05:43,815 --> 00:05:48,510
比长度不必是分组倍数的信息数目少得多

77
00:05:48,510 --> 00:05:52,853
因此我们不能获得一个从大的所有信息的集合

78
00:05:52,853 --> 00:05:56,986
到小的分组倍数长的信息集合的一一映射

79
00:05:56,986 --> 00:06:01,013
总会有我们必须扩展原信息的情况

80
00:06:01,013 --> 00:06:05,040
这种情况就对应于加假的补齐分组

81
00:06:05,040 --> 00:06:09,279
但是 有一个非常聪明的方法叫CMAC

82
00:06:09,279 --> 00:06:13,639
可以使用一个随机的补齐函数 不用加假分组了

83
00:06:13,639 --> 00:06:18,353
我来解释一下CMAC如何工作 CMAC使用了三个密钥

84
00:06:18,353 --> 00:06:22,941
事实上这叫做三密钥机制 第一个密钥K

85
00:06:22,941 --> 00:06:27,654
用于CBC计算 标准的CBC-MAC算法 然后密钥k1和k2

86
00:06:27,654 --> 00:06:32,815
仅用于补齐最后一个分组

87
00:06:32,815 --> 00:06:38,479
事实上在CMAC标准中 密钥k1和k2是由密钥k推出的

88
00:06:38,479 --> 00:06:43,834
使用某种伪随机数发生器 CMAC如下工作

89
00:06:43,834 --> 00:06:48,960
如果信息长度正好是分组长度的整数倍 那么我们采用ISO补齐方法

90
00:06:48,960 --> 00:06:54,022
但我们还要把这最后一个分组和密钥k1异或

91
00:06:54,022 --> 00:06:58,560
攻击者不知道k1 但是如果信息长度是分组长度的倍数

92
00:06:58,560 --> 00:07:02,872
那么当然 我们不做扩展 而是与另一密钥k2异或

93
00:07:02,872 --> 00:07:06,692
攻击者也不知道k2

94
00:07:06,692 --> 00:07:11,276
这样做的话 不可能实施对级联函数、原CBC所适用的扩展攻击

95
00:07:11,276 --> 00:07:14,933
因为可怜的攻击者

96
00:07:14,933 --> 00:07:18,971
不知道最后分组运行了哪个函数

97
00:07:18,971 --> 00:07:22,900
他不知道k1 因此他不知道这个点的值

98
00:07:22,900 --> 00:07:27,103
所以他无法实施扩展攻击 事实上

99
00:07:27,103 --> 00:07:32,158
这个命题可以证明 这个机制就是简单地

100
00:07:32,158 --> 00:07:36,441
异或k1或是异或k2 是个PRF 尽管不需要做原CBC函数后面的

101
00:07:36,441 --> 00:07:40,327
最终加密步骤 那么这是一个好处

102
00:07:40,327 --> 00:07:44,768
没有最终加密 那么好处是

103
00:07:44,768 --> 00:07:49,430
我们解决了“是否发生了补齐”所带来的歧义

104
00:07:49,430 --> 00:07:54,149
通过使用两个密钥来区分 “信息长度是分组长度的倍数”

105
00:07:54,149 --> 00:07:58,761
与信息长度不是分组长度的倍数 而我们补齐了这两种情况

106
00:07:58,761 --> 00:08:03,099
两个不同的密钥解决了两种情况之间的歧义

107
00:08:03,099 --> 00:08:06,866
因此这个补齐是充分安全的 所以如我所说

108
00:08:06,866 --> 00:08:11,660
CMAC有一个漂亮的定理告诉我们

109
00:08:11,660 --> 00:08:15,884
CMAC机制是一个伪随机函数 具有与

110
00:08:15,884 --> 00:08:20,438
CBC-MAC相同的安全性 那么我想提醒一下

111
00:08:20,438 --> 00:08:24,864
CMAC是NIST标准化的联邦标准 如果大家最近想用CBC-MAC

112
00:08:24,875 --> 00:08:29,373
还是去用CMAC吧 作为标准方法

113
00:08:29,373 --> 00:08:34,290
特别是在CMAC中 底层函数是AES

114
00:08:34,290 --> 00:08:38,261
可以给我们一个由AES推出的安全的CBC-MAC
本节完结 下节我们讨论

115
00:08:38,261 --> 00:08:39,549
一个并行的MAC机制

