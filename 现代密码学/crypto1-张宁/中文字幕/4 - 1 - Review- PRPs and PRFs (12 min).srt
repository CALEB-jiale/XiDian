1
00:00:00,000 --> 00:00:03,765
既然我们已经知道分组密码是什么、如何构造，接下来

2
00:00:03,765 --> 00:00:07,898
我们了解一下如何将它应用于安全加密,
但在此之前我想简单回顾


3
00:00:07,898 --> 00:00:11,413
一下两个重要的抽象的概念叫做

4
00:00:11,413 --> 00:00:15,949
伪随机函数(PRF)和伪随机排列组合(PRP),
正如我们上节课提到的分组密码流程图

5
00:00:15,949 --> 00:00:20,428
N位比特输入映射到N位比特输出。
以及举了两个DES和AES的例子。

6
00:00:20,598 --> 00:00:24,737
现在我们根据PRP和PRF的这种思想引出了有关

7
00:00:24,737 --> 00:00:28,762
分组密码的一个重要而抽象的概念，记住，


8
00:00:28,762 --> 00:00:33,185
一个伪随机函数PRF实际上
就是一个带有两个输入的函数

9
00:00:33,185 --> 00:00:37,470
即取一个密钥和集合X里的一个元素作为输入，
并输出集合Y中的某个元素，

10
00:00:37,470 --> 00:00:41,390
现在唯一的要求就是
找一个有效的算法评估这个函数。


11
00:00:41,390 --> 00:00:45,118
我们稍后来讨论PRF的安全性

12
00:00:45,118 --> 00:00:49,811
这里有一个与PRF很类似的概念
即伪随机排列组合，

13
00:00:49,811 --> 00:00:54,561
实际上，这就是PRF的有效评估算法。

14
00:00:54,561 --> 00:00:58,739
但是，这里有一个额外的要求，就是

15
00:00:58,739 --> 00:01:02,918
也存在一个算法D用于求函数E的逆，

16
00:01:02,918 --> 00:01:07,562
所以，PRP实际就是PRF，
但是这个函数要求所有密钥必须是一一映射的

17
00:01:07,562 --> 00:01:12,204
这个有效的求逆算法是存在的，
现在让我们来讨论。

18
00:01:12,204 --> 00:01:17,550
如何确定PRF的安全性？
我们已经说过PRF的最终目标

19
00:01:17,550 --> 00:01:23,229
是看上去要像一个从集合X到Y的随机函数，
所以为了更精确地说明它

20
00:01:23,229 --> 00:01:28,508
我们定义这样的概念：
函数集合[X，Y]是从X到Y所有函数组成的一个集合

21
00:01:28,508 --> 00:01:34,054
类似地我们定义SF是一系列从
由PRF定义的从集合X到Y的所有函数，

22
00:01:34,054 --> 00:01:39,458
换句话说，一旦确定密钥K就

23
00:01:39,458 --> 00:01:44,991
可以得到从集合X到Y的一个函数。
在给定了伪随机函数的前提下，

24
00:01:44,991 --> 00:01:50,597
所有这些函数的集合就是集合SF.就像我们

25
00:01:50,597 --> 00:01:56,713
前面说的函数集合[X，Y]实际
就是从X到Y的一个巨大函数集合。

26
00:01:56,713 --> 00:02:02,537
我认为实际上对于AES的规模是2^128的2^128倍，

27
00:02:02,537 --> 00:02:08,215
其中X和Y是2^128比特。显然

28
00:02:08,215 --> 00:02:12,788
这是一个巨大的数字，另一方面，
由AES分组密码定义的函数

29
00:02:12,788 --> 00:02:17,110
个数仅仅只有2^128个。即，
一个函数对应一个密钥。我们想说的是，

30
00:02:17,110 --> 00:02:21,717
从如此庞大的集合中随机选择

31
00:02:21,717 --> 00:02:25,584
与从一个小集合中随机选择几乎不可分辨

32
00:02:25,584 --> 00:02:29,906
我们说的不可分辨意思是

33
00:02:29,906 --> 00:02:34,513
一个攻击者可以和这里的一个随机函数相互作用
而不能分辨是否在进行这种交流。

34
00:02:34,513 --> 00:02:38,949
现在让我们给出准确的证明

35
00:02:38,949 --> 00:02:43,268
通常，我们定义两个实验，

36
00:02:43,268 --> 00:02:47,289
实验0和实验1.我们的目标是让敌手

37
00:02:47,289 --> 00:02:51,254
不能分辨出这两个实验。所以，
在实验0中，挑战者

38
00:02:51,254 --> 00:02:55,219
实际随机选择一个伪随机函数。
明白？也就是说

39
00:02:55,219 --> 00:02:59,798
他已经准备了随机密钥K，
即定义了这个函数f，

40
00:02:59,798 --> 00:03:03,765
这里的f是经PRF实现的函数之一。

41
00:03:03,765 --> 00:03:08,662
另一方面实验1中，挑战者从集合X映射到集合Y
中的函数选择了一个真正随机的函数。

42
00:03:08,662 --> 00:03:13,261
同样，我们把这个真正随机函数称为f

43
00:03:13,261 --> 00:03:17,979
无论是实验0还是实验1中

44
00:03:17,979 --> 00:03:23,142
挑战者以函数f结束的不是选自PRF就是

45
00:03:23,142 --> 00:03:28,447
选自从集合X映射到Y中的随机函数。
现在对手实际开始对这个f函数产生质疑。

46
00:03:28,447 --> 00:03:33,882
所以他开始提交一个质疑数X1
并且得到函数f在X1处的值，

47
00:03:33,882 --> 00:03:39,056
之后提交一个质疑数X2，得到在点X2处f的值。

48
00:03:39,056 --> 00:03:44,351
一遍又一遍之后，他提交了Q个质疑数。
所以他得到了

49
00:03:44,351 --> 00:03:49,477
函数f在这Q个点处的值。现在他的目标是确定

50
00:03:49,477 --> 00:03:54,603
这个函数f是不是从函数集合[X,Y]中选出的真正随机的函数，
或者是从经PRF简化的函数集合中选出的

51
00:03:54,603 --> 00:03:59,603
所以他输出一个确定的比特值b

52
00:03:59,603 --> 00:04:04,602
这个输出是作为实验1或者实验0的输出。

53
00:04:04,602 --> 00:04:09,365
通常我们说PRF是安全的。实际上

54
00:04:09,365 --> 00:04:13,616
前提是对手分辨不出来这两个实验。换句话说

55
00:04:13,616 --> 00:04:17,974
他输出1，0的可能性是相同的，
和他在实验1中输出1的可能性十分相似

56
00:04:17,974 --> 00:04:22,333
换句话说，这两种可能性的区别

57
00:04:22,333 --> 00:04:26,417
是可以忽略的。所以这种定义是好的

58
00:04:26,417 --> 00:04:31,080
事实是对手的确分辨不出出来选自集合[X，Y]的函数是

59
00:04:31,080 --> 00:04:35,682
伪随机还是真正随机函数。
现在，对安全的伪随机组合

60
00:04:35,682 --> 00:04:40,345
的本质和安全分组密码的定义，也是相似的。

61
00:04:40,345 --> 00:04:45,254
在实验0中，对手将改变

62
00:04:45,254 --> 00:04:50,285
PRF的一个随机实例，
所以他选择了一个随机集合K，


63
00:04:50,285 --> 00:04:55,194
并且定义f是在伪随机组合中
与小k一致的一个函数，

64
00:04:55,194 --> 00:05:00,311
在实验1中对手从X到Y中
选了一个不是真正的随机函数，

65
00:05:00,311 --> 00:05:05,694
但是是一个从X到X的真正随机一一映射的函数，明白？
现在我们PRP的目标是

66
00:05:05,694 --> 00:05:10,758
从X到X看起来是一个随机的组合，
即从X到它自身的一个随机的一一映射函数

67
00:05:10,758 --> 00:05:15,247
所以f函数是一个随机函数。

68
00:05:15,247 --> 00:05:19,448
从集合X到它自身，同样，
挑战者以这个f函数结束。

69
00:05:19,448 --> 00:05:23,791
之后对手开始提交一些质疑数，

70
00:05:23,791 --> 00:05:28,124
并且看这些质疑数对应的结果。之后，

71
00:05:28,124 --> 00:05:32,707
他还是不能分辨实验1和实验0。又一次，

72
00:05:32,707 --> 00:05:37,464
给出对手选择的一些线索点处的对应函数f的值，

73
00:05:37,464 --> 00:05:41,873
他依然分辨不出函数f来自PRP还是

74
00:05:41,873 --> 00:05:46,476
是从X到X的一个真正随机组合。
下来让我们看一个简单的例子。

75
00:05:46,476 --> 00:05:50,974
假设集合X仅包含两个点，0和1，
在这个例子中，排列[X]是容易定义的。

76
00:05:50,974 --> 00:05:55,473
实际上，我们能看到的这儿确实有两个点0, 1。

77
00:05:55,473 --> 00:06:00,208
我们会问在集合01中什么是所有的可逆函数的集合

78
00:06:00,208 --> 00:06:04,706
这里只有两个这样的函数，
一个函数是恒等函数，另一个


79
00:06:04,706 --> 00:06:09,264
函数实际是非函数，就是这里的函数。

80
00:06:09,264 --> 00:06:14,028
在01集合中这儿仅有两个可逆函数。所以实际

81
00:06:14,028 --> 00:06:18,557
在这个例子中排列[X]仅包含两个函数，
现在让我们看一下下面的PRP

82
00:06:18,557 --> 00:06:23,448
密文空间为01，当然即X为01，

83
00:06:23,448 --> 00:06:28,348
让我们把PRP定义为X异或K，好的，
这就得到了我们的PRP。而我的问题是，

84
00:06:28,348 --> 00:06:33,488
这是一个安全的PRP吗？换句话说，
这个PRP与排列[X]中的一个随机函数是可分辨的么？

85
00:06:33,488 --> 00:06:39,211
我希望每个人的回答是肯定的。因为实际上

86
00:06:39,211 --> 00:06:45,521
在PRP中实现的函数集合和排列[X]
中的函数集合是完全相同的。

87
00:06:45,521 --> 00:06:50,550
所以这里密钥的随机选择和函数的随机选择是相同的

88
00:06:50,550 --> 00:06:54,675
因此，这两种分配，伪随机或者随机是一样的

89
00:06:54,675 --> 00:06:58,743
所以显然，对手是不可能分辨出这两种分配。

90
00:06:58,743 --> 00:07:03,212
现在我们已经讲了一对例子有关安全PRP的三重DES和AES

91
00:07:03,212 --> 00:07:07,853
现在我想说明的是，如果你想

92
00:07:07,853 --> 00:07:12,322
理解得更具体些，我们还有一个关于AES的具体的安全假设。

93
00:07:12,322 --> 00:07:17,077
举个例子，所有运行时间为2的80次方的算法
对AES的攻击优势的极限是2的-40次方

94
00:07:17,077 --> 00:07:22,295
这是有关AES的一个合理假设

95
00:07:22,295 --> 00:07:26,674
并且我仅想说明它的具体性。
让我们来看另一个例子，


96
00:07:26,674 --> 00:07:31,376
从刚才的问题重新考虑PRP，即XX或者K

97
00:07:31,376 --> 00:07:36,270
记住，集合X仅是1比特，即0和1.

98
00:07:36,270 --> 00:07:40,726
这次我想问，这个PRP是一个安全的PRF吗？换句话说

99
00:07:40,726 --> 00:07:45,411
这个PRP与选自X到X的的随机函数是不可分辨的吗？在这个例子中

100
00:07:45,411 --> 00:07:50,282
从X到X的随机函数集合[X，X]仅包含4个元素

101
00:07:50,282 --> 00:07:54,967
其中有两个是可逆函数，我们之前了解过的，

102
00:07:54,967 --> 00:07:59,589
一个是恒等函数。另一个是反函数

103
00:07:59,589 --> 00:08:04,524
它把1变成0，0变成1。这里还有另外两个函数


104
00:08:04,524 --> 00:08:10,183
即，这个函数把所有的值都给0。这个函数把所有值给1.

105
00:08:10,183 --> 00:08:16,498
这四个函数都属于函数集合【X，X】，
现在的问题是

106
00:08:16,498 --> 00:08:22,507
我们现在看到的这个PRP与从
函数集合[X，X]随机选择的是可分辨的吗

107
00:08:22,507 --> 00:08:27,542
我希望大家都能说出来，
不，它不安全的原因是

108
00:08:27,542 --> 00:08:31,949
这儿有一个很简单攻击，
即，攻击者认为他

109
00:08:31,949 --> 00:08:36,762
可以区别出他是与PRP交流还是在与
从函数集合[X，X]中随机选择的一个函数沟通。

110
00:08:36,762 --> 00:08:41,343
并且这样的分辨是很简单的。

111
00:08:41,343 --> 00:08:45,923
我们将计算函数f在x等于0和等于1时的值，
如果我们得到了矛盾，

112
00:08:45,923 --> 00:08:50,736
换句话说如果f(0)=f(1)，
然后确保我们没有用PRP交流

113
00:08:50,736 --> 00:08:54,907
这种情况我们输出1，也就是说

114
00:08:54,907 --> 00:08:58,967
我们用一个随机函数来进行交流，否则呢输出0

115
00:08:58,967 --> 00:09:03,723
首先让我们看一下这种分辨器的优点。当他用PRP交流时

116
00:09:03,723 --> 00:09:08,087
将永远不会输出1，因为f(0)永远不可能等于f(1)，

117
00:09:08,087 --> 00:09:12,621
即，输出1的可能性是0，但是，当我们用

118
00:09:12,621 --> 00:09:17,324
函数集合[XX]中一个真正随机的函数交流时，

119
00:09:17,324 --> 00:09:21,915
f(0)=f(1)的可能性是1/2。
因为一半的函数满足f(0)=f(1)，


120
00:09:21,915 --> 00:09:26,335
另一半的函数不满足。
所以我们输出1的概率是1/2

121
00:09:26,335 --> 00:09:30,472
所以这种分辨器的优势是1/2，它是不可忽略的

122
00:09:30,472 --> 00:09:35,274
因此PRP不是一个安全的PRF。现在


123
00:09:35,274 --> 00:09:40,226
我们证明出只有当集合X很小的时候它是正确的，

124
00:09:40,226 --> 00:09:44,810
实际上有一个重要的引理叫做
伪随机函数切换引理，

125
00:09:44,810 --> 00:09:49,212
是指当集合X足够大时，
一个安全的PRP实际是一个安全的PRF,

126
00:09:49,212 --> 00:09:53,919
我说的足够大是指AES的输出空间是2^128，所以

127
00:09:53,919 --> 00:09:58,870
通过这个我们马上将详细阐释的引理可知，
如果AES是一个安全的PRP

128
00:09:58,870 --> 00:10:03,883
那么它就是一个安全的PRF。实际这个引理的意思如下

129
00:10:03,883 --> 00:10:10,313
如果我给一个通过集合X的伪随机组合数，
对于任何质疑这个PRP的对手

130
00:10:10,313 --> 00:10:15,857
这个挑战函数至少有Q个质疑点。

131
00:10:15,857 --> 00:10:20,911
与一个随机函数相比，
它攻击PRP的优势与它分辨PRP和

132
00:10:20,911 --> 00:10:25,154
随机组合的优势之间的区别是十分接近的，

133
00:10:25,154 --> 00:10:30,020
实际这种区别是被数量所限制的，

134
00:10:30,020 --> 00:10:34,700
我们已经说X非常大，这个数量Q^2/2X是可忽略的

135
00:10:34,700 --> 00:10:38,876
好，我们的目的达到了。
再次的，当X很大时为2^128

136
00:10:38,876 --> 00:10:43,630
Q将是2^32。这是一个对手制造的
数量级为十亿的质疑数。

137
00:10:43,630 --> 00:10:48,443
这个比值仍然可忽略。在这个例子里

138
00:10:48,443 --> 00:10:52,847
对手的优势是可以分辨随机函数和PRP

139
00:10:52,847 --> 00:10:58,010
这和它能分辨出PRP与随机组合数的优势十分相似

140
00:10:58,010 --> 00:11:02,431
所以，如果E已经是一个安全的PRP

141
00:11:02,431 --> 00:11:08,844
那么它就是一个安全的PRF。
所以对于AES，我们相信它是一个安全的PRP

142
00:11:08,844 --> 00:11:14,517
因此，我们也可以把AES当做一个安全的PRF.

143
00:11:14,517 --> 00:11:16,530
最后总结一下，到现在，你们可能有点忘记了

144
00:11:16,530 --> 00:11:21,312
AES的内部具体工作和三重DES的相关知识。
我们将简单假设它们都是安全的PRP，

145
00:11:21,312 --> 00:11:26,218
之后我们将看到如何应用它们。

146
00:11:26,218 --> 00:11:30,442
但是当我提到PRP或者PRF时，
你们应该立刻能想到，AES或者三重DES。【END】