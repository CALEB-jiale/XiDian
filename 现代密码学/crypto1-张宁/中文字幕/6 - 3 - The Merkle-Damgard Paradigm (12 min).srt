1
00:00:00,000 --> 00:00:03,760
现在我们要看一个非常通用的机制，叫做Merkle-Damgard机制

2
00:00:03,760 --> 00:00:07,668
用于组建抗碰撞的哈希函数

3
00:00:07,668 --> 00:00:11,526
在这之前，让我提醒一下我们的目标

4
00:00:11,526 --> 00:00:15,483
通常情况下，我们说H是个哈希函数，将大的信息空间映射到小的标签空间

5
00:00:15,483 --> 00:00:19,195
我们说哈希函数的一个碰撞是一对不同的信息

6
00:00:19,195 --> 00:00:23,053
它们正好被哈希函数映射到同样的值

7
00:00:23,053 --> 00:00:27,205
我们的目标是构建一个很难找到一个碰撞的抗碰撞的哈希函数

8
00:00:27,205 --> 00:00:30,974
尽管我们知道有很多碰撞存在

9
00:00:30,974 --> 00:00:35,090
没有有效的算法可以输出哪怕一个碰撞。那么我们要构建这些哈希函数

10
00:00:35,090 --> 00:00:38,948
我们分两步构造这些抗碰撞的哈希函数

11
00:00:38,948 --> 00:00:43,064
第一步，就是我们本节要讲的，它将展示如果

12
00:00:43,064 --> 00:00:47,437
你给我一个处理短信息的抗碰撞的哈希函数，我们可以扩展它

13
00:00:47,437 --> 00:00:51,427
来构建一个处理长的多的信息的抗碰撞的哈希函数

14
00:00:51,427 --> 00:00:54,946
在下一节，我们将构建处理短信息的抗碰撞的哈希函数。

15
00:00:54,946 --> 00:00:59,219
那我们来看这个机制

16
00:00:59,219 --> 00:01:02,924
这个机制很通用，事实上，所有的抗碰撞的哈希函数

17
00:01:02,924 --> 00:01:06,891
都遵循这个机制。这是一个非常优雅的机制，让我来告诉你它怎样工作

18
00:01:06,891 --> 00:01:10,545
这里我们有函数H，我们假设它是抗碰撞的哈希函数

19
00:01:10,545 --> 00:01:14,869
可以处理短输入

20
00:01:14,869 --> 00:01:19,565
我们使用这个小函数h，h有时叫做压缩函数

21
00:01:19,565 --> 00:01:24,319
我们将取长信息M，把它分成若干组

22
00:01:24,319 --> 00:01:28,991
然后我们使用一个固定值叫做Ⅳ。这里Ⅳ永远是固定的

23
00:01:28,991 --> 00:01:33,496
它内嵌在代码和标准里，只是一个固定的ID

24
00:01:33,496 --> 00:01:37,788
是函数的一部分。然后我们对第一个信息分组应用

25
00:01:37,788 --> 00:01:41,709
小的压缩函数H，一并使用这个ID

26
00:01:41,709 --> 00:01:45,948
得到的叫做链接变量，将被交给下一压缩函数

27
00:01:45,948 --> 00:01:50,028
来压缩下一个分组，一并使用前一个链接变量

28
00:01:50,028 --> 00:01:54,320
输出下一个链接变量

29
00:01:54,320 --> 00:01:58,772
然后下个信息分组被压缩，等等，直到我们到达最后分组

30
00:01:58,772 --> 00:02:03,087
在最后分组上，我们要做一个特别的事情

31
00:02:03,087 --> 00:02:07,246
就是我们必须将这个补齐分组PB附在信息后面

32
00:02:07,246 --> 00:02:11,567
我们稍后解释这个这个补齐分组。但在我附上补齐分组之后

33
00:02:11,567 --> 00:02:16,104
我们还是要压缩最后的链接变量与最后的分组

34
00:02:16,104 --> 00:02:20,124
得到的输出就是实际哈希函数的输出

35
00:02:20,124 --> 00:02:25,232
总结一下，用符号表示，我们用这个压缩函数在T中取元素

36
00:02:25,232 --> 00:02:29,468
这与哈希函数正好相反

37
00:02:29,468 --> 00:02:34,169
加上信息分组，这个X对应信息分组，输出下一链接变量

38
00:02:34,169 --> 00:02:38,982
如我所说，这就是压缩函数的工作。然后根据这个压缩函数

39
00:02:38,982 --> 00:02:43,625
我们可以构建一个长输入的哈希函数

40
00:02:43,625 --> 00:02:48,099
输入是空间X的L次方，表示至多L^X的分组。当然这些长度可变

41
00:02:48,099 --> 00:02:52,686
这样我们可以有不同的信息长度

42
00:02:52,686 --> 00:02:57,193
它们给函数h输入，得到的是标签空间中的标签

43
00:02:57,193 --> 00:03:01,456
唯一剩下的需要定义的是补齐分组

44
00:03:01,456 --> 00:03:05,719
补齐分组非常重要，我们接下来会看到

45
00:03:05,719 --> 00:03:10,089
这是序列1000，为实际明文分组的结尾

46
00:03:10,089 --> 00:03:14,460
这个分组最重要的部分是我们对信息长度进行的编码

47
00:03:14,460 --> 00:03:18,879
在这个补齐分组里。信息长度域固定为64位

48
00:03:18,879 --> 00:03:23,186
所以在所有的SHA哈希函数中

49
00:03:23,186 --> 00:03:27,828
最大的信息长度为2^64-1

50
00:03:27,828 --> 00:03:32,247
事实上信息长度应当适应于64位分组。2^64-1位的信息长度的上界

51
00:03:32,247 --> 00:03:36,778
对应我们能释放的信息来说足够长了

52
00:03:36,778 --> 00:03:41,071
好，这是补齐分组

53
00:03:41,071 --> 00:03:45,130
当然，那么问题来了，如果最后一个分组

54
00:03:45,130 --> 00:03:49,190
是压缩函数分组长度的倍数，我们该怎么办？我们该如何补齐分组？

55
00:03:49,190 --> 00:03:53,380
通常，答案是如果在最后分组中没有空间

56
00:03:53,380 --> 00:03:58,003
留给补齐分组时，那么我们就必须加另外一个假分组

57
00:03:58,003 --> 00:04:02,561
把补齐分组放在那里。当然以正确的方式写1000

58
00:04:02,561 --> 00:04:07,062
有一点非常重要，那就是

59
00:04:07,062 --> 00:04:11,507
补齐分组包含信息长度，我们待会将会看到

60
00:04:11,676 --> 00:04:16,065
那么这就是Merkle-Damgard机制，最后一点技术内容

61
00:04:16,065 --> 00:04:20,285
是我们有这些链接变量。那么HO是初始值，H1，H2，H3直到H4

62
00:04:20,285 --> 00:04:24,881
H4是哈希函数的最终输出。如我所说

63
00:04:24,881 --> 00:04:29,443
所有的标准哈希函数都遵循着这个机制，由一个压缩函数构建抗碰撞的哈希函数

64
00:04:29,443 --> 00:04:33,966
这个机制如此流行的原因是

65
00:04:33,966 --> 00:04:37,673
因为下面这个定理告诉我们

66
00:04:37,673 --> 00:04:41,373
如果小的压缩函数是抗碰撞的

67
00:04:41,380 --> 00:04:45,493
那么大的 Merkle-Damgard哈希函数也是抗碰撞的

68
00:04:45,493 --> 00:04:49,607
换句话说，如果我们要为长输入构建抗碰撞的哈希函数

69
00:04:49,607 --> 00:04:53,771
我们只需构建一个抗碰撞的压缩函数。那么我们来证明这个定理

70
00:04:53,771 --> 00:04:57,732
这个证明很优雅，且不难，我们证明它的逆否命题

71
00:04:57,732 --> 00:05:01,794
也就是，如果你能找到这个大哈希函数的一个碰撞

72
00:05:01,794 --> 00:05:06,107
那么我们我们可以推出这个小压缩函数的一个碰撞

73
00:05:06,107 --> 00:05:10,460
因此，如果h是抗碰撞的，那么H也是

74
00:05:10,460 --> 00:05:15,085
假设给我一个大压缩函数的碰撞，即两个不同的信息M和M'

75
00:05:15,085 --> 00:05:19,492
它们正好被哈希到同一个输出，我们将使用M和M'

76
00:05:19,492 --> 00:05:23,854
来构建这个小压缩函数的一个碰撞

77
00:05:23,854 --> 00:05:28,645
首先我们必须记住 Merkle-Damgard机制的过程

78
00:05:28,645 --> 00:05:33,872
特别的，当我们哈希M和M'，给链接变量起一些名字

79
00:05:33,872 --> 00:05:38,787
当我们计算信息M的哈希值时，会得到这些链接变量

80
00:05:38,787 --> 00:05:43,952
那么H0是固定的Ⅳ，开启整个过程，H1是用Ⅳ计算第一个分组的哈希结果，等等

81
00:05:43,952 --> 00:05:48,932
直到H_t+1是最后一个链接变量

82
00:05:48,932 --> 00:05:53,945
也是Merkle-Damgard链的最后输出

83
00:05:53,945 --> 00:05:59,401
类似的对于M',定义H0'为第一个链接变量

84
00:05:59,401 --> 00:06:04,668
H1'是第一个分组M'的压缩结果，等等……

85
00:06:04,668 --> 00:06:09,997
直到我们获得H'_r+1,，即信息M'的最后哈希值

86
00:06:09,997 --> 00:06:14,820
现在大家注意信息M和M'的长度

87
00:06:14,820 --> 00:06:20,654
不一定是一样的。特别的，M的长度为t，M'的长度为r

88
00:06:20,654 --> 00:06:24,876
由于发生了碰撞，我们知道这两个值是相等的

89
00:06:24,876 --> 00:06:29,067
H（M）是等于H(M').换句话说，最后的链接变量是

90
00:06:29,067 --> 00:06:33,416
是等于另一个的。现在让我们仔细观察

91
00:06:33,416 --> 00:06:37,389
H t+1和H' r+1是怎样算出来的

92
00:06:37,389 --> 00:06:41,780
H t+1 是由压缩函数应用到之前的的链接变量和最后分组得到的M得到的

93
00:06:41,780 --> 00:06:46,002
包括补白区块。大家注意

94
00:06:46,002 --> 00:06:50,618
这里假设补白区块符合最后的分组M，即使

95
00:06:50,618 --> 00:06:55,121
最后补白区块在它自己的分组，也没有任何区别

96
00:06:55,121 --> 00:06:59,512
为了简便，我们假设补白区块在最后的分组M中，

97
00:06:59,512 --> 00:07:03,960
因此，通过计算放着补白区块的最后分组的和最后一个链接变量的哈希

98
00:07:03,960 --> 00:07:08,547
我们得到了H t+1，同样的，我们对M'进行同样的计算

99
00:07:08,547 --> 00:07:12,922
通过计算最后的信息分组和最后的链接变量的哈希

100
00:07:12,922 --> 00:07:17,350
我们得到了H’r+1，我们知道，只要这两个变量是相等的

101
00:07:17,350 --> 00:07:21,778
我么就有了一个候选的压缩函数的碰撞

102
00:07:21,778 --> 00:07:26,099
这里，我们圈出这个候选的碰撞，这是它的一部分，这是它的另一部分

103
00:07:26,099 --> 00:07:30,072
由于在这两个参数间有一个等式

104
00:07:30,072 --> 00:07:34,405
把这两个参数给压缩函数，正好产生的相同的值

105
00:07:34,405 --> 00:07:38,853
我们不获得任何一个碰撞的唯一方法是,这两个参数相等

106
00:07:38,853 --> 00:07:43,533
换句话说，这里我们注意到，如果这两个参数不同

107
00:07:43,533 --> 00:07:47,750
那么我们就得到了h的一个碰撞，我们写的更精确一些

108
00:07:47,750 --> 00:07:55,220
如果Ht不等于H'r或者Mt不等于M'r

109
00:07:55,220 --> 00:08:02,784
或者补白区块不同，我们就会得到压缩函数h的一个碰撞

110
00:08:02,784 --> 00:08:08,415
这样的们就完成了，就可以结束了。我们还要继续做的情况是

111
00:08:08,415 --> 00:08:12,653
如果这三个‘或’条件不成立，三个‘或’条件不成立是什么意思呢？

112
00:08:12,653 --> 00:08:16,998
我们需要继续工作的唯一情形是，当最后一个变量和倒数第二个变量相等

113
00:08:16,998 --> 00:08:21,183
两个信息的最后分组也相同

114
00:08:21,183 --> 00:08:25,605
并且，两个补白区块也相同，两个补白区块相等是什么意思呢？

115
00:08:25,605 --> 00:08:29,961
还记得被编码在补白区块的信息长度吧

116
00:08:29,961 --> 00:08:34,371
特别的，这意味着M的长度等于M'的长度

117
00:08:34,371 --> 00:08:38,782
也就是说t是等于r的。所以现在我可以假设t=r。

118
00:08:38,782 --> 00:08:43,972
我写r时就等同于我写t。但是现在我们可以对倒数第二个变量应用相同的参数

119
00:08:43,972 --> 00:08:48,773
换句话说，H是怎么计算的？

120
00:08:48,773 --> 00:08:53,703
Ht 是通过前一个链接变量Ht-1和倒数第二个的信息分组的哈希计算得来的

121
00:08:53,703 --> 00:08:58,929
相似的，我们可以得到H't

122
00:08:58,929 --> 00:09:05,128
注意到我用r代替了t，所以H't是通过通过前一个的链接变量和

123
00:09:05,128 --> 00:09:10,804
M' 的倒数第二个的信息分组的哈希得到的

124
00:09:10,804 --> 00:09:16,704
由于这两者相同，所以我们得到了另一个候选的压缩函数的碰撞

125
00:09:16,704 --> 00:09:23,030
换句话说，如果Ht+1不等于Ht-1，或者Mt-1不等于M't-1

126
00:09:23,030 --> 00:09:29,985
那我们就有了一个h的碰撞，那么我们就可以结束了

127
00:09:29,985 --> 00:09:36,710
现在，我们唯一需要继续的情况是这个条件不存在

128
00:09:36,710 --> 00:09:44,464
也就是说，假设Ht-1等于H't-1

129
00:09:44,464 --> 00:09:50,600
我们已经知道，Mt 等于M't 

130
00:09:50,600 --> 00:09:56,060
并且Mt-1等于M't-1。假设这两个条件都成立

131
00:09:56,270 --> 00:10:02,010
这里你可以看到，我们可以继续迭代了

132
00:10:02,010 --> 00:10:07,750
换句话说，我们可以给Ht-1和H't-1使用相同的参数

133
00:10:07,750 --> 00:10:12,566
然后依次迭代，我们就可以迭代出

134
00:10:12,566 --> 00:10:17,450
信息的开始。迭代到信息的开始，下面两者之一一定成立：

135
00:10:17,450 --> 00:10:22,252
我们找不到任何一个压缩函数的碰撞或者

136
00:10:25,257 --> 00:10:28,262
所有的信息M和M’的所有信息分组都相等

137
00:10:28,262 --> 00:10:34,089
换句话说，对于所有的i，Mi =M'i。这意味着

138
00:10:34,089 --> 00:10:39,941
由于我们已经证明过这些信息是一样长的，所以M=M’的

139
00:10:39,941 --> 00:10:44,469
然而，是和这与你给我的是个碰撞的前提矛盾

140
00:10:44,469 --> 00:10:48,849
换句话说，由于有矛盾，故这不可能发生

141
00:10:48,849 --> 00:10:53,342
因为它与M和M'是这个大Merkle-Damgard函数H相碰撞这个事实矛盾


142
00:10:53,342 --> 00:10:58,059
因此，我们必须为这个压缩函数找一碰撞

143
00:10:58,059 --> 00:11:02,664
既然这样，让我们从信息的最后开始工作

144
00:11:02,664 --> 00:11:07,269
一直算到信息的开始，在某处我们一定可以找到h的碰撞

145
00:11:07,269 --> 00:11:11,492
这基本就完成了我们的证明

146
00:11:11,492 --> 00:11:15,738
我可以在这里写个‘证明完毕’，这就是证明

147
00:11:15,738 --> 00:11:19,553
如果压缩函数h是抗碰撞的，那么大Merkle-Damgard函数H

148
00:11:19,553 --> 00:11:24,013
必须也是抗碰撞的。所以，人们喜欢这个机制的原因是

149
00:11:24,013 --> 00:11:28,366
这个定理展示了如何构建大的哈希函数

150
00:11:28,366 --> 00:11:32,611
只要能构建短输入的压缩就足够了

151
00:11:32,611 --> 00:11:34,439
下面我们进入下一章节

152
00:11:32,611 --> 00:11:34,439
gonna do that in the next segment.

