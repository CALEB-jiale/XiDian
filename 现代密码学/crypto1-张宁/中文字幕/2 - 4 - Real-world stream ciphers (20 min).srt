1
00:00:00,000 --> 00:00:04,010
在这一部分，我想举几个实践中用到的流密码的例子。

2
00:00:04,010 --> 00:00:07,072
我打算以两个过时的流密码例子开头，
实际上它们已经不

3
00:00:07,072 --> 00:00:11,017
应该被用在新的系统中。
但是尽管如此，他们仍然相当

4
00:00:11,017 --> 00:00:14,164
广泛地被使用着，所以我只想提及它们的名字
以便于你们能熟悉这些概念

5
00:00:14,164 --> 00:00:19,087
我想说的第一个流密码是于1987年被设计出来的被称为RC4，

6
00:00:19,087 --> 00:00:23,429
我只打算做一个高阶的描述

7
00:00:23,429 --> 00:00:27,818
然后我们将会谈论RC4的一些缺点，
仅此而已。

8
00:00:27,818 --> 00:00:32,702
RC4采用一个大小可变的种子，在这里
我只举一个采用128比特的种子作为例子

9
00:00:32,702 --> 00:00:36,980
这个种子会被用作流密码的密钥。

10
00:00:36,980 --> 00:00:41,738
首先，CR4流密码先将128比特的密码扩展为2048比特，

11
00:00:41,738 --> 00:00:46,382
并将被扩展后的密码将作为生成器的内部状态。

12
00:00:46,382 --> 00:00:51,197
然后一旦它完成了扩展
基本上就开始执行一个非常简单的循环

13
00:00:51,197 --> 00:00:55,898
每次循环输出一个字节。
所以，本质上你可以在任何时候

14
00:00:55,898 --> 00:01:00,653
运行生成器,每次运行输出一个字节。
现在RC4确实是像我说的那样相当流行。

15
00:01:00,653 --> 00:01:05,205
实际上它经常被用在HTTPS协议上。

16
00:01:05,205 --> 00:01:11,888
例如，如今的谷歌在它的HTTPS协议上就使用了RC4,

17
00:01:11,888 --> 00:01:15,686
就像我们在上一部分谈论的那样,
它也被应用在WEP上,被错误和

18
00:01:15,686 --> 00:01:18,861
以不安全的方式在WEP的内部使用。
所以这些年来，

19
00:01:18,861 --> 00:01:23,886
RC4的一些缺点已经被人们发现.于是,在新的工程中并不建议使用RC4

20
00:01:23,886 --> 00:01:28,793
而是使用一种更加现代化的伪随机密码产生器,
就像我们将要

21
00:01:28,793 --> 00:01:34,059
在最后一部分讨论的那样。
所以我在此就提一下它的两个缺点，

22
00:01:34,059 --> 00:01:39,561
第一个缺点，也是有点奇怪的，
如果你注意到RC4输出的

23
00:01:39,561 --> 00:01:44,630
第二个字节，就会发现它是有轻微偏差的。

24
00:01:44,630 --> 00:01:49,780
如果RC4是完全随机的，
第二个字节碰巧等于零的概率

25
00:01:49,780 --> 00:01:54,744
将正好是1/256。一共有256种可能的字节，

26
00:01:54,744 --> 00:01:59,646
它是零的可能性应该是1/256。
然而对于RC4而言，概率恰恰是2/256

27
00:01:59,646 --> 00:02:04,486
那就意味着，
如果你使用RC4的输出来加密一个消息,

28
00:02:04,486 --> 00:02:09,574
它的第二个字节可能根本不会被加密。
换句话说

29
00:02:09,574 --> 00:02:14,575
它与0异或的概率将会是原本概率的两倍

30
00:02:14,575 --> 00:02:19,436
所以是2/256，而不是1/256。
顺便说一下，应该说

31
00:02:19,436 --> 00:02:22,849
第二个字节并没有什么特别之处。
这就使得第一和第三个字节

32
00:02:22,849 --> 00:02:27,818
也产生了偏差。实际上,
如果你打算使用RC4，更为推荐的做法是

33
00:02:27,818 --> 00:02:32,800
你应该忽视第一组的256字节的输出，而直接

34
00:02:32,800 --> 00:02:37,246
从第257个字节开始使用产生器的输出。

35
00:02:37,246 --> 00:02:41,241
前几个字节是有偏差的,
而你只需要忽略它们。第二种攻击是

36
00:02:41,241 --> 00:02:48,482
如果你考虑一个非常长的RC4的输出，

37
00:02:48,482 --> 00:02:53,863
而它正好可能会得到一个‘00’序列。
换句话说，

38
00:02:53,863 --> 00:02:58,970
你更可能会得到16比特,即两个字节的'00',
这比你本应得到的要多。再说，如果RC4

39
00:02:58,970 --> 00:03:03,948
得到0的概率是完全随机的，
则得到00的概率将正好是1/256的平方

40
00:03:03,948 --> 00:03:08,556
因此使得RC4有一点偏差,
而偏离率是1/256^3。

41
00:03:08,556 --> 00:03:13,718
事实证明这种偏离实际上是在RC4
生成几千兆字节的数据之后开始的。

42
00:03:13,718 --> 00:03:18,634
无论怎么说，这是可以用来预测产生器的

43
00:03:18,634 --> 00:03:23,120
更可以被用来
从一个真正随机的序列中辨别产生器的输出

44
00:03:23,120 --> 00:03:28,097
基本上，有更多的“00”出现

45
00:03:28,097 --> 00:03:32,414
是区分二者的关键。
在前面最近一部分，我们讨论了

46
00:03:32,414 --> 00:03:36,313
被用来攻击WEP的相关密钥攻击，
基本上是说

47
00:03:36,313 --> 00:03:41,078
如果一个人使用的密钥与另一个人
使用的密钥是彼此密切相关的话，

48
00:03:41,078 --> 00:03:45,732
那么就很可能还原出原始密钥。
所以这些都是已知的RC4的弱点。所以最后的结论是

49
00:03:45,732 --> 00:03:50,217
新的系统并不建议使用RC4，
而是使用一种现代化的伪随机序列生成器。

50
00:03:50,217 --> 00:03:54,421
好了，我想举的第二个例子是一个

51
00:03:54,421 --> 00:03:59,131
被用于加密DVD电影，
已经被严重破解的流密码

52
00:03:59,131 --> 00:04:03,504
当你在商店里买一部DVD，
真正的电影内容被一种称为CSS的流密码加密了。

53
00:04:03,504 --> 00:04:07,933
CSS被证明是一种已经被严重破解的流密码

54
00:04:07,933 --> 00:04:12,523
我们能够很轻易地破解它，
并且我想向你们展示一下这个攻击算法是怎么

55
00:04:12,523 --> 00:04:16,894
工作的。我们自己做一遍
所以你们可以看到个算法攻击的例子

56
00:04:16,894 --> 00:04:21,435
而事实上，有很多系统基本上
都使用这种攻击方式来解密

57
00:04:21,435 --> 00:04:25,749
被加密的DVD。CSS流密码是在基于一些

58
00:04:25,749 --> 00:04:30,291
硬件设施的基础上设计的。
它被设计成一种硬件流密码，这种流密码是

59
00:04:30,291 --> 00:04:34,491
容易在硬件中实现的和基于
LFSR(线性反馈移位寄存器)

60
00:04:34,491 --> 00:04:38,749
所以一个LFSR基本上就是一个

61
00:04:38,749 --> 00:04:43,801
由一些单元小格组成的，
每个小格储存一个比特的寄存器。

62
00:04:43,801 --> 00:04:49,046
然后有一些接口与这些单元小格连接，
并不是所有的小格都被接口连接

63
00:04:49,046 --> 00:04:54,134
这些特定的位置被称为接口。
然后这些接口被输入到一个异或门，

64
00:04:54,134 --> 00:04:59,053
然后在每一个时钟周期内，
移位寄存器就会进行一次右移，
最后一位被去掉。

65
00:04:59,053 --> 00:05:04,345
第一位就成了异或门的输出。
所以你可以看到

66
00:05:04,345 --> 00:05:08,703
这是一个很容易实现的机制，
在硬件上只需要很少的

67
00:05:08,703 --> 00:05:13,622
晶体管就能实现。只要向右移,
最后一个比特被移出,先前的

68
00:05:13,622 --> 00:05:18,541
异或的结果就成为了第一比特位。
所以这个LFSR的种子

69
00:05:18,541 --> 00:05:23,460
就是LFSR的最初的状态。

70
00:05:23,650 --> 00:05:28,538
这是许多流密码的基础来源。
这里有一些例子。所以，

71
00:05:28,538 --> 00:05:33,362
正如我说的那样，DVD加密运用了两次LFSR。
我将快速给你们展示那是怎样工作的。

72
00:05:33,362 --> 00:05:38,060
GSM加密采用的算法被称为A51和A52，

73
00:05:38,060 --> 00:05:43,456
它使用三次LFSRs，还有蓝牙加密算法--E0，

74
00:05:43,456 --> 00:05:48,534
这些都是流密码，而且使用四次LFSRs。
结果这些算法都被完全破解了

75
00:05:48,534 --> 00:05:53,245
在实际加密通信中并不可信，但是他们都是

76
00:05:53,245 --> 00:05:56,705
在硬件上实现的,
所以现在要改变硬件的工作机制是有难度的。

77
00:05:56,705 --> 00:06:01,047
但是这里面最简单的是：
针对CSS，实际上有一个聪明的攻击方法，让

78
00:06:01,047 --> 00:06:05,459
我给你们展示这个攻击是怎么运作的。
让我们让我们描述CSS实际上是如何运作的。

79
00:06:05,459 --> 00:06:11,073
CSS的密钥是五个字节,
即40比特位,5乘8等于40位

80
00:06:11,073 --> 00:06:15,587
它们被限制为40位的原因是DVD加密方式是被设计

81
00:06:15,587 --> 00:06:19,941
在美国出口条例只允许出口

82
00:06:19,941 --> 00:06:25,086
40位加密算法的密钥的时期。
因此，CSS的设计者

83
00:06:25,086 --> 00:06:30,206
将密钥限制的很短,很短,只有40位。
因此,它们的设计如下，

84
00:06:30,206 --> 00:06:35,398
大体上,CSS用两个LFSR。
一个是17位的LFSR,换句话说，

85
00:06:35,398 --> 00:06:40,806
寄存器容量是17比特。
另一个是25位的LSFR，

86
00:06:40,806 --> 00:06:46,647
25位的LFSR要更大一点。
这些LSFR被植入的方式如下

87
00:06:46,647 --> 00:06:51,870
用于加密的密钥，基本上看上去是这样的

88
00:06:51,870 --> 00:06:57,669
以1作为开头，
把它与密钥的前两个字节连接。

89
00:06:57,669 --> 00:07:02,947
这就是这个LFSR的初始状态。

90
00:07:02,947 --> 00:07:08,256
然后，第二个LFSR基本上是同样的方式初始化。

91
00:07:08,256 --> 00:07:14,012
一个寄存器连接最后的三个字节

92
00:07:14,012 --> 00:07:19,889
并被装载进了LFSR的最初状态。
你可以看到前两个字节

93
00:07:19,889 --> 00:07:25,411
即16位，加上开头的1位,
一共17比特位。同时第二个LFSR

94
00:07:25,411 --> 00:07:31,217
是24位再加一个是25位。
你可以注意到我们使用了密钥的全部五位。

95
00:07:31,217 --> 00:07:36,881
因此，这些LFSR基本上运行8个循环，它们产生

96
00:07:36,881 --> 00:07:42,333
8比特的输出。然后，它们经过加法器做

97
00:07:42,333 --> 00:07:48,197
模256的加法运算。
因此这是一个模256的加法计算器。

98
00:07:48,197 --> 00:07:54,325
这里还有一点是，
加法要考虑前面分组的进位，

99
00:07:54,325 --> 00:07:59,723
不过这不是那么重要，
它只是一个不怎么相关的细节。

100
00:07:59,723 --> 00:08:04,761
对于每一个分组，
我们需要注意做模256加法运算时

101
00:08:04,761 --> 00:08:09,982
忽略了进位，进位是以0或1

102
00:08:09,982 --> 00:08:15,147
进入到下一分组。并且每次循环将输出一个字节。

103
00:08:15,147 --> 00:08:20,411
当然,这个字节同电影里的字节进行异或加密。

104
00:08:20,411 --> 00:08:25,167
它是一个非常简单的流密码，

105
00:08:25,167 --> 00:08:29,986
只需要很少硬件来实现的。
它运行地非常快，

106
00:08:29,986 --> 00:08:35,830
甚至在非常低廉的硬件上也能够快速加密电影
因此导致只需要2的17次方次的尝试就可以将其破解

107
00:08:35,830 --> 00:08:41,222
现在让我来给你们演示一下怎么做的。

108
00:08:41,222 --> 00:08:45,734
现在假设你截获了一部电影，

109
00:08:45,734 --> 00:08:50,647
这里有你想要破解的加密电影。
我们假设电影全都被加密了

110
00:08:50,647 --> 00:08:55,279
你不知道里面是什么。
然而，碰巧由于

111
00:08:55,279 --> 00:08:59,970
DVD加密是用MPEG文件，
如果你碰巧知道明文的前缀，

112
00:08:59,970 --> 00:09:04,250
我们假设它是20个字节的。那么我们知道如果你

113
00:09:04,250 --> 00:09:08,589
对这两个进行异或，换句话说，你在这进行了异或

114
00:09:08,589 --> 00:09:13,523
你将会得到PRG的最初的部分。
因此，你将会得到

115
00:09:13,523 --> 00:09:18,472
CSS输出的前20个字节也就是PRG的输出。

116
00:09:18,472 --> 00:09:23,986
我们有了20个字节的输出，
那么接下来要做的就是

117
00:09:23,986 --> 00:09:31,405
尝试2的17次方个全部可能第一个LFSR的值。

118
00:09:31,405 --> 00:09:37,088
因此，对于2的17次方种可能的

119
00:09:37,088 --> 00:09:42,622
LFSR寄存器的初始值，我们将运行

120
00:09:42,622 --> 00:09:47,953
这些LFSR来产生20个字节。
因此我们将从假设的2的17次方个可能的初始设置中

121
00:09:47,953 --> 00:09:53,284
生成第一个LFSR的20个字节

122
00:09:53,284 --> 00:09:58,615
现在，记得我们有全部的CSS输出系统。
现在我们可以做的是

123
00:09:58,615 --> 00:10:03,814
我们可以把得到的输出减去
从第一个LFSR产生的20个字节。

124
00:10:03,814 --> 00:10:08,928
事实上，如果我们对初始状态的猜测是正确的，

125
00:10:08,928 --> 00:10:14,042
我们将得到的是第二个LFSR产生的前20个字节

126
00:10:14,042 --> 00:10:19,222
对吗？因为这是根据CSS系统的定义而输出的。

127
00:10:19,222 --> 00:10:24,501
现在，事实上20个字节队列，

128
00:10:24,501 --> 00:10:29,763
非常容易辨别出来它是不是
来自一个25字节的LFSR。

129
00:10:29,763 --> 00:10:33,561
如果不是，我们就知道
我们的17位LFSR的假设是错误的，

130
00:10:33,561 --> 00:10:37,416
并且我们进行下一步的假设，

131
00:10:37,416 --> 00:10:41,904
下下步的假设，以此类推。
直到最终我们得到正确的

132
00:10:41,904 --> 00:10:46,937
17位LFSR的初始状态。
然后我们事实上会得到的，我们将会看到

133
00:10:46,937 --> 00:10:51,969
得到的这20个字节可能的输出情况。

134
00:10:51,969 --> 00:10:56,936
事实上，是25位LFSR的一种可能的输出情况。
这样，我们不仅

135
00:10:56,936 --> 00:11:02,164
学会了正确的17位LFSR的初始状态，

136
00:11:02,164 --> 00:11:07,523
我们还学会了25位LFSR的初始状态。
我们可以预测剩余的CSS的输出。

137
00:11:07,523 --> 00:11:12,796
当然，用这种方法，我们可以破解电影的剩余部分

138
00:11:12,796 --> 00:11:17,565
进而可以还原整个明文。

139
00:11:17,565 --> 00:11:22,335
我们以前已经讲过这个了。
因此，我说的快了一点点，

140
00:11:22,335 --> 00:11:27,331
但愿还算清晰。
我们在流密码这部分有一道作业题，

141
00:11:27,331 --> 00:11:31,444
通过这道题你将会有掌握攻击算法是怎样做的。

142
00:11:31,444 --> 00:11:36,018
我要提醒的是有许多开源系统，

143
00:11:36,018 --> 00:11:41,453
现在都是用这种方法破解CSS密码的。
好，现在我们看完了两个简单的例子，

144
00:11:41,453 --> 00:11:45,888
让我们看看更好的例子，
有个来自于eStreamd的

145
00:11:45,888 --> 00:11:49,370
更好的伪随机函数产生器。这个

146
00:11:49,370 --> 00:11:55,556
项目在2008年完成了，
给出了5种不同的流密码，

147
00:11:55,556 --> 00:12:00,207
但是这里我只想讲一种。
因此，首先，这些流密码的参数

148
00:12:00,207 --> 00:12:04,029
与我们以前用过的有一点不一样。

149
00:12:04,029 --> 00:12:08,340
这些流密码和其他的正常的一样有种子。
此外还有一个

150
00:12:08,340 --> 00:12:12,821
被称为随机数的，
我们马上来看随机数是用来干嘛的。

151
00:12:12,821 --> 00:12:17,487
它们需要输入一个种子和一个随机数。
我们来看如何输入随机数。

152
00:12:17,487 --> 00:12:21,274
理所应当，它们会产生一个非常大的输出，

153
00:12:21,274 --> 00:12:26,603
这里的n远远大于s。现在,
当我说到随机数的时候,就是指只要密钥确定,

154
00:12:26,603 --> 00:12:31,218
它的值就永远不变。我接下来将会详细解释。

155
00:12:31,218 --> 00:12:35,400
而现在,只需要把它看作是一个独一无二的值

156
00:12:35,400 --> 00:12:40,527
只要密钥确定，它就永不重复。
当然，一旦你有了PRG，

157
00:12:40,527 --> 00:12:45,357
你就能加密像之前流密码加密一样，
除了你现在看到的，PRG需要密钥和随机数

158
00:12:45,357 --> 00:12:49,955
作为输入。而随机数是一对的(k, r)

159
00:12:49,955 --> 00:12:56,350
所以，切记切记：
密钥,随机数,永远永远不会重复。

160
00:12:56,350 --> 00:13:03,096
它是一次一密，
但底线是你可以重复利用密钥。

161
00:13:03,096 --> 00:13:09,710
因为随机数让它们独一无二，

162
00:13:09,710 --> 00:13:16,135
因为k和r只用一次，我说它们是唯一。
这个随机数是一个“狡猾”的小花招

163
00:13:16,135 --> 00:13:21,541
避免了我们每次更新密钥的麻烦。好，这个特殊的

164
00:13:21,541 --> 00:13:26,000
来自eStream的例子正是我想给你们展示的Salsa20.

165
00:13:26,000 --> 00:13:30,292
它是一个特别设计的在硬件和
软件设施均可用的流密码。

166
00:13:30,292 --> 00:13:33,385
这有点意思，大家知道到一些流密码是为

167
00:13:33,385 --> 00:13:38,763
软件而设计的，比如RC4。所有关于它的设计

168
00:13:38,763 --> 00:13:42,689
都是为了让软件更快地运行。
而其他的流密码是为硬件而设计的，

169
00:13:42,689 --> 00:13:48,143
比如CSS，运用了一个特别为低廉硬件定制的LFRS寄存器

170
00:13:48,143 --> 00:13:50,963
关于它的一件比较好的事情是

171
00:13:50,963 --> 00:13:55,008
它被这样设计所以它对硬件和软件都有利，

172
00:13:55,008 --> 00:13:59,747
运行速度都很快。
让我来解释Salsa是怎么工作的。

173
00:13:59,747 --> 00:14:05,130
Salsa 输入128位或者256位的密钥，
我将只解释128位版本的Salsa。

174
00:14:05,130 --> 00:14:11,244
这就是种子。需要输入一个随机数，像刚才一样，

175
00:14:11,244 --> 00:14:15,425
也是64位。然后会产生一个巨大的输出。

176
00:14:15,425 --> 00:14:21,060
现在看，它是怎么工作的呢？
函数定义如下。

177
00:14:21,060 --> 00:14:26,378
基本上给定的密钥和随机数，
它将会产生一个很长,很长的伪随机序列，

178
00:14:26,378 --> 00:14:31,222
相当的长,如果有必要的话。
我将通过使用的函数我把它记作H来实现.

179
00:14:31,222 --> 00:14:35,653
这个H函数需要三个输入：
密钥，种子k,随机数r,

180
00:14:35,653 --> 00:14:40,498
一个计数器一步一步计数。

181
00:14:40,498 --> 00:14:45,263
它从0到1，2,3,4,直到我们需要。明白了吗？

182
00:14:45,263 --> 00:14:49,956
所以通过评估H函数和(k,r),
用递增计数器，

183
00:14:49,956 --> 00:14:54,882
直到我们得到我们想要的队列。
我们全部需要做的就是描述

184
00:14:54,882 --> 00:14:59,460
这个函数H是怎么工作的。
现在，让我来描述一下。它是按以下方式工作的，

185
00:14:59,460 --> 00:15:04,693
开始先把状态扩充至64个字节长，

186
00:15:04,693 --> 00:15:10,156
我们按以下方式做。我们在刚开始先定义一个常数，

187
00:15:10,156 --> 00:15:15,552
τ0是4字节，它是个4字节常量，

188
00:15:15,552 --> 00:15:20,611
Salsa给定了τ0的值。
然后，我们把k放在

189
00:15:20,611 --> 00:15:25,467
16字节的地方。然后我们把另一个常量，
也是四字节的放进去。

190
00:15:25,467 --> 00:15:30,795
正如我所说，说明书上也定义了这个常量。

191
00:15:30,795 --> 00:15:37,435
我们取8字节的随机数，再取索引表。

192
00:15:37,435 --> 00:15:43,063
这是计数器0,1,2,3,4,是另外8比特。
然后我们取另外一个常量

193
00:15:43,063 --> 00:15:49,056
τ2,也是四字节的。再取密钥，

194
00:15:49,056 --> 00:15:54,714
这是另外一个16字节的。
最后我们取第三个常量，τ3,

195
00:15:54,714 --> 00:15:59,948
还是4字节的。如我所说，
如果你把这些加起来，你将会看到

196
00:15:59,948 --> 00:16:05,249
你得到字节数。我们已经扩展了
密钥，随机数，计数器为64字节，

197
00:16:05,249 --> 00:16:10,886
并且密钥重复了两次。
接下来我们要用一个函数

198
00:16:10,886 --> 00:16:16,321
我们把这个函数称为h。

199
00:16:16,321 --> 00:16:21,659
这个函数是由64字节到64字节一一对应的

200
00:16:21,659 --> 00:16:26,005
它是一个完全可逆的函数。
这个函数h，正如我所说的，是一个可逆函数。

201
00:16:26,005 --> 00:16:30,260
因此，给定一个输入你将得到输出，

202
00:16:30,260 --> 00:16:34,906
给一个输出将会返回输入。
并且它被特殊设计过,

203
00:16:34,906 --> 00:16:39,553
因此在x86上很容易运行

204
00:16:39,553 --> 00:16:44,199
因为x86有SSE2指令支持操作

205
00:16:44,199 --> 00:16:48,622
这个函数。它非常非常地快。
总之，Salsa有一个

206
00:16:48,622 --> 00:16:52,764
非常快的流密码。它不断地做这件事。
因此它应用于

207
00:16:52,764 --> 00:16:57,744
函数h得到另外的64字节。诸如此类，

208
00:16:57,744 --> 00:17:05,318
基本上它要这样做10次，好，
这里是全部的，重复10次，

209
00:17:05,318 --> 00:17:17,961
因此基本上用h用10次。对它自身来说，它并不是

210
00:17:17,961 --> 00:17:22,144
随机的，因为正如我们所说的，
H是一个完全可逆的。

211
00:17:22,144 --> 00:17:25,521
因此给定了最终的输出就非常容易求h的逆，

212
00:17:25,521 --> 00:17:31,831
再返回原始输入，
然后测试输入的正确结构。

213
00:17:31,831 --> 00:17:36,979
那么我们就再做另外一件事，
把最终输出和输入进行异或。

214
00:17:36,979 --> 00:17:42,405
对不起，不是异或，实际上是相加。
做一字一句地相加。

215
00:17:42,405 --> 00:17:47,762
因此，如果是64字节，要进行4字节一次地相加，

216
00:17:47,762 --> 00:17:52,980
最终得到64字节的输出，就是结果了。

217
00:17:52,980 --> 00:17:57,175
这就是整个伪随机数发生器。
因此，对于整个函数是h,

218
00:17:57,175 --> 00:18:01,758
正如我解释的，整个机制是函数H。

219
00:18:01,758 --> 00:18:06,009
然后通过递增计数器从0,1,2,3
向上来评估函数H。

220
00:18:06,009 --> 00:18:10,408
这样你会得到一个伪随机数发生器只要你需要。

221
00:18:10,408 --> 00:18:15,325
基本上在这方面还没有重大的攻击。
它的安全系数接近2^128。

222
00:18:15,325 --> 00:18:20,371
我们随后将会讨论更详细的内容。

223
00:18:20,371 --> 00:18:25,417
它是非常快的流密码，
无论在硬件上还是在软件上。就我们而言，

224
00:18:25,417 --> 00:18:30,431
它看上去似乎是不可预测的作为流密码，
正如一个流密码需要的那样。

225
00:18:30,431 --> 00:18:34,797
因此为应该说eStream工程
实际上有五个像这样的流密码。

226
00:18:34,797 --> 00:18:39,395
我只举Salsa的例子我认为最合适的。
但是我可以给你们一些性能参数。

227
00:18:39,395 --> 00:18:44,053
这些是在x86机上的2.2Ghz性能值。
可以看到这些性能参数，

228
00:18:44,053 --> 00:18:48,768
你可以看到RC4事实上是最慢的。

229
00:18:48,768 --> 00:18:53,017
因为在本质上，它在硬件上并不占优势。

230
00:18:53,017 --> 00:18:57,475
它只有字操作，因此有很多浪费的循环没有被用。

231
00:18:57,475 --> 00:19:01,182
但是eStream,无论是Salsa还是其他的，

232
00:19:01,182 --> 00:19:05,202
都被称为Sosemanuk。
我认为它们是eStream的优胜者。

233
00:19:05,202 --> 00:19:09,588
事实上，有很多流密码都获得了eStream项目的批准。

234
00:19:09,588 --> 00:19:13,712
你可以看到它们取得了很高的速率。
这个架构每秒处理643M字节的数据，

235
00:19:13,712 --> 00:19:18,150
这个速度足以应对电影
并且相当令人印象深刻。

236
00:19:18,150 --> 00:19:22,432
因此，现在你已经看到两个
老的已经不应该被用到流密码的例子，

237
00:19:22,432 --> 00:19:26,661
包括流密码的攻击。你已经看到

238
00:19:26,661 --> 00:19:30,480
看起来像随机数的现代流密码。
根据现代流密码的性能参数,

239
00:19:30,480 --> 00:19:34,546
如果你需要使用流密码，你可以使用一种eStream的优胜方案。

240
00:19:34,546 --> 00:19:37,991
特别地,你可以用Salsa。【END】

