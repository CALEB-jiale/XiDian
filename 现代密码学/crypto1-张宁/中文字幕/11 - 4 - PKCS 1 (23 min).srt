1
00:00:00,000 --> 00:00:04,748
在这一节我想展示一下RSA加密如何在实际中应用的，尤其

2
00:00:04,748 --> 00:00:09,497
我想告诉你们一个叫做PKCS的公钥加密技术标准

3
00:00:09,497 --> 00:00:14,734
我已经告诉你们很多次告诉大家你永远不应该

4
00:00:14,734 --> 00:00:19,262
用RSA加密密文，你也永远不能直接用RSA加密信息

5
00:00:19,262 --> 00:00:23,962
因为它是不安全的。你在运用RSA 函数时总是对明文必须做点什么

6
00:00:23,962 --> 00:00:28,318
我们在前一节了解了ISO标准

7
00:00:28,318 --> 00:00:32,846
在这个标准中我们做的是生成随机值x，用RSA对x进行加密

8
00:00:32,846 --> 00:00:37,375
之后从x我们可以派生一个对称加密密钥，但是实际这不是RSA在实际中的应用

9
00:00:37,375 --> 00:00:41,677
在实践中有所不同和典型

10
00:00:41,677 --> 00:00:46,150
是指系统生成加密密钥，之后

11
00:00:46,150 --> 00:00:50,508
RSA与其被用于加密这个给出的对称加密密钥

12
00:00:50,508 --> 00:00:55,275
不如用于生成对称密钥作为我们同一加密法或者RSA加密的一部分，

13
00:00:55,275 --> 00:01:00,908
所以说，RSA体系是指给出这个输入一个对称加密密钥，

14
00:01:00,908 --> 00:01:06,408
例如，这里有个a是AES密钥，128长度的比特串

15
00:01:06,408 --> 00:01:12,040
之后实际加密的方法是首先我们把这128个比特串

16
00:01:12,040 --> 00:01:17,077
扩大为全模尺寸。例如，2048个比特串

17
00:01:17,077 --> 00:01:21,678
之后我们再用RSA函数。那么问题是，这个预处理怎么做呢？

18
00:01:21,678 --> 00:01:26,132
给出的这128个比特串怎么扩大乘2048个比特值以应用于RSA呢？

19
00:01:26,132 --> 00:01:30,531
并且进一步的一个问题是

20
00:01:30,531 --> 00:01:35,150
我们又怎么讨论这个结果体系是安全的呢？所有解决

21
00:01:35,150 --> 00:01:40,082
这些问题的方法是在实践中被广泛使用的称作PKCS1.5版本

22
00:01:40,082 --> 00:01:44,491
即公钥加密标准，即PKCS的含义

23
00:01:44,491 --> 00:01:49,307
我想给你们看一下这个机制是怎么工作的，尤其说一下什么叫做

24
00:01:49,307 --> 00:01:53,775
PKCS模式2，模式2代表加密，模式1代表数字签名

25
00:01:53,775 --> 00:01:58,126
所以这里我们将关注这个加密方法。PKSC1工作如下

26
00:01:58,126 --> 00:02:02,710
你拿到你的明文，例如，这是128比特的AES密钥

27
00:02:02,710 --> 00:02:07,392
你把它当做最低有效位输入

28
00:02:07,392 --> 00:02:12,641
接下来，你应该做的是给它添加16个比特，

29
00:02:12,641 --> 00:02:18,009
这里是16个比特，之后你做的是添加这随机的填补位

30
00:02:18,009 --> 00:02:23,104
在这个随机填补位的任何一处都不包含FF。

31
00:02:23,104 --> 00:02:28,072
所以这实际上它有些像它的序列，1900个随机比特

32
00:02:28,072 --> 00:02:33,356
除了在这些随机比特字中的FF序列。最后，在最顶端

33
00:02:33,356 --> 00:02:38,513
放置数字02，这说明这个明文已经用PKSC1模式2加密了

34
00:02:38,513 --> 00:02:43,476
这里的所有值，我们生成的所有值

35
00:02:43,476 --> 00:02:48,893
这仅仅的2048个比特串被送入RSA函数

36
00:02:48,893 --> 00:02:54,118
之后被升为e的次方模n。输出结果是PKCS1密文

37
00:02:54,118 --> 00:02:59,471
这个解密方法是倒置RSA函数，将会返回这个模块

38
00:02:59,471 --> 00:03:03,267
看一下这个最高有效位，它将说

39
00:03:03,430 --> 00:03:07,885
这里有一个02，这意味着PKCS1格式化了，因为它是PKCS1的格式化

40
00:03:07,885 --> 00:03:12,123
所以他将移动这些02.之后将移动这所有的填补直达FF

41
00:03:12,123 --> 00:03:16,810
凡落后的事物都是之后将要用到的原始信息，

42
00:03:16,810 --> 00:03:22,180
并且你知道解密这密文的实际内容

43
00:03:22,180 --> 00:03:28,206
正如我说的这种机制被相当广泛的使用了，例如

44
00:03:28,206 --> 00:03:33,088
被用于HTTPS中，有意思的是，这个PKCS1 1.5版本在80年代后期设计出来的

45
00:03:33,088 --> 00:03:37,861
的确没有安全证据来说明这个机制是安全的

46
00:03:37,861 --> 00:03:42,952
当没有安全证据时，事物是易被攻破证明是普遍存在的

47
00:03:42,952 --> 00:03:48,234
并且存在一个非常非常高端的攻击

48
00:03:48,234 --> 00:03:53,071
由于1998年Bleichenbacher的论文，Bleichenbacher向我们

49
00:03:53,071 --> 00:03:58,290
展示了如何攻击PKCS1，当它被用于HTTPS里面时。所以让我们看一下这个攻击如何展开的

50
00:03:58,290 --> 00:04:03,228
这个思路是，假设攻击者拦截了一个确定的密文

51
00:04:03,228 --> 00:04:07,988
就是PKCS1密文，那么关键是它用PKCS1编码的，之后

52
00:04:07,988 --> 00:04:12,812
结果被送入RSA函数，我们称这密文是RSA函数的输出

53
00:04:12,812 --> 00:04:16,797
攻击者想破解这个密文，

54
00:04:16,797 --> 00:04:21,065
那么让我给大家详细展示一下这攻击者是怎么做的。我们仅仅简化一下SSL

55
00:04:21,065 --> 00:04:25,349
并且这个攻击者实际上可以直接把密文发送到网络服务器

56
00:04:25,349 --> 00:04:29,421
网络服务器将尝试用它的密钥破解这个密文

57
00:04:29,421 --> 00:04:33,441
之后他会成功吗？在加密之后他做的第一件事是

58
00:04:33,441 --> 00:04:37,208
将会问对破解的密文是用PKCS1编码的吗？

59
00:04:37,208 --> 00:04:41,229
换句话说，看到这最高有效位会问

60
00:04:41,229 --> 00:04:45,250
在这最高有效位是02吗？如果是，将继续

61
00:04:45,250 --> 00:04:49,322
正确地解密并继续使用这个协议，如果这些位置不是02

62
00:04:49,322 --> 00:04:53,292
将会警告一个错误执行，所以，如果这明文的最高有效位是

63
00:04:53,292 --> 00:04:57,558
02，将如期继续这个协议，如果最高有效位

64
00:04:57,558 --> 00:05:01,951
不是02将会返回一个错误信息并告诉攻击者

65
00:05:01,951 --> 00:05:06,059
输入了无效的密文。现在不可思议的是

66
00:05:06,059 --> 00:05:10,276
这会让要求攻击者测试给出的密文中解密最显著

67
00:05:10,276 --> 00:05:14,712
的16位比特数是否是02.换句话说，就是

68
00:05:14,712 --> 00:05:19,635
攻击者可以提交任何他想提交的密文给web服务。web服务将会

69
00:05:19,635 --> 00:05:24,772
转化RSA公钥加密算法，之后告诉攻击者转化后是否从02

70
00:05:24,772 --> 00:05:30,210
开始。所以在某种意义上说是给攻击者一个提示让他检测

71
00:05:30,210 --> 00:05:35,407
密文的转换是不是从02开始的。这也证明了

72
00:05:35,407 --> 00:05:39,916
实际上解密攻击者所期望的密文是完全可行的。只要加上一点点因为

73
00:05:39,916 --> 00:05:44,800
RSA公钥加密算法的信息泄露，攻击者至少

74
00:05:44,800 --> 00:05:49,860
可以完全的解密一个给定的密文。所以这就是攻击者想做的。

75
00:05:49,860 --> 00:05:54,052
如果他有一个想解密的密文，他要做的就是将这个得到的密文

76
00:05:54,052 --> 00:05:57,940
直接输入web服务并且询问

77
00:05:57,940 --> 00:06:01,929
它是否是从02开始的。他要做的下一步就是选择一个

78
00:06:01,929 --> 00:06:06,480
随机值R然后建立一个新的密文c集合。它也就是

79
00:06:06,480 --> 00:06:12,013
c模N。现在要做什么呢？如果我们把r带入RSA函数中

80
00:06:12,013 --> 00:06:17,546
那我们做的就是我们乘了rsa的密文。你知道数据包1

81
00:06:17,546 --> 00:06:23,289
中包含了m，我们让r和m相乘，这个样子我们最终得到的是r的e次方。

82
00:06:23,289 --> 00:06:27,897
好了，这就是将c与（r的e次方)相乘得到的。它使密文和

83
00:06:27,897 --> 00:06:32,334
r相乘，一个被攻击者控制的值。之后攻击者

84
00:06:32,334 --> 00:06:37,371
会把c一撇输入web服务中，web服务会承认这次会话，然后以02或者

85
00:06:37,371 --> 00:06:42,132
不是02开始.所以现在我们可以概括一下这个问题

86
00:06:42,132 --> 00:06:47,805
把这个问题简化成更平常的你可以想象的问题，就比如我的脑中有一个

87
00:06:47,805 --> 00:06:53,010
未知数x。这个数是我尝试编码m从数据包1中得到的。我在考虑

88
00:06:53,010 --> 00:06:58,483
这个未知数x，之后我想让你们做的事情是对r做的。针对你选择的r我要告诉你们的是

89
00:06:58,483 --> 00:07:04,088
r倍的x模n是否从02开始。同时这也证明了

90
00:07:04,088 --> 00:07:09,294
询问足够的问题，事实证明不是很多这种类型的问题，

91
00:07:09,294 --> 00:07:14,962
你可以回复所有的未知数x。通过学习利用询问方式找到r倍的x

92
00:07:14,962 --> 00:07:20,533
是否从02开始，你确实可以复原x。所以在现实中

93
00:07:20,533 --> 00:07:24,634
这意味着攻击者可以获取一个给定的密文。可能

94
00:07:24,634 --> 00:07:28,847
对应着用户使用信用卡的编号或者是

95
00:07:28,847 --> 00:07:33,226
密码，现在攻击者想解密这个密文。他要做的事

96
00:07:33,226 --> 00:07:37,272
是发送百万级的像这样的密文，web服务会回复每个

97
00:07:37,272 --> 00:07:41,928
密文是否以02开始或者不是，在这个攻击的结尾

98
00:07:41,928 --> 00:07:46,473
攻击者就会以块分割它们，也就是密文c

99
00:07:46,473 --> 00:07:50,727
的译码。所以这对你来说可能有一点魔术意味，你能从仅仅是

100
00:07:50,727 --> 00:07:54,896
特征比特是不是02知道什么呢，你怎么样

101
00:07:54,896 --> 00:07:59,439
去还原全部的简单密钥。所以让我为你展示一个简单地例子。

102
00:07:59,439 --> 00:08:03,822
我将会把那些基本攻击加值叫做Bleichenbacher仅仅是为了让大家稍微了解一下

103
00:08:03,822 --> 00:08:08,098
这样的攻击可能怎么工作。想象一下攻击者有能力发送密文c，

104
00:08:08,098 --> 00:08:12,641
web服务将会使用秘密密钥去解密但是让我们假设

105
00:08:12,641 --> 00:08:16,596
它可能会替对02的检查也可能不会，所有的web服务所做的就是攻击者

106
00:08:16,596 --> 00:08:21,036
所询问的特征比特1或是0 如果特征比特是1，那么web服务会

107
00:08:21,036 --> 00:08:25,710
回到是的，如果特征比特不是1，那么web服务就会拒绝。更深一侧，

108
00:08:25,710 --> 00:08:30,565
为了简化问题，我们假设RSA加密模块是2的n次方，也就是说

109
00:08:30,565 --> 00:08:35,539
n=2^n。当然，这并不是一个有效的RSA解码。RSA解码通常是

110
00:08:35,539 --> 00:08:40,453
两个不同的集合的产物。但是为了让事情变得简单一点，

111
00:08:40,453 --> 00:08:45,367
我们假设存在这一时刻n确实是2^N，所以你们现在知道了通过

112
00:08:45,367 --> 00:08:49,802
发送密文c到web服务，敌手就会得到特征

113
00:08:49,802 --> 00:08:54,551
比特的明文x。事实上，服务的行为完全

114
00:08:54,551 --> 00:08:59,240
显示了特征比特，现在攻击者需要做的就是

115
00:08:59,240 --> 00:09:04,175
把密文乘上e的二次方。现在乘上e的二次方

116
00:09:04,175 --> 00:09:09,274
对于密文来说就相当于2倍x的e。次方

117
00:09:09,274 --> 00:09:15,067
并且，因为我们要求2x的模n，也就是左边这个式子。

118
00:09:15,067 --> 00:09:20,789
好的，所以事实上现在当我们左进位我们就会知道2x的特征

119
00:09:20,789 --> 00:09:26,581
比特，也就是x的第二特征比特。好的，我们把x左进位后

120
00:09:26,581 --> 00:09:32,257
就得到了2x的特征比特。我们分解解密

121
00:09:32,257 --> 00:09:37,596
n。所以现在2x的特征比特模n实际上就是x的其次

122
00:09:37,596 --> 00:09:42,846
特征比特。所以现在我们知道了另一个x的字符。我们现在开始

123
00:09:42,846 --> 00:09:48,158
重复上面的步奏。我们会开始质疑4的e次方乘c，这和质疑

124
00:09:48,158 --> 00:09:54,108
4x的e次方是一致的。针对4x的询问实际上也反映了4x特征

125
00:09:54,108 --> 00:09:59,454
比特。这就反映了俩比特进位。也就意味着，我们

126
00:09:59,454 --> 00:10:03,641
现在早知道了x的第三特征比特。当我们重复再重复，

127
00:10:03,641 --> 00:10:08,041
之后得到了不同的c的明文。你可以看到很少的几个讯问后，大约1000或者

128
00:10:08,041 --> 00:10:11,751
2000个询问，我们就能复原全部的x。之所以Bleichenbacher

129
00:10:11,751 --> 00:10:15,674
需要百万级的询问的原因是没有测试

130
00:10:15,674 --> 00:10:20,020
第一次，实际上就是是否针对是02进行测试。所以他需要

131
00:10:20,020 --> 00:10:24,208
百万级的询问而不是2000次的，但是无论如何

132
00:10:24,208 --> 00:10:28,729
依旧足够去复原所有的密文。

133
00:10:28,729 --> 00:10:34,337
我希望这能解释这个攻击为什么是可能的 为什么这一点关于

134
00:10:34,337 --> 00:10:39,359
RSA反转中最重要的比特的信息就足以完全破解RSA

135
00:10:39,359 --> 00:10:46,023
这里的底线是像上面那样被用于网络服务器的PACK1

136
00:10:46,023 --> 00:10:50,323
在这个攻击被发现之前基本上是安全的

137
00:10:50,323 --> 00:10:54,902
因为攻击者可以通过向网络服务器发送足够的查询就能破解密文

138
00:10:54,902 --> 00:11:00,215
所以 我们要怎样来抵御这种攻击呢

139
00:11:00,215 --> 00:11:05,004
SSL团体的想要减少他们代码的变化这样就能避免

140
00:11:05,004 --> 00:11:09,854
有效攻击 如果你注意到RFC 他们所提出的是

141
00:11:09,854 --> 00:11:14,704
好吧 这里有很多的文字 他们所提出的就是

142
00:11:14,704 --> 00:11:19,433
如果在你使用了RSA解密之后 你收到一个不是PACK1编码的明文

143
00:11:19,433 --> 00:11:24,344
换句话说就是它不是以02开头的 那么你应该做的就是

144
00:11:24,344 --> 00:11:28,949
随机选择一个字符串R  然后只用假装这个明文

145
00:11:28,949 --> 00:11:33,078
只是一个随机的字符串R 然后当做什么都没发生一样继续 当然

146
00:11:33,078 --> 00:11:38,438
协议之后会失效 具体来说就是 如果PACK1编码是错误的

147
00:11:38,438 --> 00:11:42,526
你要做的就是 声称预制密钥就是这个

148
00:11:42,526 --> 00:11:46,873
随机字符串 然后继续协议

149
00:11:46,873 --> 00:11:50,961
当然建立的会话会失败因为客户端和服务器

150
00:11:50,961 --> 00:11:55,152
会认同不同的密钥这样就导致会话终止

151
00:11:55,152 --> 00:11:59,447
所以实际上我们并没有告诉攻击者明文是不是以02开头的

152
00:11:59,447 --> 00:12:05,479
我们所做的就是假装明文是一些随机的数值

153
00:12:05,479 --> 00:12:10,096
对于网络服务器来说这只是细微的代码变化 而且它是容易实施的

154
00:12:10,096 --> 00:12:14,892
实际上 如今大部分网络服务器使用这个版本的PACK1

155
00:12:14,892 --> 00:12:19,329
然而 这就引发了PACK1是否应该被

156
00:12:19,329 --> 00:12:23,946
完全改变从而我们能够证明它具有选择密文安全性

157
00:12:23,946 --> 00:12:28,322
这就给了我们另外一种使用RSA加密的方式

158
00:12:28,322 --> 00:12:33,391
这种方式被称为最优非对称加密填充 简称OAEP 事实上

159
00:12:33,391 --> 00:12:40,092
PKCS标准被更新 而且2.0版本的PKCS1实际上是支持OAEP的

160
00:12:40,092 --> 00:12:48,871
而OAEP是一种RSA加密的更好方式 所以让我来解释下OAEP是如何工作的

161
00:12:48,871 --> 00:12:54,911
OAEP是94年BEllare和Rogaway发明的 OAEP的运行方式如下

162
00:12:54,911 --> 00:13:01,334
选取一个你想要加密的信息 比如这个128比特的AES密钥

163
00:13:01,334 --> 00:13:06,589
然后 首先要做的就是给它附加上一段短填充

164
00:13:06,589 --> 00:13:11,249
在这种情况下 将01加到开始的位置然后再加一堆0

165
00:13:11,249 --> 00:13:16,026
至于多少0取决于标准 但是你们知道这里应该有128个0

166
00:13:16,026 --> 00:13:20,686
同时选取一个随机的数值

167
00:13:20,686 --> 00:13:25,521
让整个字符串和RSA的模数一样大 比如2047比特

168
00:13:25,521 --> 00:13:30,065
在你使用RSA函数之前 首先要把你选择的随机数值

169
00:13:30,065 --> 00:13:34,491
输入到哈希函数中 哈希函数会产生一个

170
00:13:34,491 --> 00:13:38,787
和左侧编码一样大的数值 把输出进行异或

171
00:13:38,787 --> 00:13:42,768
将得到的结果输入到另外一个被称为G哈希函数中

172
00:13:42,768 --> 00:13:46,750
将结果和随机数值进行异或 最后 就得到了两个被连接在一起的数值

173
00:13:46,750 --> 00:13:51,365
不管连接的是左侧

174
00:13:51,365 --> 00:13:56,852
还是右侧 都将得到2047比特的长度

175
00:13:56,852 --> 00:14:03,131
并把它输入到RSA函数上 得到的输出就是RSA的加密

176
00:14:03,131 --> 00:14:07,636
这里有一个在2001年被Fujisaki Okamoto Pointcheval 和Stern证明的理论

177
00:14:07,636 --> 00:14:12,557
它将向你证明如果你所做的是将RSA函数假定为一个陷门置换

178
00:14:12,557 --> 00:14:17,062
一个安全的置换操作 但实际上这种用RSA加密的模式

179
00:14:17,062 --> 00:14:21,686
实际上是选择密文安全的 但是

180
00:14:21,686 --> 00:14:26,607
我们必须假设函数H和G都是理想的哈希函数 正如我所说

181
00:14:26,607 --> 00:14:31,053
它们被称为随机oracle 我们假设H和G就是

182
00:14:31,053 --> 00:14:36,293
从定义域映射到值域的随机函数 在实际运用中

183
00:14:36,293 --> 00:14:41,277
当使用OAEP时 人们只对H和G使用SHA-256 这为什么被称为

184
00:14:41,277 --> 00:14:45,618
最优非对称加密填充 为什么是这个o 为什么这表示最佳

185
00:14:45,618 --> 00:14:50,070
原因是如果你观察密文 就会注意到

186
00:14:50,070 --> 00:14:54,690
密文基本上达到它所能达到的最短 密文正好是一个RSA输出的长度

187
00:14:54,690 --> 00:14:59,286
这里没有附加在密文上的尾部的数值

188
00:14:59,286 --> 00:15:03,992
比如在ISO标准中 如果你记得 即便你要加密一个很短的信息

189
00:15:03,992 --> 00:15:08,589
你要做的就是将x用RSA加密

190
00:15:08,589 --> 00:15:12,638
然后将它附加到x上 这就是在对称加密系统下对短信息的加密

191
00:15:12,638 --> 00:15:17,126
即便你只用加密一个128比特长度的AES密钥

192
00:15:17,126 --> 00:15:21,411
通过ISO标准你就会得到一个RSA输出并附加一个对称的密码

193
00:15:21,411 --> 00:15:26,643
而在OAEP中 你只会得到一个RSA输出 所以在这种情况下

194
00:15:26,643 --> 00:15:31,090
它是最优的 最优在于密文的长度

195
00:15:31,090 --> 00:15:35,897
有趣的是 这种理论十分依赖于RS的特性 实际上

196
00:15:35,897 --> 00:15:40,644
如果你使用一个普通的陷门置换的话 这种理论就是错误的

197
00:15:40,644 --> 00:15:45,512
其他的一些置换并不具备RSA的代数特性

198
00:15:45,512 --> 00:15:50,260
这就遗留下了问题 如果我们有一个普通的陷门置换 什么才是使用OAEP的正确方式

199
00:15:50,260 --> 00:15:55,127
结果对于OAEP有小的修正

200
00:15:55,127 --> 00:16:00,115
这样结果更具普适性 这是在2001年返回Shoup导致的

201
00:16:00,115 --> 00:16:04,729
来看看如果给一个普通的陷门置换f会有什么情况

202
00:16:04,729 --> 00:16:09,546
结果表明替换掉通过哈希函数使用OAEP的固定填充 这个哈希函数

203
00:16:09,546 --> 00:16:14,116
恰巧就是消息m和加密所用的随机性r的哈希函数

204
00:16:14,116 --> 00:16:18,996
解密时要确保哈希函数值是对的

205
00:16:18,996 --> 00:16:23,875
解密时还要确保变量m和r对应函数值w

206
00:16:23,875 --> 00:16:28,816
写入了明文的位置

207
00:16:28,816 --> 00:16:33,829
如果是这样的话这样的OAEP基本上就是OAEP+

208
00:16:33,829 --> 00:16:38,078
事实上这就是任何陷门置换的CCS安全性（被选密文安全）

209
00:16:38,078 --> 00:16:42,621
安全不需要依靠RSA的特性 还会产生另一个结果简单非对称加密填充

210
00:16:42,621 --> 00:16:47,342
SAEP+是说如果要利用RSA的特性

211
00:16:47,342 --> 00:16:51,827
当公共指数3用RSA这种特定方式

212
00:16:51,827 --> 00:16:56,429
事实上不需要进行第二阶段的加密

213
00:16:56,429 --> 00:17:01,386
又一次使用函数w的简单填充模式

214
00:17:01,386 --> 00:17:06,321
足够保证被选密文安全性

215
00:17:06,321 --> 00:17:11,760
所以有很多种OAEP但不是都被使用 我只是提出来让你们了解它们的存在

216
00:17:11,760 --> 00:17:16,239
主要是标准OAEP被使用

217
00:17:16,239 --> 00:17:20,974
RSA在公共加密最广泛的应用

218
00:17:20,974 --> 00:17:25,729
事实上是HTTPS REF标准化的PKCS1

219
00:17:25,729 --> 00:17:30,526
你要清楚实际如何进行解密

220
00:17:30,526 --> 00:17:35,683
我来问你怎么解密SAEP密文

221
00:17:35,863 --> 00:17:40,600
密文给定是ct 在于这三个理论哪个是适用于解密

222
00:17:40,600 --> 00:17:47,177
是第一个 我们来看看为什么

223
00:17:47,177 --> 00:17:52,181
密文给定 我们首先要用RSA取反函数

224
00:17:52,181 --> 00:17:57,250
我们能通过密文得到在x和r情形下RSA明文

225
00:17:57,250 --> 00:18:02,447
所以要给出x和r

226
00:18:02,447 --> 00:18:07,709
然后我们需要带入哈希函数得到r 和结果异或

227
00:18:07,709 --> 00:18:12,152
就能得到m和w(m,r) 最后我们要保证填充W(m,r)是正确的

228
00:18:12,152 --> 00:18:17,213
验算w是否等于W(m,r)

229
00:18:17,213 --> 00:18:22,711
如果等就输出m 如果不等输出bottom说明密文无效

230
00:18:22,711 --> 00:18:27,304
解密算法丢弃它

231
00:18:27,304 --> 00:18:31,731
顺便强调一下加密填充过程的核算在所以我们所见过的机制中都是很重要的

232
00:18:31,731 --> 00:18:36,956
例如在OAEP+和SAEP+中进行解密

233
00:18:36,956 --> 00:18:42,917
确保正确填充很重要

234
00:18:42,917 --> 00:18:48,534
我们用来加密的w值 就是m和r待人哈希函数得到的值

235
00:18:48,534 --> 00:18:54,152
类似的对于OAEP 在解密过程中核算很重要

236
00:18:54,152 --> 00:18:59,544
事实上填充值是不变的010000000

237
00:18:59,544 --> 00:19:04,556
当然如果不是01000就输出bottom 宣告密文无效

238
00:19:04,556 --> 00:19:08,713
最后我想指出执行OAEP是是否聪明的做法

239
00:19:08,713 --> 00:19:12,679
我们来看看为什么这样说 假设你编写一个OAEP解密程序

240
00:19:12,679 --> 00:19:17,347
用密文作为输入

241
00:19:17,347 --> 00:19:22,330
首先对密文使用RSA取反函数

242
00:19:22,330 --> 00:19:27,565
想得到n比特值输出

243
00:19:27,565 --> 00:19:32,548
已经知道在2048比特RSA模函数的2047比特

244
00:19:32,548 --> 00:19:37,150
如果有比2047的2次方大的数 声称丢弃

245
00:19:37,150 --> 00:19:42,014
声称错误为1 退出

246
00:19:42,014 --> 00:19:46,820
然后要核查这个填充是否正确 然后再一次拒绝并退出

247
00:19:46,820 --> 00:19:51,512
这个执行的问题在于 应该意识到即使现在对于定时攻击来说

248
00:19:51,512 --> 00:19:55,918
这样的加密是脆弱的

249
00:19:55,918 --> 00:20:00,382
因此通过定时信息的泄露攻击者很容易计算出哪出错

250
00:20:00,382 --> 00:20:04,674
是因为RSA解密很复杂出现错误

251
00:20:04,674 --> 00:20:08,909
或者由于填充太多出现错误

252
00:20:08,909 --> 00:20:13,257
如果攻击者能通过定时区分这两种错误

253
00:20:13,257 --> 00:20:17,889
如果和Bleichenbacher攻击很像 很可能完全解出你选择的任何密文

254
00:20:17,889 --> 00:20:22,408
即便是非常非常小的信息泄露

255
00:20:22,408 --> 00:20:28,203
也可以让攻击解密出他想要的所用密文

256
00:20:28,203 --> 00:20:32,624
其实正确执行了OAEP的数学理论

257
00:20:32,624 --> 00:20:37,101
也非常容易弄砸很容易自己暴露在定时的攻击下

258
00:20:37,101 --> 00:20:41,074
执行就非常不安全

259
00:20:41,074 --> 00:20:45,215
依照以往的经验就是不要自己加密

260
00:20:45,215 --> 00:20:49,692
对于自己执行来说RSA OAEP真的很危险 例如使用标准函数库

261
00:20:49,692 --> 00:20:54,281
OpenSSL有OAEP执行功能

262
00:20:54,281 --> 00:20:59,038
当然它会非常小心地保证OAEP解密时间总是相同

263
00:20:59,038 --> 00:21:03,401
不管出现了什么错误 这节到此结束

264
00:21:03,401 --> 00:21:07,435
下节将介绍RSA陷门置换的安全性。【END】

