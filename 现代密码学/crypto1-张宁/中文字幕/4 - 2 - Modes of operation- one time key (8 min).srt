1
00:00:00,000 --> 00:00:03,831
那么作为我们的第一个例子，
让我们看一个十分简单的使用分组密码的加密。

2
00:00:03,831 --> 00:00:07,905
特别的，我们看看怎么使用
具有一次性密钥的分组密码。

3
00:00:07,905 --> 00:00:12,108
所以在这一节我们将使用一次性密钥的分组密码来加密

4
00:00:12,108 --> 00:00:15,907
换句话说，攻击者看到的将仅仅是一份密文

5
00:00:15,907 --> 00:00:19,600
他的目标将是破解密文的语义。现在，

6
00:00:19,600 --> 00:00:23,339
在下一段中，我们将了解更多更有意思的分组密码的应用

7
00:00:23,339 --> 00:00:26,939
以及如何使用密钥对多组信息进行多次加密

8
00:00:26,939 --> 00:00:30,538
那么在我们开始之前，我想要提的一点是，

9
00:00:30,538 --> 00:00:34,464
一个使用分组密码的经典错误。
不幸的是，有许多产品正是这么工作的，

10
00:00:34,464 --> 00:00:38,251
它们被完全的破解了，所以我想要确信

11
00:00:38,251 --> 00:00:42,130
你们中没人会犯这个错误。这种操作模式

12
00:00:42,130 --> 00:00:46,003
被称为电子密码本。它如下工作：

13
00:00:48,211 --> 00:00:50,420
当你想用分组密码时你可能会首先想到它。

14
00:00:50,420 --> 00:00:54,568
我们拿到我们的信息并将之分块，
每一块都和加密块一样大小，

15
00:00:54,568 --> 00:00:58,931
比如在AES的例子中，我们将把我们的信息分成16字节的块，

16
00:00:58,931 --> 00:01:03,099
然后分别加密我们的每一块。

17
00:01:03,099 --> 00:01:06,993
这种模式常被称为电子代码本。
不幸的是这是很不安全的。

18
00:01:06,993 --> 00:01:11,460
因为你意识到如果两块是相同的，

19
00:01:11,460 --> 00:01:16,099
比如有两个块恰好是相同的，
那么必然导致密文也是相同的

20
00:01:16,099 --> 00:01:20,279
那么一个分析密文的攻击者，
即使他可能不知道

21
00:01:20,279 --> 00:01:24,590
这些块到底写了什么，
但会知道这些块是相同的。

22
00:01:24,590 --> 00:01:28,523
那么，结果就是他知道了关于明文的一些他不该知道的信息

23
00:01:28,523 --> 00:01:33,002
如果这么讲不够清楚，最好的解释是，

24
00:01:33,002 --> 00:01:37,590
用一副图。这有一个家伙，你知道他有

25
00:01:37,590 --> 00:01:42,361
深黑色的头发。那么我们用电子密码本模式

26
00:01:42,361 --> 00:01:47,056
加密这幅位图。你看他占大量空间的头发

27
00:01:47,056 --> 00:01:50,932
基本上总是被用相同的方式加密，这是他的剪影

28
00:01:50,932 --> 00:01:54,935
事实上，这是完全可见的，即使是在加密的数据中。

29
00:01:54,935 --> 00:01:59,149
所以这是一个电子密码本可能泄露给攻击者关于

30
00:01:59,149 --> 00:02:03,311
明文的信息的例子。那么问题是

31
00:02:03,311 --> 00:02:07,367
如何正确的用分组密码来加密长的信息。那么，

32
00:02:07,367 --> 00:02:11,159
我将简单的提醒你我们将要实现的想法，

33
00:02:11,159 --> 00:02:15,268
就是简单的用一次性密钥保证语义安全。

34
00:02:15,268 --> 00:02:18,969
那么攻击者输出两组信息，M0和M1，
那么当他将得到M1或M2的加密。

35
00:02:18,969 --> 00:02:22,777
有两组不同实验，我们的目标是确定

36
00:02:22,777 --> 00:02:26,256
攻击者不能将两者区分开来，

37
00:02:26,256 --> 00:02:30,283
也就是说，你不能区分M0的加密和M1的加密。

38
00:02:30,283 --> 00:02:34,619
我们认为一次性密钥是安全的原因是
这个密钥只被用来加密一组信息。

39
00:02:34,619 --> 00:02:38,485
于是，攻击者可能只会见到一份

40
00:02:38,485 --> 00:02:42,716
用了这组密钥的密文。好了，
我们想要展示的第一件事是，

41
00:02:42,716 --> 00:02:46,269
事实上我们刚看的模式，电子密码本，
事实上不是语义安全的。

42
00:02:46,269 --> 00:02:50,500
只要你加密不止一个块他就不是语义安全的

43
00:02:50,500 --> 00:02:54,575
这有一个例子。假设我们用分组密钥加密两个分组，

44
00:02:54,575 --> 00:02:58,702
我来向你们证明电子密码本实际上是不安全的

45
00:02:58,702 --> 00:03:03,525
我们将这么做。假设我们是攻击者。
我们输出两个信息，m0和m1

46
00:03:03,525 --> 00:03:07,806
在一个信息中，分组是不同的，
另一个中，分组是相同的。

47
00:03:07,806 --> 00:03:12,203
这两个分组相同，那么挑战者要如何做？

48
00:03:12,203 --> 00:03:16,270
挑战者将要加密m0或m1

49
00:03:16,270 --> 00:03:20,228
两种情况我们都得到两个分组，
那么密文包含两个分组

50
00:03:20,228 --> 00:03:23,886
第一个分组是单词“Hello”的加密

51
00:03:23,886 --> 00:03:27,695
第二个分组是“Hello”或“World”的加密

52
00:03:27,695 --> 00:03:31,854
如果这两个密文分组一样，那么攻击者知道

53
00:03:31,854 --> 00:03:35,963
他收到是“Hello Hello”的加密

54
00:03:35,963 --> 00:03:39,851
如果不一样，他知道他收到是“Hello World”的加密。对吧

55
00:03:39,851 --> 00:03:44,311
所以，攻击者遵循一个简单的策略，
大家想一想，就可以知道他的优势是什么

56
00:03:44,311 --> 00:03:48,300
那么优势是什么呢？

57
00:03:48,300 --> 00:03:52,003
攻击者总在他接收到m1的加密时输出0

58
00:03:52,003 --> 00:03:55,573
总是在他接收到m0的加密时输出1

59
00:03:55,573 --> 00:03:58,603
由于优势是1，也就是说这种机制是不安全的

60
00:03:58,603 --> 00:04:02,492
也再次表明，电子密码本不是语义安全的

61
00:04:02,492 --> 00:04:07,195
永远不应被用来加密长于一个分组的信息

62
00:04:07,195 --> 00:04:12,293
那么我们该怎么办？有个简单的例子

63
00:04:12,293 --> 00:04:15,813
我们可以使用一个确定的计数器模式

64
00:04:15,813 --> 00:04:19,287
在确定的计数器模式下，
我们主要用分组密码构建一个流密码。

65
00:04:19,287 --> 00:04:24,608
假设我们有一个伪随机函数(PRF) f。
我说PRF时大家应该可以想到AES，

66
00:04:24,608 --> 00:04:29,143
AES也是一个安全的PRF。我们要做的基本上就是

67
00:04:29,143 --> 00:04:35,539
计算AES在点0处的值，在点1处的值，在点2处的值，一直到点L

68
00:04:35,539 --> 00:04:40,766
这会产生一个伪随机密码本，
我会将它和所有明文分组进行异或

69
00:04:40,766 --> 00:04:45,102
得到密文作为结果

70
00:04:45,102 --> 00:04:49,561
这其实只是一个由PRF构造的流密码。
同AES和3重DES一样，是个简单的加密方法

71
00:04:49,561 --> 00:04:53,630
我想很快的为大家证明这个安全定理

72
00:04:53,630 --> 00:04:58,368
事实上，我们已经讨论使用PRF的流密码时
已经看到过这个安全定理了。

73
00:04:58,368 --> 00:05:02,939
所以我不打算将他重复一遍

74
00:05:02,939 --> 00:05:07,343
我只是提醒大家，对每个试图攻击确定计数器模式的攻击者A

75
00:05:07,343 --> 00:05:11,746
我们证明存在一个试图攻击PRF的攻击者B

76
00:05:11,913 --> 00:05:16,510
由于这个量是可以忽略的，因为PRF是安全的

77
00:05:16,510 --> 00:05:20,720
我们得到这个量也是可忽略的。因此，

78
00:05:20,720 --> 00:05:24,818
这个攻击者对确定的计数器模式只有一个可忽略的优势

79
00:05:24,818 --> 00:05:29,028
这个证明用图形表示很简单，为求完整，

80
00:05:29,028 --> 00:05:33,013
我就为大家再证明一次

81
00:05:33,013 --> 00:05:37,448
当攻击者有明文m0的加密时，
这是m0的加密密文

82
00:05:37,448 --> 00:05:41,602
m0异或计数器的PRF值

83
00:05:41,602 --> 00:05:45,680
或是m1的加密。我们想证明这两个分布

84
00:05:45,680 --> 00:05:50,183
是计算上不可区分的。
那么基本证明方法是，

85
00:05:50,183 --> 00:05:54,734
上面这个分布，如果我们用真随机函数，而不是PRF。

86
00:05:54,734 --> 00:05:59,362
比如，这里f是一个真随机函数，
那么由于PRF的性质，

87
00:05:59,362 --> 00:06:03,931
攻击者不能区分两个实验。

88
00:06:03,931 --> 00:06:08,617
一个PRF和一个真随机函数是无法区分的，

89
00:06:08,617 --> 00:06:13,244
所以当我们用右边的真随机函数替换左边的PRF时

90
00:06:13,244 --> 00:06:17,601
攻击者的行为是不会变的，你无法区分这两个分布

91
00:06:17,601 --> 00:06:22,067
但现在因为f是一个真随机函数，
这个密码本是真的一次性密码本

92
00:06:22,067 --> 00:06:26,642
因此没有攻击者能够区分在一次性密码本下的

93
00:06:26,642 --> 00:06:30,836
m0和m1的加密。因此这两个分布是一样的

94
00:06:30,836 --> 00:06:35,139
事实上，这有一个等式。这两个分布

95
00:06:35,139 --> 00:06:39,659
就是一样的分布。类似的，当我们从一个真随机函数

96
00:06:39,659 --> 00:06:43,799
回到一个PRF时，因为PRF是安全的，所以攻击者无法区分

97
00:06:43,799 --> 00:06:48,063
下面这两个分布，左边的和右边的。

98
00:06:48,063 --> 00:06:52,655
根据下面这三个等式，
我们证明了这些我们希望证明相等的东西。

99
00:06:52,655 --> 00:06:56,340
实际上计算不可区分的

100
00:06:56,340 --> 00:07:00,874
这是一个非常简单的证明来表明
确定的计数器模式，事实上是安全的。

101
00:07:00,874 --> 00:07:05,409
这个证明和我们之前证明流密码的语义安全是一样的

102
00:07:05,409 --> 00:07:09,874
好，本节完成。下节我们将讨论

103
00:07:09,874 --> 00:07:13,737
能够让我们使用一个密钥加密多个信息的加密模式。【END】

