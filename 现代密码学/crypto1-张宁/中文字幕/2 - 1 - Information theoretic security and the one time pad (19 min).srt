1
00:00:00,000 --> 00:00:04,262
现在，我们已经了解了一些历史上的密码，这些密码都已经被攻破，

2
00:00:04,262 --> 00:00:07,130
我们将改变视角，看一些设计得更好的密码。

3
00:00:10,122 --> 00:00:13,115
但是在那之前，
我想先更精确地定义一下什么是密码。

4
00:00:13,115 --> 00:00:17,432
首先，一个密码实际上是由两个算法构成的。

5
00:00:17,432 --> 00:00:21,694
一个加密算法和一个解密算法。但是

6
00:00:21,694 --> 00:00:26,012
实际上，密码是定义在三元组上的。
所以，所有可能的密钥的集合，

7
00:00:26,012 --> 00:00:31,292
我将用花体的K来表示，
有时我会叫它密钥空间

8
00:00:31,292 --> 00:00:35,968
这是一个包含所有可能的密钥的集合。
这里是可能的信息集合，这是可能的

9
00:00:35,968 --> 00:00:40,365
密文集合。好，
所以这个三元组在某种意义上定义了

10
00:00:40,365 --> 00:00:44,756
这个密码被定义的环境。那么这个密码本身是

11
00:00:44,756 --> 00:00:49,236
一对有效的算法E和D。E是加密算法，

12
00:00:49,236 --> 00:00:57,762
D是解密算法。当然，
加密算法E输入的是密钥和消息，输出的是密文。

13
00:00:57,762 --> 00:01:06,770
解密算法D输入的是密钥和密文，输出的是信息。

14
00:01:06,770 --> 00:01:12,282
这些算法的唯一要求是一致性。它们必须满足

15
00:01:12,282 --> 00:01:17,933
正确性。因此对消息空间中的每个消息

16
00:01:17,933 --> 00:01:23,593
和密钥空间的每个密钥，最好的情况是，
如果我用密钥K

17
00:01:23,593 --> 00:01:29,185
对某个消息进行加密，那么我用同样的密钥
对得到的密文进行解密能够得到原始的消息。

18
00:01:29,185 --> 00:01:34,711
那么，这里的这个等式必须成立，称之为

19
00:01:34,711 --> 00:01:39,974
一致性等式。任何一个密码必须满足这个等式，

20
00:01:39,974 --> 00:01:44,970
否则的话就不能解密。这里我想特别指出

21
00:01:44,970 --> 00:01:49,782
我给“有效”这里加上引号。之所以这么做，

22
00:01:49,782 --> 00:01:54,041
是因为“有效”一词对不同的人意义不同。
如果你更偏重理论，

23
00:01:54,041 --> 00:01:58,811
“有效”意味着多项式时间。
即算法E和D的运行时间相对于

24
00:01:58,811 --> 00:02:02,842
它们输入的大小必须是多项式的。
如果你更偏重于实际

25
00:02:02,842 --> 00:02:07,045
“有效”意味着在能在固定期间内运行。
即比如

26
00:02:07,045 --> 00:02:11,474
可能要求算法E在一分钟内加密1G字节的数据。

27
00:02:11,474 --> 00:02:16,073
现在无论哪种方式，
“有效”都具有这两个方面的含义，你可以

28
00:02:16,073 --> 00:02:20,158
随便按你喜欢的想法来解释。我现在只想指出

29
00:02:20,158 --> 00:02:24,139
带引号的“有效”对于偏重理论的你而言可以理解为

30
00:02:24,189 --> 00:02:27,964
是多项式时间，否则把它想成一个

31
00:02:27,964 --> 00:02:32,100
时间限制也行。另外一点，我想提示大家，
这个算法E

32
00:02:32,100 --> 00:02:36,455
实际上经常是一个随机算法。
这个意味着当你加密

33
00:02:36,455 --> 00:02:40,981
消息的时候，算法E会生成一些随机比特，它会

34
00:02:40,981 --> 00:02:45,676
用这些比特加密要被处理的消息。另一方面

35
00:02:45,676 --> 00:02:50,258
解密算法一般是确定性的。换句话说，已知

36
00:02:50,258 --> 00:02:54,558
密钥和密文，输出永远是相同的。
不依赖于任何

37
00:02:54,558 --> 00:02:58,970
算法的随机性。好，
我们现在对密码的理解

38
00:02:58,970 --> 00:03:03,552
更深入了一些，
现在我想讲一下安全的密码的首个例子。

39
00:03:03,552 --> 00:03:08,364
它叫做一次一密(One-Time-Pad)。
是Vernam在

40
00:03:08,364 --> 00:03:12,724
20世纪初设计的。
在我正式解释这个密码前，让我们

41
00:03:12,724 --> 00:03:17,383
先用我们刚定义的术语研究一下这个密码。
一次一密的

42
00:03:17,383 --> 00:03:22,221
消息空间和密文空间一样，是

43
00:03:22,221 --> 00:03:27,653
n长二元字符串的集合。
这意味着比特序列，

44
00:03:27,653 --> 00:03:33,854
也就是是01字符串。
密钥空间基本和消息空间一样，

45
00:03:33,854 --> 00:03:40,134
是n位二元字符串集合。
所以，一次一密中的密钥

46
00:03:40,134 --> 00:03:46,290
就是简单的随机串，是随机比特序列。
和待加密的消息

47
00:03:46,290 --> 00:03:51,508
长度一样。好，现在我们已经

48
00:03:51,508 --> 00:03:56,726
知道了这个密码被定义的环境，
其实我们也已经知道了

49
00:03:56,726 --> 00:04:02,010
这个密码的操作方式，它其实是很简单的。
所以，本质上密文

50
00:04:02,010 --> 00:04:07,812
是用特定密钥加密消息的结果，就是

51
00:04:07,812 --> 00:04:13,766
两者的简单异或。即K异或M.
我们来快速看一个例子

52
00:04:13,766 --> 00:04:20,026
回忆异或，就是带圆圈的加号

53
00:04:20,026 --> 00:04:26,825
异或就是模2加。如果我有一个特定的消息，
比如说，0110111

54
00:04:26,825 --> 00:04:33,871
取一个特定的密钥，比如说，1011001
当我用这个密钥

55
00:04:33,871 --> 00:04:38,838
加密这个消息时，
我所要做的就是算这两个

56
00:04:38,838 --> 00:04:43,942
字符串的异或。换句话说，
我进行逐比特进行模2加。所以我得到

57
00:04:43,942 --> 00:04:48,645
1101110。这就是密文。
那我怎么解密呢？

58
00:04:48,645 --> 00:04:52,893
我猜是一样的做法。
就是用特定密钥来解密密文。

59
00:04:52,893 --> 00:04:57,248
我要做的就是把密钥和密文再异或一次。这样，

60
00:04:57,248 --> 00:05:01,819
我们需要确认的就是满足一致性要求。我将再慢慢

61
00:05:01,819 --> 00:05:06,443
做一次，然后我觉得这个对你们来说就很容易理解了。

62
00:05:06,443 --> 00:05:10,798
我们将要确保如果我对这个密文解密，

63
00:05:10,798 --> 00:05:14,893
用加密时的那个特定密钥，要得到原始

64
00:05:14,893 --> 00:05:20,481
消息M。这是怎么做到的呢？好，
我们来看。如果我考虑一下k和m的加密过程，

65
00:05:20,481 --> 00:05:25,996
按照定义只是k和m异或，
那k和m的异或用k进行解密是什么呢？

66
00:05:25,996 --> 00:05:31,628
就是k异或m。这样，
我说过，异或是模2加，

67
00:05:31,628 --> 00:05:36,948
加法具有交换律，
所以这个等于(k异或k)异或m，

68
00:05:36,948 --> 00:05:43,007
当然你知道k异或k是零，零异或任何数

69
00:05:43,007 --> 00:05:49,066
就是m。好，这个过程就证明了
一次一密就是个密码构造。

70
00:05:49,066 --> 00:05:54,277
但是，对这个密码的安全没有做任何说明。
现在，我们就要讨论一下

71
00:05:54,277 --> 00:05:58,319
这个密码的安全性。
首先，让我迅速地

72
00:05:58,319 --> 00:06:02,205
给你提个问题，确认我们大家同步。
假设给你一个

73
00:06:02,205 --> 00:06:06,092
消息m和已经被一次一密加密过的密文c。

74
00:06:06,092 --> 00:06:10,522
所以，你已知的是消息和密文。
我的问题是，已知这一对

75
00:06:10,522 --> 00:06:15,467
m和c，你能从m得到c的过程中

76
00:06:15,467 --> 00:06:20,588
推算出进行加密的密钥吗？

77
00:06:20,588 --> 00:06:23,030
我希望你们都能意识到，
实际上，已知明文相对应

78
00:06:23,030 --> 00:06:25,473
的密文，要恢复出密钥是相当容易的。
这里，密钥就是

79
00:06:25,473 --> 00:06:30,241
m⊕c（即m⊕m⊕k=0⊕k=k）
如果你们觉得这种情况不是很显然

80
00:06:30,241 --> 00:06:35,238
我们会在这一讲的后面提到。好，

81
00:06:35,238 --> 00:06:40,198
从操作性能来讲，一次一密是很不错的，
你要做的就是

82
00:06:40,198 --> 00:06:44,656
对密钥和消息进行异或，
所以，对于加密和解密

83
00:06:44,656 --> 00:06:48,464
很长的消息，它非常非常快。
但是，不幸的是，在实际当中

84
00:06:48,464 --> 00:06:52,768
很难使用。很难使用的原因在于，

85
00:06:52,768 --> 00:06:56,907
密钥基本上要和消息一样长才行。
那么，如果Alice和Bob要安全地通信

86
00:06:56,907 --> 00:07:01,321
也就是，你知道Alice要给Bob发消息，

87
00:07:01,321 --> 00:07:06,011
在她开始发第一个比特之前，
她必须给Bob传一个

88
00:07:06,011 --> 00:07:10,536
和消息一样长的密钥。
如果她有办法传一个和消息一样长的安全密钥

89
00:07:10,536 --> 00:07:15,061
她就能用同样的方法传这个消息了。

90
00:07:15,061 --> 00:07:19,439
所以，实际上让密钥和消息一样长是

91
00:07:19,439 --> 00:07:23,490
很有问题的，使得一次一密在实际当中很难使用。

92
00:07:23,490 --> 00:07:28,040
尽管我们在后面会看到一次一密背后的思想还是十分有用的。

93
00:07:28,040 --> 00:07:32,590
但是现在，我还是把重点放在安全性讨论上。

94
00:07:32,590 --> 00:07:36,918
这儿有个很明显的问题，
为什么一次一密是安全的？

95
00:07:36,918 --> 00:07:41,195
为什么它是一个好密码？
那么，为了回答这个问题，首先我们要

96
00:07:41,195 --> 00:07:45,191
回答的是，一个安全的密码是什么？

97
00:07:45,191 --> 00:07:49,759
什么使得密码安全？好的，
为了学习密码的安全性，我们必须

98
00:07:49,759 --> 00:07:54,962
讨论一点信息论。事实上，
严格地研究密码安全性的第一个人

99
00:07:55,150 --> 00:08:00,076
非常有名，就是信息论之父，Claude Shannon

100
00:08:00,076 --> 00:08:05,042
在1949年他发表了一篇著名的论文分析

101
00:08:05,042 --> 00:08:10,603
一次一密的安全性。好了，
香农对安全性的定义是这样的：

102
00:08:10,603 --> 00:08:15,182
基本上就是，如果你看到密文，
那么你应该对明文

103
00:08:15,182 --> 00:08:19,379
绝对一无所知。换句话来说，
密文应该不会

104
00:08:19,379 --> 00:08:23,413
揭示明文的任何信息。

105
00:08:23,413 --> 00:08:28,047
你会明白为什么一个发明信息论的人会提出这个概念

106
00:08:28,047 --> 00:08:32,517
因为你必须公式化地，
正式地解释明文的信息表示什么。

107
00:08:32,517 --> 00:08:37,653
好了，这就是香农干的，让我给你看看香农的定义。

108
00:08:37,653 --> 00:08:42,841
我来慢慢地把它写出来先。
香农说的是，你知道，和前面一样，假如我们

109
00:08:42,841 --> 00:08:48,029
有一个定义在三元组K、M和C上的密码ED。

110
00:08:48,029 --> 00:08:53,411
所以K、M和C定义了密钥空间，
消息空间和密文空间。

111
00:08:53,411 --> 00:08:58,404
当我们说密码具有完善保密性

112
00:08:58,404 --> 00:09:03,592
如果以下条件成立。
对明文空间的任何两个消息M0和M1

113
00:09:03,592 --> 00:09:08,684
这样两个消息，唯一的要求就是

114
00:09:08,684 --> 00:09:13,831
它们有相同的长度。是的，我们只需要，

115
00:09:13,831 --> 00:09:19,106
我们马上就会看到这个要求是必要的。
还有，对密钥空间中的每个密文也是如此。

116
00:09:19,106 --> 00:09:25,221
对每一个明文密文对，（满足以下等式）

117
00:09:25,221 --> 00:09:31,118
最好的情况是，如果我问，有多大概率

118
00:09:31,357 --> 00:09:37,096
用k对m0加密，呃，用k对m0加密得到C，好吧？

119
00:09:37,096 --> 00:09:43,551
那么，有多大的可能，如果我们选一个随机密钥，
有多大的概率我们加密m0，得到c。

120
00:09:43,551 --> 00:09:49,819
这个概率应该和我们加密m1得到c的情况一样。

121
00:09:49,819 --> 00:09:54,920
所以，我们加密m1得到c的概率应该

122
00:09:54,920 --> 00:09:59,955
和加密m0得到c的概率相等。我刚才说

123
00:09:59,955 --> 00:10:04,658
密钥，密钥分布在密钥空间上。
所以，密钥在密钥空间

124
00:10:04,658 --> 00:10:10,157
是均匀分布的.所以k在K上是均匀分布的，我一般写k箭头

125
00:10:10,157 --> 00:10:15,390
上面带个小r来表示k是一个随机变量

126
00:10:15,390 --> 00:10:20,491
在空间K上均匀分布。
好，这是香农定义的主要部分。

127
00:10:20,491 --> 00:10:25,892
现在，让我们再看一下这个定义是在说什么。

128
00:10:25,892 --> 00:10:30,965
那么，这两个概率相等是什么意思？
好，它是说，

129
00:10:30,965 --> 00:10:36,304
如果我是一个攻击者，
我拦截了一个特定的密文C，那么

130
00:10:36,304 --> 00:10:41,577
现实中，这个密文是m0的加密密文和

131
00:10:41,577 --> 00:10:46,798
是m1的加密密文的概率是一样的。因为

132
00:10:46,798 --> 00:10:52,219
这两个概率是相等的。
所以，如果我有，而且仅有截获到的密文C

133
00:10:52,219 --> 00:10:57,639
那么我根本不知道密文是m0的密文

134
00:10:57,639 --> 00:11:03,196
还是m1的密文，因为，
再一次，因为对m1和

135
00:11:03,196 --> 00:11:08,651
m0加密得到c的概率是相等的。

136
00:11:08,651 --> 00:11:13,286
所以这里，我们重申了一下这个定义。
我想把这些性质

137
00:11:13,286 --> 00:11:17,749
再写得更清楚一些。让我们把这个再写一遍。
所以，这个定义表示，

138
00:11:17,749 --> 00:11:22,326
如果给我一个特定的密文，
我不能分辨它是从哪儿来的。

139
00:11:22,326 --> 00:11:27,125
我无法得知它是哪个消息加密而来的。
是m0还是m1？

140
00:11:27,125 --> 00:11:32,090
实际上，这个性质对所有的消息都成立。

141
00:11:32,090 --> 00:11:37,117
对所有的m0和m1.
我不仅仅不能分辨c是m0还是m1的密文，

142
00:11:37,117 --> 00:11:42,144
我也不能分辨它是m2或者m3或者m4的密文，

143
00:11:42,144 --> 00:11:47,109
因为所有的明文生成密文C的概率相同。
这其实是说

144
00:11:47,109 --> 00:11:52,074
如果你用一次一密加密消息，那最强的攻击者

145
00:11:52,074 --> 00:11:56,729
我不管你有多聪明，最厉害的攻击者，

146
00:11:56,729 --> 00:12:02,530
也不可能知道关于明文的任何信息，
不可能从密文知道任何关于

147
00:12:02,530 --> 00:12:09,624
明文的信息。所以从另一个角度来说，

148
00:12:09,624 --> 00:12:16,315
证明了如果具有完善保密性，
那对密码的唯密文攻击是不存在的。

149
00:12:16,315 --> 00:12:23,263
现在，密码攻击不止是唯密文攻击。

150
00:12:23,263 --> 00:12:29,440
实际上，其它攻击也存在，也存在其它攻击。

151
00:12:32,160 --> 00:12:36,772
好，现在让我们来理解一下完善保密性，
也就是说，问题是

152
00:12:36,772 --> 00:12:41,327
我们能构造具有完善保密性的密码吗？
结果是我们不需要再研究多深入

153
00:12:41,327 --> 00:12:45,517
一次一密就具备完善保密性。所以，我

154
00:12:45,517 --> 00:12:50,719
想给大家证明一下香农的第一个结论，
我想给大家证明的这个事实

155
00:12:50,719 --> 00:12:55,858
它其实是个十分简单的证明，
所以让我们继续做做看。

156
00:12:55,858 --> 00:13:01,061
我们需要简单解释一下E(k, m0)=c的概率是什么。

157
00:13:01,061 --> 00:13:06,200
实际上不难看出，对于每一个消息和每一个

158
00:13:06,200 --> 00:13:11,022
每一个密文，在密钥k下对m加密等于c

159
00:13:11,022 --> 00:13:16,161
的概率，就是我们随机选择密钥K的概率

160
00:13:16,161 --> 00:13:23,720
根据定义，这就是，密钥的个数k，属于K。

161
00:13:24,758 --> 00:13:31,533
这样，如果我加密，用k加密得到c。
所以，我就是数一下密钥的个数，

162
00:13:31,533 --> 00:13:37,207
除以密钥的个数，对吧？
这就是它的含义，

163
00:13:37,207 --> 00:13:42,833
如果我随机选择密钥，密钥将m映射到c。
好的，这就是

164
00:13:42,833 --> 00:13:47,707
能将消息m映射到c的密钥的个数除以密钥总数。
这就是这个概率。

165
00:13:47,707 --> 00:13:53,406
所以现在，假设我们有一个密码，
对所有消息和密文，

166
00:13:53,406 --> 00:13:58,967
如果看这个个数，k的个数，k属于K，

167
00:13:58,967 --> 00:14:04,391
使得E(k, m)=c。换句话说，我在找能使

168
00:14:04,391 --> 00:14:09,259
消息m映射成密文c的密钥的个数。
假设这个数恰好是个常数，假如说

169
00:14:09,259 --> 00:14:14,079
恰好就是2,3,或者10或15，它恰好是个

170
00:14:14,079 --> 00:14:19,332
常数，如果是这种情况，
根据定义，对于所有的m0和m1

171
00:14:19,332 --> 00:14:24,747
和c，这个概率必须相同，因为分母相同，

172
00:14:24,747 --> 00:14:30,097
分子也相同，它恰好是个常数，因此，这个概率

173
00:14:30,097 --> 00:14:35,644
对所有的m和c相同。
如果这个性质是正确的，那么这个密码

174
00:14:35,644 --> 00:14:43,616
必然是完善保密的。
好了，让我们看一下一次一密的这个量值。

175
00:14:43,616 --> 00:14:48,804
所以现在，我们的问题是，如果我

176
00:14:48,804 --> 00:14:54,770
有一个消息的密文，一次一密中有多少个密钥，

177
00:14:54,770 --> 00:15:00,381
能把这个消息m映射成c，所以，换句说，

178
00:15:00,381 --> 00:15:06,101
有多少个密钥能使m异或k得到c？我希望你们的答案是1。

179
00:15:06,101 --> 00:15:12,683
那么我们来看看为什么是这样。
对于一次一密来说，如果我们

180
00:15:12,683 --> 00:15:18,303
对消息m用密钥k加密得到c，
但是，基本上，根据定义

181
00:15:18,303 --> 00:15:24,885
这个意味着k异或m等于c。
但是它也简单地表示k等于

182
00:15:24,885 --> 00:15:31,766
m异或c。是的，我只需要在这两边同时异或m就得到k等于

183
00:15:31,766 --> 00:15:37,561
m异或c，对吧？所以，这里是说，
对于一次一密，实际上，

184
00:15:37,561 --> 00:15:43,707
密钥的个数，K中的密钥个数，
满足E(k, m)=c，就是1。而且

185
00:15:43,707 --> 00:15:49,852
这对所有的密文和消息都成立。
所以，和我们前面说的一样，

186
00:15:49,852 --> 00:15:54,987
这说明一次一密具有完善保密性。


187
00:15:54,987 --> 00:15:59,093
完善保密性和完善保密性的证明非常
非常简单。这是一个很简单的引理。

188
00:15:59,093 --> 00:16:03,644
有趣的是，虽然这个引理的证明非常简单，

189
00:16:03,644 --> 00:16:08,194
但是它能证明一个很强的结论。它说明

190
00:16:08,194 --> 00:16:12,328
对于一次一密，没有唯密文攻击。所以不像

191
00:16:12,328 --> 00:16:16,393
代换密码，或者维吉尼亚密码，或者转轮机，

192
00:16:16,393 --> 00:16:20,778
这些密码都能被唯密文攻击破译，
我们刚证明了一次一密

193
00:16:20,778 --> 00:16:25,110
就是不能进行唯密文攻击。
已知密文，你就是不能获得

194
00:16:25,110 --> 00:16:29,281
任何有关明文的消息。
然而，如你所见，这并非故事的结局。

195
00:16:29,281 --> 00:16:33,131
我是说，我们结束了吗？我的意思是，
我们关于密码这门课学完了吗？

196
00:16:33,131 --> 00:16:37,359
因为我们有办法，对一个消息加密，而攻击者无法破译。

197
00:16:37,359 --> 00:16:41,206
所以有可能，我们学完了。
但是实际上，后面我们会看到

198
00:16:41,206 --> 00:16:45,261
还有其它的攻击。而且，
事实上，一次一密并不是

199
00:16:45,261 --> 00:16:49,316
一种安全的密码。事实是，
还有其他可能的攻击，我们很快

200
00:16:49,316 --> 00:16:54,075
就会讲到。这里我再次强调，
具备完善保密性

201
00:16:54,075 --> 00:16:58,785
并不意味着一次一密是一个安全可用的密码。
好的，但是我们前面

202
00:16:58,785 --> 00:17:03,733
说过一次一密的问题在于，密钥实在太长了。

203
00:17:03,733 --> 00:17:08,071
如果你有办法在通信双方协商秘密密钥，
你就可以用同样

204
00:17:08,071 --> 00:17:12,253
的方法进行消息通信。

205
00:17:12,253 --> 00:17:16,652
这种情况下，你根本就不用密码了，
好吧？所以问题又出现了，

206
00:17:16,652 --> 00:17:21,105
一次一密有很长的密钥，
显而易见的问题是，

207
00:17:21,105 --> 00:17:25,450
有没有其它密钥具备完善保密性，
而且可能只有较短的密钥？

208
00:17:25,450 --> 00:17:30,136
好的，坏消息是，香农证完一次一密有

209
00:17:30,136 --> 00:17:34,945
完善保密性后，证明了另外一个定理，
这个定理说，实际上，如果一个密码

210
00:17:34,945 --> 00:17:39,878
具备完善保密性，
那么密钥的个数至少要和这个密码

211
00:17:39,878 --> 00:17:44,935
要加密的消息一样多。特别地，这意味着

212
00:17:44,935 --> 00:17:51,037
如果我具备完善保密性，那么密钥个数，或者我密钥的长度

213
00:17:51,037 --> 00:17:56,309
必须比消息长度要大。实际上，

214
00:17:56,309 --> 00:18:00,834
因为一次一密满足这里的等号，
所以，一次一密是一种最优的

215
00:18:00,834 --> 00:18:04,862
具备完善保密性的密码，
好吧？这是一个

216
00:18:04,862 --> 00:18:09,056
很有趣的概念。一次一密是一个很有趣的密码。
但是，事实上在现实中，

217
00:18:09,056 --> 00:18:13,360
它很难被实际应用。
因为它的长密钥，使得它在

218
00:18:13,360 --> 00:18:17,790
实际中很难用。所以，
完善保密性这个概念，

219
00:18:17,790 --> 00:18:21,840
尽管它很有趣，但是，
它基本上不能告诉我们

220
00:18:21,840 --> 00:18:26,279
实际当中的密码是否安全。
尽管如此，我们会看到，我们前面说过

221
00:18:26,279 --> 00:18:30,994
一次一密背后的想法是很好的。
我们将会看到，下一节，

222
00:18:30,994 --> 00:18:33,547
我们怎么样把这种想法做成一个实用的系统。【END】