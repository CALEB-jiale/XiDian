1
00:00:00,000 --> 00:00:03,843
在这个小节,我想告诉你另一个密钥交换方法基于

2
00:00:03,843 --> 00:00:07,714
公钥加密的概念 我要再一次提醒你们的那个系统 我们

3
00:00:07,714 --> 00:00:11,916
一如既往 我们的好朋友爱丽丝和鲍勃 他们彼此交换密钥K

4
00:00:11,916 --> 00:00:15,402
窃听者可以看到他们发送给对方的消息 但是

5
00:00:15,402 --> 00:00:19,270
尽管他不知道关于密钥K的任何信息

6
00:00:19,270 --> 00:00:22,900
和往常一样 在这个小节 我们来看窃听安全性

7
00:00:22,900 --> 00:00:26,725
再次提醒你们一下，这里我们不允许攻击者篡改数据

8
00:00:26,725 --> 00:00:30,719
或其他任何形式的主动攻击。在这一周的开头我们

9
00:00:30,719 --> 00:00:34,514
看了一个基于通用分组密码的低效率的机制，在之前的部分

10
00:00:34,514 --> 00:00:38,009
我们学习了Diffie-Hellman密钥交换机制

11
00:00:38,009 --> 00:00:42,153
这是一个参与者与攻击者所要做的工作有指数差距的机制

12
00:00:42,153 --> 00:00:46,198
事实上这个Diffie-Hellman协议

13
00:00:46,198 --> 00:00:49,992
在网页上用的很频繁 这节课我要给你们讲一种

14
00:00:49,992 --> 00:00:54,309
基于公开密钥加密的不同的方法 那什么是公开加密？ 就像

15
00:00:54,309 --> 00:00:58,891
在对称加密的情况下 这是对称加密的加密算法

16
00:00:58,891 --> 00:01:03,415
和解密算法 然而这里的加密算法给定了一个密钥

17
00:01:03,415 --> 00:01:07,764
就是我们所谓的公开密钥 我们称它为鲍勃的公钥

18
00:01:07,764 --> 00:01:12,172
解密算法给定了另外的密钥

19
00:01:12,172 --> 00:01:16,696
我们称之为私钥 它也是鲍勃的 这两个密钥有时

20
00:01:16,696 --> 00:01:24,144
被合称为密钥对 密钥对的一半是公钥 另一半是

21
00:01:24,144 --> 00:01:28,752
私钥 现在你们的加密方式跟往常一样 一个消息

22
00:01:28,752 --> 00:01:33,187
进来 加密算法会生成一个密文 这是

23
00:01:33,187 --> 00:01:38,026
用公钥加密的消息 当这个密文

24
00:01:38,026 --> 00:01:42,864
被送到解密算法那里 解密算法会输出

25
00:01:42,864 --> 00:01:47,645
相应的消息 如我所说 PK是公钥 SK是

26
00:01:47,645 --> 00:01:52,308
私钥 更准确地说 什么是公开加密  公开加密

27
00:01:52,308 --> 00:01:56,957
通常由三个算法组成 G E和D 算法G是被称为

28
00:01:56,957 --> 00:02:01,492
密钥生成算法 当你运行算法G的时候 它会输出两个密钥

29
00:02:01,492 --> 00:02:05,744
公钥和私钥 加密算法的消息中

30
00:02:05,744 --> 00:02:10,053
给出公钥 就会输出相应的密文

31
00:02:10,053 --> 00:02:14,418
解密算法的密文中给出私钥 就会

32
00:02:14,418 --> 00:02:19,332
输出原文 如果发生错误 它将停止输出 像往常一样

33
00:02:19,332 --> 00:02:24,269
和我们通常的一致性属性说 对于任何密钥生成算法

34
00:02:24,269 --> 00:02:29,148
输出的公钥和私钥 如果我们使用的公钥加密消息

35
00:02:29,148 --> 00:02:33,794
然后使用私钥解密 我们就能够得到

36
00:02:33,794 --> 00:02:38,313
原始消息 什么意味着这个公钥系统是安全的？

37
00:02:38,313 --> 00:02:42,975
我们用之前使用过的语义安全的概念 除了这个游戏

38
00:02:42,975 --> 00:02:47,300
现在有点难 我来解释一下 我们该如何定义语义

39
00:02:47,300 --> 00:02:51,737
公钥系统的安全 这里 挑战者会运行这个密钥 生成

40
00:02:51,737 --> 00:02:56,287
算法生成一个公钥和一个私钥对 他要把这个

41
00:02:56,287 --> 00:03:00,242
公钥给对手 挑战者自己保留私钥

42
00:03:00,242 --> 00:03:05,373
对手要做的是 他会像之前一样输出两个等长的消息M0和

43
00:03:05,373 --> 00:03:10,321
M1 然后这个挑战者会给他M0和M1的密文

44
00:03:10,321 --> 00:03:15,147
像往常一样 我们定义两个试验：试验0和试验1 试验0中

45
00:03:15,147 --> 00:03:20,279
对手已知M0的密文 试验1中对手

46
00:03:20,279 --> 00:03:24,860
已知M1的密文 然后对手的目标是猜测

47
00:03:24,860 --> 00:03:29,381
他已知的是哪个密文 是M0的密文还是

48
00:03:29,381 --> 00:03:34,945
M1的密文呢 我们指的是他猜测输出是试验0

49
00:03:34,945 --> 00:03:40,119
还是试验1 有一件事我要强调 对于公共

50
00:03:40,119 --> 00:03:44,590
加密 没必要给攻击者太多选择明文加密

51
00:03:44,590 --> 00:03:49,083
攻击的能力 为什么呢？在一个对称密钥系统中

52
00:03:49,083 --> 00:03:53,813
攻击者必须先请求他所选择的消息的密文 在对称

53
00:03:53,813 --> 00:03:58,081
密钥系统中 攻击者拥有公钥 因此他可以自己

54
00:03:58,081 --> 00:04:02,350
为自己加密任何他想要的消息 他不需要

55
00:04:02,350 --> 00:04:07,022
挑战者帮助去产生他所选择的消息的密文 因此

56
00:04:07,022 --> 00:04:11,348
在公钥系统中 选择密文攻击是固有的 我们没有理由

57
00:04:11,348 --> 00:04:16,035
给攻击者额外的力量去增加这一个选择密文攻击

58
00:04:16,035 --> 00:04:20,513
这就是我们我们从不讨论选择明文查询的上下文中

59
00:04:20,513 --> 00:04:25,210
定义的语义查询公钥系统的安全的原因 我们定义的

60
00:04:25,210 --> 00:04:29,539
那个游戏 我们会说,一个公钥系统GED基本上

61
00:04:29,539 --> 00:04:34,093
是语义安全 如果攻击者无法区分试验0和试验1

62
00:04:34,093 --> 00:04:38,534
换句话说 对手在试验0输出1的概率和

63
00:04:38,534 --> 00:04:42,920
他在试验1输出1的概率相同

64
00:04:42,920 --> 00:04:47,024
所以 攻击者不能确定他是已知M0的密文

65
00:04:47,024 --> 00:04:51,694
还是M1的密文 现在我们理解了什么是公钥加密

66
00:04:51,694 --> 00:04:56,151
我们来看如何使用它来建立一个共享的秘密 这是我们的朋友爱丽丝和

67
00:04:56,151 --> 00:05:00,666
鲍勃 爱丽丝将开始通过密钥生成算法给自己

68
00:05:00,666 --> 00:05:04,952
生成一个随机的公钥密钥对 她要把公钥PK

69
00:05:04,952 --> 00:05:09,523
发送给鲍勃 她还说 嗨 这个消息是来自爱丽丝的 鲍勃

70
00:05:09,523 --> 00:05:14,324
要做的是 他会产生一个128比特的随机数值X 并把这些发送给爱丽丝

71
00:05:14,324 --> 00:05:19,124
说 嗨这个消息来自鲍勃 而且他会返回X在爱丽丝的

72
00:05:19,124 --> 00:05:23,674
公钥加密下的值 爱丽丝会收到这个密文 她会用自己的

73
00:05:23,674 --> 00:05:28,686
私钥解密 她会得到X的值 现在X的值

74
00:05:28,686 --> 00:05:34,339
可以被当做他们之间的共享秘密 我要强调的是

75
00:05:34,339 --> 00:05:38,966
这个协议跟我们在上节课中看到的Diffie-Hellman协议

76
00:05:38,966 --> 00:05:43,375
很不一样 这里 当事人必须轮流发送 在某种意义上

77
00:05:43,375 --> 00:05:47,730
鲍勃不能发送消息 直到他从爱丽丝接收消息

78
00:05:47,730 --> 00:05:52,316
换句话说 鲍勃不能用爱丽丝的公钥加密X直到他从爱丽丝那里收到公钥

79
00:05:52,316 --> 00:05:56,272
然而在Diffie-Hellman协议中 这两个参与者可以

80
00:05:56,272 --> 00:06:00,802
随心所欲的发送消息 完全没有顺序限制

81
00:06:00,802 --> 00:06:04,808
这样就有了一个很好的例子关于Diffie-Hellman的应用

82
00:06:04,808 --> 00:06:08,887
例如 每个人都可以在FACEBOOK上上传他们的消息

83
00:06:08,887 --> 00:06:13,190
我们简单来看下FACEBOOK 任何一对都会有一个共有的密钥

84
00:06:13,190 --> 00:06:17,492
而不需要任何附加的联系

85
00:06:17,492 --> 00:06:21,963
这里 并不是非常正确 即使每个人都可以把他们的密钥发送给FACEBOOK

86
00:06:21,963 --> 00:06:26,380
他们也仍旧需要发送一条信息在密钥生成之前。

87
00:06:26,380 --> 00:06:30,997
现在 我们理解了这个协议 那么第一个问题来了 为什么这个协议是安全的

88
00:06:30,997 --> 00:06:35,556
通常我们会仅仅看它的窃听安全性

89
00:06:35,556 --> 00:06:40,173
针对这个协议 攻击者会先观察公钥以及用公钥加密的X的密文

90
00:06:40,173 --> 00:06:44,960
然后 他就会要来求出X的值

91
00:06:44,960 --> 00:06:49,748
现在我们就知道了公钥系统是语义上安全的

92
00:06:49,748 --> 00:06:54,151
这就意味着攻击者不能从随机序列中区分出X

93
00:06:54,151 --> 00:06:59,164
换句话说 仅仅给出X的密文

94
00:06:59,164 --> 00:07:04,164
攻击者是不能得知他得到的是X的明文 还是M中一段随机码

95
00:07:04,164 --> 00:07:08,920
正因为这样 我们可以说 通过观察这个协议中的消息

96
00:07:09,103 --> 00:07:13,980
攻击者不能从M的随机元素中区分出X的值

97
00:07:13,980 --> 00:07:18,797
结果就是 X可以被这两个参与者作为会话密钥

98
00:07:18,797 --> 00:07:23,370
仅仅通过一个随机值 攻击者是不能

99
00:07:23,370 --> 00:07:28,014
猜测到M中的所有其他可能值的

100
00:07:28,014 --> 00:07:32,483
那么 我可以说 从语义安全上来说 这两个分布是不可区分的

101
00:07:32,483 --> 00:07:36,234
事实上 这有一个简单的练习

102
00:07:36,234 --> 00:07:39,984
假如攻击者可以区分这两个分布

103
00:07:39,984 --> 00:07:44,218
那他同样可以打破语义安全性 通常来说

104
00:07:44,218 --> 00:07:48,816
即使这个协议面对窃听是安全的 那它针对中间人攻击也是不安全的

105
00:07:48,816 --> 00:07:53,488
好吧 我们来看个中间人攻击的例子

106
00:07:53,488 --> 00:07:58,257
爱丽丝生成了她自己的公钥密钥对

107
00:07:58,257 --> 00:08:02,561
同时中间人也生成他的公钥密钥对

108
00:08:02,561 --> 00:08:07,156
当爱丽丝把她的公钥发送给鲍勃时 中间人截获了公钥

109
00:08:07,156 --> 00:08:11,808
然后他用一条消息来替代爱丽丝的公钥

110
00:08:11,808 --> 00:08:16,169
但是因为爱丽丝的公钥是最初的 所以鲍勃收到这条消息

111
00:08:16,169 --> 00:08:20,461
他会认为这是一条来自爱丽丝的消息 并且他会选择一个随机数X

112
00:08:20,461 --> 00:08:24,535
然后会把最初的PK加密过的X发送回爱丽丝

113
00:08:24,535 --> 00:08:28,882
中间人将会截获这条消息 并且他会用别的东西替换它

114
00:08:28,882 --> 00:08:33,065
他的目标是确保密钥被成功替换掉

115
00:08:33,065 --> 00:08:37,412
换句话说爱丽丝人认为她收到了一条来自鲍勃的消息

116
00:08:37,412 --> 00:08:41,541
并且中间人也会准确地知道他们所交换的秘密是什么

117
00:08:41,541 --> 00:08:47,211
那么这种情况下 中间人应该给爱丽丝发送什么呢 我们先称之为密文C

118
00:08:47,211 --> 00:08:51,783
中间人会用他自己的密钥来解密密文C

119
00:08:51,783 --> 00:08:56,356
这样就会将X暴露在中间人面前 然后

120
00:08:56,356 --> 00:09:00,873
他就会直接用爱丽丝的公钥来加密X 并将其发送给爱丽丝

121
00:09:00,873 --> 00:09:05,220
爱丽丝得到了这个X 并且她以为自己和鲍勃交换了密钥

122
00:09:05,220 --> 00:09:09,849
他们两个都得到了X的值 但问题是

123
00:09:09,849 --> 00:09:14,418
中间人也知道了X的值 所以这个协议是完全不安全的

124
00:09:14,418 --> 00:09:19,264
一旦中间人篡改了爱丽丝和鲍勃之间的消息的话

125
00:09:19,264 --> 00:09:23,772
所以我们来做些事情来让这个协议变得安全

126
00:09:23,772 --> 00:09:28,280
我们要做的是 数字签名

127
00:09:28,280 --> 00:09:32,557
那么现在 我要告诉你们的就是 公钥加密意味着

128
00:09:32,557 --> 00:09:36,633
面对窃听的密钥交换安全 那我们如何来构建一个公钥加密系统呢

129
00:09:36,633 --> 00:09:40,761
一般来说 我们需要依靠数字理论和代数

130
00:09:40,761 --> 00:09:44,941
就像Diffie-Hellman协议依靠代数构建而成

131
00:09:44,941 --> 00:09:49,017
在我们看这些协议的更多细节之前

132
00:09:49,017 --> 00:09:53,406
我想简单的绕个弯 说个别的东西 在下一小节中

133
00:09:53,406 --> 00:09:57,743
我们要介绍下相关的数字理论的背景 我们会用一个小节介绍它

134
00:09:57,743 --> 00:10:02,317
然后再回来看公钥设施以及更多密钥交换的例子

135
00:10:02,317 --> 00:10:06,818
所以这就是这一小节的结尾了 提前预习下

136
00:10:06,818 --> 00:10:11,705
第一张上面我想在这里指出的是 如果我们依靠对称加密

137
00:10:11,705 --> 00:10:16,062
以及Hash函数 那么Merkle谜题就是最好的关于密钥交换

138
00:10:16,062 --> 00:10:20,713
并且事实上 我们不可能比一个平方鸿沟做的更多

139
00:10:20,713 --> 00:10:25,077
除非我们先得到原始的黑匣子

140
00:10:25,077 --> 00:10:28,994
所以说 平方鸿沟是最好的可能

141
00:10:28,994 --> 00:10:33,110
然后另一张上面总结了我们说过的这些密钥交换机制

142
00:10:33,110 --> 00:10:37,176
包括了使用公钥加密的密钥交换和使用了Diffie-Hellman的密钥交换。


143
00:10:37,176 --> 00:10:41,342
你可以看一下这一页 可以预习下后面的东西

144
00:10:41,342 --> 00:10:45,557
也可以明白怎么让密钥交换协议怎么抵御中间人攻击

145
00:10:45,557 --> 00:10:49,956
而不仅仅是面对窃听 好吧 这一小节到这里就结束了

146
00:10:49,956 --> 00:10:54,480
在下一节中 我们会简单的说一下

147
00:10:54,480 --> 00:10:56,080
算数和数字理论。【END】

