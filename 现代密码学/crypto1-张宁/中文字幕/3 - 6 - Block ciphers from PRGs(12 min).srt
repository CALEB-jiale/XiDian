1
00:00:00,000 --> 00:00:04,388
本节,我们会提出一个问题,是否能使用简单基元 
如伪随机数发生器来建造分组密码?

2
00:00:04,388 --> 00:00:09,456
而接下来我们会证明答案是肯定的。
所以首先，我们会问，

3
00:00:09,456 --> 00:00:14,215
能否利用伪随机数发生器构建伪随机函数

4
00:00:14,215 --> 00:00:18,789
而不是伪随机置换。
也就是我们能否由PRG构建PRF?

5
00:00:18,789 --> 00:00:23,873
尽管我们的最终目标是建造一个分组密码，
也就是伪随机置换，最终我们会达到这个目标

6
00:00:23,873 --> 00:00:29,130
那现在，我们要构造一个伪随机函数。
所以我们从可以将输入延长一倍的伪随机数产生器开始

7
00:00:29,130 --> 00:00:34,590
所以伪随机数产生器的种子就是K里面的一个元素，

8
00:00:34,590 --> 00:00:39,420
输出为K里面的两个元素，
这里我们有一个发生器的原理图。

9
00:00:39,420 --> 00:00:44,296
产生器得到C和K做为输入，
然后输出K中的两个元素

10
00:00:44,296 --> 00:00:48,992
伪随机数发生器是安全的指的是：

11
00:00:48,992 --> 00:00:52,965
不能从输出中区别出K^2里面的任意元素

12
00:00:52,965 --> 00:00:58,355
事实上，依伪随机数产生器定义1位伪随机数函数是非常容易的。

13
00:00:58,355 --> 00:01:03,455
所以1比特伪随机数函数指的是，

14
00:01:03,455 --> 00:01:08,360
定义域仅为1比特的伪随机数函数，
也就是只以一比特长度为输入

15
00:01:08,360 --> 00:01:13,461
所以，我们这里会说，如果输入位X是0

16
00:01:13,461 --> 00:01:18,627
那么我就会将PRF输出赋值为左边这个，
如果输入位X是1，那我就会将PRF输出赋值为右边这个

17
00:01:18,627 --> 00:01:23,678
如果以符号表示的话，就是在这写的这个公式

18
00:01:23,678 --> 00:01:28,523
可以很明显地看到，G就是一个安全的PRG，
那么这个1比特PRF事实上就是

19
00:01:28,523 --> 00:01:32,901
一个安全PRF，如果你思考片刻就会知道，
这完全是无谓的重复，

20
00:01:32,901 --> 00:01:37,571
将同样的事叙述两次，所以我会把这个留给你们

21
00:01:37,571 --> 00:01:42,241
去思考更简洁的叙述方式，
并说服自己这个理论是正确的。

22
00:01:42,241 --> 00:01:46,853
真正要解决的问题是我们是否能建立
一个PRF使之具有大于1比特的定义域。

23
00:01:46,853 --> 00:01:51,756
理想情况下，我们希望定义域为128比特。

24
00:01:51,756 --> 00:01:56,425
正如AES的域一样，那么问题就在于我们能否用
一个伪随机数产生器来构建一个128位PRF？

25
00:01:56,425 --> 00:02:01,197
好了，让我们来看看我们能否取得进展。

26
00:02:01,197 --> 00:02:05,970
那么我们要做的第一件事是，

27
00:02:05,970 --> 00:02:10,863
以一个可以允许两倍输入的PRG开始，
看我们是否能建一个能够接受四倍输入的PRG。

28
00:02:10,863 --> 00:02:15,797
所以流程为从K→K^4 而不是K→K^2。
好的，让我们看看怎么完成这个过程。

29
00:02:15,797 --> 00:02:20,809
我们从能够两倍化输入的PRG开始

30
00:02:20,809 --> 00:02:25,884
这里需要记住的是，这个是PRG，这意味着

31
00:02:25,884 --> 00:02:30,771
它的输出和K中的两个随机值不可区分，

32
00:02:30,771 --> 00:02:35,847
如果输出与K中的两随机值相似，
那我们就可以将这两个输出再次送入PRG。

33
00:02:35,847 --> 00:02:40,358
假设我们先把左边的输出送入PRG。

34
00:02:40,358 --> 00:02:45,342
再把右边的这个输出送入PRG 然后我们称这

35
00:02:45,342 --> 00:02:50,448
四元组的输出为G1(K)，这里我用符号表示

36
00:02:50,448 --> 00:02:55,554
这个生成器的行为，但你能从这个图中看出。

37
00:02:55,554 --> 00:03:00,862
产生器的工作方式，所以我们有一个能做到K→K^4的产生器。

38
00:03:00,862 --> 00:03:06,170
实质上也得到了一个2比特的PRF。
换句话说 给定两比特

39
00:03:06,170 --> 00:03:11,410
00, 01, 10或11就可以输出与G1(K)输出对应的特定分组。

40
00:03:11,410 --> 00:03:16,070
所以 我们这里就有了一个可以

41
00:03:16,070 --> 00:03:21,061
接收四种输入的PRF，而不是像前面那样，
只有两种可能输入的PRF了

42
00:03:21,061 --> 00:03:26,113
那么问题是为什么G1是安全的？ 
为什么G1是个安全的PRG？

43
00:03:26,113 --> 00:03:30,611
为什么这个四元组输出与随机序列不可被区分？

44
00:03:30,611 --> 00:03:35,664
让我们仅仅以图片形式快速证明这些问题 

45
00:03:35,664 --> 00:03:40,408
这个是我们想证明是安全的产生器，
我们试图证明其安全性。

46
00:03:40,408 --> 00:03:45,399
这意味着我们想证明这个分布与
K^4中的随机四元组是不可区分的、

47
00:03:45,399 --> 00:03:49,292
所以我们的目标是证明

48
00:03:49,292 --> 00:03:53,887
这两个是不可区分的。
我们一步一步来，我们知道这个产生器

49
00:03:53,887 --> 00:03:58,028
是安全的。因此，第一层的输出

50
00:03:58,028 --> 00:04:02,453
与随机数是不可区分的。
换句话说，如果我们以真随机串替换第一层。

51
00:04:02,453 --> 00:04:06,991
这两个是从密钥空间中选出的真随机串，

52
00:04:10,267 --> 00:04:11,359
那么没有有效的攻击能够区分这两个分布。事实上，

53
00:04:11,359 --> 00:04:15,954
如果你可以区分这两个分布，那很容易证明，

54
00:04:15,954 --> 00:04:20,768
你也可以破解最初的PRG，
你应该知道我们能进行替换，

55
00:04:20,768 --> 00:04:25,581
(以真随机值替换G的输出)的原因是PRG的定义，

56
00:04:25,581 --> 00:04:30,578
即PRG的输出与随机数是不可区分的。

57
00:04:30,578 --> 00:04:35,391
所以，我们同样可以将随机数放到这里。

58
00:04:35,391 --> 00:04:40,265
并且没有有效的攻击可以分辩出这两个分布。
目前为止一切还算顺利，

59
00:04:40,265 --> 00:04:45,018
现在我们给左边做同样的处理，换句话说，

60
00:04:45,018 --> 00:04:49,710
我们以真随机输出替换这两个伪随机输出。

61
00:04:49,710 --> 00:04:53,925
同样地，由于发生器G是安全的，
所以没有有效的攻击可以辨别出

62
00:04:54,091 --> 00:04:57,807
这两种分配方式的区别。但不同的是，

63
00:04:57,807 --> 00:05:02,077
如果一个攻击者可以分辨这两种分配方式的不同，
那我们也可以给出

64
00:05:02,077 --> 00:05:06,707
一个对发生器G的攻击。最后我们再做一次替换，

65
00:05:06,707 --> 00:05:11,280
我们以真随机对替换掉这一伪随机对，你看！

66
00:05:11,280 --> 00:05:15,672
我们获得了我们想要的分布，

67
00:05:15,672 --> 00:05:19,851
也就是以四个独立分组构成的分布，
我们已经证明在这个转换中，

68
00:05:19,851 --> 00:05:23,279
这两个是无法区分的，

69
00:05:23,279 --> 00:05:27,243
这两个是无法区分的，
还有这两个是不可区分的。因此，

70
00:05:27,243 --> 00:05:31,475
这两个也是无法区分的。
这正是我们想证明的，

71
00:05:31,475 --> 00:05:35,760
这是证明的大致想法，
要想用其它方法严谨地证明并非难事。

72
00:05:35,760 --> 00:05:39,792
但我只想告诉大家直观的证明思路

73
00:05:39,792 --> 00:05:44,363
如果我们可以延长发生器输出一次，
那就没有什么能阻止我们再延长一次。

74
00:05:44,363 --> 00:05:48,822
于是这里有一个输出密钥空间中四个元素的发生器G1。

75
00:05:48,822 --> 00:05:53,337
并且记住，这里的输出与随机四元组是不可区分的。

76
00:05:53,337 --> 00:05:57,909
就是我们刚证明过的，
我们完全可以再次用这个发生器延长输出。

77
00:05:57,909 --> 00:06:02,480
这里我们用这个发生器来延长这个看似随机的串，

78
00:06:02,480 --> 00:06:07,221
当然得到的也是一个看似随机的串，就是这一对。

79
00:06:07,221 --> 00:06:11,511
我们当然能一次又一次地延长输出，

80
00:06:11,511 --> 00:06:16,405
所以基本上，我们建立了一个可以输出K^8中元素的发生器。

81
00:06:16,405 --> 00:06:21,261
与前面的K^4发生器不同。还有，

82
00:06:21,261 --> 00:06:26,056
其安全性证明与我前面展示的方法一样，
也就是那个以真随机输出替换原输出的方法。

83
00:06:26,056 --> 00:06:30,612
所以我们会先将这个替换为真随机输出，

84
00:06:30,612 --> 00:06:35,168
然后这里、接着那里、然后这里、再接着那里等等，直到，

85
00:06:35,168 --> 00:06:39,724
最后我们得到真正的随机字符串，
并且以G2(K)开始的两个原始分配

86
00:06:39,724 --> 00:06:44,396
与真随机数是不可区分的。

87
00:06:44,396 --> 00:06:49,325
到目前还好，所以我们得到了一个能输出K^8中元素的发生器。

88
00:06:49,325 --> 00:06:54,016
基本上就是一个3比特PRF，换句话说，

89
00:06:54,016 --> 00:06:58,884
在000时，我们输出这个分组，以此类推，直到111时，

90
00:06:58,884 --> 00:07:03,163
它会输出这个分组。
现在，有趣的是事实上这个PRF很容易计算。

91
00:07:03,163 --> 00:07:07,695
例如，如果我们想要计算PRF，

92
00:07:07,695 --> 00:07:11,948
在101时的输出，注意这个是3比特PRF，
所以选101，接下来呢？

93
00:07:11,948 --> 00:07:16,536
我们先以原始密钥K开始，然后我们会使用发生器G，

94
00:07:16,536 --> 00:07:20,620
但我们只关注G输出的右侧，

95
00:07:20,620 --> 00:07:25,040
因为第一个比特是1，接下来，我们再使用发生器一次。

96
00:07:25,040 --> 00:07:29,516
但是我们只关注左边的输出，

97
00:07:29,516 --> 00:07:33,864
因为第二个比特是0。再之后，
我们再用一次发生器，并且只关注

98
00:07:33,864 --> 00:07:38,588
右侧的输出。因为第三个比特是1，然后

99
00:07:38,588 --> 00:07:43,140
这个输出就是最终输出，
就像你看到的，这个就是101的情况。

100
00:07:43,140 --> 00:07:47,461
事实上因为整个发生器是伪随机的，
所以我们可以知道

101
00:07:47,461 --> 00:07:52,796
这个输出也是伪随机的，
这就给了我们一个3比特的PRF，

102
00:07:52,796 --> 00:07:58,632
好了，既然这个过程能生效三次，
那没就有理由不能生效N次，

103
00:07:58,632 --> 00:08:03,501
一如果我们次又一次地运用这种转换，
最终我们就会得到一个GGMPRF。

104
00:08:03,501 --> 00:08:07,956
GGM是指Goldreich、Goldwasser、Micali 他们是这个PRF的发明家，

105
00:08:07,956 --> 00:08:12,528
这个PRF的工作方式是这样的：
我们以一个两倍化输出的发生器开始，

106
00:08:12,528 --> 00:08:17,279
之后我们能够建一个拥有巨大定义域的PRF，

107
00:08:17,279 --> 00:08:22,236
这个域的大小为0 1一直到N，这里N可以是128甚至更大。

108
00:08:22,236 --> 00:08:26,897
让我们来看看，假设给定一个
长为N的0、1比特输入，我会展示给你们

109
00:08:26,897 --> 00:08:31,274
怎么求这个PRF，当然你现在应该也有一个应该怎么做的想法。

110
00:08:31,274 --> 00:08:35,480
基本上，我们以原始密钥开始，然后使用

111
00:08:35,480 --> 00:08:40,255
发生器并且以X0的比特来决定来选择左、右的输出。

112
00:08:40,255 --> 00:08:44,746
之后我们得到了下一密钥K1，然后我们继续使用发生器，

113
00:08:44,746 --> 00:08:49,444
并以X1的值决定输出是左边还是右边，
这步我们得到下一个密钥，

114
00:08:49,444 --> 00:08:54,730
然后我们循环做这个步骤，
直到我们得到最后的输出。

115
00:08:54,730 --> 00:08:59,818
这样我们就处理了所有的比特，
并且得到了整个函数的输出。

116
00:08:59,818 --> 00:09:05,170
而且我们可以用前面证明的方法来证明整个过程的安全性。

117
00:09:05,170 --> 00:09:10,324
这样我们就能知道，如果G是一个安全的PRG，
那么事实上 我们就得到了一个安全的PRF。

118
00:09:10,324 --> 00:09:14,917
它定义在{0,1}^N上且具有很大的定义域。
整个过程很奇炒，

119
00:09:14,917 --> 00:09:19,064
本质上，我们就有了一个可证其安全的PRF 。

120
00:09:19,064 --> 00:09:23,495
以安全的发生器为前提，并且整个发生器(近似于PRF)，

121
00:09:23,495 --> 00:09:28,153
比一个实际的PRF更容易建造。
它还可以处理非常大的分组，

122
00:09:28,153 --> 00:09:33,296
特别地，如128位的01比特串。
这正是我们需要的，所以你可能会问到，

123
00:09:33,296 --> 00:09:39,122
为什么不在实际中应用这个东西呢？
原因是 它的速度很慢。

124
00:09:39,122 --> 00:09:44,597
想象现在我们接通一个发生器，一个salsa发生器。

125
00:09:44,597 --> 00:09:50,142
现在来计算这个PRF在某个128位输入的值，
我们必须要运行这个salsa发生器。

126
00:09:50,142 --> 00:09:55,617
128次，一次只对应一位输入，
这样我们会得到一个PRF。

127
00:09:55,617 --> 00:10:01,513
其运行时间却是原本Salsa的128倍，
这比AES慢太多太多。

128
00:10:01,513 --> 00:10:06,227
AES是一种启发式PRF，但不管怎么样，
它比我们刚做出来的这个要快得多。

129
00:10:06,227 --> 00:10:10,585
所以即使它的结构非常简洁，我们依然不会用。

130
00:10:10,585 --> 00:10:14,522
它来建造伪随机函数，虽然本周我们会

131
00:10:14,522 --> 00:10:18,915
用这种结构来构建数据完整性的机制。最后，

132
00:10:18,915 --> 00:10:23,183
我们已经建了一个PRF，但问题是，我们是否能够

133
00:10:23,183 --> 00:10:27,729
构建分组密码？换句话说，
我们能否从一个安全的PRG构建一个安全的PRP？

134
00:10:27,729 --> 00:10:32,054
迄今我们所做的一切并不是可逆的

135
00:10:32,054 --> 00:10:36,600
如果你们看着这个结构，只给定最后输出，并不能解密出明文。

136
00:10:36,600 --> 00:10:40,535
你不能逆向返回，或者至少，
我们不知道怎么逆向返回出原明文。

137
00:10:40,535 --> 00:10:44,520
所以现在一个比较有趣的问题是我们能不能解决

138
00:10:44,520 --> 00:10:48,654
我们最初想要解决的那个问题，也就是，
我们能不能根据安全的PRG构建一个分组密码？

139
00:10:48,654 --> 00:10:53,540
我会留点时间让你们考虑，并记下答案，

140
00:10:53,540 --> 00:10:57,718
当然我希望每个人的回答都是肯定的，

141
00:10:57,718 --> 00:11:01,896
并且你已经想出完成它所需要的材料，更具体点，
你已经知道怎么从一个伪随机数发生器来构建一个PRF。

142
00:11:01,896 --> 00:11:06,395
我们以前说过，只要你有一个PRF，那么我们就可以将它嵌入

143
00:11:06,395 --> 00:11:10,573
Luby-Rackoff结构，如果你记得，它只是一个三轮Feistel网络，

144
00:11:10,573 --> 00:11:14,750
所以，我们说过，如果你将一个安全PRF嵌入到一个三轮Feistel中，

145
00:11:14,750 --> 00:11:19,044
你会得到安全的PRP，所以结合这两点，
基本上就能够由PRG生成一个安全的PRP。

146
00:11:19,044 --> 00:11:23,328
这个PRP的安全条件是，

147
00:11:23,328 --> 00:11:28,075
只需要结构中内含的发生器是安全的，
这个是很好的结果，但不幸的是，

148
00:11:28,075 --> 00:11:32,475
实际应用中不会出现这种用法，
因为这种结构比类似AES的启发式结构来的慢得多。

149
00:11:32,475 --> 00:11:36,725
好了，这样我们就完成了构建，

150
00:11:36,725 --> 00:11:40,456
伪随机置换和函数，在接下来的模块中，

151
00:11:40,456 --> 00:11:44,287
我们将讨论怎么运用这些东西来正确地加密。【END】

