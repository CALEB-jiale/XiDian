1
00:00:00,152 --> 00:00:01,703
接下来我们将讨论的问题是

2
00:00:01,703 --> 00:00:03,638
RSA真的是一个单向函数吗

3
00:00:03,638 --> 00:00:05,788
换句话说，在不知道天窗的情况下

4
00:00:05,788 --> 00:00:08,104
求RSA的逆真的很难吗？

5
00:00:09,012 --> 00:00:11,998
所以，如果一个攻击者想要求函数的RSA的逆

6
00:00:11,998 --> 00:00:15,001
攻击者有的是公钥

7
00:00:15,001 --> 00:00:19,054
也就是（N，e）现在他有x^e

8
00:00:19,054 --> 00:00:23,293
他的目标是复原X。好了，问题是

9
00:00:23,293 --> 00:00:26,131
有了想X^e（mod N）,还原x的难度有多大呢

10
00:00:26,131 --> 00:00:28,933
我们真正问的是

11
00:00:28,933 --> 00:00:33,113
计算合数模e的次方根有多难

12
00:00:34,178 --> 00:00:38,544
如果这个问题很难被解决，则RSA是单向函数

13
00:00:38,544 --> 00:00:39,968
如果这个问题很容易被解决

14
00:00:39,968 --> 00:00:44,564
当然我们不相信它是容易的，那么RSA就会被破解了

15
00:00:44,564 --> 00:00:46,832
所以，解决这个问你的最好算法是

16
00:00:46,832 --> 00:00:49,563
需要我们先分解模N

17
00:00:50,050 --> 00:00:52,236
然后，一旦我们分解了模，上周我们就知道了

18
00:00:52,236 --> 00:00:55,892
计算模p的e的次方根就很容易了

19
00:00:55,892 --> 00:00:58,483
容易计算模p的e次方根

20
00:00:58,483 --> 00:01:02,107
然后有了这些e的次方根，把他们组合在一起就很容易了

21
00:01:02,107 --> 00:01:04,699
使用中国剩余定理

22
00:01:04,699 --> 00:01:07,667
就可以还原模N的e的次方根

23
00:01:07,667 --> 00:01:09,946
所以，一旦我们能分解模

24
00:01:09,946 --> 00:01:12,848
计算模p的e的次方根就变得很容易

25
00:01:12,848 --> 00:01:14,636
但是，分解模

26
00:01:14,636 --> 00:01:16,761
正如我们所知，是一个非常非常困难的问题

27
00:01:16,761 --> 00:01:19,865
但是一个自然的问题是，为了计算模N的e次方根

28
00:01:19,865 --> 00:01:22,568
我们去分解模N是正确的吗？

29
00:01:22,568 --> 00:01:25,707
正如我们所知

30
00:01:25,707 --> 00:01:27,369
计算模N 的e次方的最佳算法

31
00:01:27,369 --> 00:01:30,002
是需要将N进行分解

32
00:01:30,002 --> 00:01:31,626
但是，谁知道呢，也许有一条捷径

33
00:01:31,626 --> 00:01:33,771
能让我们计算模N的e次方根

34
00:01:33,771 --> 00:01:36,704
而不需要分解模

35
00:01:36,704 --> 00:01:38,808
为了证明这是不可能，我们必须证明一个简约

36
00:01:38,808 --> 00:01:40,314
也就是说，我们需要证明

38
00:01:40,314 --> 00:01:42,001
如果我给大家一个有效的算法

39
00:01:42,001 --> 00:01:43,872
可以计算模N的e次方根

40
00:01:43,872 --> 00:01:48,132
那么这个有效的算法就被可以改造成一个计算分解因子的算法

41
00:01:48,132 --> 00:01:51,015
这叫做一个简约，给定一个计算模N的e次方根的算法

42
00:01:51,015 --> 00:01:53,137
我们可以得到一个计算分解因子的算法

43
00:01:53,137 --> 00:01:57,314
这就说明任何人都不能计算模N的e次方根

44
00:01:57,314 --> 00:02:00,101
比分解模的速度更快

45
00:02:00,101 --> 00:02:02,285
如果我们有这样一个结论，这说明

46
00:02:02,285 --> 00:02:05,716
破解RSA和分解大合数一样难

47
00:02:05,716 --> 00:02:08,110
但很不幸，目前这个证明我们还不知道

48
00:02:08,110 --> 00:02:11,969
事实上，这是公钥密码学里最古老的问题之一

49
00:02:11,969 --> 00:02:14,415
让我举个具体的例子

50
00:02:14,415 --> 00:02:18,523
假设我给你们一个可以计算出模N的立方根的算法

51
00:02:19,037 --> 00:02:23,693
所以，对于任意的Z_N中的x，这个算法可以算出x的模N的立方根

52
00:02:23,693 --> 00:02:25,971
我的问题是，你能证明

53
00:02:25,971 --> 00:02:29,066
用这样的算法可以分解模N吗？

54
00:02:29,066 --> 00:02:31,239
即使这个证明你不知道。我们都知道的

55
00:02:31,239 --> 00:02:33,920
我要告诉你的是，例如e=2

56
00:02:34,375 --> 00:02:37,711
如果给你一个计算模N的平方根的算法

57
00:02:37,711 --> 00:02:40,696
事实上，这就暗示着分解模的算法

58
00:02:40,696 --> 00:02:44,699
所以，计算模N的平方根和分解模式一样困难的

59
00:02:44,712 --> 00:02:47,779
不幸的是，如果你回想起来RSA的定义

60
00:02:47,779 --> 00:02:52,913
它要求ed=1mod φ（N）

61
00:02:52,913 --> 00:02:58,612
意思是，e和模φ（N）必须是互质的

62
00:02:58,612 --> 00:03:03,128
这里第一个方程就是说，e是模φ（N）可逆的

63
00:03:03,128 --> 00:03:06,125
但是，如果e模φ（N）式可逆的，这意味着

64
00:03:06,125 --> 00:03:09,107
e必须和φ（N）是互质的

65
00:03:09,107 --> 00:03:13,927
但是，φ（N），如果你们记得，φ（N）=（p-1）*（q-1）

66
00:03:13,927 --> 00:03:19,377
如果p和q都是大质数，（p-1）和（q-1）一定是偶数

67
00:03:19,377 --> 00:03:25,503
事实上，GCD（2，φ（N））=2

68
00:03:25,503 --> 00:03:28,221
因为φ（N）是偶数，因此

69
00:03:28,221 --> 00:03:30,863
公钥指数2和φ（N）不是互质的

70
00:03:30,863 --> 00:03:33,174
意思是说，即使我们有了一个简约

71
00:03:33,174 --> 00:03:35,263
从计算平方根来求因子分解

72
00:03:35,263 --> 00:03:38,758
e=2也不能被拿来当做RSA指数

73
00:03:38,758 --> 00:03:43,643
那么真正合法的最小的RSA指数等于3

74
00:03:43,643 --> 00:03:46,911
但是等于3，问题就是计算立方根

75
00:03:46,911 --> 00:03:48,976
与因子分解一样难，这是个开放的问题

76
00:03:48,976 --> 00:03:50,978
这个问题很有趣，值得想想

77
00:03:50,978 --> 00:03:53,444
那么我鼓励大家简单想想这个问题

78
00:03:53,444 --> 00:03:58,352
就是说，如果我给你一个有效算法，来计算模N的立方根

79
00:03:58,352 --> 00:04:02,111
你能使用这个算法来分解模N吗？

80
00:04:02,111 --> 00:04:05,301
我会告诉大家，有一些证据说明

81
00:04:05,301 --> 00:04:09,402
这样的规约可能并不存在，但这只是一个很弱的证据

82
00:04:09,402 --> 00:04:11,366
这个证据是说

83
00:04:11,366 --> 00:04:13,500
如果你给我一个非常特别的形式的规约

84
00:04:13,500 --> 00:04:16,070
换句话说，如果你的规约是代数的

85
00:04:16,070 --> 00:04:18,509
我在这里先不解释它的意义

86
00:04:18,509 --> 00:04:23,087
如果有一个立方根神谕，你可以给我一个算法

87
00:04:23,087 --> 00:04:26,055
可以计算因子分解。这个规约本身

88
00:04:26,055 --> 00:04:28,554
就会蕴含着因子分解的算法

89
00:04:28,554 --> 00:04:31,084
这就是说，如果因子分解是困难的

90
00:04:31,084 --> 00:04:33,637
那么规约根本就不存在

91
00:04:33,637 --> 00:04:35,537
但是，如我所说，这是非常弱的证据

92
00:04:35,537 --> 00:04:37,617
因为，需要规约是代数的

93
00:04:37,617 --> 00:04:39,725
也许会有其他类型的规约

94
00:04:39,725 --> 00:04:42,857
比如我们没有考虑过的类型

95
00:04:42,857 --> 00:04:44,339
那么我会鼓励大家去略微考虑一下这个问题

96
00:04:44,339 --> 00:04:46,235
这是很有趣的

97
00:04:46,235 --> 00:04:50,087
如何使用一个立方根算法来分解模？

98
00:04:51,308 --> 00:04:54,143
但是如我所说，我们目前只知道RSA是一个单向函数

99
00:04:54,143 --> 00:05:00,274
事实上破解RSA，计算e次方根，都要求因子分解模

100
00:05:00,274 --> 00:05:02,918
我们都相信那是正确的，这就是目前的研究现状

101
00:05:02,918 --> 00:05:07,637
但是，现在有很多研究工作，试图提高RSA的性能

102
00:05:07,637 --> 00:05:12,041
提高RSA加密的性能，或是RSA解密的性能

103
00:05:12,041 --> 00:05:14,901
实际上，这个研究方向开始时人们走了很多弯路

104
00:05:14,901 --> 00:05:18,796
我想展示给大家这个非常好的例子，作为警示

105
00:05:18,796 --> 00:05:23,232
这是一个试图提高RSA性能的错误例子

106
00:05:23,232 --> 00:05:26,772
设想如果我想加速RSA解密

107
00:05:26,772 --> 00:05:28,578
记得解密是通过计算

108
00:05:28,578 --> 00:05:30,895
密文的d次方。大家记得

109
00:05:30,895 --> 00:05:34,265
指数算法的运行时间

110
00:05:34,265 --> 00:05:37,767
与d的长度大小成线性关系，与log(d)成线性

111
00:05:37,767 --> 00:05:39,762
那么大家可以回想一下，如果我想

112
00:05:39,762 --> 00:05:43,522
加速RSA解密，我为什么不使用一个小d呢？

113
00:05:43,522 --> 00:05:48,265
比如说，使用一个解密指数，大约是2的128次方

114
00:05:48,419 --> 00:05:52,350
那么这已经够大了，穷举d实际上是不可能的

115
00:05:52,350 --> 00:05:57,418
但正常情况下，解密指数d约与模一般大，比如说2000位

116
00:05:57,418 --> 00:06:04,669
通过使用仅为128位的d，我可以提高RSA解密速度20倍

117
00:06:04,669 --> 00:06:07,533
我从2000位降到100位

118
00:06:07,533 --> 00:06:10,915
那么计算指数的速度会快20倍

119
00:06:10,915 --> 00:06:15,440
实际上这是一个糟糕的点子。非常糟糕的点子，根据接下来的思路来看

120
00:06:15,440 --> 00:06:18,638
Michael Wiener有一个攻击，证明了事实上

121
00:06:18,638 --> 00:06:23,425
一旦私钥指数d小于模的4次方

122
00:06:23,425 --> 00:06:27,526
我们看，如果模大约是2048位

123
00:06:27,526 --> 00:06:34,581
这意味着如果d小于2的512次方，那么RSA是完全不安全的

124
00:06:34,581 --> 00:06:37,509
而且这是最坏的一种不安全

125
00:06:37,509 --> 00:06:43,129
即给定一个公钥。你可以很快还原出私钥d

126
00:06:44,227 --> 00:06:48,493
所以有传言说：这个攻击可以针对最多512位

127
00:06:48,493 --> 00:06:52,378
那么我们为什么不让这个模，比如说530位

128
00:06:52,378 --> 00:06:54,234
那么这个攻击就不能用了

129
00:06:54,234 --> 00:06:57,545
但是我们依然可以让RSA解密加速4倍

130
00:06:57,545 --> 00:07:01,997
因为我们能把指数从2000位降到比如说530位

131
00:07:01,997 --> 00:07:03,978
实际上，即使这是不安全的。事实上

132
00:07:03,978 --> 00:07:06,243
Wiener的攻击有一个扩展

133
00:07:06,243 --> 00:07:08,176
复杂的多的扩展，证实了

134
00:07:08,176 --> 00:07:13,233
如果d小于N^0.292，那么RSA也是不安全的

135
00:07:13,233 --> 00:07:16,674
事实上这个猜想是说，这对最多N^0.5来说是正确的

136
00:07:16,674 --> 00:07:21,975
即使d大约为N^0.4999，RSA依然是不安全的

137
00:07:21,975 --> 00:07:25,780
尽管这是个开放问题，也是一个极好的开放问题

138
00:07:25,780 --> 00:07:28,394
这个问题存在到现在已经14年了

139
00:07:28,394 --> 00:07:31,556
没人可以超过这个0.292

140
00:07:31,556 --> 00:07:34,327
这有点奇怪 为什么0.292是正确的答案

141
00:07:34,327 --> 00:07:38,217
没人能超过0.292呢

142
00:07:38,802 --> 00:07:41,671
所以 为了准确 当我说RSA是不安全的

143
00:07:41,671 --> 00:07:45,218
我的意思是 当给了公钥（N,e）时

144
00:07:45,218 --> 00:07:48,077
你的目标是还原私钥d

145
00:07:49,102 --> 00:07:52,257
如果你对0.292是怎么来的感到好奇

146
00:07:52,257 --> 00:07:56,312
我会告诉你 它实际上是等于1减去1除以根号2

147
00:07:56,312 --> 00:07:58,503
为什么这会是问题的正确答案呢

148
00:07:58,503 --> 00:08:01,296
答案是N^0.5看起来会更加合理

149
00:08:01,296 --> 00:08:04,340
但这仍然是一个开放问题 如果你仍然想思考这个问题

150
00:08:04,340 --> 00:08:06,163
这是一个很有趣的值得研究的问题

151
00:08:06,163 --> 00:08:10,101
这里得到的经验是不应该在d上强制添加任何结构

152
00:08:10,101 --> 00:08:12,475
来提高RSA的性能 实际上

153
00:08:12,475 --> 00:08:15,276
现在有很多这样的结果

154
00:08:15,276 --> 00:08:19,714
证明了任何像这样的试图提高RSA性能的技巧

155
00:08:19,714 --> 00:08:24,285
最后都会以灾难结束 所以这不是正确的改善RSA性能的方法

156
00:08:24,285 --> 00:08:27,987
原本我不想讲解Wiener攻击的细节

157
00:08:27,987 --> 00:08:31,582
但是根据课堂上的讨论 我觉得你们当中有些人会想看这些细节

158
00:08:31,582 --> 00:08:35,229
它所有涉及到的只是对不等式的一些运算

159
00:08:35,229 --> 00:08:37,743
如果你对这些不太感兴趣 放轻松 跳过这几张幻灯片就好

160
00:08:37,743 --> 00:08:40,979
尽管我觉得你们当中很多人会对这些细节很感兴趣

161
00:08:40,979 --> 00:08:43,365
那么我提醒大家 在Wiener的攻击里

162
00:08:43,365 --> 00:08:46,893
我们给定了模和RSA指数（N,e）

163
00:08:46,893 --> 00:08:50,513
我们的目标是得到私钥指数d

164
00:08:50,513 --> 00:08:54,171
我们知道的信息只有d是小于N的四次方根的

165
00:08:54,171 --> 00:08:57,711
实际上 我将假设d是小于N的四次方根除以3的

166
00:08:57,711 --> 00:09:02,373
这个3不重要 但是这里主要起作用的项是d小于N的四次方根

167
00:09:02,373 --> 00:09:05,944
那么我们来看看是怎么做的 首先记住

168
00:09:05,944 --> 00:09:09,144
因为e和d分别是RSA的公钥和私钥指数

169
00:09:09,144 --> 00:09:14,145
我们知道e*d=1modφ（N） 这是什么意思

170
00:09:14,145 --> 00:09:22,248
这意味着这里存在某个整数k 满足e*d=kφ（N）+1

171
00:09:22,248 --> 00:09:26,280
这就是e^d=1modφ（N）的含义

172
00:09:26,280 --> 00:09:29,832
即某个整数乘以φ（N）+1

173
00:09:29,832 --> 00:09:32,592
那么现在让我们盯着这个等式看一会儿

174
00:09:32,592 --> 00:09:35,826
实际上这个等式就是攻击的关键

175
00:09:35,826 --> 00:09:40,352
那么我们首先将要做的是两边同时除以φ（N）

176
00:09:40,352 --> 00:09:43,703
实际上我把这一项移到左边

177
00:09:43,703 --> 00:09:47,453
在我对两边同时除以d*φ（N）我得到了

178
00:09:47,453 --> 00:09:58,500
e/φ（N）-k/d=1/(d*φ（N）)

179
00:09:59,469 --> 00:10:02,902
我只做了除以d*φ（N）

180
00:10:02,902 --> 00:10:05,850
然后我把k*φ（N）这一项移到等式左边

181
00:10:05,850 --> 00:10:09,119
为了更清楚的表达 我将会加上绝对值

182
00:10:09,119 --> 00:10:13,484
这个马上会用到 当然，这不会改变它们的相等性

183
00:10:13,484 --> 00:10:20,184
现在 φ（N）约等于N 即与N非常接近 正如我们之前所说

184
00:10:20,184 --> 00:10:23,371
现在我需要它们 我们认为这个分式

185
00:10:23,371 --> 00:10:26,639
小于1除以根号N 它远小于1除以根号N

186
00:10:26,639 --> 00:10:30,571
因为1/φ（N）的数量级是1/N

187
00:10:30,571 --> 00:10:35,638
但是对于我们的目标 我们所需要的只是这个分式小于1除以根号N

188
00:10:35,638 --> 00:10:37,939
现在我们仔细看一下这个分式

189
00:10:37,939 --> 00:10:44,506
大家会发现我们并不知道分式的左边

190
00:10:44,506 --> 00:10:49,039
我们知道e 但是我们不知道φ（N） 所以我们不知道e/φ（N）

191
00:10:49,039 --> 00:10:53,631
但是对于e/φ（N）我们有一个不错的估算方法 我们知道

192
00:10:53,631 --> 00:10:59,238
φ（N）与N非常接近 因此e/φ（N）就约等于e/N

193
00:10:59,238 --> 00:11:03,436
那么我们对等式左边的e/N有了很好的估算

194
00:11:03,436 --> 00:11:06,028
现在我们最想得到的是等式右边的部分

195
00:11:06,028 --> 00:11:07,649
因为一旦我们得到了右边的分式

196
00:11:07,649 --> 00:11:12,960
它包含了d 那么我们就可以得到d了

197
00:11:12,960 --> 00:11:19,041
如果我们用e/N代替e/φ（N） 看看会得到哪种错误

198
00:11:19,041 --> 00:11:22,514
分析一下 我们首先要提醒自己

199
00:11:22,514 --> 00:11:26,204
φ（N）= N - p - q + 1

200
00:11:26,204 --> 00:11:30,804
这意味着N-φ（N）要小于p+q

201
00:11:30,804 --> 00:11:34,752
实际上我应该写p+q+1 但是大家知道

202
00:11:34,752 --> 00:11:37,838
并不用在意这个1 它不会对结果产生任何影响

203
00:11:37,838 --> 00:11:40,238
所以我将会忽略它来使问题变得更简单

204
00:11:40,238 --> 00:11:45,508
好的 N-φ（N）小于p+q p和q都大约为N的长度的一半

205
00:11:45,508 --> 00:11:48,918
大家知道 它们的数量级是N^2

206
00:11:48,918 --> 00:11:53,876
那么 p+q 比N的3次方根要小

207
00:11:53,876 --> 00:11:56,844
我们很快会用到这个不等式

208
00:11:56,844 --> 00:12:00,243
但我们现在要用的是我们知道的一些关于d的事实

209
00:12:00,243 --> 00:12:02,958
也就是d是一个比较小的数 所以如果我们观察这个不等式

210
00:12:02,958 --> 00:12:05,543
d比N的四次方根除3要小

211
00:12:05,543 --> 00:12:08,596
这很容易就能看出 我们将两边平方

212
00:12:08,596 --> 00:12:12,118
我稍微配平一下 就不难看出

213
00:12:12,118 --> 00:12:15,510
这直接推出了下面的联系

214
00:12:15,510 --> 00:12:24,263
N平方根的2d-1次分之一比N平方根的份子三要大

215
00:12:24,263 --> 00:12:28,542
正如我所说 下一步是两边平方

216
00:12:28,542 --> 00:12:33,334
两边取反 然后将一边乘以另一半

217
00:12:33,334 --> 00:12:37,906
现在你可以很容易的得到结论了 我们马上用到这个关系

218
00:12:37,906 --> 00:12:40,166
现在我们看看 我们要做的是比较

219
00:12:40,166 --> 00:12:45,059
e除N和k除d 好的 我们知道的有什么

220
00:12:45,059 --> 00:12:47,872
根据三角不等式 我们知道它等于

221
00:12:47,872 --> 00:12:52,122
e除N次到phi（N)分之e的距离

222
00:12:52,122 --> 00:12:56,566
加phi（N)分之e到k分之d的距离

223
00:12:56,566 --> 00:13:01,813
这就是所谓的三角不等式 这只适用于绝对值

224
00:13:01,813 --> 00:13:04,705
这里的绝对值 我们已经知道如何定界了

225
00:13:04,705 --> 00:13:07,116
如果你考虑的话 这就是我们已经导出的界

226
00:13:07,116 --> 00:13:11,977
所以我们知道这里的绝对值比N的平方根小

227
00:13:17,737 --> 00:13:20,486
我们同分母化 看我们得到什么

228
00:13:20,486 --> 00:13:25,236
共同的分母会是N*phi（N)

229
00:13:25,236 --> 00:13:31,253
这里的分子是e*phi（N)-N

230
00:13:31,253 --> 00:13:35,760
我们这里知道 这个表达式比N平方根的3倍小

231
00:13:35,760 --> 00:13:40,842
所以分子应该取3e倍N平方根

232
00:13:40,842 --> 00:13:44,327
分子要比3e倍N平方根

233
00:13:44,327 --> 00:13:51,246
现在我们知道e比phi（N）小 所以我知到e除以phi（N)小于1

234
00:13:51,246 --> 00:13:57,313
换句话说 如果我们消掉e和phi（N) 我们只会让分数更大

235
00:13:57,313 --> 00:14:00,016
那么最初的绝对值将

236
00:14:00,016 --> 00:14:03,655
小于N平方根*3除N 这很简单

237
00:14:03,655 --> 00:14:09,237
N平方根*3除N就是3除N平方根

238
00:14:09,237 --> 00:14:11,270
那么对3除N平方根我们又知道什么

239
00:14:11,270 --> 00:14:17,706
我们知道它比1除N平方根分之负一的2d次

240
00:14:17,706 --> 00:14:20,473
这就是我们的推导过程

241
00:14:20,473 --> 00:14:26,439
所以现在我们知道第一个绝对值小于1除N平方根分之负一的2d次

242
00:14:26,439 --> 00:14:29,509
第二个绝对值比N平方根分之一小

243
00:14:29,509 --> 00:14:34,369
因此他们的和小于2d方分之一

244
00:14:34,369 --> 00:14:36,576
我希望你们好好看看这个公式

245
00:14:36,576 --> 00:14:42,951
那么让我稍稍化简 约掉这部分和这部分

246
00:14:43,582 --> 00:14:46,445
我们注意下这个分式

247
00:14:46,445 --> 00:14:51,444
我们首先注意到的 和之前一样 现在我们知道N分之e的值

248
00:14:51,444 --> 00:14:54,825
我们想要知道的是d分之k的值

249
00:14:54,825 --> 00:14:56,862
但我们对k分之d知道什么呢？

250
00:14:56,862 --> 00:15:00,715
我们知道这两个分式之间的差别很小

251
00:15:00,715 --> 00:15:05,385
小于2d平方分之一 这出现很不频繁

252
00:15:05,385 --> 00:15:10,588
k分之d接近N分之e 那么

253
00:15:10,588 --> 00:15:15,307
这两者之间的差距小于k分之d的分母的平方

254
00:15:15,307 --> 00:15:17,324
这就说明这不可能频繁发生

255
00:15:17,324 --> 00:15:22,338
也说明很少有k分之d的分母接近于另一个分母

256
00:15:22,338 --> 00:15:26,422
那么他们之间的差距小于2d方分之一

257
00:15:26,422 --> 00:15:30,308
事实上这样分母的数值最多为N的对数

258
00:15:30,308 --> 00:15:33,953
现在还有一个分母算法 这是一个很著名的算法

259
00:15:33,953 --> 00:15:38,877
简单来说 他做的是 从N分之e的分母

260
00:15:38,877 --> 00:15:42,977
这会恢复log（N)的k分之d的可能值

261
00:15:42,977 --> 00:15:47,148
我们一个个尝试 直到我们找到正确的k分之的

262
00:15:47,148 --> 00:15:51,645
我们就做完了 因为我们知道

263
00:15:51,645 --> 00:15:55,376
e乘d模k为1 因此d对k是互素的

264
00:15:55,376 --> 00:16:00,852
那么如果我们用k分之d代表合理的分母 你知道 分子除分母

265
00:16:00,852 --> 00:16:05,271
分母一定是d 我们就恢复了 你知道

266
00:16:05,271 --> 00:16:10,355
我们会尝试所有可能的log（N)分数接近N分之e

267
00:16:10,355 --> 00:16:13,688
使差距小于2d方分之一

268
00:16:13,688 --> 00:16:19,338
然后我们看所有这些分式的分母 其中的一个一定是d

269
00:16:19,338 --> 00:16:22,841
那么我们就做完了 我们已经恢复了私钥

270
00:16:22,841 --> 00:16:26,341
这就是一个漂亮的攻击 这展示了如何

271
00:16:26,341 --> 00:16:31,267
如果私有指数是小的 小于N的四次方根

272
00:16:31,267 --> 00:16:35,354
那么我们就可以完全恢复d，很简单。好的 就说到这里。【END】

