1
00:00:00,000 --> 00:00:03,515
好的，现在我们基本上完成了对对称加密的讨论。

2
00:00:03,515 --> 00:00:06,471
现在再开始下一个题目之前，有几个小问题

3
00:00:06,471 --> 00:00:10,431
我们需要讨论一下。首先我要提到的是我们应该怎么从很多密钥中

4
00:00:10,431 --> 00:00:14,497
得到唯一密钥。实际上，这个问题会在实践中很多次的出现，所以我

5
00:00:14,497 --> 00:00:18,287
想确保你们知道怎么去正确的找到它。所以说我们寻找的

6
00:00:18,287 --> 00:00:22,775
是怎样的设置?好吧，想象我们现在有一个确定来源的很多

7
00:00:22,775 --> 00:00:26,435
理论中的一种密钥。想象有源密钥是被硬件随机

8
00:00:26,435 --> 00:00:30,094
数生成器生产或者是被我们一会将要讨论的密钥交换协议

9
00:00:30,094 --> 00:00:34,036
所生成的。但是现在有很多方式

10
00:00:34,036 --> 00:00:38,110
在Alice和Bob之间产生一个有源密钥，就是

11
00:00:38,110 --> 00:00:42,569
攻击者不知道的有源密钥。但是现在正如我们所说的，在很多情况下，

12
00:00:42,569 --> 00:00:46,863
我们确实需要很多密钥去保证会话的安全，不仅仅是一个简单地有源密钥。

13
00:00:46,863 --> 00:00:51,267
举个例子，如果你还记得，在TLS里面有单向性的密钥，

14
00:00:51,267 --> 00:00:55,285
我们需要在每个方向上都有密钥，事实上，在每个方向上，

15
00:00:55,285 --> 00:00:59,093
我们都需要多种密钥，我们需要MAC密钥，我们需要加密密钥，我们需要IV，等等。

16
00:00:59,093 --> 00:01:03,594
不知道你们还记不记得，与基于新鲜值的加密相似

17
00:01:03,594 --> 00:01:08,031
我们曾经使用过并联密钥以及其他密钥，所以问题是我们怎么使用

18
00:01:08,031 --> 00:01:12,351
我们得到的有源密钥，不论是从硬件随机生成数或者是

19
00:01:12,351 --> 00:01:16,531
密钥交换协议生成的，并且从中得到一系列我们可以用它们

20
00:01:16,531 --> 00:01:20,951
提高我们的会话安全性的密钥。我们这样做是应用了被叫做

21
00:01:20,951 --> 00:01:25,846
密钥推导函数的机制，简称KDF。现在我想简单介绍一下密钥推导函数是怎么

22
00:01:25,846 --> 00:01:30,993
构造的。首先假设我们我们有个安全的脉冲重复频率，工作时有个

23
00:01:30,993 --> 00:01:37,207
密钥空间K。现在，假设它这样工作使我们的有源密钥SK在K空间中

24
00:01:37,207 --> 00:01:42,453
随机分配。在这种情况下，一个对于安全脉冲频率F来说是均匀分布的

25
00:01:42,453 --> 00:01:46,444
随机密钥。我们可以用它直接来生成密钥，所有的我们需要的提高安全性

26
00:01:46,444 --> 00:01:49,771
的密钥都可以用这种方法来构造。所以在这种情况下，密钥推导函数真的非常简单。

27
00:01:49,771 --> 00:01:54,025
该机制会像下面所说的一样工作。它得到作为输入的

28
00:01:54,025 --> 00:01:58,766
有源密钥。它会有一个上下文参数的输入，我一会会讲到的

29
00:01:58,766 --> 00:02:03,615
输入。之后它会把输入的长度也作为一个

30
00:02:03,615 --> 00:02:08,400
输入。接下来要做的就是在零的时候评估PRF。然后

31
00:02:08,400 --> 00:02:12,449
在一的时候评估PRF,之后在二的时候评估PRF，一直提高到L。

32
00:02:12,449 --> 00:02:16,353
我一会会谈论一下这样做的环境是什么。之后你会

33
00:02:16,353 --> 00:02:20,256
将会使用跟你需要去为会话构造的密钥一样的

34
00:02:20,256 --> 00:02:24,355
的输出比特数。所以如果你需要你将要生成的单向密钥，你们知道的

35
00:02:24,355 --> 00:02:28,356
在每一个方向的密钥都会包含加密密钥和介质访问控制层密钥。

36
00:02:28,356 --> 00:02:32,259
基本上，你可以生成你需要比特数的密钥，

37
00:02:32,259 --> 00:02:37,177
最后在你已经生成够了你所需要的保证会话安全的密钥，切断输出。

38
00:02:37,177 --> 00:02:41,656
这是一个相当直接的机制，基本上只应用了

39
00:02:41,656 --> 00:02:45,451
安全脉冲重复频率作为伪随机数生成器。现在就只剩下一个问题

40
00:02:45,451 --> 00:02:49,545
就是什么是它的上下文应用环境。好吧，基本上环境字符串是一个不同寻常的

41
00:02:49,545 --> 00:02:54,304
定义应用的字符串。所以在事实上，你可能会在同一个系统上有很多

42
00:02:54,304 --> 00:02:59,169
不同的应用程序试图建立多个安全密钥。

43
00:02:59,169 --> 00:03:05,145
你可能有运行安全外壳协议去做为一个进程，同时运行一个网络服务作为另一个进程

44
00:03:05,145 --> 00:03:09,533
Internet链接协议作为第三个进程，所有的三个进程都要求生成秘密密钥。

45
00:03:09,533 --> 00:03:12,589
基本上环境变量会尝试着把它们分成三份。所以，让我问一下你们，

46
00:03:15,204 --> 00:03:18,312
更准确的说，你们觉得环境变量的目的是什么？

47
00:03:18,312 --> 00:03:22,166
我猜我已经把它放到一边了，基本上环境变量是被用来

48
00:03:22,166 --> 00:03:26,863
分离应用程序的，举个例子来说，即使

49
00:03:26,863 --> 00:03:31,741
上面三个我们谈论过的服务，安全外壳协议，网络服务和Internet链接，

50
00:03:31,741 --> 00:03:36,378
如果它们都获得了从硬件随机数生成器生成的的相同有源密钥，

51
00:03:36,378 --> 00:03:41,617
之后从三个环境不同对于应用程序不同开始，环境上下文

52
00:03:41,617 --> 00:03:45,873
会确保它们可以得到三个独立的字符串并且用它来提高会话的安全性。

53
00:03:45,873 --> 00:03:49,648
我只希望你们可以记住它，即使这实际上是非常

54
00:03:49,648 --> 00:03:53,374
简单的。之前我们谈论过，环境字符串事实上是很

55
00:03:53,374 --> 00:03:57,300
重要的。它确实是需要用来分辨应用程序，所以说，每一个应用程序

56
00:03:57,300 --> 00:04:01,139
都可以得到它独有的安全密钥，即使多个程序都要求

57
00:04:01,139 --> 00:04:05,714
一个相同的SK。下一个问题是当有源密钥实际上并不均匀时，

58
00:04:05,714 --> 00:04:10,113
我们应该怎么办？好吧现在我们有了一个新的问题，如果有源密钥对于伪随机数函数

59
00:04:10,113 --> 00:04:14,511
来说不是均匀密钥我们就不能假设

60
00:04:14,511 --> 00:04:19,841
伪随机函数的输出对于随机数来说是不可分辨的。

61
00:04:19,841 --> 00:04:23,416
我们就运用了刚刚描述过得密钥推导函数，之后输出对于敌手来说看上去就不想

62
00:04:23,416 --> 00:04:27,562
是随机数了，之后他就可能有能力去预想一些我们可能使用的会话密钥

63
00:04:27,562 --> 00:04:31,510
从而打断这个会话。所以我们又出现了一个问题，为什么

64
00:04:31,510 --> 00:04:35,560
这个有源密钥不是均匀的呢？这会有很多发生的原因。

65
00:04:35,560 --> 00:04:38,826
比如如果你使用了密钥交换协议，通常该协议会

66
00:04:38,826 --> 00:04:42,774
生成一个高熵的密钥。但是这个

67
00:04:42,774 --> 00:04:47,455
高熵的密钥将会分布在密钥空间的

68
00:04:47,455 --> 00:04:51,763
一些子空间里。所以它不会成为均匀的字符串。它将会均匀分布在一些

69
00:04:51,926 --> 00:04:56,317
大集合的子集中，并且我们将会看到这样的一些例子

70
00:04:56,317 --> 00:05:00,492
存在在密钥交换协议里。KDF机制必须要容纳密钥交换协议

71
00:05:00,492 --> 00:05:04,830
通常不会生成均匀的比特字符。另外一个

72
00:05:04,830 --> 00:05:09,384
问题是，事实上你使用的硬件随机数生成器

73
00:05:09,384 --> 00:05:13,252
通常会生成有偏移的输出。我们不想依赖没有偏移的

74
00:05:13,252 --> 00:05:17,842
硬件随机数生成器。所以我们想要假设的是它会生成

75
00:05:17,842 --> 00:05:22,735
一个高熵的字符串，但是会有一定的偏移。在这样的情况下，我们必须去

76
00:05:22,735 --> 00:05:27,962
清除这样的偏移。所以这里介绍这样的方法，去创造KDF的范式。

77
00:05:27,962 --> 00:05:33,247
叫做提取扩展模式，创建密钥推导函数的第一步就是

78
00:05:33,247 --> 00:05:36,829
提取自然来源密钥中的伪随机密钥。所以在

79
00:05:36,829 --> 00:05:41,343
这幅图中你可以认为这个就像是它。这些有源密钥可能有不同的可能

80
00:05:41,343 --> 00:05:45,541
性价值。这是x轴和y轴

81
00:05:45,541 --> 00:05:49,464
基本上是每一个密钥价值的可能性。你可以看到这是

82
00:05:49,464 --> 00:05:54,561
一种摆动函数可以说有源密钥并不是在

83
00:05:54,561 --> 00:05:58,913
密钥空间里均匀分布。面对这种情况，我们要做的是使用被叫做

84
00:05:58,913 --> 00:06:03,462
提取器的东西。提取器是提取离散分布数据并且

85
00:06:03,462 --> 00:06:06,027
使它们可以均匀分布在密钥空间里的东西。在这种情况下，我们事实上

86
00:06:06,027 --> 00:06:10,894
只是使用了叫做计算提取器的东西，换句话说

87
00:06:10,894 --> 00:06:16,257
提取器在必要的情况下最后并不产生均匀分布

88
00:06:18,910 --> 00:06:23,323
而是生成对于均匀分布来说不可分辨的分布。

89
00:06:23,323 --> 00:06:27,318
现在提取器通常获取作为输入的被叫做盐的东西，然后

90
00:06:27,318 --> 00:06:32,022
它就像在一份沙拉里调味的东西，它所起的作用就是

91
00:06:32,022 --> 00:06:35,738
把局面搞混乱，所有无论输入的分布是什么，输出的分布总是

92
00:06:35,738 --> 00:06:39,973
从随机角度考虑是不可被分辨的。

93
00:06:39,973 --> 00:06:44,565
到底它是什么？实际不是私密的字符串，因此它是公开的

94
00:06:44,565 --> 00:06:49,096
如何敌手知道盐是什么也没关系，它永远都是可操控的

95
00:06:49,096 --> 00:06:53,173
唯一的要点是当你选择它时，必须是随机选择一个。之后的希望是

96
00:06:53,173 --> 00:06:56,274
你尝试从kinda那里提取的有趣的分布

97
00:06:56,274 --> 00:06:59,729
不是完全取决于你选择的盐，因此用你的盐

98
00:06:59,729 --> 00:07:03,020
你可以得到一个与随机的分布不可分辨的分布

99
00:07:03,020 --> 00:07:06,220
实际你可以一段时间内一直敲击键盘生成它

100
00:07:06,220 --> 00:07:10,249
但是需要一些真正随机的东西，

101
00:07:10,249 --> 00:07:16,304
但之后是永远可以被操控，如果敌手知道

102
00:07:16,304 --> 00:07:20,713
它是什么将是很好的，因此提取器就可以提取出熵

103
00:07:20,713 --> 00:07:25,667
并且输出一个均匀随机串K，在某种程度上，这个盐只是防御

104
00:07:25,667 --> 00:07:30,581
对方可能搞混我们提取器的糟糕的分布，

105
00:07:30,581 --> 00:07:34,911
好的，现在我们已经提取出一个伪随机的密钥，我们将把它用于一个KDF中

106
00:07:34,911 --> 00:07:39,481
我们仅看到用一个安全的伪随机函数来扩大

107
00:07:39,481 --> 00:07:43,431
密钥使之成为能保证回话安全的密钥长度

108
00:07:43,431 --> 00:07:47,584
好的这里有三个步骤，第一，我们提取一个伪随机密钥，

109
00:07:47,584 --> 00:07:52,033
一旦我们有了一个伪随机密钥，我们就已经知道怎样用

110
00:07:52,033 --> 00:07:57,170
伪随机函数把它扩展成我们需要长度的密钥，所以执行这一步的

111
00:07:57,170 --> 00:08:02,561
标准方法叫做HKDF，它是一种从HMAC建立而成的密钥推导函数，

112
00:08:02,561 --> 00:08:07,699
这里的HMAC既可以用作扩大的PRF也可以当做提取原始密钥的提取器

113
00:08:07,699 --> 00:08:12,900
让我解释一下它是如何工作的

114
00:08:12,900 --> 00:08:17,101
在提取的这一步，我们用我们的盐，一开始它是一个公开的随机生成的价值

115
00:08:17,101 --> 00:08:23,526
我们把它当做HMAC密钥

116
00:08:23,526 --> 00:08:28,292
之后源密钥用作HMAC数据，所以我们把一个公开的值当做密钥

117
00:08:28,292 --> 00:08:33,623
因此，有人会质疑HMAC是否具有提取的特征

118
00:08:33,623 --> 00:08:38,452
实际当我们应用HMAC时，最终的密钥与随机的是不可分辨的

119
00:08:38,452 --> 00:08:43,329
前提是假设源密钥对它有足够的熵值。

120
00:08:43,329 --> 00:08:48,037
现在我们拥有了伪随机密钥

121
00:08:48,037 --> 00:08:52,389
我们将仅用HMAC作为一个伪随机函数来生成一个我们需要长度的会话密钥

122
00:08:52,389 --> 00:08:56,763
好的，最终总结一下我们有关HKDF的讨论，

123
00:08:56,763 --> 00:09:00,912
我只想让你们记住一旦获得源密钥

124
00:09:00,912 --> 00:09:05,566
无论是来自硬件还是密钥交换协议，你把它转化成

125
00:09:05,566 --> 00:09:10,108
会话密钥的方法不是直接用那个样本，你永远不会

126
00:09:10,108 --> 00:09:14,369
把源密钥直接当做协议中的会话密钥，你可能会

127
00:09:14,369 --> 00:09:18,575
通过一个密钥推导函数来运行原密钥。

128
00:09:18,575 --> 00:09:23,042
并且这个KDF将给出你所有的密钥

129
00:09:23,042 --> 00:09:27,952
并且输出你所需要的密钥，将这个随机的密钥用在协议中

130
00:09:27,952 --> 00:09:32,430
应用的一个典型的密钥推导函数就是HKDF，在这里必须提出来

131
00:09:32,430 --> 00:09:37,921
好的，我想说的最后一个话题是

132
00:09:37,921 --> 00:09:41,764
怎样从口令中提取出密钥，这叫做基于密钥推导函数的口令。简称PBKDF

133
00:09:41,764 --> 00:09:46,154
问题是口令具有相当低的熵值

134
00:09:46,154 --> 00:09:50,291
实际，在我们后面讨论用户身份验证时会讨论口令

135
00:09:50,291 --> 00:09:55,010
所以在这里我不想多说。

136
00:09:55,010 --> 00:09:58,882
我想说的是口令一般具有很小的熵，大约20比特序列的熵

137
00:09:58,882 --> 00:10:02,804
因此，显然没有足够熵值从口令生成会话密钥，

138
00:10:02,804 --> 00:10:06,828
并且我们仍然需要重复用它

139
00:10:06,828 --> 00:10:10,744
我们仍需要从口令中推导出加密的密钥和MAC等等

140
00:10:10,744 --> 00:10:14,657
所以问题是如何推导

141
00:10:14,657 --> 00:10:18,105
首先是，

142
00:10:18,105 --> 00:10:23,787
对于这样的意图，我们不能用HKDF，它不是为推导而设计的

143
00:10:23,787 --> 00:10:29,002
可能的是推导出的密钥对于一些称作字典法的攻击实际是易受攻击的

144
00:10:29,002 --> 00:10:34,878
这将在我们讨论用户身份验证的时候会提到，所以PBKDF的方法

145
00:10:34,878 --> 00:10:39,097
防御低熵值问题会由于两种方式导致字典法攻击

146
00:10:39,097 --> 00:10:45,355
首先，和我们之前用的盐一样，一个公开的，随机的值可以永远被操控

147
00:10:45,355 --> 00:10:49,911
但是另外的，它们也使用一个叫做低哈希函数的方法，让我描述一种

148
00:10:49,911 --> 00:10:53,398
从口令提取密钥的标准方式，叫做PKCS#5

149
00:10:53,398 --> 00:10:56,663
特别地，我将描述的这个版本叫做PBKDF1

150
00:10:56,663 --> 00:10:59,788
这种机制被用于很多加密文献中，所以你们没必要把它用于你自己

151
00:10:59,788 --> 00:11:04,353
你们仅要做的是，你将有一个从口令中提取出来的函数

152
00:11:04,353 --> 00:11:07,741
将口令作为输入给出，得到一个密钥作为输出，但是你应该意识到

153
00:11:07,741 --> 00:11:13,155
这个密钥没有很高的熵值，所以实际上它是可以猜测出来的

154
00:11:13,155 --> 00:11:16,964
这些PBKDF所尝试做的是使得这些猜测尽可能的困难

155
00:11:16,964 --> 00:11:21,693
首先如我们说的，它们工作的方法实际就是哈希

156
00:11:21,693 --> 00:11:25,170
口令和盐的一系列值

157
00:11:25,170 --> 00:11:30,063
之后哈希本身被设计为很低的哈希函数。我们建立一个低哈希函数

158
00:11:30,063 --> 00:11:35,425
的方法是通过用一个特殊的哈希函数SHA-256，反复申明它很多很多次

159
00:11:35,425 --> 00:11:39,356
假设有1000次，也可能几百万次。

160
00:11:39,356 --> 00:11:44,494
反复申明它是什么意思呢？我们有口令和盐

161
00:11:44,494 --> 00:11:50,025
把他们当做哈希函数的一个输入

162
00:11:50,025 --> 00:11:53,779
之后我们运行这个哈希函数，呦~让我写在这里

163
00:11:53,779 --> 00:11:56,779
我们用这个哈希函数得到一个输出，再用这个哈希函数

164
00:11:56,779 --> 00:12:01,830
得到另一个输出。重复这样做一遍又一遍

165
00:12:01,830 --> 00:12:06,710
可能1000次或者一百万次，取决于你的处理器有多快

166
00:12:06,710 --> 00:12:11,057
最后呢，我们得到最终的输出

167
00:12:11,057 --> 00:12:15,371
也就是密钥推导函数的输出密钥，现在要点在这里吗？

168
00:12:15,371 --> 00:12:18,922
重复申明一个函数1000次甚至一百万次对于现代的CPU只需很短的时间

169
00:12:18,922 --> 00:12:23,792
因此，它不能真实反映一个用户的经历

170
00:12:23,792 --> 00:12:27,654
用户键入他的口令，哈希一百万次并得到输出

171
00:12:27,654 --> 00:12:31,489
这可能会花费十分之一秒，用户几乎觉察不到

172
00:12:31,489 --> 00:12:35,689
但是攻击者所做的尝试字典中的所有口令

173
00:12:35,689 --> 00:12:39,780
因为知道人们习惯于在字典中选择密码口令

174
00:12:39,780 --> 00:12:45,232
所以只要他一个一个的试，SALT是公开的，

175
00:12:45,232 --> 00:12:49,796
所以他就知道了SALT是什么了。所以他就可以一个一个的试这个哈希。但是因为

176
00:12:49,796 --> 00:12:53,965
哈希函数是低熵的，每一种尝试将花费十分之一秒，所以他

177
00:12:53,965 --> 00:12:58,416
需要跑完整个字典里的2000亿个口令

178
00:12:58,416 --> 00:13:02,584
由于哈希是低熵的，这将需要很长的时间

179
00:13:02,584 --> 00:13:07,608
通过这样，我们可以减慢字典攻击，使得攻击者获得我们会话密钥更难

180
00:13:07,608 --> 00:13:11,748
不是不可能，只是更难。这就是它所尽力做的

181
00:13:11,748 --> 00:13:15,835
这就是我实际想说的，口令是基于KDF的

182
00:13:15,835 --> 00:13:19,976
就像我说的，这不是你给自己建立一些东西。所有的加密文献都运用PKCS#5机制

183
00:13:19,976 --> 00:13:24,275
而你将仅仅正确的函数

184
00:13:24,275 --> 00:13:28,362
把一个口令转化成一个密钥，之后用这个最终密钥

185
00:13:28,362 --> 00:13:31,229
好的，在下一小节中，我们将明白如何使用对称加密

186
00:13:31,229 --> 00:13:35,229
在某种程度上，允许我们在密文中搜索。【END】

