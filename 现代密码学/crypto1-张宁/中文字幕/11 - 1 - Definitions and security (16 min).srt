1
00:00:00,000 --> 00:00:03,583
上周我们学了公钥加密所需的数论知识,

2
00:00:03,583 --> 00:00:07,166
这周我们要用这些知识了，我们将构建

3
00:00:07,166 --> 00:00:10,889
许多安全的公钥加密机制。首先，我们需要定义

4
00:00:10,889 --> 00:00:14,565
什么是公钥加密，以及安全的公钥加密是什么意思？

5
00:00:14,565 --> 00:00:18,241
我提示大家，在公钥加密机制中

6
00:00:18,241 --> 00:00:21,778
有一个加密算法记为E，还有个解密算法

7
00:00:21,778 --> 00:00:25,361
我们记为D。不过这里的加密算法

8
00:00:25,361 --> 00:00:29,477
取一个公钥为输入，而解密算法取一个私钥为输入

9
00:00:29,477 --> 00:00:34,356
这一对叫做密钥对。公钥用于加密信息

10
00:00:34,356 --> 00:00:39,002
私钥用于解密信息。那么这里，一个明文m

11
00:00:39,002 --> 00:00:43,880
使用公钥加密，得到密文c。类似地

12
00:00:43,880 --> 00:00:48,643
把密文c交给解密算法，使用私钥.

13
00:00:48,643 --> 00:00:53,577
解密算法的输出就是原明文m.

14
00:00:53,577 --> 00:00:57,989
公钥加密有许多应用。上周我们看了经典的应用

15
00:00:57,989 --> 00:01:02,455
比如会话建立，密钥交换，目前我们只看了

16
00:01:02,455 --> 00:01:06,867
仅对窃听攻击安全的密钥交换。如果大家还记得

17
00:01:06,867 --> 00:01:11,227
这个协议的工作过程Alice会产生一个公钥、私钥对

18
00:01:11,227 --> 00:01:15,546
她会把公钥发给Bob.Bob会产生一个随机X

19
00:01:15,546 --> 00:01:20,136
X被作为共享密钥，然后Bob把X加密后发送给Alice

20
00:01:20,136 --> 00:01:24,904
使用Alice的公钥进行加密。Alice可以解密，还原X

21
00:01:24,904 --> 00:01:29,554
现在双方都有了这个共享密钥X了，他们可以使用它来安全的互相通信

22
00:01:29,554 --> 00:01:34,143
攻击者当然只能看到公钥

23
00:01:34,143 --> 00:01:38,972
和使用公钥加密后的X，根据这些他不能够

24
00:01:38,972 --> 00:01:43,800
获得任何关于X的信息。我们要更精确地定义

25
00:01:43,800 --> 00:01:48,507
不能获得任何关于X的信息是什么意思?

26
00:01:48,507 --> 00:01:52,522
公钥加密实际上有很多应用。例如

27
00:01:52,522 --> 00:01:57,235
它在非互动应用中非常有用。考虑一个电子邮件系统,

28
00:01:57,235 --> 00:02:01,716
这里Bob想发送电子邮件给Alice，随着Bob发送了这份邮件

29
00:02:01,716 --> 00:02:06,603
电子邮件经由一个个邮件中转点，最终到达Alice

30
00:02:06,603 --> 00:02:10,502
Alice可以解密之。这样建立的电子邮件系统

31
00:02:10,502 --> 00:02:15,045
是为Bob发送邮件的非互动情形设计的.

32
00:02:15,045 --> 00:02:19,195
然后Alice应收到邮件，为了解密邮件

33
00:02:19,195 --> 00:02:23,502
Alice不应与Bob通信。这里，因为这种非互动性

34
00:02:23,502 --> 00:02:27,705
没有建立Alice和Bob之间的共享密钥的机会

35
00:02:27,705 --> 00:02:32,169
这里Bob会发送加密的邮件，使用Alice的公钥

36
00:02:32,169 --> 00:02:36,571
他发送了邮件，世界上任何人可以发送加密后的电子邮件

37
00:02:36,571 --> 00:02:41,103
给Alice，使用她的公钥。当Alice接收到邮件时

38
00:02:41,103 --> 00:02:45,748
她使用她的私钥来解密密文，还原明文

39
00:02:45,748 --> 00:02:50,507
当然这种系统有一个前提，事实上Bob

40
00:02:50,507 --> 00:02:54,804
需要通过某种方法知道Alice的公钥。目前我们还只是假设

41
00:02:54,804 --> 00:02:58,297
Bob已经有了Alice的公钥，但待会儿当我们讨论

42
00:02:58,297 --> 00:03:02,457
数字签名时，我们会看到，这点使用所谓的

43
00:03:02,457 --> 00:03:06,823
公钥管理将非常有效，如我所说，我们待会再来看

44
00:03:06,823 --> 00:03:10,931
我想让大家记住的主要是，公钥加密

45
00:03:10,931 --> 00:03:14,578
用于会话建立。这在网络上很普遍

46
00:03:14,578 --> 00:03:18,840
公钥加密用于建立起一个浏览器和网页服务器之间的安全密钥

47
00:03:18,840 --> 00:03:22,898
公钥加密对非互动的应用是很实用的

48
00:03:22,898 --> 00:03:26,390
这个世界的任何人，需要非互动的发送信息

49
00:03:26,390 --> 00:03:30,653
给Alice时，可以使用Alice的公钥加密信息

50
00:03:30,653 --> 00:03:36,105
Alice可以解密并还原明文。下面我来告诉大家,

51
00:03:36,105 --> 00:03:40,347
关于公钥加密系统的更多细节。公钥加密系统由三个算法构成G,E,D

52
00:03:40,347 --> 00:03:44,431
G叫做密钥生成算法

53
00:03:44,431 --> 00:03:48,672
G会生成这个密钥对，即公钥和私钥。如此所写

54
00:03:48,672 --> 00:03:53,018
G无输入参数，但在现实中，G其实有一个参数

55
00:03:53,018 --> 00:03:57,260
叫做安全参数，指定了这个密钥生成算法将要生成的密钥大小

56
00:03:57,260 --> 00:04:01,731
通常有这些加密算法

57
00:04:01,731 --> 00:04:06,051
它们取一个公钥和明文为输入，产生一个密文

58
00:04:06,051 --> 00:04:10,530
在解密算法中，取对应私钥和密文为输入产生对应明文.

59
00:04:10,530 --> 00:04:14,955
通常为求一致性，我们说,
如果我们使用一个给定的公钥加密了一个明文

60
00:04:14,955 --> 00:04:19,380
然后我们用对应的私钥解密,

61
00:04:19,380 --> 00:04:23,852
我们可以获得原先的明文. 
现在, 一个公钥加密是安全的, 是什么意思呢?

62
00:04:23,852 --> 00:04:27,913
我想先从定义对抗窃听的安全性出发,

63
00:04:27,913 --> 00:04:32,002
然后再定义对抗主动性攻击的安全性,

64
00:04:32,002 --> 00:04:36,237
定义对抗窃听的安全性, 与对称密码的情况很类似.

65
00:04:36,237 --> 00:04:40,626
上周我们已经看过, 来快速回顾一下,

66
00:04:40,626 --> 00:04:44,808
这个攻击游戏如下定义, 我们定义两个实验

67
00:04:44,808 --> 00:04:49,249
实验0和实验1, 在两个实验中,

68
00:04:49,249 --> 00:04:52,965
挑战者都会生成一对公钥和私钥

69
00:04:52,965 --> 00:04:57,342
他把公钥给攻击者, 攻击者产生两个信息m0和m1

70
00:04:57,342 --> 00:05:01,663
长度相同 然后攻击者会得到m0或m1的加密

71
00:05:01,663 --> 00:05:06,039
在实验0中 他会得到m0的加密

72
00:05:06,039 --> 00:05:10,748
在实验1中, 他会得到m1的加密, 然后攻击者需要识别,

73
00:05:10,748 --> 00:05:15,240
他得到的是哪个信息的加密? 他得到的是m0还是m1的加密?

74
00:05:15,240 --> 00:05:19,676
在这游戏中, 攻击者只会得到一个密文.

75
00:05:19,676 --> 00:05:24,226
这个对应于窃听攻击中他监听的密文C,

76
00:05:24,226 --> 00:05:28,719
现在他的目标是分辨出密文C是m0还是m1的加密

77
00:05:28,719 --> 00:05:34,221
对密文C的篡改是不被允许的, 通常我们说,

78
00:05:34,221 --> 00:05:38,206
这个公钥加密机制是语义安全的. 

79
00:05:38,206 --> 00:05:42,085
如果攻击者不能区分实验0和实验1的话, 

80
00:05:42,085 --> 00:05:47,757
换句话说, 他不能区分他获得的是m0还是m1的加密.

81
00:05:47,757 --> 00:05:52,311
在我们讨论主动攻击之前, 我想简单提一下这个定义,

82
00:05:52,311 --> 00:05:56,105
与对称密码的窃听安全这一定义之间的关系,

83
00:05:56,105 --> 00:06:00,438
如果大家还记得, 当我们讨论对称密码的窃听攻击时,

84
00:06:00,438 --> 00:06:04,771
我们区分了两种情况, 密钥只使用一次,

85
00:06:04,771 --> 00:06:08,998
和密钥使用多次的情况, 事实上我们看到这有明确的区分.

86
00:06:08,998 --> 00:06:13,357
例如, 一次性密码本是安全的, 如果密钥只被用于加密单个明文.

87
00:06:13,357 --> 00:06:17,382
但如果密钥用于加密多个明文, 将是不安全的了.

88
00:06:17,382 --> 00:06:21,358
如果大家还记得, 事实上我们有两个不同的定义.

89
00:06:21,358 --> 00:06:25,383
一个是一次性安全, 还有另一个不同的定义.

90
00:06:25,383 --> 00:06:29,700
更强一点, 当密钥被使用多次,

91
00:06:29,700 --> 00:06:34,043
上一张幻灯片里的定义与对称密码的一次性安全很类似,

92
00:06:34,043 --> 00:06:38,499
事实上, 对于公钥加密,

93
00:06:38,499 --> 00:06:43,124
如果系统的一次性密钥是安全的, 那么它对多次密钥也安全

94
00:06:43,124 --> 00:06:47,929
换句话, 如果我们不必赋予攻击者

95
00:06:47,929 --> 00:06:53,171
请求加密他选择的明文的能力, 

96
00:06:53,171 --> 00:06:57,870
因为他自己可以创建这些加密, 他有了公钥, 

97
00:06:57,870 --> 00:07:04,672
因此它可以自己加密任何他喜欢的明文,

98
00:07:04,672 --> 00:07:09,289
因此在某种意义上, 公钥和私钥对天生就是用来加密多个信息的

99
00:07:09,289 --> 00:07:13,905
因为攻击者可以加密很多他选择的明文,

100
00:07:13,905 --> 00:07:18,891
使用我们第一步给定的公钥, 所以事实上

101
00:07:18,891 --> 00:07:23,692
一次性安全的定义足以蕴含着多次安全,

102
00:07:23,692 --> 00:07:28,801
这就是为什么我们称这个概念是选择明文攻击下的不可区分性,

103
00:07:28,801 --> 00:07:34,012
这只是稍微解释下为什么在公钥加密的设定里,

104
00:07:34,012 --> 00:07:37,770
我们不需要更复杂的定义来理解窃听安全,

105
00:07:37,770 --> 00:07:42,515
现在我们理解了窃听安全性,

106
00:07:42,515 --> 00:07:47,343
我们来看一下更有力的可以产生实际攻击的对手

107
00:07:47,343 --> 00:07:51,585
特别地，我们来看一下电子邮件的例子，那么这里我们有我们的朋友Bob

108
00:07:51,585 --> 00:07:56,228
他想给他的朋友Caroline发邮件。并且Caroline恰好有一个

109
00:07:56,228 --> 00:08:00,699
Gmail上的账户。过程如下，这个被加密的邮件

110
00:08:00,699 --> 00:08:05,514
被发送到Gmail的服务器上。服务器解密这封邮件，找寻预期的接收者

111
00:08:05,514 --> 00:08:09,297
之后，如果是，预期接收者是Caroline，

112
00:08:09,297 --> 00:08:13,653
它就把邮件给Caroline。如果预期接收者是攻击者，

113
00:08:13,653 --> 00:08:18,573
他就会把邮件交给攻击者。这很像Gmail的工作方式

114
00:08:18,573 --> 00:08:23,441
因为发送者会发送通过SSL加密的邮件给Gmail服务器

115
00:08:23,441 --> 00:08:28,087
Gmail服务器会中断SSL连接然后将邮件给

116
00:08:28,087 --> 00:08:33,081
合适的接收者。现在假设Bob加密的邮件，使用的系统

117
00:08:33,081 --> 00:08:37,764
允许攻击者在不被探测到的情况下篡改密文。

118
00:08:37,764 --> 00:08:42,387
例如，假设这个邮件用计数模式加密的，或者类似的方法。

119
00:08:42,387 --> 00:08:47,070
然后，当攻击者拦截这封邮件时，他可以改变接收者，

120
00:08:47,070 --> 00:08:50,732
因此现在接收者是attacker@gmail.com，并且我们知道对于

121
00:08:50,732 --> 00:08:55,415
计数模式，这样做是很容易的。攻击者知道

122
00:08:55,415 --> 00:09:00,278
邮件是发送给Caroline的，他只是对邮件内容感兴趣。因此，他可以

123
00:09:00,278 --> 00:09:04,226
简单的将邮件接收者改为attacker@gmail.com并且当服务器

124
00:09:04,226 --> 00:09:08,129
接收到邮件时，他将会解密邮件，看到接收者应该是攻击者

125
00:09:08,129 --> 00:09:12,033
然后就将邮件给了攻击者。并且现在攻击者可以

126
00:09:12,033 --> 00:09:16,022
阅读本来要送给Caroline的邮件的内容。所以这是一个

127
00:09:16,022 --> 00:09:21,198
典型的主动攻击的实例，并且你可以注意到攻击者

128
00:09:21,198 --> 00:09:26,174
只能解密接收方是攻击者的密文

129
00:09:26,174 --> 00:09:31,548
也就是以“致攻击者”开头的明文所对应的密文。所以我们的目标是

130
00:09:31,548 --> 00:09:36,657
设计一个安全的公共密钥系统，即使攻击者可以篡改密文

131
00:09:36,657 --> 00:09:42,999
并且有可能解密某些密文。再次，我想要

132
00:09:42,999 --> 00:09:47,612
强调攻击者的目的是得到明文的内容。攻击者

133
00:09:47,612 --> 00:09:52,055
已经知道邮件的接收方是Caroline。并且他要做的只是

134
00:09:52,055 --> 00:09:56,863
改变接收方。因次这次篡改攻击就引入了

135
00:09:56,863 --> 00:10:01,620
选择密文安全的定义。事实上，这就是公钥加密安全性的

136
00:10:01,620 --> 00:10:07,462
标准概念。那么让我解释这个攻击，

137
00:10:07,462 --> 00:10:11,899
如我所说我们的目标是建立一个在非常保守的加密概念下安全的

138
00:10:11,899 --> 00:10:15,756
系统。因次我们有一个加密体系（G,E,D）。并且我们说

139
00:10:15,756 --> 00:10:20,140
它在一个明文空间和一个密文（M,C）上定义的，并且像往常一样

140
00:10:20,140 --> 00:10:24,313
我们将定义两个实验，实验0，实验1.这里‘b’

141
00:10:24,313 --> 00:10:28,222
表示挑战者是否执行了实验0或实验1.

142
00:10:28,222 --> 00:10:32,659
挑战者最开始产生一个公钥和一个私钥，然后

143
00:10:32,659 --> 00:10:37,254
将公钥给了攻击者。现在攻击者可以说：“这里有一系列

144
00:10:37,254 --> 00:10:41,611
密文，请为我解密”攻击者上传

145
00:10:41,611 --> 00:10:46,452
密文C1并且得到了C1的解密，叫它M1。

146
00:10:46,452 --> 00:10:51,414
然后他反复的操作，他上传密文C2，然后又得到解密的信息

147
00:10:51,414 --> 00:10:56,195
M2，密文C3，然后得到M3，诸如此类。

148
00:10:56,195 --> 00:11:00,188
最后，攻击者说“游戏结束”，然后他

149
00:11:00,188 --> 00:11:04,485
上传两个等长的明文M0和M1，

150
00:11:04,485 --> 00:11:08,820
并且接收挑战密文C，

151
00:11:08,820 --> 00:11:13,052
也就是m0或m1的加密。取决于我们在实验0还是实验1

152
00:11:13,052 --> 00:11:17,003
现在攻击者可以继续提交密文询问

153
00:11:17,003 --> 00:11:21,063
因此他可以继续请求解密密文。所以他提交一个

154
00:11:21,063 --> 00:11:25,447
密文，之后得到密文的解密，当然，

155
00:11:25,447 --> 00:11:29,994
现在应该有一个警告。如果攻击者可以提交他选择的任意密文

156
00:11:29,994 --> 00:11:34,270
当然他可以破解挑战。他将要做的是上传一个

157
00:11:34,270 --> 00:11:38,506
挑战密文C作为解密询问。然后他被告知

158
00:11:38,506 --> 00:11:42,665
他在挑战阶段获得的是M0还是M1的加密结果

159
00:11:42,665 --> 00:11:46,825
因为我们有这么一个限制，攻击者可以提交

160
00:11:46,825 --> 00:11:51,031
任何他选择的密文，除了挑战密文

161
00:11:51,031 --> 00:11:55,034
那么攻击者可以询问他选择的任何密文的解密

162
00:11:55,034 --> 00:11:59,297
除了挑战密文。即使攻击者有所有这些的解密

163
00:11:59,297 --> 00:12:03,196
他依然不能分辨出他得到的是M0还是M1的加密

164
00:12:03,196 --> 00:12:09,212
所以大家注意，这是一个非常保守的定义

165
00:12:09,212 --> 00:12:14,113
它赋予了攻击者比我们上一张幻灯片里看到的更多的能力

166
00:12:14,113 --> 00:12:18,710
上一张幻灯片里，攻击只能解密以“致攻击者”开头的信息

167
00:12:18,710 --> 00:12:23,611
这里，攻击者可以解密任何他选择的密文

168
00:12:23,611 --> 00:12:29,717
只要提交的密文与挑战密文C不同

169
00:12:29,717 --> 00:12:34,094
然后攻击者的目标是，判断挑战密文是M0还是M1的加密

170
00:12:34,094 --> 00:12:37,918
通常，如果攻击者不能做到，换句话说

171
00:12:37,918 --> 00:12:42,351
他的表现在实验0和实验1中是一样的

172
00:12:42,351 --> 00:12:46,839
那么他不能区分M0与M1的加密

173
00:12:46,839 --> 00:12:51,219
即使他拥有这么多的能力。那么我们说

174
00:12:51,219 --> 00:12:55,877
这个系统是选择密文CCA安全的。有时有一个缩写词

175
00:12:55,877 --> 00:13:00,596
对选择密文攻击的不可区分性

176
00:13:00,596 --> 00:13:05,745
我记为CCA安全。那么我们看这如何抓住了我们前边看的电子邮件的例子的特点

177
00:13:05,745 --> 00:13:10,587
那么假设使用的加密系统满足

178
00:13:10,587 --> 00:13:15,429
给定信息的加密，攻击者可以改变接收方

179
00:13:15,429 --> 00:13:20,129
从“致Alice”改为“致Charlie”,那么我们可以这样赢得游戏

180
00:13:20,129 --> 00:13:25,033
第一步攻击者当然得到了公钥，

181
00:13:25,033 --> 00:13:29,578
然后攻击者会发出两个等长度的密文，第一个明文内容是0

182
00:13:29,578 --> 00:13:33,943
第二个明文内容是1   两个明文都给Alice

183
00:13:33,943 --> 00:13:39,890
Alice回复后，攻击者会得到密文C

184
00:13:39,890 --> 00:13:45,130
那么现在我们有挑战密文C了

185
00:13:45,130 --> 00:13:49,961
现在攻击者会使用他的能力去修改接收方

186
00:13:49,961 --> 00:13:55,269
他会返回给Alice一个密文C'

187
00:13:55,269 --> 00:14:01,760
C'是Charlie的明文加密结果，其内容是挑战密文的内容b

188
00:14:01,760 --> 00:14:07,822
如果大家记得是0还是1  现在因为明文不同

189
00:14:07,822 --> 00:14:12,486
我们知道密文也不同  那么特别地

190
00:14:12,486 --> 00:14:17,206
C'一定和挑战密文C不一样，对吧？那么C'一定不同于C

191
00:14:17,206 --> 00:14:21,758
因此可怜的挑战者现在必须解密，根据CCA游戏的定义

192
00:14:21,758 --> 00:14:26,141
挑战者必须解密任何不同于挑战密文的密文

193
00:14:26,141 --> 00:14:30,648
那么挑战者解密了，给攻击者解密结果M'

194
00:14:30,648 --> 00:14:35,256
他给了攻击者B，现在攻击者可以输出挑战结果b

195
00:14:35,256 --> 00:14:40,293
他以优势1赢得了这个游戏，那么他对这个游戏的优势是1

196
00:14:40,293 --> 00:14:45,143
因为攻击者能够改变挑战密文

197
00:14:45,146 --> 00:14:49,999
从一个接收方改到另一个，使得他能以优势1赢得这个CCA游戏

198
00:14:49,999 --> 00:14:55,003
如我所说，选择密文安全事实上是

199
00:14:55,003 --> 00:14:59,327
公钥加密的正确的观念

200
00:14:59,327 --> 00:15:03,651
这是个非常有趣的概念，对吧？即使攻击者有这能力

201
00:15:03,651 --> 00:15:07,839
能解密任何他想解密的密文，挑战密文除外

202
00:15:07,839 --> 00:15:12,028
他依然不能学到挑战密文是什么。那么本章余下的目标

203
00:15:12,028 --> 00:15:16,275
其实也包括下一章，目标是构建CCA安全的系统

204
00:15:16,275 --> 00:15:20,093
很惊人的是，这是可以做到的

205
00:15:20,093 --> 00:15:24,310
我会告诉大家怎么做。事实上我们构建的这些CCA安全系统

206
00:15:24,310 --> 00:15:28,579
就是在现实中使用的系统。每次系统试图

207
00:15:28,737 --> 00:15:33,007
布置一个不是CCA安全的公钥加密机制时

208
00:15:33,007 --> 00:15:37,487
都有人提出攻击并破解了它

209
00:15:37,487 --> 00:15:39,280
下面几节我们将看到这些攻击的几个例子。【END】

