1
00:00:00,000 --> 00:00:04,052
现在我们知道MAC是什么了，我们继续构建第一类安全的MAC

2
00:00:04,052 --> 00:00:08,469
首先我想提醒大家，MAC是一对算法

3
00:00:08,469 --> 00:00:12,922
第一个是签名算法，给定信息和密钥，会产生相应的标签

4
00:00:12,922 --> 00:00:17,103
第二个是验证算法，给定密钥、信息和标签

5
00:00:17,103 --> 00:00:21,736
输出0或1，结果取决于标签是否有效

6
00:00:21,736 --> 00:00:26,313
我们说过MAC是安全的，如果它对选择信息攻击是不可被伪造的

7
00:00:26,313 --> 00:00:30,890
换句话说，攻击者可以实施选择信息攻击

8
00:00:30,890 --> 00:00:35,298
他提交由他选择的任意信息，并获得相应的标签

9
00:00:35,298 --> 00:00:39,520
然后尽管有能力生成任意的标签

10
00:00:39,520 --> 00:00:43,616
攻击者也不能产生一个新的，

11
00:00:43,616 --> 00:00:47,976
不是在选择信息攻击中所给出的信息-标签对，上一节中我们已经

12
00:00:47,976 --> 00:00:52,179
看了这个定义。现在的问题是我们如何构建MAC？

13
00:00:52,179 --> 00:00:57,217
我想给大家看的第一个例子是证明任何安全的PRF可直接

14
00:00:57,217 --> 00:01:01,952
给我们一个安全的MAC。那我们看怎么来做

15
00:01:01,952 --> 00:01:06,808
假设我们有一个伪随机函数PRF，这个PRF取输入X，输出Y

16
00:01:06,808 --> 00:01:12,173
我们定义如下的MAC，我们为信息M签名

17
00:01:12,173 --> 00:01:17,182
即为计算函数在M处的值。所以信息M的标签

18
00:01:17,182 --> 00:01:21,350
就是在点M处的函数值，然后我们通过这一对来验证信息

19
00:01:21,350 --> 00:01:26,006
方法就是重新计算在信息M处的函数值

20
00:01:26,006 --> 00:01:30,283
检查结果是否等于给我们的标签。如果一样，我们说“是”

21
00:01:30,283 --> 00:01:34,681
否则我们拒绝。那么这里有图片描述

22
00:01:34,681 --> 00:01:39,023
Alice想给Bob发一条消息，她计算标签通过计算PRF的值得来

23
00:01:39,023 --> 00:01:43,252
那么她把这个得来的标签附在信息后面，Bob收到了这一对信息

24
00:01:43,252 --> 00:01:47,820
他重新计算函数值，并测试得到的标签

25
00:01:47,820 --> 00:01:52,730
是否等于在点M处的函数值。那么我们看一个设计的不好的例子

26
00:01:52,730 --> 00:01:57,832
那么假设我们有一个伪随机函数

27
00:01:57,832 --> 00:02:02,873
只输出10位，好，这是一个很好的伪随机函数

28
00:02:02,873 --> 00:02:07,668
对于任何信息M，它只输出10位

29
00:02:07,668 --> 00:02:12,463
我的问题是，如果我们使用这个函数F构建了一个MAC

30
00:02:12,463 --> 00:02:17,184
得到的MAC是安全的吗？那么答案是否定的，这个MAC是不安全的。特别地

31
00:02:17,184 --> 00:02:21,471
是因为标签太短。那么考虑下面这个简单例子

32
00:02:21,471 --> 00:02:26,119
攻击者选择一个任意信息M

33
00:02:26,119 --> 00:02:30,768
随便猜一个MAC的值，作为这个信息的标签，由于这个标签只有10位

34
00:02:30,768 --> 00:02:35,175
攻击者有1除以2的10次方的机会猜中MAC

35
00:02:35,175 --> 00:02:40,004
换句话说，攻击者猜测的优势

36
00:02:40,004 --> 00:02:44,351
给定信息，猜测不同的随机标签，攻击者将有一个

37
00:02:44,351 --> 00:02:48,898
对这个MAC的优势就是1除以2的10次方

38
00:02:48,898 --> 00:02:52,962
即1024分之一，当然不是可忽略的

39
00:02:52,962 --> 00:02:57,348
那么攻击者会成功地为给定的信息伪造MAC

40
00:02:57,348 --> 00:03:01,841
以千分之一的概率，这是不安全的，但事实上这是唯一的会有错误的例子

41
00:03:01,841 --> 00:03:06,280
仅当函数输出太小，事情才会有问题

42
00:03:06,280 --> 00:03:10,536
如果这个PRF的输出很大，我们就可以获得一个这个函数的安全的MAC

43
00:03:10,536 --> 00:03:14,344
我们看一个安全性定理。假设我们有

44
00:03:14,344 --> 00:03:18,257
一个函数F，取X中的信息为输入，输出Y中的标签

45
00:03:18,257 --> 00:03:22,588
那么由这个PRF推出的MAC事实上是安全的。特别地

46
00:03:22,588 --> 00:03:26,804
如果大家看到这个安全性定理，会很清楚地看到这个误差上届，换句话说

47
00:03:26,804 --> 00:03:31,179
由于PRF是安全的，我们知道这个量是可忽略的

48
00:03:31,179 --> 00:03:35,395
如果我们希望这个量是可忽略的，这是我们想要的，我们想说

49
00:03:35,395 --> 00:03:39,664
没有攻击者可以击败MAC I_F，意味着我们希望这个量是可忽略的

50
00:03:39,664 --> 00:03:43,722
换句话说，我们希望输出空间很大

51
00:03:43,722 --> 00:03:48,096
例如，取一个PRF，输出80位就很好了

52
00:03:48,096 --> 00:03:52,102
它们会产生80位MAC，因此任意攻击者的优势

53
00:03:52,102 --> 00:03:56,521
最多是1除以2的80次方。那么这个定理的证明很简单

54
00:03:56,521 --> 00:04:00,906
我们来看看，事实上我们不从PRF开始

55
00:04:00,906 --> 00:04:05,446
假设我们有一个从信息空间到标签空间的真随机函数

56
00:04:05,446 --> 00:04:10,087
这是一个从X到Y的真随机函数，它是从所有函数集中随机选择的

57
00:04:10,087 --> 00:04:14,966
我们看这个函数能否给我们一个安全的MAC

58
00:04:14,966 --> 00:04:19,551
那么攻击者说，我想要信息M1的标签

59
00:04:19,551 --> 00:04:24,157
他获得了标签，即在点M1处的函数值

60
00:04:24,157 --> 00:04:28,489
注意这里没有密钥，因为F只是一个从X到Y的真随机函数

61
00:04:28,489 --> 00:04:33,096
然后攻击者从选择信息M2，他获得了M2的标签

62
00:04:33,096 --> 00:04:37,264
他选择M3，M4直到Mq，他获得了所有对应的标签

63
00:04:37,264 --> 00:04:41,432
现在他的目标是产生一个信息标签对，也就是说他赢了，记得那就是

64
00:04:41,432 --> 00:04:45,891
存在性伪造，换句话说，首先一定有T=F(M)

65
00:04:45,891 --> 00:04:49,968
这意味着T是M的一个有效标签。其次

66
00:04:49,968 --> 00:04:54,685
信息M必须是新的，信息M不能是M1到Mq中的任何一个

67
00:04:54,685 --> 00:04:58,879
那我们想一想这是什么意思

68
00:04:58,879 --> 00:05:03,830
攻击者看到在点M1到Mq处这个真随机函数的值

69
00:05:03,830 --> 00:05:08,800
现在他要预测新点M的函数值

70
00:05:08,800 --> 00:05:13,411
但是对于真随机函数，在点M的函数值

71
00:05:13,411 --> 00:05:18,195
是独立的，所以攻击者能做的最好的

72
00:05:18,195 --> 00:05:22,749
预测点M的函数值，就是猜

73
00:05:22,749 --> 00:05:27,302
因为他没有任何函数F在M值的信息，因此他的优势

74
00:05:27,302 --> 00:05:31,625
如果他猜在点M处的函数值，他猜中的概率

75
00:05:31,625 --> 00:05:36,294
是1除以|Y|。然后他产生的标签以概率1除以|Y|

76
00:05:36,294 --> 00:05:40,582
是正确的。好，攻击者没有任何信息

77
00:05:40,582 --> 00:05:44,801
是关于函数在M的值，最好的办法就是猜

78
00:05:44,801 --> 00:05:49,347
猜的话，他以1除以|Y|的概率猜对。当然

79
00:05:49,347 --> 00:05:54,420
因为函数F是随即函数，当我们

80
00:05:54,420 --> 00:05:58,565
给攻击者真随机函数或伪随机函数 攻击者表现是一样的

81
00:05:58,565 --> 00:06:02,659
攻击者不能说出它们的区别 因此，即使我们有一个

82
00:06:02,659 --> 00:06:06,600
伪随机函数，攻击者在游戏中获胜的优势最多为1除以|Y|

83
00:06:06,600 --> 00:06:10,774
好，那么大家可以看到这个安全性定理

84
00:06:10,774 --> 00:06:15,561
我们回头看一会。这是我们为什么有这一误差项

85
00:06:15,561 --> 00:06:20,005
1除以|Y|，因为是猜测攻击所致，而且这是攻击者赢得游戏唯一的办法

86
00:06:20,005 --> 00:06:24,734
那么我们现在知道任何PRF

87
00:06:24,734 --> 00:06:29,122
同时也是安全的MAC，我们已经知道第一种MAC的例子。特别的

88
00:06:29,122 --> 00:06:33,680
我们知道AES，或者我们至少相信AES是一个安全的PRF，因此

89
00:06:33,680 --> 00:06:38,011
由于AES取16字节的输入，AES的信息空间是128位

90
00:06:38,011 --> 00:06:43,212
即16字节。因此AES加密会给我们一个MAC

91
00:06:43,212 --> 00:06:48,140
匹配严格的16字节信息。好的，这是第一个MAC例子

92
00:06:48,140 --> 00:06:53,257
现在问题是，如果我们有了一个PRF针对像AES这样的仅16字节的小输入

93
00:06:53,257 --> 00:06:58,564
那么我们能不能为长信息也构建一个MAC呢 比如几个G的数据呢？

94
00:06:58,564 --> 00:07:02,066
有时我们把这个称之为麦当劳问题

95
00:07:02,066 --> 00:07:05,871
给一个小的MAC，我们构建一个大MAC 换句话说，给定短信息的MAC

96
00:07:05,871 --> 00:07:10,234
我们构建长的MAC。我们看两个这样的机制

97
00:07:10,234 --> 00:07:14,835
第一个例子叫做CBC MAC

98
00:07:14,835 --> 00:07:19,315
取针对短信息的PRF为输入 输出一个PRF，可以处理长信息

99
00:07:19,315 --> 00:07:23,686
作为输出。第二个我们要看到的机制是HMAC 它做的事情是一样的

100
00:07:23,686 --> 00:07:28,278
取处理短输入的PRF，产生能处理长输入的PRF

101
00:07:28,278 --> 00:07:32,050

102
00:07:32,050 --> 00:07:36,315
现在这两个被用在了不同的上下文中

103
00:07:36,315 --> 00:07:40,797
CBC-MAC在银行业广为应用 例如有一个系统的叫做

104
00:07:40,797 --> 00:07:44,788
自动打扫房间ACH，银行使用这个系统来处理银行之间的支票

105
00:07:44,788 --> 00:07:49,107
CBC-MAC被用来确保支票的完整性

106
00:07:49,107 --> 00:07:53,173
支票是在银行之间传递的。在因特网上SSL、IPsec和SSH等协议

107
00:07:53,173 --> 00:07:57,086
都使用HMAC来保护完整性。这两个不同的MAC

108
00:07:57,086 --> 00:08:01,274
我们将在下面几节中讨论它们 如我所说，从处理短信息的PRF出发

109
00:08:01,274 --> 00:08:06,043
产生能够的处理几个G的信息的PRF

110
00:08:06,043 --> 00:08:10,597
特别地，它们两种MAC都可以用AES作为底层密码

111
00:08:10,597 --> 00:08:15,269
那么我最后想说的是，关于这些基于PRF的MAC的

112
00:08:15,269 --> 00:08:19,941
事实上它们的输出是可以被截断的 假设我们有一个PRF，输出N位

113
00:08:19,941 --> 00:08:24,909
对于AES，这是一个输出128位的PRF

114
00:08:24,909 --> 00:08:31,062
这是一个容易证明的引理。事实上如果你有一个N位的PRF，如果你截断之，换句话说


115
00:08:31,062 --> 00:08:36,529
如果你只输出前K位，结果依然是安全的PRF

116
00:08:36,529 --> 00:08:42,059
直观地说，如果大PRF对任意输入，都能输出N位随机字符串

117
00:08:42,059 --> 00:08:46,572
那么把结果截断成T位后

118
00:08:46,572 --> 00:08:51,657
看上去依然是随机的。攻击者获得更少的信息

119
00:08:51,657 --> 00:08:56,742
所以他区分随机输出的工作会更困难。换句话说

120
00:08:56,742 --> 00:09:01,177
如果N位PRF是安全的，那么T位PRF，截断PRF

121
00:09:01,177 --> 00:09:05,993
也是安全的。这是一个神奇的引理，由于任何安全PRF

122
00:09:05,993 --> 00:09:10,686
也能给我们一个安全的MAC，这意味着如果你给我一个基于PRF的MAC

123
00:09:10,864 --> 00:09:15,379
我可以把它截断成N位，但是，因为基于PRF的MAC的定理中的误差项

124
00:09:15,379 --> 00:09:19,954
我们知道截断到W位是安全的

125
00:09:19,954 --> 00:09:24,410
只要1除以2的|W|次方是可忽略的 那么你如果截断PRF到只有3位

126
00:09:24,410 --> 00:09:29,222
那么得到的MAC就是不安全的。不过

127
00:09:29,222 --> 00:09:33,974
如果你把它截断成80位，甚至是64位 那么得到的MAC也是

128
00:09:33,974 --> 00:09:39,235
一个安全的MAC。好，需要记住的事情是

129
00:09:39,235 --> 00:09:44,115
即使我们使用AES来构建更大的PRF 最后PRF的输出将是128位

130
00:09:44,115 --> 00:09:48,550
这并不意味着MAC自身必须产生128位标签

131
00:09:48,550 --> 00:09:53,097
我们总可以吧结果截断成90位或80位 因此，我们依然可以得到

132
00:09:53,097 --> 00:09:57,702
安全的MAC，但现在输出标签有着更合理的大小

133
00:09:57,702 --> 00:09:58,726
the CBC-MAC works.

134
00:09:57,702 --> 00:09:58,726
不必是满满的128位。好，
在下一节中我们将看CBC-MAC是如何工作的【END】

