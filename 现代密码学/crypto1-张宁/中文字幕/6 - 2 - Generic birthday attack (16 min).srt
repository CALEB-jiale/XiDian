1
00:00:00,000 --> 00:00:04,000
接下来我想讲一下一个有关碰撞连续哈希函数的普遍攻击

2
00:00:04,000 --> 00:00:06,831
如果你记得我们曾讲到的流密码，

3
00:00:06,831 --> 00:00:10,020
我们明白有关流密码的普遍攻击——穷举搜索

4
00:00:10,020 --> 00:00:15,852
这种攻击要求密钥的规模必须是2^128甚至更多

5
00:00:15,852 --> 00:00:19,939
类似的，有关碰撞连续性也有一个普遍攻击——生日攻击

6
00:00:19,939 --> 00:00:24,128
它要求碰撞连续哈希函数的输出必须是大于一个确定的界限

7
00:00:24,128 --> 00:00:28,317
所以，我来展示一下这种攻击方法并且我们将明白这些界限如何推导出

8
00:00:28,317 --> 00:00:32,633
这儿有一个普通攻击可以解决背离碰撞连续哈希函数

9
00:00:32,633 --> 00:00:36,744
假设这里我们有我们的碰撞连续的哈希函数，

10
00:00:36,744 --> 00:00:39,701
并且假设它输出N个比特值。换句话说

11
00:00:39,701 --> 00:00:44,452
输出空间的规模大概是2^N。现在明文空间必须远远大于N比特

12
00:00:44,452 --> 00:00:48,461
也就是说经过哈希的明文是N比特的100倍

13
00:00:48,461 --> 00:00:52,881
我想给你们看一种算法

14
00:00:52,881 --> 00:00:57,660
可以以2^n/2的概率找到这个哈希函数H的密钥碰撞

15
00:00:57,660 --> 00:01:02,016
约等于输出空间的平方根。这里是这种算法如何运算的

16
00:01:02,016 --> 00:01:06,541
我们需要做的是在我们的明文空间中

17
00:01:06,541 --> 00:01:10,785
随机选择2^2/N的明文子集：m1,m2...m n/2

18
00:01:10,785 --> 00:01:15,030
因为这个明文本身大于N比特，

19
00:01:15,030 --> 00:01:19,387
即是N比特的100倍，很可能这些明文就是不寻常的

20
00:01:19,387 --> 00:01:23,967
因此它们不同的概率很大。但是对于这些明文中的每一个值

21
00:01:23,967 --> 00:01:28,534
我们都经过哈希得到Ti。当然Ti是N比特长的字串

22
00:01:28,534 --> 00:01:33,183
我们将在Ti中找一个碰撞密钥

23
00:01:33,183 --> 00:01:37,602
换句话说，我们已经得到I,J，并且Ti=Tj

24
00:01:37,602 --> 00:01:42,339
一旦我们这样做了之后实际上我们就找到了这个碰撞

25
00:01:42,339 --> 00:01:46,848
因为，Mi不等于Mj的可能性是很大的。但是

26
00:01:46,848 --> 00:01:51,585
哈希函数的Mi等于Mj，因此我们找到函数H的碰撞密钥

27
00:01:51,585 --> 00:01:55,923
现在如果这样那么我们查找明文Ti的所有2^2/n比特

28
00:01:55,923 --> 00:02:00,660
但找不到碰撞密钥，现在我们返回第一步并且

29
00:02:00,660 --> 00:02:04,978
尝试另一个2^2/n的明文序列，现在的问题是这种方法有多好

30
00:02:04,978 --> 00:02:09,112
换句话说在我们找到这样的碰撞得重复这样的步骤多少次？

31
00:02:09,112 --> 00:02:13,297
我想给你们看一下实际这个重复的次数是很小很小的

32
00:02:13,297 --> 00:02:20,638
也就意味着这种算法会以大约为2^n/2的概率及时找到碰撞密钥

33
00:02:20,638 --> 00:02:23,026
所以为了分析攻击

34
00:02:23,026 --> 00:02:25,664
我不得不告诉你们一些有关生日悖论的知识。我想

35
00:02:25,664 --> 00:02:28,673
你们中有人已经听过生日悖论。正如这个定理

36
00:02:28,673 --> 00:02:33,024
所说的那样，并且我想给你们证明一下，因为每一个人

37
00:02:33,024 --> 00:02:37,490
在他们的生活中至少看到一个有关生日悖论的证明。这里

38
00:02:37,490 --> 00:02:42,133
假设我们有N个随机变量r1到rN属于区间{0，B}，

39
00:02:42,133 --> 00:02:48,273
关于它们我唯一假设的是它们之间是独立的

40
00:02:48,273 --> 00:02:54,759
这N个样本值r1到rn之间相互独立是很关键的

41
00:02:54,759 --> 00:02:56,417
并且恰巧它们是均等分配的

42
00:02:56,417 --> 00:03:00,000
例如，在区间{0.B}内它们可能保持一致

43
00:03:00,000 --> 00:03:04,617
但是同样他们都是独立一致的变量。所以如果我们

44
00:03:04,617 --> 00:03:12,448
设n等于为B的平方根，换句话说如果我们从区间[0，B]

45
00:03:12,448 --> 00:03:17,457
中大概抽取根号B个样本，更精确得说是1.2倍的根号B，

46
00:03:17,457 --> 00:03:21,312
之后这些样本中的两个数相等的概率至少为1/2

47
00:03:21,312 --> 00:03:28,387
现在证明了一致分配实际是生日悖论最遭的例子。换句话说

48
00:03:28,387 --> 00:03:33,368
如果取自Ri样本的分配不一致

49
00:03:27,368 --> 00:03:31,151
那么实际上小于

50
00:03:31,151 --> 00:03:36,535
1.2倍的根号B的样本是需要的

51
00:03:34,535 --> 00:03:38,168
这个一致分配是最遭的案例。我们已经证明了有关一致分配

52
00:03:38,168 --> 00:03:44,099
也证明了对于所有的分配情况

53
00:03:44,099 --> 00:03:48,131
但是我给出的证明仅仅针对于一致分配

54
00:03:48,131 --> 00:03:51,071
好的，让我们证明一下，其实一点也不难。

55
00:03:51,071 --> 00:03:58,621
我们会问存在一个I不等于J但是哈希I等于哈希J的概率是多少

56
00:03:58,621 --> 00:04:02,900
所以让我们从对立面入手，即1减去

57
00:04:02,900 --> 00:04:08,449
所有I不等于J的概率，我们有ri不等于rj。

58
00:04:08,449 --> 00:04:14,944
这实际意味着在我们选择的N个样本中没有碰撞发生

59
00:04:14,944 --> 00:04:19,141
好，让我们试着更精确地写出来。我们已经写在这1减。

60
00:04:19,141 --> 00:04:21,735
现在当我们第一个选择R1时

61
00:04:21,735 --> 00:04:27,273
这是我们选择的第一个值，因此，
它不和任何其他的值冲突，现在让我们看看

62
00:04:27,273 --> 00:04:35,640
当我们选择R2，我问你，R2不和R1冲突的概率是多少？

63
00:04:35,640 --> 00:04:38,201
好的，R1占一个位置，

64
00:04:38,201 --> 00:04:43,838
如果R2掉入不与R1冲突时所以是B减1位置，换句话说

65
00:04:43,838 --> 00:04:51,000
R2与R1不冲突的概率是(B-i)除以B,

66
00:04:51,000 --> 00:04:59,000
类似的，当我们选择R3,与R1，R2不冲突的概率是多少？

67
00:04:59,000 --> 00:05:01,000
同样R1，R2占两个位置。

68
00:05:01,000 --> 00:05:05,236
之后概率是B减去

69
00:05:05,236 --> 00:05:13,671
如果R3与B减去与R1，R2不冲突的两项的剩余的两项，

70
00:05:13,671 --> 00:05:14,220
我假想你们已经明白这个模式

71
00:05:14,220 --> 00:05:19,649
所以R4与R1，R2，R3都不冲突的概率是

72
00:05:19,649 --> 00:05:24,597
B减去这三项除以B，等等一直到很大的Rn,

73
00:05:24,597 --> 00:05:30,026
Rn与之前的Ri个值不冲突的概率是

74
00:05:30,026 --> 00:05:35,455
N减去之前Ri个值所占的比例，所以如果Rn掉进

75
00:05:35,455 --> 00:05:44,372
剩下部分的任何一个，B减N加一项与之前的R1到Rn-1都不冲突

76
00:05:44,372 --> 00:05:48,609
现在你们注意到我能把所有这些可能性乘起来的原因是

77
00:05:48,609 --> 00:05:50,003
因为这Ri个值相互独立的。

78
00:05:50,003 --> 00:05:54,378
在这一步中这Ri项相互独立是至关重要的

79
00:05:54,378 --> 00:06:06,000
所以让我重写一下这个表达：1减从i到n-1项的1-i/B之和，好的

80
00:06:06,000 --> 00:06:08,344
我做的这些仅仅是重新写一下这一大项

81
00:06:08,344 --> 00:06:11,075
它们是这些对立事件的单独项之和。

82
00:06:11,169 --> 00:06:21,082
1-X小于e^负X，很容易看出，因为如果你看一下e^负X的泰勒展开

83
00:06:21,082 --> 00:06:26,934
是1-x+(x^2)/2-...等等

84
00:06:26,934 --> 00:06:31,726
显然看得出我们实际是忽略了泰勒展开的后面部分

85
00:06:31,726 --> 00:06:33,781
省略的部分恰巧是正的，结果

86
00:06:33,781 --> 00:06:39,455
左边小于右边。好的，让我们堵上这个不等式

87
00:06:39,527 --> 00:06:41,799
我们得到了什么？我们得到了

88
00:06:41,799 --> 00:06:47,799
这是大于1减从i=1到i=n-1项e的负的i/b的积

89
00:06:47,799 --> 00:06:52,791
好的，这是可直接放入X集合中的等于I/B

90
00:06:52,791 --> 00:06:55,796
的所有项。接下来的话我们会发现关于指数的知识是

91
00:06:55,796 --> 00:07:00,584
我们把指数相乘，指数相加。结果上就是

92
00:07:00,584 --> 00:07:10,266
简单地等于1减去e的负i/b的和次方，这里我们把1到B从括号中取出

93
00:07:10,266 --> 00:07:15,405
然后对于从1到n-1项求和。我要做的就是我把-1/b从括号中拿出来

94
00:07:15,405 --> 00:07:18,234
同时我们留下了从1到n-1项的和

95
00:07:18,234 --> 00:07:21,435
所以从n到n-1项的和

96
00:07:21,435 --> 00:07:27,449
是简单地n倍的n-1项，这样可以约束N的次数超过二

97
00:07:27,449 --> 00:07:33,259
所以我最后真的得到的是1减e的负2b分之n的二次方。

98
00:07:33,259 --> 00:07:37,037
我实际上把n的次数降到了2.非常好

99
00:07:37,037 --> 00:07:42,671
所以我们应该怎么处理2b分之n的平方呢？我们可以确切的

100
00:07:42,671 --> 00:07:55,304
从这块的关系式中得到它的结果。如果考虑这样做，

101
00:07:45,304 --> 00:07:52,938
我们先来解决2分之n平方。二分之n的平方就是二分之1.2的平方。

102
00:07:52,938 --> 00:08:02,440
1.2的平方就是1.44再除以二是0.72。再乘以b的平方的算术平方根，

103
00:08:02,440 --> 00:08:09,853
那就是B。太好了，那2分之N的平方就是0.72B.作为结果，2B分之N的平方只是0.72。

104
00:08:09,853 --> 00:08:14,268
所以我们就得到了结果是1减0.72次方的e。

105
00:08:15,268 --> 00:08:22,682
所以现在就把这个结果带入你的计算式你就会得到0.53大于1/2

106
00:08:22,682 --> 00:08:26,096
的0.53。所以这就证明了生日悖论，你也会注意到

107
00:08:26,096 --> 00:08:29,621
对于字符串来说样本是独立于其他的非常重要，我们呢

108
00:08:29,621 --> 00:08:34,201
只能证明它们是均匀分布的。但是正如我所说的这是非常容易讨论的

109
00:08:34,201 --> 00:08:39,788
远离平均分布的任意分布总可以

110
00:08:39,788 --> 00:08:43,056
满足一个更低的平衡。所以如果你有b的1.2次方，这个定律

111
00:08:43,056 --> 00:08:47,657
就会不适用于平均分布。之所以叫做

112
00:08:47,657 --> 00:08:52,147
悖论是因为平方根函数的增长很缓慢是与此矛盾的

113
00:08:52,147 --> 00:08:56,582
特殊的如果你尝试去提供一个生日日期，让我们假设我们

114
00:08:56,582 --> 00:08:59,265
有很多人在一个房间里，继续假设他们的

115
00:08:59,265 --> 00:09:05,229
生日彼此独立并且平均分配在1到365的区间内。

116
00:09:05,229 --> 00:09:12,909
生日悖论说的是我们需要大约1.2倍的365的平方根，

117
00:09:12,909 --> 00:09:17,313
我相信就是23左右，也就是说我们需要大约23个人在

118
00:09:16,313 --> 00:09:22,497
一间屋子里，他们有一半的可能，会有两个人的生日是相同的。

119
00:09:22,497 --> 00:09:27,846
这个理论被称为悖论的原因是23看上去对于人们来说太小了，

120
00:09:27,846 --> 00:09:29,920
而对于我们刚证明的理论来说

121
00:09:29,920 --> 00:09:32,103
将会有一半的机会会有两个人用相同的生日。顺便说一下，

122
00:09:32,103 --> 00:09:35,672
直觉告诉我们为什么这个事实是成立的是因为

123
00:09:35,672 --> 00:09:41,438
所有可能的人群生日配对是随机碰撞的。如果你已经知道了

124
00:09:41,438 --> 00:09:49,059
b人群的平方根，这就是b平方配对的平方根。大约就是b人群配对的总数

125
00:09:49,059 --> 00:09:54,681
并且如果你知道有b对的话，每一组匹配的碰撞

126
00:09:54,681 --> 00:09:57,123
可能性是1/b ,看上去像是配对中的一个会重合。

127
00:09:57,123 --> 00:10:01,735
这像是给出一个直觉能找到平方根从哪里来的解决方案，

128
00:10:01,735 --> 00:10:05,234
它的最基本依据的事实是，你有N个人在房间里，

129
00:10:05,234 --> 00:10:11,734
房间里就有N的平方种可能配对。我必须说虽然生日悖论经常被用来

130
00:10:11,734 --> 00:10:14,120
提供生日日期，但是生日日期并不一定是均匀分布的。

131
00:10:14,120 --> 00:10:19,120
如果你真正的调查过人们的生日，你会了解到非常清楚的

132
00:10:19,120 --> 00:10:25,795
生日大多偏向九月，令我惊奇的生日日期偏向周二

133
00:10:25,795 --> 00:10:29,786
也偏向周二。所以当我们利用生日悖论去

134
00:10:29,786 --> 00:10:33,975
预测生日时，在事实上，实际的结合更接近于1减去b的二次方根

135
00:10:33,975 --> 00:10:37,041
因为我们说在没有前期分布的情况下，你可能

136
00:10:37,041 --> 00:10:39,305
只需要更少的例子在你得到重合之前。所以让我给你们展示

137
00:10:39,305 --> 00:10:44,850
一下生日悖论的图示，它的走向非常有趣。这里把b以百万

138
00:10:44,850 --> 00:10:47,283
做单位，换句话说我们是在以百万为单位的样本中

139
00:10:47,283 --> 00:10:52,884
寻找随机数据。在X轴这里，是我们采摘的例子数目，

140
00:10:52,884 --> 00:10:57,981
而Y轴，是我们在N个例子中得到重合的可能性。

141
00:10:57,981 --> 00:11:01,297
所以我们可以看出可能性为一半时，大约在1.2倍的B的平方根。

142
00:11:01,297 --> 00:11:05,500
大约在1200，也就是1.2倍的b的评分根。你们可以看到

143
00:11:05,500 --> 00:11:09,646
如果我们精确的找到b的平方根，重合的可能性大约在

144
00:11:09,646 --> 00:11:14,020
0.4到0.41之间。你也会注意到可能性增长到一会变得很快。

145
00:11:14,020 --> 00:11:19,166
举个例子，在大约仅是在两倍的b的平方根处，这可能性

146
00:11:19,166 --> 00:11:23,443
已经是90%、相似的，当我们从那向下走时，

147
00:11:23,443 --> 00:11:30,010
可能性非常快的降到0.好吧，在b的平方根处

148
00:11:30,010 --> 00:11:34,578
存在着临界效应，在此之上，可能性很快到1，

149
00:11:34,578 --> 00:11:39,318
在此之下，可能性也很快的降到0。

150
00:11:39,318 --> 00:11:43,654
所以我们现在可以分析这种攻击算法。

151
00:11:43,654 --> 00:11:47,900
让我提醒你们这里我们选择两个随机二元空间在

152
00:11:47,900 --> 00:11:51,117
信息库中，我们哈希它们。我们从一个在数据库中的随机分布开始

153
00:11:51,117 --> 00:11:55,334
在我们分析它之后，我们以一些分布结束，

154
00:11:55,334 --> 00:11:58,100
这些样本的标签可能不是均匀分布的，但是我们不用理会。

155
00:11:58,100 --> 00:12:04,752
重要的是这些标签从T1到T2再到二分之N是独立的。

156
00:12:04,752 --> 00:12:12,096
如果我们选择二到N或者是1.2到二分之N，那么重合的

157
00:12:12,096 --> 00:12:16,839
可能性将会存在于大约2分之1左右。让我接下来给你看。

158
00:12:16,839 --> 00:12:21,499
在这种情况下，我们需要按照算法迭代多少次才能找到重合？

159
00:12:21,499 --> 00:12:26,013
每次迭代将会找到一个可能性为二分之一配对

160
00:12:26,013 --> 00:12:29,358
我们在实验中必须迭代两次左右。

161
00:12:29,358 --> 00:12:36,062
该算法的耗费时间是二到二分之n估计的哈希函数的消耗时间。

162
00:12:36,062 --> 00:12:40,463
所以我们也注意到该算法也要占用大量的空间，

163
00:12:40,463 --> 00:12:42,642
我们不去理会空间的因素，我们只把精力放在消耗时间上。

164
00:12:42,642 --> 00:12:45,211
这有点厉害，这就是说如果你的哈希函数

165
00:12:45,211 --> 00:12:49,445
输出N比特的输出，这个攻击算法

166
00:12:49,445 --> 00:12:56,466
将会运行在二到二分之n。举个例子来说就是如果我们输出128比特

167
00:12:56,466 --> 00:13:01,800
重合就会在二到60小时内被找到。这并没有进行充分的

168
00:13:01,800 --> 00:13:07,375
安全考虑。好吧，这就是为什么哈希函数的反转那个

169
00:13:07,375 --> 00:13:10,830
通常不会输出128比特，所以让我给你们看一些例子，

170
00:13:10,830 --> 00:13:16,645
一分之三通常是联邦标准，而SHA-1,SHA-256,SHA-512

171
00:13:17,645 --> 00:13:22,461
高级加密标准的设计，它们叫做循环环，

172
00:13:22,461 --> 00:13:26,646
你也可以看到SHA-1输出160比特并且作为结果，这是一个通用的

173
00:13:26,646 --> 00:13:31,307
对它的攻击，在2到80的时间里。SHA-2输出256比特

174
00:13:31,307 --> 00:13:34,698
所以通用攻击将会在2到128时间内结束等等

175
00:13:34,698 --> 00:13:39,601
我也列表了算法的速度，你也会发现最大的块大小

176
00:13:39,601 --> 00:13:43,938
通常也会慢于算法。所以说这样的算法有个

177
00:13:43,938 --> 00:13:48,024
性能损失但是确实对安全性有益

178
00:13:48,024 --> 00:13:51,781
现在你会发现SHA函数确实是灰色输出。

179
00:13:51,781 --> 00:13:55,944
这个SHA函数尽管没有人找到SHA-1的碰撞，但是它还是要求一个新的项目，

180
00:13:55,944 --> 00:13:59,899
要求一个新的项目，同时也希望课堂演示

181
00:13:59,899 --> 00:14:04,270
不要使用SHA-1，你可以用SHA-256来取代。特殊的，

182
00:14:04,270 --> 00:14:08,538
这里利用SHA-1确实是存在理论上的能找到的碰撞，在消耗

183
00:14:08,538 --> 00:14:12,805
时间2到51后。所以说它可能存在时间上的问题直到有人知道

184
00:14:12,805 --> 00:14:17,072
符合的sha-1的碰撞。但是关于sha-1的正确建议是

185
00:14:17,072 --> 00:14:20,975
它依然是一个耐碰撞的哈希函数，因为没有人可以找到它的碰撞。

186
00:14:20,975 --> 00:14:25,208
但是在时间上它可能存在一定的问题可能会花费几个月几年

187
00:14:25,208 --> 00:14:29,010
直到一个符合的碰撞被找到。这是一个新的创造并且也是新的课题SHA-1

188
00:14:29,010 --> 00:14:32,357
不会被应用，只应用SHA-256或者如果你对

189
00:14:32,357 --> 00:14:35,133
SHA-512很好奇，你也可以使用它。所以本课将告一段落，

190
00:14:35,133 --> 00:14:37,133
现在我们就可以去建立抗碰撞散列了。【END】

