1
00:00:01,794 --> 00:00:04,612
在这一节中我们来看一下在没有可信第三方的情况下的一个密钥交换协议

2
00:00:04,612 --> 00:00:08,174
我们像往常一样设两个朋友Alice和Bob

3
00:00:08,174 --> 00:00:11,841
并且这两人之前并没有见过，但他们都想产生一个共享密钥

4
00:00:11,841 --> 00:00:15,263
他们将来回地互相发送信息

5
00:00:15,263 --> 00:00:18,895
并且这次他们的通信是没有可信第三方的

6
00:00:18,895 --> 00:00:23,641
在协议的最后，他们应该有两人都知道的共享密钥

7
00:00:23,641 --> 00:00:26,153
所以会有一个他们都知道的密钥k

8
00:00:26,153 --> 00:00:32,667
但是窃听者监听这条通道时完全不知道密钥k是什么

9
00:00:32,667 --> 00:00:37,669
现在，我们只要担心能够窃听到通信的攻击者

10
00:00:37,669 --> 00:00:40,374
换句话说，我们不允许对通信内容进行任何篡改

11
00:00:40,374 --> 00:00:43,611
我们所允许的只是监听，而且监听者

12
00:00:43,611 --> 00:00:46,417
并不知道密钥k

13
00:00:46,417 --> 00:00:50,080
在这些设定下，我们将看到许多密钥交换协议

14
00:00:50,080 --> 00:00:52,954
很明显，当攻击者只窃听会话

15
00:00:52,954 --> 00:00:58,694
但不能改变通信量。并且我们将要看到实现这一目标的三个协议

16
00:00:58,694 --> 00:01:01,262
这节第一个问题是

17
00:01:01,262 --> 00:01:04,095
“只是用对称密码学能做到吗？”

18
00:01:04,095 --> 00:01:08,236
可以只是用分组加密或者哈希函数，或者

19
00:01:08,236 --> 00:01:11,327
任何我们在过去4周学过的工具来实现吗

20
00:01:11,327 --> 00:01:15,747
令人惊奇的是，答案是肯定的。事实上，我们可以做密钥交换

21
00:01:15,747 --> 00:01:20,284
仅仅使用分组加密或者哈希函数，不借助可信第三方

22
00:01:20,284 --> 00:01:25,265
但不幸的是，结果协议非常无效，事实上从没有应用到实践中

23
00:01:25,265 --> 00:01:28,904
尽管如此，存在一个简单的协议，我会告诉你它们如何工作

24
00:01:28,904 --> 00:01:33,317
并且他们会转为更加有效的协议，我们将在这周和下周讨论

25
00:01:33,317 --> 00:01:38,305
我想告诉你的这个简单协议叫Merkle谜题协议

26
00:01:38,305 --> 00:01:43,810
这个协议是由Ralph Merkle在1974年发明的，当时他还是个大学生

27
00:01:43,810 --> 00:01:48,218
有趣的是，他发明这个协议是作为他参加的小组研讨的一部分

28
00:01:48,218 --> 00:01:52,204
但是显然，教授没有很好地理解这个结构的意义

29
00:01:52,204 --> 00:01:55,151
最后Ralph Merkle毕业，又来到斯坦福大学

30
00:01:55,151 --> 00:01:58,342
在那里他成了Marty Hellman的学生

31
00:01:58,342 --> 00:02:02,255
自从那时起他们做了许多有关公共密钥密码术的研究

32
00:02:02,255 --> 00:02:05,478
接下来让我给大家展示Merkle Puzzles是怎么工作的

33
00:02:05,478 --> 00:02:08,084
这个协议的主要工具叫做一个“谜题”

34
00:02:08,084 --> 00:02:10,164
让我解释一下“谜题”的意思

35
00:02:10,164 --> 00:02:14,020
一个谜题就是一个很难解决的问题，但可以通过一些努力去解决

36
00:02:14,020 --> 00:02:17,282
换句话说，如果你真的想着这个问题那么你就可以解决它

37
00:02:17,282 --> 00:02:18,719
那么让我举个例子

38
00:02:18,719 --> 00:02:22,826
假设我们有一个对称密码，它使用128位长的密钥

39
00:02:22,826 --> 00:02:24,988
可以想到AES例子

40
00:02:24,988 --> 00:02:31,080
假设我选择一个前96位都为零的AES密钥

41
00:02:31,080 --> 00:02:35,996
只有剩下的32位是非零的，并且随机选择

42
00:02:35,996 --> 00:02:42,502
好的，那么这个128位密钥中只有32位是随机的。剩下的都为零

43
00:02:42,502 --> 00:02:46,683
我要做的是加密一个固定的明文，

44
00:02:46,683 --> 00:02:52,504
这个明文“message”使用的128位密钥中的大部分都是0

45
00:02:52,504 --> 00:02:55,252
加密的结果就叫就“谜题”

46
00:02:55,252 --> 00:02:58,250
我称之为谜题的原因是，事实上并不难找到密钥P，

47
00:02:58,250 --> 00:03:03,279
只需通过2的32次方，我们总可能找到。

48
00:03:03,279 --> 00:03:10,376
记住，前96位都为零，只要尝试2的32次方种可能的密钥

49
00:03:10,376 --> 00:03:16,407
并且对于每一个密钥，我们将要试着去解密这个谜题，看看是否我们得到了明文“message”

50
00:03:16,407 --> 00:03:20,877
如果是这样，我们就知道我们找到了正确的解决方法P

51
00:03:20,877 --> 00:03:25,043
因此，经过这2的32次方次的工作，我们事实上可以解决谜题

52
00:03:25,043 --> 00:03:28,507
显然，给我们谜题 (p) 我们就可以找到 P

53
00:03:28,507 --> 00:03:30,350
工作方法如下

54
00:03:30,350 --> 00:03:33,524
Alice一开始创建了大量的谜题

55
00:03:33,524 --> 00:03:36,473
特别地，她将建立2的32次方个不同的谜题

56
00:03:36,473 --> 00:03:40,558
现在她建立每一个谜题的方式如下题

57
00:03:40,558 --> 00:03:44,912
她选择一个32位的随机谜题P-i

58
00:03:44,912 --> 00:03:48,106
（这里i从1到2的32次方）

59
00:03:48,106 --> 00:03:52,567
之后她将选择两个值，x-i，k-i

60
00:03:52,567 --> 00:03:54,108
每一个都是128位的

61
00:03:54,108 --> 00:04:00,779
她要做的是她使用96位0链接谜题P-i作为AES密钥

62
00:04:00,779 --> 00:04:06,581
因此，她讲创建一个128位的密钥，它的96位置零

63
00:04:06,581 --> 00:04:09,987
只有32有效位是随机的

64
00:04:09,987 --> 00:04:13,511
所以这个密钥具有32位的熵

65
00:04:13,511 --> 00:04:15,934
并且只有2的32次方个这样的密钥

66
00:04:15,934 --> 00:04:19,439
现在她用这个密钥加密明文，这个明文，

67
00:04:19,439 --> 00:04:22,025
我把它写在这，

68
00:04:22,025 --> 00:04:23,890
基本上，这个明文以“puzzle”开头

69
00:04:23,890 --> 00:04:29,623
这个谜题由识别符xi来识别，正好是128位

70
00:04:29,623 --> 00:04:34,056
我们在xi后面附上ki，ki也刚好是128位

71
00:04:34,056 --> 00:04:38,270
所以，她对所有2的32次方个谜题都如此操作，因此

72
00:04:38,270 --> 00:04:41,267
她得到了2的32次方个不同的谜题

73
00:04:41,267 --> 00:04:44,283
她将这些2的32次方个谜题发给Bob

74
00:04:44,283 --> 00:04:46,213
那么Bob会怎么做呢？

75
00:04:46,213 --> 00:04:49,790
Bob接收2的32次方个不同的谜题

76
00:04:49,790 --> 00:04:51,785
他只选择其中的一个

77
00:04:51,785 --> 00:04:53,503
他甚至不必记住任何一个

78
00:04:53,503 --> 00:04:55,857
他只要随机的忽略大部分的谜题

79
00:04:55,857 --> 00:04:57,997
然后只选择其中的一个

80
00:04:57,997 --> 00:05:00,215
假设他选择了谜题“j”

81
00:05:00,215 --> 00:05:04,150
然后他花2的32次方的时间去解这个谜题

82
00:05:04,150 --> 00:05:06,127
解决谜题是什么意思呢

83
00:05:06,127 --> 00:05:08,430
他将会尝试pi所有可能的值

84
00:05:08,430 --> 00:05:11,971
他将解密他选择的这一谜题

85
00:05:11,971 --> 00:05:15,490
并且他会检查是否明文的首部

86
00:05:15,490 --> 00:05:17,152
以puzzle开头

87
00:05:17,152 --> 00:05:19,481
如果是这样，他就会知道他正确地解了这个谜题

88
00:05:19,481 --> 00:05:25,552
并且基本上获得了谜题中嵌入的数据xj，kj

89
00:05:25,552 --> 00:05:29,801
记住，xj定义了谜题

90
00:05:29,801 --> 00:05:31,455
而kj是他是他使用的一个密钥

91
00:05:31,455 --> 00:05:35,988
现在他解决了谜题，他知道他正确地解决了谜题

92
00:05:35,988 --> 00:05:38,087
并且得到了xj和kj

93
00:05:38,087 --> 00:05:40,667
他接下来要做的是将xj传回给Alice

94
00:05:40,667 --> 00:05:45,885
只是xj的值。kj他自己保留，而且将它保密

95
00:05:45,885 --> 00:05:49,186
然后Alice在她的谜题数据库中查找

96
00:05:49,186 --> 00:05:52,311
她将要去查找谜题xj

97
00:05:52,311 --> 00:05:57,577
之后她就知道了Bob选择了密钥kj

98
00:05:57,577 --> 00:05:59,608
现在他们拥有了这个共享密钥

99
00:05:59,608 --> 00:06:02,875
因此kj就成为了他们用来互相安全交流的共享密钥

100
00:06:02,875 --> 00:06:07,262
所以在示意图中这个协议工作的方式如下

101
00:06:07,262 --> 00:06:11,228
Alice开始向Bob传了2的32次方的谜题

102
00:06:11,228 --> 00:06:14,468
我们可以推广这一说法。她想Bob发送了n个谜题

103
00:06:14,468 --> 00:06:19,152
每个谜题需要花费正比于n的时间去解决

104
00:06:19,152 --> 00:06:21,512
Bob解出了其中一个谜题

105
00:06:21,512 --> 00:06:24,347
并且他将x-j回送给Alice

106
00:06:24,347 --> 00:06:28,494
目前双方都花了时间n

107
00:06:28,494 --> 00:06:31,595
然后Alice查看谜题x_j

108
00:06:31,595 --> 00:06:35,339
还原出对应于谜题的密钥

109
00:06:35,339 --> 00:06:38,411
因此现在双方有了一个共享密钥

110
00:06:38,411 --> 00:06:40,185
他们可以使用这个密钥来相互交流

111
00:06:40,185 --> 00:06:42,157
我们来看他们所做的工作

112
00:06:42,157 --> 00:06:44,845
Alice必须准备n个谜题

113
00:06:44,845 --> 00:06:47,255
准备谜题花掉固定长的时间

114
00:06:47,255 --> 00:06:51,006
她必须准备n个谜题，她的工作是0（n）的

115
00:06:51,006 --> 00:06:54,232
Bob选择一个谜题并解决

116
00:06:54,232 --> 00:06:57,402
所以他的工作是与n成正比的 与n成线性

117
00:06:57,402 --> 00:07:00,238
我们看窃听者怎么办

118
00:07:00,238 --> 00:07:03,001
可怜的窃听者看着n个谜题过去了

119
00:07:03,001 --> 00:07:05,366
然后他看到Bob返回了一个x_j

120
00:07:05,366 --> 00:07:08,678
攻击者并不知道Bob解的是哪个谜题

121
00:07:08,678 --> 00:07:12,022
他看到的只是谜题中的随机值

122
00:07:12,022 --> 00:07:14,480
为了破解这个协议，窃听者会

123
00:07:14,480 --> 00:07:18,347
解决所有谜题，直到他找到正确的谜题

124
00:07:18,347 --> 00:07:21,517
里面有x_j,那么攻击者就会还原k_j

125
00:07:21,517 --> 00:07:24,894
我给大家的问题是，“攻击者要做多少工作？”

126
00:07:24,894 --> 00:07:26,955
攻击者必须做多少工作

127
00:07:26,955 --> 00:07:28,705
才能破解这个协议

128
00:07:28,705 --> 00:07:33,536
答案当然是0（n^2）

129
00:07:33,536 --> 00:07:35,487
n平方的时间

130
00:07:35,487 --> 00:07:39,125
他必须解决n个谜题，每个谜题花掉时间n

131
00:07:39,125 --> 00:07:42,306
因此他必须花掉时间n^2

132
00:07:42,306 --> 00:07:45,467
在我们的例子中，我们说过有2的32次方个谜题

133
00:07:45,467 --> 00:07:47,986
每个谜题需要2的32次方的时间来解决

134
00:07:47,986 --> 00:07:51,820
所以总的来看，攻击者需要做2的64次方步工作

135
00:07:51,820 --> 00:07:55,465
大家可以看到这个协议的问题了

136
00:07:55,465 --> 00:07:58,151
首先，参与者Alice和Bob自己

137
00:07:58,151 --> 00:07:59,584
需要做大量的工作

138
00:07:59,584 --> 00:08:01,421
想一想，Alice必须发送

139
00:08:01,421 --> 00:08:03,481
2的32次方个谜题给Bob

140
00:08:03,481 --> 00:08:07,168
她必须发很多GB的数据给Bob

141
00:08:07,168 --> 00:08:10,893
比如16GB或32GB，取决于谜题的大小

142
00:08:10,893 --> 00:08:14,937
Bob必须花2的32次方的时间，来解决其中的一个谜题

143
00:08:14,937 --> 00:08:16,787
这大概也会花几秒钟

144
00:08:16,787 --> 00:08:20,361
那么他们获得的所有的安全性在于

145
00:08:20,361 --> 00:08:23,435
攻击者可以在2的64次方的时间内破解这一协议

146
00:08:23,435 --> 00:08:26,677
2的64次方依然不能被认为是安全的

147
00:08:26,677 --> 00:08:29,366
因此，如果攻击者真想

148
00:08:29,366 --> 00:08:31,502
破解这个协议，他是可以的

149
00:08:31,502 --> 00:08:33,738
那么为了让这个协议安全，参与双方必须

150
00:08:33,738 --> 00:08:36,141
增加参数n

151
00:08:36,141 --> 00:08:38,391
他们必须发送，比如说，2的64次方个谜题

152
00:08:38,391 --> 00:08:41,450
给对方，然后花2的64次方的时间

153
00:08:41,450 --> 00:08:44,380
去解决这个谜题，那么攻击者的工作

154
00:08:44,380 --> 00:08:47,791
将是2的128次方，可认为是安全的了

155
00:08:47,791 --> 00:08:50,165
但是参与者花了2的64次方的时间

156
00:08:50,165 --> 00:08:55,429
来建立一个安全的会话，对每个参与者来说有点吃力了

157
00:08:55,429 --> 00:08:58,954
所以这就是为什么这个协议不实用

158
00:08:58,954 --> 00:09:01,496
不过这里有一个很好的想法

159
00:09:01,496 --> 00:09:04,194
参与者必须花线性的时间

160
00:09:04,194 --> 00:09:06,748
而攻击者必须花平方的时间

161
00:09:06,748 --> 00:09:09,083
这就有一个“平方鸿沟”

162
00:09:09,083 --> 00:09:11,604
横亘在参与者和攻击者的工作之间

163
00:09:11,604 --> 00:09:13,607
当攻击者想破解这个协议

164
00:09:13,607 --> 00:09:16,926
那么一个很自然的问题是，我们能否做得更好

165
00:09:16,926 --> 00:09:20,132
只使用对称密码，做得比平方鸿沟更好呢？

166
00:09:20,132 --> 00:09:21,602
换句话说，使用我们前面四个礼拜

167
00:09:21,602 --> 00:09:24,144
在本课程中见过的技术

168
00:09:24,144 --> 00:09:27,384
答案是未知的

169
00:09:27,384 --> 00:09:30,633
我们不知道平方鸿沟是否是我们所能做到的最好的结果

170
00:09:30,633 --> 00:09:32,993
大家可以试着想一想

171
00:09:32,993 --> 00:09:36,062
如何使用AES或SHA-256来进行密钥交换

172
00:09:36,062 --> 00:09:38,556
可以获得比平方鸿沟更好的结果？

173
00:09:38,556 --> 00:09:40,759
不过我可以告诉大家，我们相信

174
00:09:40,759 --> 00:09:41,931
平方鸿沟是我们所能做到的最好的了

175
00:09:41,931 --> 00:09:44,436
这里还有一些负面的结果

176
00:09:44,436 --> 00:09:47,557
不严格地说，有一个结果说

177
00:09:47,557 --> 00:09:51,177
事实上，如果我们把分组密码或哈希函数

178
00:09:51,177 --> 00:09:53,736
当做黑盒神谕来使用，换句话说

179
00:09:53,736 --> 00:09:57,124
参与者只能询问分组密码

180
00:09:57,124 --> 00:09:59,165
或询问哈希函数在特定点的值

181
00:09:59,165 --> 00:10:03,237
并获得结果，如果这些是参与者所能做的全部

182
00:10:03,237 --> 00:10:05,729
换句话说，参与者不能实际使用

183
00:10:05,729 --> 00:10:08,541
分组密码或哈希函数的实现

184
00:10:08,541 --> 00:10:12,414
那么事实上有一个结果告诉我们，如果参与者只能

185
00:10:12,414 --> 00:10:15,351
询问分组密码在n个点的值，那么总有一个攻击

186
00:10:15,351 --> 00:10:18,707
运行在n平方的时间里

187
00:10:18,707 --> 00:10:21,549
这就是说，如果你只能使用

188
00:10:21,549 --> 00:10:24,094
分组密码作为一个黑盒进行询问

189
00:10:24,094 --> 00:10:26,128
那么无论交换什么密钥

190
00:10:26,128 --> 00:10:29,371
这个密钥交换总有一个平方时间的攻击

191
00:10:29,371 --> 00:10:31,747
事实上，在本章结束时，我指出这篇论文

192
00:10:31,747 --> 00:10:34,713
最近的一篇2009年的论文

193
00:10:34,713 --> 00:10:36,591
证明了平方是我们能做的最好的

194
00:10:36,591 --> 00:10:38,985
如果大家想了解更多的关于这种不可能性的结果

195
00:10:38,985 --> 00:10:41,126
去读这篇文章吧

196
00:10:41,126 --> 00:10:44,093
这篇论文可读性强，大家应该能理解它

197
00:10:44,093 --> 00:10:46,104
那么问题是接下来怎么办

198
00:10:46,104 --> 00:10:47,470
我们有点困住了

199
00:10:47,470 --> 00:10:49,013
我们说过用分组密码，我们不能

200
00:10:49,013 --> 00:10:51,259
做得比平方鸿沟更好

201
00:10:51,259 --> 00:10:52,635
那我们怎么办

202
00:10:52,635 --> 00:10:55,029
那么这就是公钥密码学的起点

203
00:10:55,029 --> 00:10:57,727
我们发现，我们需要

204
00:10:57,727 --> 00:11:00,851
比通用分组密码和哈希函数更多的技术

205
00:11:00,851 --> 00:11:04,682
我们实际上需要具备非常特殊性质的函数

206
00:11:04,682 --> 00:11:08,806
为了构建这些函数，我们实际上必须依赖某些代数

207
00:11:08,806 --> 00:11:11,506
下面几节我们看

208
00:11:11,506 --> 00:11:14,002
一些代数机制，然后我们看

209
00:11:14,002 --> 00:11:20,760
如何使用它们来进行密钥交换。【END】

