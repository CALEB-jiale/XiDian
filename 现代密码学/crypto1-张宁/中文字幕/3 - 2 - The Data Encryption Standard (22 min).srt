1
00:00:00,000 --> 00:00:03,662
好了，现在我们理解了什么是分组密码。
让我们来看一个经典的例子：

2
00:00:03,662 --> 00:00:07,655
数据加密标准DES。
先快速提醒一下，

3
00:00:07,655 --> 00:00:12,379
分组密码基本上就是N比特输入映射到N比特输出。
我们讨论了两个

4
00:00:12,379 --> 00:00:17,045
规范的例子，三重DES和AES。
在这一节，我们讨论DES

5
00:00:17,045 --> 00:00:21,480
接着在下一节讨论三重DES。

6
00:00:21,480 --> 00:00:26,031
我之前提到分组密码一般是迭代构成的，特别的

7
00:00:26,031 --> 00:00:30,985
我们将看到，这种分组密码的迭代方式是：

8
00:00:30,985 --> 00:00:35,863
一个密钥先扩展成一堆密钥，
接着，一个轮函数

9
00:00:35,863 --> 00:00:40,660
对输入信息一次次进行作用。
基本上，所有的轮函数作用后，

10
00:00:40,660 --> 00:00:45,156
我们就得到了密文。对吧？回过来

11
00:00:45,156 --> 00:00:49,253
我们将要看看DES数据加密标准，
以及如何使用这种形式

12
00:00:49,253 --> 00:00:53,577
我想澄清一点，实际上，
想搞清楚这种类型的分组密码

13
00:00:53,577 --> 00:00:57,788
一是要搞清楚密钥扩展机制，
二是要搞清楚轮函数， 

14
00:00:57,788 --> 00:01:02,113
本节这里，我将集中在轮函数，

15
00:01:02,113 --> 00:01:06,551
不过多地讨论密钥扩展。但是我要提一下

16
00:01:06,551 --> 00:01:10,990
实际上，密钥扩展也是分组密码工作很重要的一个部分

17
00:01:10,990 --> 00:01:15,892
好，我们来看看DES的历史。
基本上，在20世纪七十年代早期，

18
00:01:15,892 --> 00:01:20,715
IBM意识到他们的顾客要求某种形式的加密，

19
00:01:20,715 --> 00:01:25,869
所以他们组建了一个密码学团队，
这团队的头儿是Horst Feistel，

20
00:01:25,869 --> 00:01:30,492
他在70年代早期设计了一种密码叫Lucifer密码

21
00:01:30,492 --> 00:01:35,560
事实上现在，有趣的是Lucifer密码有很多种变形。

22
00:01:35,560 --> 00:01:40,559
但是实际上后期的一种变形，
令密钥长度为128比特，分组长度也是128比特。

23
00:01:40,559 --> 00:01:45,682
好的，1973年的时候政府意识到
他们购买了大量商业现货供应的计算机，

24
00:01:45,682 --> 00:01:50,867
因此希望供应商能够提供一种良好的加密算法

25
00:01:50,867 --> 00:01:55,434
使得它们能够应用到计算机中，所以

26
00:01:55,434 --> 00:02:00,157
1973年，当时的国家标准局，提出一项征集令。

27
00:02:00,157 --> 00:02:04,503
征集一种分组密码作为联邦标准

28
00:02:04,503 --> 00:02:09,026
实际上，IBM提交了一个Lucifer密码的变种。

29
00:02:09,026 --> 00:02:13,901
这个变种在标准化的过程中进行了一些修正，最终

30
00:02:13,901 --> 00:02:18,482
在1976年，国家标准局接受DES作为联邦标准，
而且，实际上

31
00:02:18,482 --> 00:02:23,122
对DES来说，有趣的是它的密钥长度比Lucifer密码短得多

32
00:02:23,122 --> 00:02:27,602
只有56比特，分组长度也减少到64比特，

33
00:02:27,602 --> 00:02:31,838
事实上，这些决定，尤其是缩短密钥长度的决定，

34
00:02:31,838 --> 00:02:36,653
成为DES密钥长度的一个限制，
关于这个在整个DES的使用过程中，

35
00:02:36,653 --> 00:02:41,062
不断遭人诟病，尤其，在1997年，DES遭受穷举搜索攻击

36
00:02:41,062 --> 00:02:45,994
意味着一台机器可以搜素所有的2的56次方个密钥

37
00:02:45,994 --> 00:02:50,867
从而恢复出特定挑战密钥，我们也会在后面讨论

38
00:02:50,867 --> 00:02:54,683
一下穷举搜索攻击，那是个非常有意思的问题，但是

39
00:02:54,683 --> 00:02:59,335
抵抗穷举搜索攻击的方法有很多，
基本上，1997年的这次实验

40
00:02:59,335 --> 00:03:03,655
注定了DES的命运，也就是说，DES本身不再安全了。

41
00:03:03,655 --> 00:03:08,251
因此，现在的国家标准研究所，发布了新的

42
00:03:08,251 --> 00:03:12,755
项目征集，我们下一代的分组密码标准

43
00:03:12,755 --> 00:03:17,427
在2000年确定为Rijindael密码，
它最终成为高级加密标准AES，

44
00:03:17,427 --> 00:03:21,903
后面我们会讨论AES，
但是在这一节，我想

45
00:03:21,903 --> 00:03:26,199
描述一下DES是怎么工作的。
现在，DES是一种有着惊人成就的密码。

46
00:03:26,199 --> 00:03:30,496
在银行业也广为采用。
实际上，有一种经典的网络，

47
00:03:30,496 --> 00:03:34,613
称为电子清算所，借助这个，银行之间互相

48
00:03:34,613 --> 00:03:39,447
清算支票 DES被用来保证这些交易的完整性

49
00:03:39,447 --> 00:03:43,922
商业上也用这个。实际上，截止最近，
它还非常流行，在网络上

50
00:03:43,922 --> 00:03:48,699
还是主要的加密机制，当然，现在已经逐渐被AES

51
00:03:48,699 --> 00:03:52,977
和其它密码代替，总的来说，
在应用上DES是一个非常成功的密码，

52
00:03:52,977 --> 00:03:57,425
对DES的攻击也是由来已久，
我们将在下一节讨论

53
00:03:57,425 --> 00:04:01,931
好的，现在，让我们看看DES的结构。

54
00:04:01,931 --> 00:04:06,608
DES的核心理念是Feistel网络，得名自Horst Feistel

55
00:04:06,608 --> 00:04:11,087
基本上，Feistel网络是一个非常聪明的方法，
利用任意f1到fd的函数

56
00:04:11,087 --> 00:04:15,485
构造分组密码，好的，
现在想象我们有这些函数f1到fd

57
00:04:15,485 --> 00:04:18,765
从n比特映射到n比特，这些是任意函数

58
00:04:18,765 --> 00:04:22,425
不需要不可逆或者其它条件，我们现在想做的是

59
00:04:22,425 --> 00:04:26,956
用d个函数构造一个可逆函数，通过构造

60
00:04:26,956 --> 00:04:31,484
一个新的函数，用大写F来表示，
将2n比特映射到2n比特

61
00:04:31,484 --> 00:04:35,593
这里描述了这个构造。所以，
这里我们有输入，你会注意到，

62
00:04:35,593 --> 00:04:40,299
这有两组n比特数据，换句话说，
输入实际上就是2n比特

63
00:04:40,299 --> 00:04:44,792
R和L分别代表右边和左边。
通常，人们描述

64
00:04:44,792 --> 00:04:49,205
Feistel网络都是从上到下，那样，这n比特分别为左边和右边。

65
00:04:49,205 --> 00:04:52,214
但是这里为了方便我描述，我横着来，

66
00:04:52,214 --> 00:04:56,300
现在我们看看R这边的输入，
你看它就是L这边的输出，

67
00:04:56,300 --> 00:05:01,555
没有任何变化，对吧？

68
00:05:01,555 --> 00:05:07,260
但是L这边的输入发生变化了，
变化就是 R这边的

69
00:05:07,260 --> 00:05:12,888
输入经过一个函数变化f1的结果和L0进行异或，
结果是新的R1输入。

70
00:05:12,888 --> 00:05:17,711
好的，这个就是Feistel网络的一轮。

71
00:05:17,711 --> 00:05:22,584
这里用到了一个f1函数，
现在我们再看下一轮Feistel网络。

72
00:05:22,584 --> 00:05:26,122
这里用到了f2，然后我们一遍遍地这样做，

73
00:05:26,122 --> 00:05:31,969
直到我们到最后一轮，
用函数fd，最后输出

74
00:05:31,969 --> 00:05:37,542
是Rd和Ld。好的，如你所愿，我们用符号把它写出来

75
00:05:37,542 --> 00:05:43,003
Li=Ri-1，Ri要更复杂一些，我们看看

76
00:05:43,003 --> 00:05:50,451
就跟着这线条这里。
Ri=Fi(Ri-1)⊕Li-1（这里应该是bug不能是Li）

77
00:05:50,451 --> 00:05:58,968
对吧？所以这个我基本上就是从1走到d，

78
00:05:58,968 --> 00:06:06,618
所以这就是定义Feistel网络的方程，

79
00:06:06,618 --> 00:06:09,673
把2n比特的输入映射到2n比特的输出。
所以这边我们还有，就是把

80
00:06:09,673 --> 00:06:14,831
Feistel网络的图复制一下，
这里比较奇特的是，实际上

81
00:06:14,831 --> 00:06:19,541
不管你给我什么函数，对于任何函数f1到fd

82
00:06:19,541 --> 00:06:24,602
Feistel网络函数，实际上是可逆的，我们证明

83
00:06:24,602 --> 00:06:27,635
这一点的方法，基本上就是我们要构造一个逆，
因为不仅它可逆，

84
00:06:27,635 --> 00:06:31,235
而且它的逆很容易计算，所以我们看一下，我们看

85
00:06:31,235 --> 00:06:36,628
Feistel网络的一轮，这里，这个是输入，
Ri和Li，这里是输出

86
00:06:36,628 --> 00:06:41,618
Ri+1和Li+1，现在我想让你求逆

87
00:06:41,618 --> 00:06:48,781
所以，我们看，假设现在给的输入是Ri+1和Li+1，
我们想计算Ri和Li

88
00:06:48,781 --> 00:06:54,883
也就是我们想反方向计算这一轮，
看一下我们怎么做，

89
00:06:54,883 --> 00:07:00,024
Ri，Ri很简单，其实

90
00:07:00,024 --> 00:07:07,240
Ri=Li+1，所以，Li+1变成Ri，
现在，我问你了，

91
00:07:07,245 --> 00:07:12,157
如何用Ri+1和Li+1写出Li的表达式

92
00:07:13,049 --> 00:07:17,991
我希望每个人都知道，Li+1输入函数fi+1的结果和

93
00:07:17,991 --> 00:07:24,810
Ri+1进行异或，就得到Li

94
00:07:24,810 --> 00:07:28,181
所以，这是Feistel网络一轮的逆，

95
00:07:28,181 --> 00:07:32,865
如果我们画个图，让我们看看逆的图。

96
00:07:32,865 --> 00:07:38,810
这里你看到输入是Ri+1和Li+1，输出是Ri和Li，对吧？

97
00:07:38,810 --> 00:07:43,278
我们这样这一轮就算出来了，求逆了，你应该注意到，

98
00:07:43,278 --> 00:07:47,242
Feistel的一轮的逆和正向的一轮基本一样，

99
00:07:47,242 --> 00:07:50,237
字面上来看，你知道，因为技术原因

100
00:07:50,237 --> 00:07:54,309
实际上这互为镜像，但是，它们就是一样的构造

101
00:07:54,309 --> 00:07:59,133
如果我们把每一轮的逆都放到一起，
我们就得到了整个

102
00:07:59,133 --> 00:08:03,446
Feistel网络的逆。注意，我们这里从第d轮

103
00:08:03,446 --> 00:08:07,632
开始算d轮的逆，接着做第d-1轮

104
00:08:07,632 --> 00:08:11,458
这么一直做下去，直到第一轮，

105
00:08:11,458 --> 00:08:18,063
最后我们得到输出是R0和L0，就像这样，

106
00:08:18,063 --> 00:08:22,694
已知Rd和Ld，得到R0和L0。有趣的是

107
00:08:22,694 --> 00:08:25,882
这个逆网络和加密网络

108
00:08:25,882 --> 00:08:31,105
看起来基本是一样的，唯一不同的是
这些作用函数的顺序是相反的，

109
00:08:31,105 --> 00:08:35,566
就是我们这里从fd开始到f1结束，而在加密的时候，

110
00:08:35,566 --> 00:08:40,539
从f1开始到fd结束。所以，
对硬件设计师而言，这个很有吸引力，

111
00:08:40,539 --> 00:08:44,808
因为基本上，你可以节省硬件，

112
00:08:44,808 --> 00:08:48,536
你会发现，你的加密硬件和解密硬件一样。
所以你只需要实现一个算法，

113
00:08:48,536 --> 00:08:52,674
那这两个算法你就都实现了，唯一的

114
00:08:52,674 --> 00:08:56,899
区别就是这些函数是逆序的，好的，

115
00:08:56,899 --> 00:09:01,109
这种Feistel机制作为一种基本方法利用任何函数f1到fd

116
00:09:01,109 --> 00:09:06,224
构造可逆函数，在多种分组密码中广泛使用

117
00:09:06,224 --> 00:09:11,040
但是有趣的是在AES中没有用，所以

118
00:09:11,040 --> 00:09:15,297
Feistel网络在很多分组密码中都有。
当然，因为f1到fd的不同，

119
00:09:15,297 --> 00:09:19,838
它们和DES不尽相同，
但是AES用的是完全不同的一种结构，

120
00:09:19,838 --> 00:09:24,033
不是Feistel网络，我们后面几节课，

121
00:09:24,033 --> 00:09:29,043
会研究AES是怎么工作的。
所以现在我们知道Feistel网络了，

122
00:09:29,043 --> 00:09:32,898
我们看一个重要的关于
Feistel网络理论的定理，这个定理

123
00:09:32,898 --> 00:09:37,794
也证明了它是一个好方法。
定理是1985年Luby和Rackoff提出的，

124
00:09:37,794 --> 00:09:41,774
描述如下，假设我有一个函数，

125
00:09:41,774 --> 00:09:46,804
伪随机函数，它和随机函数不可区分。
从n比特输入映射到n比特输出，

126
00:09:46,804 --> 00:09:52,857
在密钥k的作用下，这样，结果是如果你

127
00:09:52,857 --> 00:09:57,621
用这个函数进行三轮Feistel变化，
你将得到一个

128
00:09:57,621 --> 00:10:03,208
安全的伪随机置换，换句话说，
你得到了一个可逆的函数。

129
00:10:03,208 --> 00:10:07,724
这个可逆函数和随机可逆函数不可区分

130
00:10:07,724 --> 00:10:11,457
我希望你记得安全分组密码的定义是，
需要它是一个

131
00:10:11,457 --> 00:10:16,106
安全的伪随机置换。所以，
这个定理说的是，如果你用

132
00:10:16,106 --> 00:10:20,303
一个安全的伪随机函数，
那么你就能得到一个安全的分组密码。

133
00:10:20,303 --> 00:10:23,824
好的，就是这样，让我多解释一下

134
00:10:23,824 --> 00:10:28,939
这是怎么回事，基本上，PRF在

135
00:10:28,939 --> 00:10:34,808
Feistel网络的每一轮都用。
所以，换句话说，

136
00:10:34,808 --> 00:10:39,731
这里算的就是PRF在密钥K0作用下，
这里算的是

137
00:10:39,731 --> 00:10:45,959
在密钥K1作用下R1的函数值，
这里是另一个密钥K2

138
00:10:45,959 --> 00:10:51,578
作用于R2。
这你就会发现，为什么

139
00:10:51,578 --> 00:10:55,371
这个Feistel结构的密钥空间是K的三次方。
换句话说，它用了3个独立的密钥。

140
00:10:55,371 --> 00:11:01,004
这里，密钥互相独立，十分重要。

141
00:11:01,004 --> 00:11:07,438
也就是说，我们需要真正独立的三个密钥，
这样我们就得到了

142
00:11:07,438 --> 00:11:12,600
一个安全的伪随机置换，好的，
这就是Feistel网络背后的理论。

143
00:11:12,600 --> 00:11:16,051
现在，我们明白了这个，
我们可以看看具体DES的情况。

144
00:11:16,051 --> 00:11:20,256
DES实际上是一个16轮的Feistel网络，
好的，这是函数

145
00:11:20,256 --> 00:11:26,349
f1到f16将32比特映射32比特。
所以，DES

146
00:11:26,349 --> 00:11:33,054
是作用在64比特的分组上，就是2*32。
现在，DES的16个轮函数

147
00:11:33,054 --> 00:11:37,673
实际上是从一个函数F来的，就是用的不同的密钥，

148
00:11:37,673 --> 00:11:44,765
所以，轮密钥不同。
ki是一个轮密钥，

149
00:11:44,765 --> 00:11:52,585
它是从密钥K得出的，
长度为56比特的DES密钥K。好的，

150
00:11:52,585 --> 00:11:56,567
我马上来说一下这个函数F，
但是实际上，你看到使用

151
00:11:56,567 --> 00:12:01,856
16个不同的轮密钥，我们得到16个不同的轮函数，

152
00:12:01,856 --> 00:12:06,460
从而得到Feistel网络，这就是从上层看DES是怎么工作的。

153
00:12:06,460 --> 00:12:10,829
基本上你有一个64比特的输入，
首先，这个初始置换

154
00:12:10,829 --> 00:12:15,175
仅仅置换一下这64比特的位置，
即把第一个比特置换到第六个比特，

155
00:12:15,175 --> 00:12:20,216
第二个比特置换到第17个比特这样，
这不是为了安全

156
00:12:20,216 --> 00:12:24,702
就是标准里有这一条。
(实际上是为了打乱语言统计特性)

157
00:12:24,702 --> 00:12:29,076
接着，进入到16轮Feistel网络，
你知道它是怎么工作的，

158
00:12:29,076 --> 00:12:33,810
就是使用我们前面说过的f1到f16函数，接着，

159
00:12:33,810 --> 00:12:38,721
有另外一个置换，称为最终置换，其实就是初始置换的逆，

160
00:12:38,721 --> 00:12:42,863
也是置换位置，对安全性没什么贡献。

161
00:12:42,863 --> 00:12:47,728
最终我们得到输出，好的，

162
00:12:47,728 --> 00:12:53,400
现在，像我们前面说的，
有一个密钥扩展的步骤，我就不描述了

163
00:12:53,400 --> 00:12:59,546
但是，这56比特的DES密钥扩展出这些轮密钥，

164
00:12:59,546 --> 00:13:05,028
轮密钥是48比特的，好的，
我们有16个48比特的轮密钥

165
00:13:05,028 --> 00:13:10,243
它们用于DES的16个轮，接下来，
你要想一下怎么对这个密码求逆

166
00:13:10,243 --> 00:13:15,458
你所要做的就是用这些轮密钥，这16个轮密钥，逆序

167
00:13:15,458 --> 00:13:20,490
好的，现在我们明白DES的结构了，
剩下唯一的问题就是解释

168
00:13:20,490 --> 00:13:24,809
这个函数，大F，我来解释一下这个函数是怎么工作的。

169
00:13:24,809 --> 00:13:30,238
基本上，它有32比特的输入，写作X

170
00:13:30,238 --> 00:13:35,112
实际上，你得记得，这就是R0R1R3等等。

171
00:13:35,112 --> 00:13:40,352
这是32比特，它用了一个48比特的轮密钥

172
00:13:40,352 --> 00:13:45,391
所以这里有密钥ki，它是48比特。首先

173
00:13:45,391 --> 00:13:50,039
经过一个扩展盒，这个扩展盒是把32比特映射成

174
00:13:50,039 --> 00:13:57,152
48比特，现在，扩展盒就是重复其中

175
00:13:57,152 --> 00:14:04,312
的一些比特，把其它比特移动一下，
例如 X的1号比特在

176
00:14:04,312 --> 00:14:11,086
位置2和48，X的2号比特被放在

177
00:14:11,086 --> 00:14:15,124
3号位置作为输出，就这样，重复X的某些比特。

178
00:14:15,124 --> 00:14:20,588
我们把这32比特扩展成48比特，
下一步我们把这48比特

179
00:14:20,588 --> 00:14:23,940
和轮密钥异或，有些人说密码学家就是计算异或，

180
00:14:23,940 --> 00:14:30,437
这就是个例子，好的，我们就在这个做异或。

181
00:14:30,437 --> 00:14:35,817
下面就是DES的神奇之处了，
这里，这48比特分成8组，

182
00:14:35,817 --> 00:14:42,756
每组6比特，6 7 8 让我在这儿画一下

183
00:14:42,756 --> 00:14:48,790
好的，自然的，这里这些，是6比特，接着

184
00:14:48,790 --> 00:14:53,857
他们进入到所谓的S盒，我马上就会讲到S盒，

185
00:14:53,857 --> 00:15:01,524
S盒实际上是DES的核心，

186
00:15:01,524 --> 00:15:07,380
S盒实际上是一个映射，把6比特映射到4比特，
所以S盒输出是这四个比特，

187
00:15:07,380 --> 00:15:12,913
把它们合起来，就给出32比特，对吧？

188
00:15:12,913 --> 00:15:17,914
8个4比特，给我们32比特。
最终，输入到另一个置换中，

189
00:15:17,914 --> 00:15:22,982
这个置换就是换一下位置，例如

190
00:15:22,982 --> 00:15:27,045
第一个比特跑到第9个的位置，
第二个比特跑到第15个的位置，等等。

191
00:15:27,045 --> 00:15:34,353
它仅仅就是置换这32个比特，
这是F函数最终的32比特输出

192
00:15:34,353 --> 00:15:39,306
好吧？所以，使用不同的轮密钥，
基本上，我们得到不同的轮函数。

193
00:15:39,306 --> 00:15:44,355
这样构成DES的16个轮函数，

194
00:15:44,355 --> 00:15:49,093
现在，剩下的唯一问题就是解释这个S盒，
S盒，字面上讲，

195
00:15:49,093 --> 00:15:54,982
就是一个从6比特到4比特的函数，
就像用一个查找表一样，

196
00:15:54,982 --> 00:15:59,993
对吧？描述一个从6比特到4比特的函数基本上就是，

197
00:15:59,993 --> 00:16:05,134
写一个输入为2的6次方的函数的输出，

198
00:16:05,134 --> 00:16:09,984
2的6次方是64，所以我们需要一个有64个值的表，

199
00:16:09,984 --> 00:16:14,504
每个值是4比特。举个例子，这个是第五个S盒

200
00:16:14,504 --> 00:16:18,972
你看，这是一个含64个值的表吧？

201
00:16:18,972 --> 00:16:26,942
4乘以16，所以64个值。例如，你想找输出，

202
00:16:26,942 --> 00:16:35,468
对应011011的输出，好的，
你看一下这两个比特 01

203
00:16:35,468 --> 00:16:41,689
这4个比特1101，你看到输出是1001。

204
00:16:41,689 --> 00:16:46,977
输出的四个比特是1001，好的，
S盒就是用这些个表。

205
00:16:46,977 --> 00:16:51,524
现在问题是，这些S盒是怎么选的，设计者是怎么选的。

206
00:16:51,524 --> 00:16:56,167
为了让你更清楚些，我们先给个S盒

207
00:16:56,167 --> 00:17:02,395
失败的例子，想象S盒是线性的，什么意思？

208
00:17:02,395 --> 00:17:07,266
就是想象这6比特的输入，

209
00:17:07,266 --> 00:17:12,678
用不同的方式互相异或得到4比特输出

210
00:17:12,678 --> 00:17:17,893
好的，另一种写法是我们可以把S盒写成一个矩阵向量积

211
00:17:17,893 --> 00:17:23,314
所以这里，你有矩阵Ai和向量，6比特向量的向量X。

212
00:17:23,314 --> 00:17:27,826
你可以看到，如果写这个矩阵向量积，

213
00:17:27,826 --> 00:17:32,107
就是用这个向量和输入向量的内积作为输出，
记住，这都是比特

214
00:17:32,107 --> 00:17:36,446
所以，6比特的向量内积，另外6比特向量，

215
00:17:36,446 --> 00:17:40,670
进行模2加，你看到了，我们计算的就是X2⊕X3.

216
00:17:40,670 --> 00:17:44,668
对吧，因为只有位置2和位置3有1，

217
00:17:44,668 --> 00:17:50,034
下面类似的，这个内积是X1⊕X4⊕X5，下面类似

218
00:17:50,034 --> 00:17:55,096
好的，你可以看到这个S盒是这么操作的，

219
00:17:55,096 --> 00:18:00,177
那么，就是对输入向量X进行矩阵A的一个矩阵变换。

220
00:18:00,177 --> 00:18:05,456
这就是我们说的S盒是完全线性的，现在我要说，

221
00:18:05,456 --> 00:18:10,670
如果S盒是线性的，那么DES就是完全不安全的，

222
00:18:10,670 --> 00:18:15,691
原因是如果S盒是线性的，
那么所有DES做的运算就是异或和各种置换，

223
00:18:15,691 --> 00:18:20,127
所以，DES就是异或和比特置换。

224
00:18:20,127 --> 00:18:24,514
这意味着，DES就是个线性函数，

225
00:18:24,514 --> 00:18:30,505
换句话说，会有一个矩阵B，这么宽的，

226
00:18:30,505 --> 00:18:35,584
实际上，这个矩阵的宽度是832，

227
00:18:35,584 --> 00:18:41,065
我将用64的比特消息加上16个轮密钥，

228
00:18:41,065 --> 00:18:46,411
密钥有16个，每一个是48，
如果你算一下，64+16*48=832

229
00:18:46,411 --> 00:18:51,825
就是832，这里我写下来，这些值，

230
00:18:51,825 --> 00:18:57,439
密钥和消息，作为一个长向量，
这里有这个矩阵，你计算

231
00:18:57,439 --> 00:19:02,143
这个矩阵向量积就行了，这样，
你得到密文的不同比特。所以，

232
00:19:02,143 --> 00:19:06,941
这里有64行，所以，你得到64比特的密文。

233
00:19:06,941 --> 00:19:10,954
好的，这是说DES是线性的。
所以，如果你稍微思考一下这个，

234
00:19:10,954 --> 00:19:14,693
你就会意识到S盒是DES里唯一的非线性部件，

235
00:19:14,693 --> 00:19:19,116
所以，如果S盒也是线性的，
那整个结构就是线性的。

236
00:19:19,116 --> 00:19:23,358
因此，可以用这个矩阵来表示，
如果是这种情况 那么DES是

237
00:19:23,358 --> 00:19:28,066
一个糟糕的安全的伪随机置换，
让我给你看个很简单的例子。

238
00:19:28,066 --> 00:19:33,596
如果你对DES的三个输出做异或，想一下

239
00:19:33,596 --> 00:19:38,984
这是什么意思，基本上我们会看到B乘以，

240
00:19:38,984 --> 00:19:43,649
这个定义DES的矩阵B，乘以一个向量，
异或上B乘以另外一个向量，

241
00:19:43,649 --> 00:19:48,540
再异或B乘以第三个向量，我们把B提出来，这样，

242
00:19:48,540 --> 00:19:54,338
得到B乘以这个向量，但是显然k⊕k⊕k=k

243
00:19:54,338 --> 00:19:59,664
所以,你想一下,我们就得到

244
00:19:59,664 --> 00:20:06,503
以密钥k加密的m1⊕m2⊕m3的DES密文，
但是这意味着DES

245
00:20:06,503 --> 00:20:10,896
有这个可怕的相关关系，我可以检测一下。
是吧？所以，本质上，如果你

246
00:20:10,896 --> 00:20:15,682
异或这三个值的输出，m1 m2和m3，你会得到

247
00:20:15,682 --> 00:20:20,317
这三个值异或的DES加密结果，
这个性质导致DES这个函数

248
00:20:20,317 --> 00:20:25,362
不能作为随机函数，
一个随机函数不能满足这样的条件

249
00:20:25,362 --> 00:20:29,707
所以，你有一种很简单的方法告诉你DES不是一个随机函数

250
00:20:29,707 --> 00:20:34,099
实际上，我们可能会以此做个简单的练习(作业里有)，
甚至不难发现，

251
00:20:34,099 --> 00:20:39,195
有足够的输入输出对，你可以恢复出整个密钥。

252
00:20:39,195 --> 00:20:44,988
是的！你只需要832对输入输出，
你就能恢复出整个密钥。

253
00:20:44,988 --> 00:20:50,290
所以，如果S盒是线性的，

254
00:20:50,290 --> 00:20:55,652
DES将彻底不安全。事实表明，实际上，
即便S盒是近似线性的，换句话说，

255
00:20:55,652 --> 00:21:01,119
S盒在大多数时候是线性的，
可能对64个输入有60个输出是线性的，

256
00:21:01,119 --> 00:21:06,322
S就是线性的了，这样我们也能攻破DES。

257
00:21:06,322 --> 00:21:11,092
我们后面会研究一下为什么。
特别的，如果你随机选择了S盒

258
00:21:11,092 --> 00:21:15,376
你会发现它们都多少趋于线性函数，

259
00:21:15,376 --> 00:21:19,606
结果就是，你能彻底攻破DES，

260
00:21:19,606 --> 00:21:23,619
你能在很短的时间内获得密钥，
DES的设计者

261
00:21:23,619 --> 00:21:27,687
给出了一系列选择S盒的规则，不出意料的，

262
00:21:27,687 --> 00:21:31,711
第一规则就是这些函数不能是线性的，

263
00:21:31,711 --> 00:21:36,208
好的，换句话说，就是没有(线性)函数能满足大部分S盒的输出。

264
00:21:36,208 --> 00:21:39,840
还有一起其它的规则，比如，

265
00:21:39,840 --> 00:21:44,146
S盒是个4对1的映射，就是说每个输出对应四个原像。

266
00:21:44,146 --> 00:21:48,433
等等还有其它，现在在我们理解了为什么S盒

267
00:21:48,433 --> 00:21:52,773
要有这样的选择方式，
实际上都是为了抵抗某种对DES的攻击

268
00:21:52,773 --> 00:21:56,742
好的，我们对DES就讲到这里，下几节

269
00:21:56,742 --> 00:21:59,706
我们将看一下DES的安全性。【END】

