1
00:00:00,000 --> 00:00:03,553
现在我们已经了解了流密码，让我们继续谈论一个

2
00:00:03,553 --> 00:00:07,430
更强大的原型：分组密码。一个分组密码由两个

3
00:00:07,430 --> 00:00:11,800
算法组成，E和D，分别表示加密算法和解密算法，

4
00:00:11,800 --> 00:00:17,183
而且这两种算法都采取一个密钥K作为输入。
现在，一个分组密码的重要的一点是，

5
00:00:17,183 --> 00:00:23,572
它采取一个N比特的明文作为输入，
并且它的输出是完全相同的比特数

6
00:00:23,572 --> 00:00:28,538
因此它将n比特的输入正好映射成n比特的输出。

7
00:00:28,538 --> 00:00:33,000
现在有两种典型的分组密码的例子，
第一种就是所谓的三重DES加密

8
00:00:33,000 --> 00:00:37,895
三重DES的分组大小(即输入比特数)是64.因此三重EDS

9
00:00:37,895 --> 00:00:44,388
将64比特分组映射成64比特分组，
并且它使用一个168比特长的密钥

10
00:00:44,388 --> 00:00:48,276
我们将在后面再来讨论三重DES是如何构建的。

11
00:00:48,276 --> 00:00:51,934
另一种更近期的分组密码，
被命名为高级加密标准(AES)

12
00:00:51,934 --> 00:00:55,846
AES有稍微不同的参数，它的分组大小是128比特

13
00:00:55,846 --> 00:01:01,687
所以AES将128比特输入映射为128比特的输出

14
00:01:01,687 --> 00:01:07,169
它实际上有三种可能大小的密钥，
我将它们的大小写在这里

15
00:01:07,169 --> 00:01:11,205
基本上密钥越长，加密越慢

16
00:01:11,205 --> 00:01:13,445
但据估安全性更高更难破解，并且一会我们将

17
00:01:13,445 --> 00:01:18,208
讨论保持分组密码的安全性意味着什么。

18
00:01:18,208 --> 00:01:21,990
现在分组密码通常通过迭代来构建。
它们采用密钥K作为输入

19
00:01:21,990 --> 00:01:26,169
例如在AES的情况下，密钥可以是128比特长

20
00:01:26,169 --> 00:01:31,467
而且第一步是密钥扩大成从K1到Kn的序列

21
00:01:31,467 --> 00:01:36,523
称为回合密钥(Round Keys)。现在，
密码使用这些回合密钥来加密的方式

22
00:01:36,523 --> 00:01:41,024
是通过一次又一次迭代加密消息并重复使用，
这就是轮函数(Round Functions)。

23
00:01:41,024 --> 00:01:45,760
而在这里，这个函数R这需要两个输入。

24
00:01:45,760 --> 00:01:50,612
这个函数R就被称为轮函数。
它的输入有回合密钥，

25
00:01:50,612 --> 00:01:55,113
另一个输入是消息的当前状态。
所以在这里，我们有我们输入的明文消息。

26
00:01:55,113 --> 00:01:59,685
再说，对于AES来说，该消息将正好是128比特位，
因为每个AES分组正好是128比特。

27
00:01:59,685 --> 00:02:04,920
然后首先我们应用的第一个轮函数

28
00:02:04,920 --> 00:02:09,713
使用密钥K1来对消息加密，
然后我们得到一个新消息作为结果。

29
00:02:09,713 --> 00:02:14,548
我们记之为m1，在下一轮轮函数中使用

30
00:02:14,548 --> 00:02:19,100
不同的密钥K2进行加密。然后我们得到下一轮消息。

31
00:02:19,100 --> 00:02:23,533
然后继续这样加密到第四次
直至所有轮函数都被用于加密，

32
00:02:23,533 --> 00:02:28,262
然后得到最终输出就是我们的加密结果。再次的

33
00:02:28,262 --> 00:02:32,645
在AES的情况下这输出结果将是128比特。
并且得到的密文也将是128比特。

34
00:02:32,645 --> 00:02:36,593
现在，不同的加密算法具有不同的轮数和

35
00:02:36,593 --> 00:02:40,439
不同的轮函数。例如，三重DES的轮数是48。

36
00:02:40,439 --> 00:02:44,438
接下来我们将看到轮函数究竟如何为三重DES工作

37
00:02:44,438 --> 00:02:48,488
对于AES，它的轮数只可能是10

38
00:02:48,488 --> 00:02:52,282
并且马上我们也将再次来看看

39
00:02:52,282 --> 00:02:54,209
轮函数是如何为AES工作的。

40
00:02:54,563 --> 00:02:57,665
在这之前，我想提及一些性能数据

41
00:02:57,665 --> 00:02:59,513
因此你可以看到这些性能数据

42
00:02:59,513 --> 00:03:04,721
都是两种典型分组密码三重DES和AES的性能数据。

43
00:03:04,721 --> 00:03:08,490
并且这些也是流密码的相应性能数据

44
00:03:08,490 --> 00:03:10,508
我们在前面模块所看到过

45
00:03:13,155 --> 00:03:15,019
你会发现该分组密码

46
00:03:15,019 --> 00:03:18,209
比流密码慢得多。但我们会看到，

47
00:03:18,209 --> 00:03:22,486
我们可以用分组密码做很多事情，
但如果用RC4却不能有效完成

48
00:03:22,486 --> 00:03:27,262
现在我本周的目标是向你展示分组密码是如何工作的

49
00:03:27,262 --> 00:03:31,700
但更重要的是我想说明如何正确使用分组密码，

50
00:03:31,700 --> 00:03:36,210
无论是对于加密或是完整性或是不管什么你能想到的任何应用。

51
00:03:36,210 --> 00:03:40,606
因此，为了向你们展示如何正确使用分组密码，

52
00:03:40,606 --> 00:03:45,345
适当的抽象将使我们对该密码有一个更清晰的认识。

53
00:03:45,345 --> 00:03:49,856
然后，我们可以争辩和推理什么结构是正确的，

54
00:03:49,856 --> 00:03:54,423
什么结构是不正确的。
所以分组密码的一个抽象而优雅的概念就是

55
00:03:54,423 --> 00:03:58,590
所谓的伪随机函数(PRF)和伪随机置换(PRP)。

56
00:03:58,590 --> 00:04:03,518
让我来解释一下这些概念是什么。一个伪随机函数

57
00:04:03,518 --> 00:04:08,831
被定义在密钥空间、一个输入空间和一个输出空间。

58
00:04:08,831 --> 00:04:14,428
并且这全部基本上是一个函数,它采用一个密钥与输入作为输入,

59
00:04:14,428 --> 00:04:20,095
并输出一些在输出空间中的元素。
而它需要给出一个密钥K，一个元素X，并输出Y.

60
00:04:20,095 --> 00:04:24,746
而唯一本质上的要求是要一个

61
00:04:24,746 --> 00:04:29,132
有效方式来计算函数。
对于函数我们不要求它们是可逆的，

62
00:04:29,132 --> 00:04:33,882
我们只要求在给出的密钥和输入值X的时候它们是可求的。

63
00:04:33,882 --> 00:04:38,118
现在，一个相关的概念能够更准确地抓住什么是分组密码

64
00:04:38,118 --> 00:04:41,698
它被称为伪随机置换。
这样的一个伪随机置换概念

65
00:04:41,698 --> 00:04:46,261
再次被定义在密钥空间和一个集和X中。

66
00:04:46,261 --> 00:04:50,362
而它的作用是它需要密钥空间的一个元素，X中的一个元素和输出，

67
00:04:50,362 --> 00:04:54,579
基本上，一个在X的元素。现在，
和通常一样，该函数E应该很容易计算。

68
00:04:54,579 --> 00:04:59,026
所以应该有一个算法来计算函数E.但更重要的是

69
00:04:59,026 --> 00:05:04,382
一旦我们确定了密钥K，这个函数E应该是一一对应的。

70
00:05:04,382 --> 00:05:09,731
换句话说，如果你认为空间X的集合在这里，并在这里是

71
00:05:09,731 --> 00:05:14,805
同样的集合X，然后函数E要做的就是一个一一对应

72
00:05:14,805 --> 00:05:20,360
函数，X中的每个元素恰好被映射到X中的一个元素上。

73
00:05:20,360 --> 00:05:24,796
然后，因为它是一一对应的，当然它也是可逆的。

74
00:05:24,796 --> 00:05:30,228
因此，给定一个输出只有一个输入与之映射。

75
00:05:30,228 --> 00:05:35,660
要求是这是一种有效的反演算法，
称之为D，给定一个特定的输出

76
00:05:35,660 --> 00:05:39,984
将输出该输出的原像并映射到该输出。说实话

77
00:05:39,984 --> 00:05:44,718
一个伪随机置换精确的反映了
分组密码的特点，在语法上

78
00:05:44,718 --> 00:05:49,393
我经常会使用术语互换来表述
什么是分组密码，什么是伪随机置换

79
00:05:49,393 --> 00:05:53,834
我将根据所在上下文和我们讨论
的事情的地点使用任何术语。

80
00:05:53,834 --> 00:05:58,706
所以我们有两个例子，正如我们所说

81
00:05:58,706 --> 00:06:04,031
伪随机置换，三重DES和AES，
这里说的AES-128。密钥空间将是

82
00:06:04,031 --> 00:06:09,225
128比特并且输出将是128比特。
对于三重DES，正如我们所说，

83
00:06:09,225 --> 00:06:13,721
分组大小只有64比特。而密钥大小是168比特。
好的，因此我们将使用

84
00:06:13,721 --> 00:06:18,108
这些贯穿整个的运行实例。
实际上，每当我说PRP，具体地

85
00:06:18,108 --> 00:06:21,667
你应该想到AES或三重DES。现在有一件事

86
00:06:21,667 --> 00:06:26,994
我想指出的是，实际上，
任何伪随机置换(PRP)，即任何分组密码

87
00:06:26,994 --> 00:06:31,326
你也可以把它当做一个PRF(伪随机函数)。
其实一个PRP是一个有更多的结构的PRF。

88
00:06:31,326 --> 00:06:35,935
特别地，当输入空间和输出空间相同的时候，
PRP就等价于PRF了。

89
00:06:35,935 --> 00:06:40,322
所以X等于Y，一旦你有私密密钥那它是可逆的。

90
00:06:40,322 --> 00:06:44,944
好，所以在某种意义上的PRP是PRF的一个特例。

91
00:06:44,944 --> 00:06:48,849
虽然这不完全准确，我们马上将看到为什么。

92
00:06:48,849 --> 00:06:53,359
到目前为止我们看了一些句法定义，关于

93
00:06:53,359 --> 00:06:57,760
什么是伪随机置换和什么是伪随机函数？
所以，现在让我们来谈谈

94
00:06:57,760 --> 00:07:01,936
这对PRF或PRP的安全性意味着什么。而这一概念

95
00:07:01,936 --> 00:07:06,393
根本上将阐述了分组密码的安全性意味着什么。
所以这就是

96
00:07:06,393 --> 00:07:09,778
为什么我想向大家展示这些定义，
在我们实际看到

97
00:07:09,778 --> 00:07:13,029
分组密码结构之前，至少在脑袋里对我们尝试去构造的东西

98
00:07:13,029 --> 00:07:19,267
有一个清晰的印象。好的，
在这里我们有一个PRF.并且我将需要一点标记，

99
00:07:19,267 --> 00:07:24,133
虽然不是很多。所以我将需要定义函数X,Y的集合

100
00:07:24,133 --> 00:07:30,133
这是所有函数的基本集合从集合X到集合Y,
表示这里作为一个

101
00:07:30,133 --> 00:07:35,467
大圆圈Funs[X,Y]。现在，
这个集合是庞大的，它的大小基本上是，

102
00:07:35,467 --> 00:07:41,120
|Y| 的|X|次方。例如对于AES,记住X和Y

103
00:07:41,120 --> 00:07:45,600
将是2和128.所以对于AES集合是非常庞大的。

104
00:07:45,600 --> 00:07:52,686
它将是2的128次方整体的2的128次方。
所以这是一种双指数

105
00:07:52,686 --> 00:07:57,797
所以这是一个庞大的数字，比宇宙中所有颗粒还要多

106
00:07:57,797 --> 00:08:02,070
但无论如何，我们可以抽象地来想这种集合。

107
00:08:02,070 --> 00:08:06,936
我们从不需要把它写下来，
我们只需要保留在我们脑海里不用担心计算就可以了

108
00:08:06,936 --> 00:08:11,627
所以这是一个特别庞大的集合对于所有从X到Y的函数来说。

109
00:08:11,627 --> 00:08:16,261
现在我们将要看看一个更小的函数集合，

110
00:08:16,261 --> 00:08:20,945
我会叫它集合S下标F,
并且这将表示所有从X到Y的函数的集合是

111
00:08:20,945 --> 00:08:25,253
由PRF指定的，只要我们固定特定密钥K。所以

112
00:08:25,253 --> 00:08:30,444
我们固定的密钥K，我们让第二论证浮动，
而且基本上定义了

113
00:08:30,444 --> 00:08:34,554
从X到Y的一个函数。然后我们将要看看所有这些函数的集合

114
00:08:34,554 --> 00:08:39,600
在一个密钥空间对应的所有可能密钥。
所以，如果你再一次思考

115
00:08:39,600 --> 00:08:47,921
对于AES来说，如果我们使用128比特的密钥，这个大小，

116
00:08:47,921 --> 00:08:53,201
我称之为S-AES，基本上是要2的128次方，
比从X的Y次方所有可能函数集合小的多。

117
00:08:53,201 --> 00:08:58,165
现在，我们说一个PRF是安全的，基本上如果

118
00:08:58,165 --> 00:09:03,455
一个随机函数从X映射到Y。
所以从字面上看，我们挑选一些任意函数

119
00:09:03,455 --> 00:09:09,079
在这个庞大的从X到Y所有函数的集合。
我们说这个PRF是安全的。

120
00:09:09,079 --> 00:09:14,637
如果事实上一个从X到Y的随机函数是不可区分的从X到Y的

121
00:09:14,637 --> 00:09:19,717
伪随机函数。就是说，
我们从集合SF挑选随机函数

122
00:09:19,717 --> 00:09:21,867
好了，更准确地说一遍

123
00:09:21,867 --> 00:09:25,267
伪随机函数集合的均匀分布

124
00:09:25,267 --> 00:09:29,632
在均匀分布的所有函数集合中是没有区别的

125
00:09:29,632 --> 00:09:32,067
让我更准确一点

126
00:09:32,067 --> 00:09:35,483
只是让你们更直观明白我的意思是什么，
然后我们将

127
00:09:35,483 --> 00:09:38,711
继续学习实际结构。所以让我更精确解释一个PRF的

128
00:09:38,711 --> 00:09:43,600
安全性意味着什么。所以我们会做的如下：
我们会有我们的

129
00:09:43,600 --> 00:09:48,150
一个攻击者，他试图区分真正随机函数和伪随机函数。

130
00:09:48,150 --> 00:09:52,030
所以我们要做的是让他们与两个中的一个交互。在这里

131
00:09:52,030 --> 00:09:56,013
在云顶，我们将做的是选择一个真正的随机函数。在云底，

132
00:09:56,013 --> 00:10:00,377
我们只为一个伪随机函数选择一个随机密钥。现在，

133
00:10:00,377 --> 00:10:04,906
这个对手将要做的是将在X提交积分点。
所以他将提交一些X

134
00:10:04,906 --> 00:10:09,293
实际上，他将反复的做这些事。所以他将

135
00:10:09,293 --> 00:10:14,722
提交X1,X2,X3,X4，然后对于每一个询问，我们将给他

136
00:10:14,722 --> 00:10:19,693
真正随机函数在x点的值，
或者点x的伪随机函数的值。

137
00:10:19,693 --> 00:10:24,676
好的，所以对手不知道他得到的是哪一个。

138
00:10:24,676 --> 00:10:29,299
顺便说一下，对于所有的询问，
他得到的总是要么是真正随机函数

139
00:10:29,299 --> 00:10:33,320
要么是伪随机函数。换句话说，他要么

140
00:10:33,320 --> 00:10:37,522
在与一个真正随机函数交互他所有的疑问，要么

141
00:10:37,522 --> 00:10:41,724
在与一个伪随机函数交互他的疑问。
所以我们说PRF是安全的

142
00:10:41,724 --> 00:10:45,926
如果这个弱的攻击者不能分辨其中差异。
他不能分辨他是

143
00:10:45,926 --> 00:10:49,921
在与一个真正随机函数交互还是在与伪随机函数交互。

144
00:10:49,921 --> 00:10:53,912
好了，让我们稍后再回来然后更精确地定义RPFs

145
00:10:53,912 --> 00:10:58,649
但现在我想给你一个直观感觉
关于PRFs是安全的这意味着是什么，

146
00:10:58,649 --> 00:11:03,155
当我们构建这些伪随机函数的时候，你就会理解

147
00:11:03,155 --> 00:11:06,333
我们到底是在构建什么。并且我想说伪随机置换的定义

148
00:11:06,333 --> 00:11:11,242
其实差不多，除了不是选择一个随机函数来。

149
00:11:11,242 --> 00:11:15,910
我们将要在集合X中选择一个随机置换

150
00:11:15,910 --> 00:11:21,964
换句话说，就是在集合X中选择一个
一一对应的随机函数。

151
00:11:21,964 --> 00:11:27,306
攻击者要么询问这个在集合X总的随机函数
要么他询问一个伪随机置换

152
00:11:27,306 --> 00:11:32,256
如果他不能分辨其中奥秘的话，那PRP就是安全的了。

153
00:11:32,256 --> 00:11:36,946
好，下面，我们的目标是要使这些函数和置换看起来

154
00:11:36,946 --> 00:11:42,271
像真正的随机函数和置换。好，让我们看看一个简单的问题。

155
00:11:42,271 --> 00:11:48,050
假设我们有一个安全的PRF ，记它为F，
而且我们知道这个PRF被定义在集合X

156
00:11:48,050 --> 00:11:53,691
并且它恰好每次输出128比特。那么发生的就是，

157
00:11:53,691 --> 00:11:59,694
这个PRF不能从一个X到{0,1}的128次方的
真正的随机函数中被区分出来。

158
00:11:59,694 --> 00:12:05,335
现在我们将构建一个新的PRF。
我们称之为PRFG,将它定义如下：

159
00:12:05,335 --> 00:12:11,121
我们说，如果x是等于0的，
总是输出0。否则

160
00:12:11,121 --> 00:12:15,654
如果x不等于0，就输出F的值。
所以，我的问题是

161
00:12:15,654 --> 00:12:19,414
你认为G是一个安全的PRF吗？

162
00:12:19,476 --> 00:12:22,179
好了，当然，答案是非常容易

163
00:12:22,179 --> 00:12:26,455
能区分函数G和一个随机函数。
所有的攻击者需要做的

164
00:12:26,455 --> 00:12:30,930
仅仅是在x=0的时候咨询函数。对于一个随机函数，

165
00:12:30,930 --> 00:12:35,405
结果为零的可能性将是2的128次方分之一。
而对于伪随机函数

166
00:12:35,405 --> 00:12:40,174
他总是得到0.因为在0，函数

167
00:12:40,174 --> 00:12:44,847
总被定义成0，不管密钥是什么。
因此所有他能做的就是

168
00:12:44,847 --> 00:12:49,717
他会说，嘿，我正在与伪随机函数互动！
如果他在x=0处得到0.

169
00:12:49,717 --> 00:12:54,525
否则他会说:我正在与一个随机函数互动！
如果他在x=0处得到非零。

170
00:12:54,525 --> 00:12:59,148
因此这非常容易辨别G和随机函数。
这个例子展示了

171
00:12:59,148 --> 00:13:04,080
尽管你有一个安全的PRF,仅仅在已知的输入的时候，

172
00:13:04,080 --> 00:13:08,844
输出是有点儿不随机的就足够了。
如果输出是固定的，那这个PRF就已经被破解了，

173
00:13:08,844 --> 00:13:13,178
尽管你知道其他地方PRF与随机函数

174
00:13:13,178 --> 00:13:17,691
是完全不可区分的。好了，
让我们来展示PRFs的能力

175
00:13:17,691 --> 00:13:22,322
让我们来看看一个非常简单的应用。
我想向你们展示实际上伪随机函数

176
00:13:22,322 --> 00:13:27,432
直接给了我们一个伪随机数生成器。
让我们假设我们有

177
00:13:27,432 --> 00:13:32,779
一个伪随机函数，而它刚好从n比特对应到n比特。然后

178
00:13:32,779 --> 00:13:37,720
让我们定义以下生成器:它的种子空间将是

179
00:13:37,720 --> 00:13:42,491
PRF的密钥空间，
它的输出空间将基本上是t个n比特的分组。

180
00:13:42,491 --> 00:13:49,657
好，所以你们能看到输出是一个n倍t比特的总数

181
00:13:49,657 --> 00:13:53,740
对于我们能选择的一些参数T来说。
并且结果基本上是，你可以做

182
00:13:53,740 --> 00:13:57,642
这些简单结构，它们有时候也叫计数器

183
00:13:57,642 --> 00:14:00,392
在主要的地方，你用PRF并在0处评估它，在1评估它，

184
00:14:00,392 --> 00:14:05,166
在2评估它，在3，在4一直增加到T，
然后你拼接这些所有的值

185
00:14:05,166 --> 00:14:09,940
那就是生成器，对吧。
所有我们为PRF设置密钥

186
00:14:09,940 --> 00:14:15,966
然后扩大到n倍t比特。好了，
这个生成器的一个重要特性是

187
00:14:15,966 --> 00:14:21,019
它是并行的。我的意思是如果你有双处理器或双内核

188
00:14:21,019 --> 00:14:25,952
你可以计算，然后你可以用其中一内核计算输出的偶数项

189
00:14:25,952 --> 00:14:30,629
用另外一内核计算输出的奇数项

190
00:14:30,629 --> 00:14:34,926
所以，基本上如果你有双核，
你可以使这个生成器运行速度比只有单核

191
00:14:34,926 --> 00:14:38,906
快两倍。因此这里面的好处是

192
00:14:38,906 --> 00:14:42,885
当然，我们知道伪随机生成器给我们的是流密码，

193
00:14:42,885 --> 00:14:47,183
因此这是一个并行流密码的例子。
并且我想指出的是

194
00:14:47,183 --> 00:14:51,375
很多我们之前看过的流密码，例如RC4

195
00:14:51,375 --> 00:14:55,725
那些都是串行的。
所以即使我们有双处理器，你也不能使

196
00:14:55,725 --> 00:15:00,148
流密码比只有单处理器工作快。
现在主要的

197
00:15:00,148 --> 00:15:04,451
问题是为什么这个生成器是安全的呢？
在这里我只给你们

198
00:15:04,451 --> 00:15:08,164
一点直观感觉，然后回到原来的内容并在之后再来详细讨论下

199
00:15:08,164 --> 00:15:13,113
但我只想说基本上这个安全性直接由PRF的属性而来。

200
00:15:13,113 --> 00:15:17,090
我们推导安全性的方式是通过PRF的定义

201
00:15:17,090 --> 00:15:21,985
与128比特真随机函数是不可以区分的得来的。

202
00:15:21,985 --> 00:15:27,000
换句话说，如果我用这个生成器
而这个生成器是使用真随机函数定义的

203
00:15:27,000 --> 00:15:30,800
再换句话，我将记下生成器的输出作为

204
00:15:30,800 --> 00:15:37,933
f(0)并联f(1),等等。使用一个真随机函数

205
00:15:37,933 --> 00:15:42,083
那么生成器就会的输出就会是真正的随机函数

206
00:15:42,083 --> 00:15:47,414
并且无法被从一个使用伪随机函数的生成器中区分开来

207
00:15:47,414 --> 00:15:52,507
这是一个PRF安全属性的精髓。

208
00:15:52,507 --> 00:15:57,200
但是使用一个真随机函数，
你注意到那输出就是真正随机的

209
00:15:57,200 --> 00:16:02,068
因为对于真随机函数，f(0)是一个随机数值，f(1)是一个独立

210
00:16:02,068 --> 00:16:06,702
随机数值,f(2)也是一个独立随机数值，以此类推。

211
00:16:06,702 --> 00:16:11,218
因此整个输出是一个真正随机的输出。
并且使用一个真正随机的

212
00:16:11,218 --> 00:16:15,793
函数生成器产生真正随机的输出，
因此是一种绝对安全的生成器

213
00:16:15,793 --> 00:16:20,028
所以你们看PRF安全属性是如何让我们争论安全性的。

214
00:16:20,028 --> 00:16:24,375
基本上，我们认为把使用真随机函数的PRF

215
00:16:24,375 --> 00:16:28,614
它的结构必然是安全的，这说明这结构更换为使用

216
00:16:28,614 --> 00:16:32,800
伪随机函数的PRF也是安全的，对吧？
在之后我们将看看更多

217
00:16:32,800 --> 00:16:37,092
像这样的例子。所以现在你们明白了分组密码是什么，

218
00:16:37,092 --> 00:16:40,587
并且你们对安全属性想要达到的性能有了直观认识

219
00:16:40,587 --> 00:16:44,820
在接下来的一段中，我们将来看分组密码的结构。【END】

