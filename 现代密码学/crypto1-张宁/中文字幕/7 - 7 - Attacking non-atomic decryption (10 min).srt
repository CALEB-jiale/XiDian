1
00:00:00,000 --> 00:00:03,722
在上一节我们看了一个填充预言机攻击

2
00:00:03,722 --> 00:00:08,005
完全破解了认证加密系统。我希望这个攻击说服大家

3
00:00:08,005 --> 00:00:10,979
不要靠自己实现认证加密，因为你可能

4
00:00:10,979 --> 00:00:15,950
已经暴露给了填充预言机攻击、时序攻击或者其他一些这样的攻击

5
00:00:15,959 --> 00:00:19,936
相反地，你应该使用GCM标准或其它

6
00:00:19,936 --> 00:00:23,710
标准化认证加密模式，有很多密码库实现了它们

7
00:00:23,710 --> 00:00:27,712
在这节里，我会给大家讲一个聪明的攻击

8
00:00:27,712 --> 00:00:31,770
它是针对认证加密系统的。我希望大家在了解这个攻击之后

9
00:00:31,770 --> 00:00:35,468
大家不再自己发明和实现认证加密系统

10
00:00:35,468 --> 00:00:39,526
但是一定要用标准机制中的一个，像GCM或其它的

11
00:00:39,526 --> 00:00:44,380
那么我想给大家讲的这个特别的攻击是针对SSH二进制数据包协议的

12
00:00:44,380 --> 00:00:48,996
SSH是一个标准的远程安全shell应用

13
00:00:48,996 --> 00:00:53,679
它是客户端和服务端之间的协议。它使用秘钥交换机制

14
00:00:53,679 --> 00:00:58,794
一旦双方交换秘钥，SSH就使用二进制数据包协议

15
00:00:58,794 --> 00:01:03,662
在客户端和服务端之间来回发送信息

16
00:01:03,662 --> 00:01:09,731
SSH是这样工作的，SSH使用加密和MAC

17
00:01:09,731 --> 00:01:13,707
技术上来说,每个SSH数据包以一个序列号开头

18
00:01:13,707 --> 00:01:18,245
这个数据包包含数据包长度，CBC填充长度

19
00:01:18,245 --> 00:01:24,020
然后是有效数据，接着是CBC填充。现在整个红色块

20
00:01:24,020 --> 00:01:29,867
使用带有链式IV的CBC加密的，因此这对我们之前所讨论的CPA攻击是很脆弱的

21
00:01:29,867 --> 00:01:34,191
但是整个红色的数据包

22
00:01:34,191 --> 00:01:39,033
是用CBC加密的。然后计算整个明文的MAC

23
00:01:39,033 --> 00:01:43,169
MAC以明文形式和数据包一起发送。因此我想让大家记住

24
00:01:43,169 --> 00:01:48,837
MAC是根据明文数据包计算的，并且MAC是以明文形式发送的

25
00:01:48,837 --> 00:01:53,597
这就是我们所说的加密和MAC。我们说过这不是一个好方法

26
00:01:53,597 --> 00:01:58,330
因为MACs没有保密性要求。

27
00:01:58,330 --> 00:02:03,064
通过明文形式发送明文信息的MAC，你可能会暴露明文的相关信息

28
00:02:03,064 --> 00:02:06,347
但是这不是我想给大家看的错误

29
00:02:06,347 --> 00:02:09,702
我想给大家看的是一个更聪明的攻击。首先，我们来看看SSH如何解密

30
00:02:09,702 --> 00:02:16,068
首先，服务器只解密加密数据包

31
00:02:16,068 --> 00:02:21,520
的长度域。那么它直接解密特定的开头几个字节

32
00:02:21,520 --> 00:02:26,440
然后它会从网络读取和数据包长度域规定的字节数相同的数据

33
00:02:26,440 --> 00:02:31,000
它会使用CBC解密剩余的密文

34
00:02:31,000 --> 00:02:35,740
一旦，它恢复了整个SSH数据包，它会开始

35
00:02:35,740 --> 00:02:40,540
校对明文的MAC，如果MAC是无效的，它会报告一个错误

36
00:02:40,540 --> 00:02:45,645
现在问题是数据包长度域被解密

37
00:02:45,645 --> 00:02:50,107
并且直接被用来决定数据包的长度，这之前没有任何认证

38
00:02:50,107 --> 00:02:54,780
事实上，认证数据包长度域的MAC是不可能的

39
00:02:54,780 --> 00:02:58,647
因为我们还没有恢复整个数据包，所以我们不能校对MAC

40
00:02:58,647 --> 00:03:04,074
但是SSH协议在验证MAC之前就使用数据包

41
00:03:04,074 --> 00:03:09,501
结果是这引入了一个非常聪明的攻击

42
00:03:09,501 --> 00:03:12,943
我只讲一个这个攻击非常简化的版本，来让大家理解

43
00:03:12,943 --> 00:03:17,244
下面我来说这个攻击。假定攻击者截获了一个特定的密文分组

44
00:03:17,244 --> 00:03:23,037
也就是直接用AES加密的明文分组M

45
00:03:23,037 --> 00:03:27,092
并且他想要恢复M。我强调一下

46
00:03:27,092 --> 00:03:31,418
这个被截获的密文正好是一个分组长度，是一个AES分组。那么攻击者

47
00:03:31,418 --> 00:03:37,073
要做的是，他会发送给服务器发送一个数据包，这个数据包的开头是正常的

48
00:03:37,073 --> 00:03:41,062
是以一个序列号开头。接下来他会

49
00:03:41,062 --> 00:03:46,304
注入他截获的密文，作为第一个密文分组，把它发送给服务器

50
00:03:46,304 --> 00:03:51,237
现在，服务器会做什么呢？服务器会解密

51
00:03:51,237 --> 00:03:57,270
第一个AEC分组的开头几个字节，攻击者会截获开头这几个字节

52
00:03:57,270 --> 00:04:01,973
作为数据包的长度域。接下来要发生的是

53
00:04:01,973 --> 00:04:06,842
服务器会期待这些字节，在此之前不进行校验MAC是否有效

54
00:04:06,842 --> 00:04:12,089
并且攻击者会每次给服务器发送一个字节

55
00:04:12,089 --> 00:04:15,390
服务器也会一个字节一个字节的读

56
00:04:15,390 --> 00:04:20,007
最终，服务器读够了和长度域规定的字节数相同的字节

57
00:04:20,007 --> 00:04:24,625
这时候，它会校验MAC是否有效。当然，攻击者

58
00:04:24,625 --> 00:04:29,477
只给服务器发送垃圾字节，结果，MAC就不会被认证

59
00:04:29,477 --> 00:04:33,978
服务器就会报MAC错误。但是大家意识到

60
00:04:33,978 --> 00:04:38,362
攻击者在数他给服务器发送了多少字节。

61
00:04:38,362 --> 00:04:43,097
他确切地知道，当他收了多少来自服务器的MAC错误，他就给服务器发送了多少字节

62
00:04:43,097 --> 00:04:48,288
这告诉了攻击者，密文C的前32比特的解密

63
00:04:48,288 --> 00:04:54,177
是严格等于在他收到MAC错误之前，已经发送的字节数

64
00:04:54,177 --> 00:04:57,374
因此这是一个非常聪明的攻击。我再说一遍

65
00:04:57,374 --> 00:05:02,556
确保大家清楚。攻击者有一个密文C的分组

66
00:05:02,556 --> 00:05:07,407
他想解密c，我们假定C解密后，得到明文的高32位

67
00:05:07,407 --> 00:05:12,309
这个数字是5，在这种情况下

68
00:05:12,309 --> 00:05:17,092
攻击者会看到如下的事情，服务器会解密

69
00:05:17,092 --> 00:05:21,815
挑战分组c，会得到数字5，并把5当作长度域

70
00:05:21,815 --> 00:05:26,777
那么现在，攻击者会给服务器一次一个字节

71
00:05:26,777 --> 00:05:31,500
在攻击者给服务器5个字节后，服务器说“我刚刚还原了整个数据包”

72
00:05:31,500 --> 00:05:35,984
让我检查MAC，MAC很可能是错的

73
00:05:35,984 --> 00:05:41,156
服务器会发送一个坏MAC的错误，那么在读了5个字节后

74
00:05:41,156 --> 00:05:45,447
攻击者会看到一个坏MAC的错误，然后攻击者就知道了解密后的分组的高32位

75
00:05:45,447 --> 00:05:51,689
等于数字5，那么你就知道了

76
00:05:51,689 --> 00:05:56,705
C的高32位，那么这是一个非常重要的攻击

77
00:05:56,705 --> 00:06:01,731
因为攻击者刚刚知道了密文分组解密后的高32位

78
00:06:01,731 --> 00:06:05,767
他可以对任何他想要的密文分组实施这个攻击

79
00:06:05,767 --> 00:06:11,410
他可以知道一条长信息的每个密文分组的高32位

80
00:06:11,410 --> 00:06:15,542
那么这里发生了什么？密码设计里面有两个错误

81
00:06:15,542 --> 00:06:19,340
第一个是，解密操作不是原子操作

82
00:06:19,340 --> 00:06:25,206
换句话说，解密算法不取整个数据包作为输入

83
00:06:25,206 --> 00:06:29,903
而返回整个明文作为输出，或者返回拒绝

84
00:06:29,903 --> 00:06:34,362
解密算法部分地解密了密文

85
00:06:34,362 --> 00:06:39,476
获得了长度域，然后等待指定数量的字节去还原

86
00:06:39,476 --> 00:06:43,924
然后完成了加密过程，这些非原子解密操作是很危险的

87
00:06:43,924 --> 00:06:48,500
一般来说，需要避免使用他们，在这个例子里，这个非原子操作。

88
00:06:48,500 --> 00:06:52,791
正好破坏了认证加密，另一问题是

89
00:06:52,791 --> 00:06:57,105
在正确认证之前，就使用了长度域

90
00:06:57,105 --> 00:07:01,470
这是另一个错误之处，不应该这么做的，所以加密的数据用不应该被使用

91
00:07:01,470 --> 00:07:05,388
在这个域在被正确认证之前，我来问一下大家

92
00:07:05,388 --> 00:07:09,449
如果大家可以重新设计SSH，如何最小地改动这里

93
00:07:09,449 --> 00:07:13,754
可以让SSH能抵抗这种攻击？我告诉大家，有很多种可能的答案

94
00:07:13,754 --> 00:07:18,259
一个方案是，以明文形式发送一个长度域，就像TLS一样

95
00:07:18,259 --> 00:07:22,741
这样，攻击者就没有机会提交选择密文攻击了

96
00:07:22,741 --> 00:07:26,998
因为长度域不会被加密

97
00:07:26,998 --> 00:07:31,603
这样攻击者无法滥用解密操作

98
00:07:31,603 --> 00:07:36,211
采用“先加密后MAC”而非“解密且MAC”并无影响，因为这个攻击对于两者都是可行的


99
00:07:36,211 --> 00:07:39,935
问题在于，在认证之前，长度域被使用了

100
00:07:39,935 --> 00:07:44,243
另一种方式也会出现这种情况，所以更好的加密模式并没有什么用处

101
00:07:44,243 --> 00:07:48,498
另一种方法是单调对长度域计算MAC

102
00:07:48,498 --> 00:07:52,591
这样服务器可以读去长度域，检查仅为长度域服务的MAC是否有效

103
00:07:52,591 --> 00:07:56,845
然后服务器就知道了接下来要读多少个字节

104
00:07:56,845 --> 00:08:00,916
之后再检查整个数据包的MAC域，最后一种方案是可行的，

105
00:08:00,916 --> 00:08:04,906
但是效率极差，可能会让服务器遭受拒绝服务攻击，

106
00:08:04,906 --> 00:08:09,322
所以我不认为这是一个有效的答案

107
00:08:09,322 --> 00:08:14,295
需要记住的主要的教训是，不要自己去实现或设计自己的认证加密系统

108
00:08:14,295 --> 00:08:18,723
只使用类似于GCM的密码学标准，但如果出于某些原因

109
00:08:18,723 --> 00:08:22,572
你不能使用标准，必须实现自己的认证加密系统

110
00:08:22,572 --> 00:08:28,356
那么请先加密后MAC，确保不犯这两节里的错误

111
00:08:28,356 --> 00:08:33,228
也就是不在认证长度域之前就使用长度域

112
00:08:33,228 --> 00:08:37,388
更一般地，不在认证前使用任何解密的域

113
00:08:37,388 --> 00:08:40,991
那么我们对认证加密的讨论完结了

114
00:08:40,991 --> 00:08:44,985
我想指出几篇关于认证加密的论文

115
00:08:44,985 --> 00:08:49,588
你们可以进行进一步的阅读，第一篇文章很敏锐

116
00:08:49,588 --> 00:08:53,918
是关于加密和认证的先后顺序的，讨论了是该先加密后MAC

117
00:08:53,918 --> 00:08:56,796
还是先MAC后加密，它证实了一个是正确的

118
00:08:56,796 --> 00:08:59,912
另一个是错的。这个文章指的一读，信息量很大

119
00:08:59,912 --> 00:09:04,476
第二篇讨论了OCB模式，OCB是一个非常有效的

120
00:09:04,476 --> 00:09:08,984
构建认证加密的方法。特别地，这篇文章看了一个带关联数据OCB的变种

121
00:09:08,984 --> 00:09:13,548
正如我们所讨论过的。最后三篇是关于攻击的论文

122
00:09:13,548 --> 00:09:17,890
第一篇描述上节讨论的填充预言机攻击

123
00:09:17,890 --> 00:09:23,398
这篇描述了这节讨论的长度攻击

124
00:09:23,398 --> 00:09:28,838
最后一篇描述了很多对加密机制的攻击

125
00:09:28,838 --> 00:09:34,038
其中加密机制只用了CPA安全，没有加完整性。最后一篇提供了很多好例子

126
00:09:34,038 --> 00:09:38,518
解释了为什么CPA安全本身永远不应该被用于加密

127
00:09:38,518 --> 00:09:43,116
记住，大家只能使用认证加密

128
00:09:43,116 --> 00:09:47,302
来保护私密性。如果大家只需要完整性，不需要私密性

129
00:09:47,302 --> 00:09:49,660
那么使用MAC就行了。【END】

