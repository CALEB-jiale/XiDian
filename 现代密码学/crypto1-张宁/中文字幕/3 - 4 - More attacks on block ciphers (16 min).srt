1
00:00:00,000 --> 00:00:02,833
你可以找到大量关于攻击分组密码的文献.

2
00:00:02,833 --> 00:00:06,667
在这一节里，我只想让你体验一下
这些攻击是什么样子的.

3
00:00:06,667 --> 00:00:10,217
同时我希望我能说服你们永远不要设计你自己的分组密码,

4
00:00:10,217 --> 00:00:14,164
而是坚持使用例如3DES和AES这样的标准.

5
00:00:14,164 --> 00:00:16,161
我想要讨论的第一类攻击

6
00:00:16,161 --> 00:00:18,297
是在分组密码实现中的攻击.

7
00:00:18,297 --> 00:00:23,400
例如，想像一下你有一块实现了分组密码的智能卡.

8
00:00:23,400 --> 00:00:27,214
这块智能卡可能会被用作信用卡支付，
它可能会有一个内部密钥

9
00:00:27,214 --> 00:00:31,486
来鉴定信用卡的支付行为，
当你把卡插入一个支付终端时, 

10
00:00:31,486 --> 00:00:36,510
现在如果一个攻击者获取了你的智能卡,

11
00:00:36,510 --> 00:00:41,039
他可能会把卡拿到实验室去运行这张卡

12
00:00:41,039 --> 00:00:45,407
非常精确地测量出这张卡加密和解密所用的时间

13
00:00:45,407 --> 00:00:48,901
现在，如果实现加密过程所用的时间

14
00:00:48,901 --> 00:00:53,529
取决于密钥的位数, 通过测量时间

15
00:00:53,529 --> 00:00:57,284
攻击者就可以获取关于密钥的一些信息，事实上

16
00:00:57,284 --> 00:01:02,044
他可以完全获得你的密钥，
有许多这样的例子，

17
00:01:02,044 --> 00:01:06,667
仅仅通过精确测量加密算法的时间

18
00:01:06,667 --> 00:01:11,587
你就可以完全获得密钥. 
另一个例子是,

19
00:01:11,587 --> 00:01:16,336
不是测量时间, 而是测量智能卡的运行功耗

20
00:01:16,336 --> 00:01:20,570
这样，你可以将其连接到一个设备上

21
00:01:20,570 --> 00:01:24,805
测量它运行时的电流，然后用曲线图非常精确地记录它们。

22
00:01:24,805 --> 00:01:29,303
这些智能卡不是很快，这样的话，

23
00:01:29,303 --> 00:01:33,993
当卡在运行时你可以测量每个时钟周期里的精确能耗

24
00:01:33,993 --> 00:01:38,405
这样，你就可以得到这种类型的图

25
00:01:38,405 --> 00:01:42,257
这是一个智能卡工作时的例子

26
00:01:42,257 --> 00:01:46,557
当它进行DES运算时. 你可以很清楚地看到，

27
00:01:46,557 --> 00:01:50,912
这里是它在进行初始置换，这里是它在进行最终置换

28
00:01:50,912 --> 00:01:54,709
看这里，你可以数一下，这里有16个波峰和波谷

29
00:01:54,709 --> 00:01:59,104
对应了16个轮。 当你像这样放大图表

30
00:01:59,104 --> 00:02:03,529
你可以将密钥位逐位读出

31
00:02:03,529 --> 00:02:08,421
只需要关注智能卡在进行不同操作时的功耗就可以

32
00:02:08,421 --> 00:02:11,564
实际上，就算智能卡对这些信息进行伪装，依然易受攻击

33
00:02:11,564 --> 00:02:15,133
这种攻击叫做差分功耗分析

34
00:02:15,133 --> 00:02:21,619
当智能卡重复运行加密算法时测量卡的功耗

35
00:02:21,619 --> 00:02:26,067
只要电流消耗上有很小的差异

36
00:02:26,067 --> 00:02:31,464
密钥各位之间的依赖性就会出现

37
00:02:31,464 --> 00:02:35,857
加密算法运行足够多的次数

38
00:02:35,857 --> 00:02:39,967
这样就可以完全获得密钥

39
00:02:39,967 --> 00:02:43,988
这些攻击是由Paul Kocher和他的同事在密码学研究所发现的

40
00:02:43,988 --> 00:02:48,468
有一个很大的产业来专门防御功耗攻击

41
00:02:48,468 --> 00:02:52,732
如果考虑计时攻击的话

42
00:02:52,732 --> 00:02:55,467
我想说这些都是真的。不仅仅针对智能卡

43
00:02:55,467 --> 00:03:00,094
比如，设想一个多核的处理器，
其中一核运行加密算法

44
00:03:00,094 --> 00:03:04,297
攻击代码运行在另一个核

45
00:03:04,297 --> 00:03:09,427
这些代码实际上使用的是同一缓存

46
00:03:09,427 --> 00:03:13,627
这样的话攻击者可以测量或者
直接观测加密算法中的缓存缺失，

47
00:03:13,627 --> 00:03:18,100
实际上，通过观测这些缓存缺失

48
00:03:18,100 --> 00:03:22,464
你可以完整地得到算法中使用的密钥

49
00:03:22,464 --> 00:03:26,828
所以，通过观察缓存缺失，
某一核可以从另一核中提取信息

50
00:03:26,828 --> 00:03:30,349
所以实现分组密码是比较困难的

51
00:03:30,349 --> 00:03:33,778
因为你需要保证旁道攻击不会泄露你的密钥信息

52
00:03:33,778 --> 00:03:38,320
另一类被很多文献讨论的攻击

53
00:03:38,320 --> 00:03:41,733
我们称之为错误攻击.

54
00:03:41,733 --> 00:03:45,535
当你攻击一个智能卡时，
实际上会造成智能卡工作异常

55
00:03:45,535 --> 00:03:50,226
可能是时钟频率过高，可能是芯片过热

56
00:03:50,226 --> 00:03:55,838
你会导致处理器工作异常并输出错误的数据

57
00:03:55,838 --> 00:04:00,558
在加密过程中，如果最后一轮出现错误

58
00:04:00,558 --> 00:04:05,336
产生的密文足以暴露密钥K

59
00:04:05,336 --> 00:04:09,682
这是一个有趣的结果，实际上如果有任何错误

60
00:04:09,682 --> 00:04:13,632
如果输出了一个错误的结果，那么可能就会暴露你的密钥

61
00:04:13,632 --> 00:04:18,508
因此，抵御这种攻击意味着你要在算法输出结果前

62
00:04:18,508 --> 00:04:23,045
进行检查来确保计算出正确的结果

63
00:04:23,045 --> 00:04:26,379
当然要做到这一点并不容易，因为你也不知道你的检查算法中有没有错误

64
00:04:26,379 --> 00:04:31,058
不过还是有其他已知的方法

65
00:04:31,058 --> 00:04:35,037
你可以计算三次或者四次，只要计算中不出现太多错误

66
00:04:35,037 --> 00:04:39,341
并保证输出是正确的

67
00:04:39,341 --> 00:04:43,763
就取结果中的占多数的结果。这些是实现过程中的攻击

68
00:04:43,763 --> 00:04:47,205
我希望这些例子可以确保大家不仅不要

69
00:04:47,205 --> 00:04:51,168
设计自己的分组密码，而且不要自己去实现这些密码原型

70
00:04:51,168 --> 00:04:55,188
因为首先，你需要确保实现过程中没有旁道攻击

71
00:04:55,188 --> 00:04:58,836
其次，你需要确保

72
00:04:58,836 --> 00:05:02,838
实现过程针对错误攻击是安全的

73
00:05:02,838 --> 00:05:06,586
所以大家应该只使用那些例如OpenSSL等可以获得的标准库

74
00:05:06,586 --> 00:05:11,043
所以不要自己去实现这些原型

75
00:05:11,043 --> 00:05:16,016
只去使用已有的库。好的，现在我要讨论一种更为复杂针的对分组密码的攻击

76
00:05:16,016 --> 00:05:20,482
我想特别讨论一下针对DES的攻击

77
00:05:20,482 --> 00:05:25,753
这些攻击由Biham和Shamir在1989年发现

78
00:05:25,753 --> 00:05:31,446
我将特别讲述Matsui在1993年发现的攻击版本

79
00:05:31,446 --> 00:05:36,500
所以，这里我们的目标是，
在给定很多的输入输出对情况下

80
00:05:36,500 --> 00:05:41,524
我们能否比穷举搜索更好地还愿密钥？

81
00:05:41,524 --> 00:05:45,400
任何比穷举搜索更好的攻击都算是分组密码攻击

82
00:05:45,400 --> 00:05:50,400
我想给你们的例子叫做线性密码分析

83
00:05:50,400 --> 00:05:56,037
试想，c是m用密钥k加密得到，

84
00:05:56,037 --> 00:06:00,895
假定我随机地观察密钥和信息

85
00:06:00,895 --> 00:06:05,366
那么明文、密文和密钥位之间存在着某种联系

86
00:06:05,366 --> 00:06:10,113
特别地，如果我逐位异或一组明文比特

87
00:06:10,113 --> 00:06:17,375
这是一组明文比特，如果我异或一组特定的密文比特

88
00:06:17,375 --> 00:06:21,697
这样两组攻击者都能看到

89
00:06:21,697 --> 00:06:26,183
攻击者同时有明文和对应的密文，
然后将其与密钥的异或进行比较

90
00:06:26,183 --> 00:06:30,395
如果两者能如你所愿完全独立的话，

91
00:06:30,395 --> 00:06:34,553
我们当然不希望明文和密文

92
00:06:34,553 --> 00:06:38,710
能用某种方式预测密钥。如果他们完全独立

93
00:06:38,710 --> 00:06:42,868
那么这个等式成立的概率就严格地为1/2

94
00:06:42,868 --> 00:06:47,080
但是设想有一点不均匀导致这个等式的概率

95
00:06:47,080 --> 00:06:52,158
是1/2加上某个小ε 。事实上，对于DES有这样的关系

96
00:06:52,158 --> 00:06:56,868
这个关系之所以成立是因为第五个S盒子的设计有一个BUG

97
00:06:56,868 --> 00:07:03,534
事实上第五个S盒子太过于接近线性函数了

98
00:07:03,534 --> 00:07:07,000
那个线性函数传遍了整个DES的计算过程

99
00:07:07,000 --> 00:07:10,893
产生了这样的一个关系

100
00:07:10,893 --> 00:07:16,582
注意这里计算的是一个线性关系

101
00:07:16,582 --> 00:07:21,086
因此第五个S盒子的微弱线性关系会对整个算法产生这样的关系

102
00:07:21,086 --> 00:07:25,769
这里的ε是很小的，约为2的21次方分之一

103
00:07:25,769 --> 00:07:29,528
这个偏量真的真的很小

104
00:07:29,528 --> 00:07:33,336
但是在使用这些特殊的比特时也会有偏量

105
00:07:33,336 --> 00:07:37,095
现在我不打算推导这个关系，也不告诉大家这是什么意思

106
00:07:37,095 --> 00:07:41,534
我只告诉你们当你找到它的时候如何使用这个关系

107
00:07:41,534 --> 00:07:45,533
这里我们只关心如何使用它。用一点统计的知识

108
00:07:45,533 --> 00:07:50,484
你就可以使用这样的一个等式来决定某些比特

109
00:07:50,484 --> 00:07:54,844
这么做：假设给定了1/ε的平方个明文-密文对

110
00:07:54,844 --> 00:07:58,612
这些必须是互相独立的随机明文和对应的密文

111
00:07:58,612 --> 00:08:03,026
应用上面的公式

112
00:08:03,026 --> 00:08:07,547
事实上你可以使用公式左边来计算

113
00:08:07,547 --> 00:08:11,907
你所有的明文密文对之间的关系

114
00:08:11,907 --> 00:08:16,122
现在，对于这些值的一半加上ε的值

115
00:08:16,122 --> 00:08:20,605
这些值等于密钥各个位的异或

116
00:08:20,605 --> 00:08:25,087
取计算结果中的大多数

117
00:08:25,087 --> 00:08:30,107
不难看出你得到了对密钥所有位异或的正确预测

118
00:08:30,107 --> 00:08:34,888
其正确概率为97.7%。换句话说，
如果这个关系在多于一半的时间里是正确的

119
00:08:34,888 --> 00:08:39,775
那么大多数的结果都将是正确的

120
00:08:39,775 --> 00:08:44,912
因为有偏量ε，概率将会超过一半，事实上是99.7%

121
00:08:44,912 --> 00:08:49,566
实际上，大部分情况下我们是正确的

122
00:08:49,566 --> 00:08:53,763
这里的大多数结果，
会给你正确的密钥所有位的异或，是不是很酷？

123
00:08:53,763 --> 00:08:58,667
在1/ε平方的次数内，你就可以解出密钥所有位的异或 。

124
00:08:58,667 --> 00:09:03,392
现在，我们把它应用到DES。DES的ε等于0.5的21次方

125
00:09:03,392 --> 00:09:08,117
意味着如果给定2的42次方个输入输出对时

126
00:09:08,117 --> 00:09:12,961
我可以接触密钥所有位的异或值。
事实上我可以告诉大家

127
00:09:12,961 --> 00:09:17,652
不严格地讲，使用这个方法，
你还不知道密钥中任何一位

128
00:09:17,652 --> 00:09:22,352
事实上，你可以取密钥中的任意两位，使用这个方法

129
00:09:22,352 --> 00:09:27,297
一个向前，一个向后

130
00:09:27,297 --> 00:09:31,825
这样就给你一些密钥中这两位的异或值，
这样就有了密钥中两位的信息了

131
00:09:31,825 --> 00:09:35,591
其实你还可以获得另外的12位

132
00:09:35,591 --> 00:09:39,786
因为你可以解出第五个S盒子的输入

133
00:09:39,786 --> 00:09:44,143
我不再详细展示了，但是是可以得到另外12位的

134
00:09:44,143 --> 00:09:48,124
这样一共就得到14位了，现在使用这个方法

135
00:09:48,124 --> 00:09:52,427
你已经还愿了密钥中14位内容，当然这需要进行2^42次。

136
00:09:52,427 --> 00:09:56,438
然后我们做什么呢？，剩下的部分就很简单了

137
00:09:56,438 --> 00:10:00,750
你只需要穷举密钥中剩余的位就可以了

138
00:10:00,750 --> 00:10:04,954
还剩下多少位呢？ 42位

139
00:10:04,954 --> 00:10:07,898
穷举密钥花掉了 2^42 的时间。那么攻击的总用时是多少？

140
00:10:07,898 --> 00:10:12,450
算法的第一步，确定14位需要2^24的时间

141
00:10:12,450 --> 00:10:16,667
剩下的穷举搜索需要另一个2^42

142
00:10:16,667 --> 00:10:22,211
所以攻击的总时间是2^43

143
00:10:22,211 --> 00:10:27,225
这比穷举攻击要好很多 在2^43时间里我们破解了DES

144
00:10:27,225 --> 00:10:32,178
不过这需要2^42个输入输出对

145
00:10:32,178 --> 00:10:37,131
而穷举搜索只需要3对。好，这里要求的明文密文对

146
00:10:37,131 --> 00:10:42,332
数目还是很多的，但给定这么多

147
00:10:42,332 --> 00:10:46,560
确实可以更快地还原DES密钥，通过这些我们学到了什么？

148
00:10:46,560 --> 00:10:51,227
第一，任何细微的线性关系

149
00:10:51,227 --> 00:10:56,219
比如这里第5个S盒子不像其他S盒子设计的那么好

150
00:10:56,219 --> 00:11:01,908
会导致一种攻击算法，任一细微的线性关系

151
00:11:01,908 --> 00:11:06,461
都会引入线性攻击。再次强调一下

152
00:11:06,461 --> 00:11:10,499
这些不是在设计密码时就能够考虑到的。所以结论是

153
00:11:10,499 --> 00:11:15,345
对分组密码存在很复杂的攻击，
仅凭自己一个人往往是无法找到的

154
00:11:15,345 --> 00:11:19,484
所以说要坚持使用标准，永远不要自己设计分组密码

155
00:11:19,484 --> 00:11:23,133
这就是关于复杂攻击所有我想说的

156
00:11:23,133 --> 00:11:27,548
现在我们来看最后一种攻击

157
00:11:27,548 --> 00:11:31,769
我称之为量子攻击，它对分组密码是通用的

158
00:11:31,769 --> 00:11:35,333
这里让我来解释一下

159
00:11:35,333 --> 00:11:40,453
首先我们来看一个普遍的问题，一个普遍的搜索问题

160
00:11:40,453 --> 00:11:45,222
假设我有一个定义在大集合X上的函数，
输出有两种值 0或1

161
00:11:45,222 --> 00:11:49,771
这个函数输出的大部分值都是0

162
00:11:49,771 --> 00:11:54,375
这个函数只有一个输入，
输入可能使函数输出1。

163
00:11:54,375 --> 00:11:58,812
目标是找出这些输入，满足函数值为1

164
00:11:58,812 --> 00:12:02,991
我们的目标就是要找到这个输入。
那么在一台经典的计算机上

165
00:12:02,991 --> 00:12:07,172
你能做什么？函数已经给出了，作为一个黑盒

166
00:12:07,172 --> 00:12:11,094
你所能做的最好是去尝试所有可能的输入

167
00:12:11,094 --> 00:12:15,378
所以需要的时间和定义域的大小是线性相关的。
但现在，如果有一台

168
00:12:15,378 --> 00:12:19,913
基于量子物理的计算机的话，就会产生神奇的结果。

169
00:12:19,913 --> 00:12:24,381
而非经典物理的话，那么你可以更快地解决这个问题

170
00:12:24,381 --> 00:12:29,142
我来解释一下。在20世纪七八十年代

171
00:12:29,142 --> 00:12:33,845
实际上是Richard Feynman最早观察到

172
00:12:33,845 --> 00:12:38,313
在经典计算机上模拟量子实验是非常困难的

173
00:12:38,313 --> 00:12:42,706
所以他说，如果是这样的话

174
00:12:42,706 --> 00:12:47,233
也许这些量子实验是经典计算机所无法计算的东西

175
00:12:47,233 --> 00:12:51,939
所以某种意义上它们可以计算得很快

176
00:12:51,939 --> 00:12:56,526
而同样的问题经典计算机很难做到。
这被证明是正确的，事实上

177
00:12:56,526 --> 00:13:01,470
我想给大家看一个令人惊奇的的例子，
如果你可以构建一个量子计算机

178
00:13:01,470 --> 00:13:06,117
用于计算量子物理，那么它可以被用来

179
00:13:06,117 --> 00:13:10,636
解决这个搜索问题，用不着|X|的时间，
而是|X|的平方根的时间即可

180
00:13:10,636 --> 00:13:14,612
即使计算机不知道任何函数F的信息

181
00:13:14,612 --> 00:13:18,397
F被视为黑盒，但是依然可以找到一个点使其函数值为1

182
00:13:18,397 --> 00:13:22,037
在|X|的平方根的时间内，我在这里不解释其原理

183
00:13:22,037 --> 00:13:25,966
在本课程的结尾，我们会有个高级课题的讲座

184
00:13:25,966 --> 00:13:29,798
来解释这个算法的工作过程

185
00:13:29,798 --> 00:13:33,678
这真的是很有趣的，事实上，量子计算机对于密码学

186
00:13:33,678 --> 00:13:37,000
影响很大。好的 我会在最后的课程解释这些

187
00:13:37,000 --> 00:13:42,190
那么，这和破解分组密码有什么关系呢？

188
00:13:42,190 --> 00:13:46,177
目前这仅仅是个普遍问题。对了

189
00:13:46,177 --> 00:13:50,377
在谈应用前我还要说一下，大家可能想知道

190
00:13:50,377 --> 00:13:54,417
能不能制造量子计算机，这个目前还完全未知

191
00:13:54,417 --> 00:13:58,936
没有人知道我们能否建造量子计算机

192
00:13:58,936 --> 00:14:03,348
来利用这个Grover提供的这个优美的算法

193
00:14:03,348 --> 00:14:07,548
那么，这和分组密码有何关系？
假定给你一个或几个明文密文对

194
00:14:07,548 --> 00:14:12,221
我们可以定义如下的函数

195
00:14:12,221 --> 00:14:17,366
这是一个定义在密钥空间K上的函数

196
00:14:17,366 --> 00:14:22,198
这个函数会输出1，如果正好满足k加密m得到c

197
00:14:22,198 --> 00:14:27,406
否则函数输出0。现在我们来讨论这个函数

198
00:14:27,406 --> 00:14:32,363
正是在密钥空间中一点处为1

199
00:14:32,363 --> 00:14:37,541
那么根据Grover算法，我们可以
用|K|的平方根的时间找到密钥

200
00:14:37,541 --> 00:14:41,609
那么这以为着什么？
对于DES，这足以完全摧毁DES了

201
00:14:41,609 --> 00:14:46,267
因为这仅用时2^28就能找出密钥，2^28仅为2亿左右

202
00:14:46,267 --> 00:14:50,747
而现代计算机上2亿步只需要毫秒级

203
00:14:50,747 --> 00:14:55,110
这足以摧毁DES了，即便是128位密钥的AES

204
00:14:55,110 --> 00:14:59,827
你也可以仅用2^64次的时间就找到密钥

205
00:14:59,827 --> 00:15:04,248
2^64在如今是视为不安全的

206
00:15:04,248 --> 00:15:08,353
它还在穷举法的范围内。所以，
如果有人可以造出量子计算机

207
00:15:08,353 --> 00:15:12,625
我们就可以说AES128不再安全

208
00:15:12,625 --> 00:15:16,683
如果你在明天的报纸上看到有文章说

209
00:15:16,683 --> 00:15:20,942
有人造出量子计算机了

210
00:15:20,942 --> 00:15:25,919
那你就可以得出结论，
大家必须立刻使用256位密钥的分组密码了

211
00:15:26,092 --> 00:15:30,837
因为256位密钥的Grover算法运行时间是2^128

212
00:15:30,837 --> 00:15:35,061
目前还是安全的

213
00:15:35,061 --> 00:15:39,112
也有256位的密码，比如AES256

214
00:15:39,112 --> 00:15:43,567
这也是AES要设计256位密钥的原因之一

215
00:15:43,567 --> 00:15:48,312
但其实不是唯一的原因，还有其他原因的

216
00:15:48,312 --> 00:15:53,529
我说过，这只是带大家初尝针对分组密码的不同攻击

217
00:15:53,529 --> 00:15:58,896
到此告一段落，如果我们决定在最后一讲讨论量子算法

218
00:15:58,896 --> 00:16:02,700
我们还会回过来看Grover算法的。【END】

