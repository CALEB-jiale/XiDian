1
00:00:00,000 --> 00:00:03,866
上一节我们已经讨论了如何解模方程组

22
00:00:03,866 --> 00:00:07,733
这一节我们讨论一下如何解模二次方程组

3
00:00:07,733 --> 00:00:11,815
通俗一点讲，就是计算模的e次根，我说过

4
00:00:11,815 --> 00:00:17,238
我们已经知道如何解模线性方程组，通过用一个相反的算法

5
00:00:17,238 --> 00:00:22,468
计算出的倒数之后与-b相乘。那么现在的问题是

6
00:00:22,468 --> 00:00:27,375
更高次的多项式，在解方程时尤其关注的是

7
00:00:27,375 --> 00:00:32,669
多项式模初始值的运算。所以解Zp中的多项式时，例如Zp

8
00:00:32,669 --> 00:00:38,092
这种形式：x**2-c，或者y**3-c或者z**37-c

9
00:00:38,092 --> 00:00:43,172
例如在解这个方程时涉及计算c的平方根

10
00:00:43,172 --> 00:00:47,589
解这个方程涉及解c的立方根

11
00:00:47,589 --> 00:00:52,620
这个方程要解c的37次根。等等

12
00:00:53,440 --> 00:00:59,268
下来我们设一个初值p，c是Zp的某一个元素

13
00:00:59,268 --> 00:01:05,709
我们说Zp中的x满足x^e等于c，我们称

14
00:01:05,709 --> 00:01:13,801
x是c的e次方根，让我们看一个例子。

15
00:01:13,801 --> 00:01:20,932
在Z11中三次根号下7等于6，因为6的立方等于216

16
00:01:20,932 --> 00:01:28,434
它恰好是7模11。因此7的立方根模11等于6

17
00:01:28,434 --> 00:01:35,751
那么我问一下，在Z11中3的平方根是多少？

18
00:01:35,751 --> 00:01:46,167
答案是5，因为5的平方等于25，刚好是3模11

19
00:01:46,167 --> 00:01:50,555
同样的，三次根号下1模11是多少

20
00:01:50,555 --> 00:01:57,449
1模11的立方根是1，因为1的立方是1.

21
00:01:57,449 --> 00:02:01,791
实际上，模任何一个初值都是正确的。有一个问题我想指出来的是

22
00:02:01,791 --> 00:02:05,802
这些e次根不是都存在的。例如

23
00:02:05,802 --> 00:02:09,865
如果我让你计算二次根号下2模11的值，你将有一个问题

24
00:02:09,865 --> 00:02:14,625
因为2的平方根模11不存在。

25
00:02:14,625 --> 00:02:19,099
现在我们明白e次跟是什么了，下一个问题就是这些e次根什么时候

26
00:02:19,099 --> 00:02:23,391
存在，并且知道在什么时候存在，我们能不能高效地把他们算出来

27
00:02:23,391 --> 00:02:28,167
所以让 我们开始这个简单的话题。这个话题是

28
00:02:28,167 --> 00:02:33,185
当我们想计算一个数的e次根时，并且恰巧e和p-1是互素的

29
00:02:33,185 --> 00:02:38,082
在这种情况下，c的1/e次方是存在的，并且也有一个简单的

30
00:02:38,082 --> 00:02:43,100
算法计算出c的e次根和Zp，所以让我们看一下它是如何工作的

31
00:02:43,100 --> 00:02:48,628
首先，因为e和p-1是互素的，并且知道e的倒数存在

32
00:02:48,628 --> 00:02:53,623
所以让我们计算这个倒数，令倒数等于d

33
00:02:53,623 --> 00:03:00,872
我们让d等于e的倒数模P-1之后我想声明一下实际上c的1/e次方就是c的d次方模p

34
00:03:00,872 --> 00:03:09,017
所以如果这个等式成立那么

35
00:03:09,017 --> 00:03:15,337
首先它证明了 对于所有的在Zp中的c它的e次根都存在

36
00:03:15,337 --> 00:03:20,682
更进一步，它给出了一个有效的算法来计算e次根

37
00:03:20,682 --> 00:03:25,976
通过计算e的倒数模p-1，并且将c提高到倒数的次方

38
00:03:25,976 --> 00:03:30,955
明白了吗？我们就有了一石二鸟之计。

39
00:03:30,955 --> 00:03:37,579
让我们看一下为什么这个等式成立。首先d倍的e等于

40
00:03:37,579 --> 00:03:44,705
1模p-1的事实意味着存在某个整数k.这样的话，如果我认为

41
00:03:44,705 --> 00:03:52,006
d倍的e实际就是p倍的（p-1）再加1，

42
00:03:52,006 --> 00:03:58,222
这个的意思是d倍的e等于1模p-1.好的，现在我们可以

43
00:03:58,222 --> 00:04:03,206
准确的证实了c的d次方是c的一个e次方根

44
00:04:03,206 --> 00:04:08,323
我们怎样证实它呢？让我们取c的d次方的e次方

45
00:04:08,323 --> 00:04:13,572
实际上当我们把它再升到e次方时，c的d次方是c的一个e次方根

46
00:04:13,572 --> 00:04:19,020
我们应该返回一个c。让我们来看看这为什么是正确的。

47
00:04:19,020 --> 00:04:24,106
那个仅仅等于c倍的d的e次方，c倍的d的e次方，

48
00:04:24,106 --> 00:04:29,488
根据定义等于c的k乘p-1再加1的次方。好的，用这个指数定律，

49
00:04:29,488 --> 00:04:37,375
我们可以写出c的p-1次方的k乘c

50
00:04:37,375 --> 00:04:41,948
我做的这些都是用标准的指数定律分配指数的

51
00:04:41,948 --> 00:04:47,087
现在我们知道c的p-1次方了吗？因为c属于Zp

52
00:04:47,087 --> 00:04:52,421
根据费马定理我们知道c的p-1次方等于1，

53
00:04:52,421 --> 00:04:57,755
1的k次方也等于1因此，这个就等于1模p

54
00:04:57,755 --> 00:05:03,822
这就是我们需要证明的c的d次方是c的一个e次方根

55
00:05:03,822 --> 00:05:08,790
好的，这就是我说的简单事例。实际，e次根通常是存在的

56
00:05:08,790 --> 00:05:13,633
当e与p-1是互素的时候。并且用这里的等式很容易计算出

57
00:05:13,633 --> 00:05:18,730
现在我们转向另一个更简单的例子

58
00:05:18,730 --> 00:05:24,192
这个简单的例子是当e与p-1不互素时，这里的例子是

59
00:05:24,192 --> 00:05:29,787
当e等于2时。现在假设我们想计算在Zp中的c的平方根

60
00:05:29,787 --> 00:05:35,183
如果p是奇数，实际从现在开始我们关注的是奇数值

61
00:05:35,183 --> 00:05:40,645
则p-1是偶数。意味着2整除p-1

62
00:05:40,645 --> 00:05:46,106
实际上2和p-1的最大公约数不等于1，所以，这不是一个简单的例子

63
00:05:46,106 --> 00:05:51,827
所以我们前面看到的算法在这里不适用了，

64
00:05:51,827 --> 00:05:56,565
当我们想计算模奇数的平方根。

65
00:05:56,565 --> 00:06:03,282
所以当我们计算模奇数时，这个平方函数实际是一个2对1的函数，即它

66
00:06:03,282 --> 00:06:09,416
它描述的是一个x和-x具有一样的值。它使得x和-x都与x平方相匹配，因此

67
00:06:09,416 --> 00:06:15,192
我们说这个函数是2对1的函数，这里有一个简单的例子

68
00:06:15,192 --> 00:06:20,585
它描述的是一个x和-x具有一样的值。它使得x和-x都与x平方相匹配，因此

69
00:06:20,585 --> 00:06:25,508
我们说这个函数是2对1的函数，这里有一个简单的例子

70
00:06:25,508 --> 00:06:30,391
让我们看一下当我们计算平方数模11会出现什么情况。

71
00:06:30,391 --> 00:06:34,837
你会发现1和10(-1%11)都匹配1，2和9(-2%11)都和4匹配

72
00:06:34,837 --> 00:06:39,595
3和8(-3%11)都和9匹配等等，所以你会明白

73
00:06:39,595 --> 00:06:44,475
这是一个2对1的函数，实际上，这些元素，1，4，

74
00:06:44,475 --> 00:06:49,227
9，5，3都有平方根。例如，4的平方根

75
00:06:49,227 --> 00:06:53,979
是2，9的平方根是3。而我想声明的是，实际上

76
00:06:53,979 --> 00:06:58,493
你会发现Z11中的其他元素都没有平方根，

77
00:06:58,493 --> 00:07:03,963
于是定义一个x在Zp中有平方根，则称x为一个二次剩余。

78
00:07:03,963 --> 00:07:09,283
是的，它在Zp中有一个平方根。假设它没有平方根，

79
00:07:09,283 --> 00:07:14,137
我们就说它是非二次剩余，例如在Z11中，

80
00:07:14,137 --> 00:07:19,457
4就是一个二次剩余，9是二次剩余，

81
00:07:19,457 --> 00:07:24,578
5是二次剩余，3是二次剩余，当然

82
00:07:24,578 --> 00:07:30,097
1也是二次剩余。好的我问一下，如果p是一个奇数，

83
00:07:30,097 --> 00:07:35,699
你认为它是Zp中的一个二次剩余吗？好的我给你们一个暗示，

84
00:07:35,699 --> 00:07:40,336
这个平方函数是一个2对1，这将意味着在Zp中一半的元素

85
00:07:40,336 --> 00:07:44,634
在这种映射下没有预映射。所以二次剩余的个数为(p-1)/2 + 1

86
00:07:44,634 --> 00:07:49,328
这个正确的原因是因为我们已经确切得知道了，

87
00:07:49,328 --> 00:07:54,123
在Zp中一半的元素是二次剩余，

88
00:07:54,123 --> 00:07:59,113
由于平方函数是2对1的映射这个事实，所以

89
00:07:59,113 --> 00:08:04,036
在这个函数映射中最多有(p-1)/2个元素，所以Zp中有一半的元素是二次剩余

90
00:08:04,036 --> 00:08:08,632
之后在Zp中也存在0，我们也必须考虑0

91
00:08:08,632 --> 00:08:13,556
0总是二次剩余，因为0的平方等于0

92
00:08:13,556 --> 00:08:18,875
好的，总而言之，在Zp<i>中我们得到 (p-1)/2个二次剩余，加1，

93
00:08:18,875 --> 00:08:24,401
元素0，它是Zp的一个二次剩余，总之，在Zp中

94
00:08:24,401 --> 00:08:29,763
有(p-1)/2 + 1 个二次剩余，好的这里应该记住的关键点是

95
00:08:29,763 --> 00:08:34,748
大概一半的元素有平方根而一半元素没有

96
00:08:34,748 --> 00:08:40,120
我想强调的是这一点不同于简单的事例，

97
00:08:40,120 --> 00:08:45,428
简单事例中e和p-1是互素的。如果你还记得那个例子

98
00:08:45,428 --> 00:08:50,412
在Zp中的每一个元素都有e次方根。当e与p-1是互素的

99
00:08:50,412 --> 00:08:55,720
不仅仅是那个例子。尤其当e=2时，

100
00:08:55,720 --> 00:09:02,735
在Zp中只有一半的元素有平方根，好的所以很自然的问题是

101
00:09:02,735 --> 00:09:08,195
给出一个Zp<i>中的元素x，我们能分辨出它是否有平方根吗？

102
00:09:08,195 --> 00:09:13,041
欧拉在这方面做了很多研究，实际上

103
00:09:08,195 --> 00:09:13,041
并且我们特别提到X和ZP是二次剩余，

104
00:09:13,041 --> 00:09:18,501
他想出了一个非常清晰的准则来准确地测试元素是二次剩余

105
00:09:13,041 --> 00:09:18,501
当且仅当X的(p-1)/2次幂等于 1 mod p的值。

106
00:09:18,501 --> 00:09:23,538
这是非常简单的情况，下面我们来看一个Z11中的例子。

107
00:09:23,538 --> 00:09:28,137
也就是说我们计算模11的情况。

108
00:09:28,137 --> 00:09:32,452
我计算它在 11 中的所有元素的五次方，

109
00:09:32,452 --> 00:09:36,880
我们看到X乘以（p-1）/2，总是为1或减去1，

110
00:09:36,880 --> 00:09:40,741
那么在二次剩余中我们可以精确到，1,3,5和9.

111
00:09:40,741 --> 00:09:44,942
以上几个数就是二次剩余，剩下的元素不是二次剩余。

112
00:09:44,942 --> 00:09:49,541
我用绿色把它们圈起来。

113
00:09:49,541 --> 00:09:54,432
这些是当我们对其做Mod11运算时没有平方根的数。

114
00:09:54,432 --> 00:09:58,704
我要特别讲一点，如果取不为零的X，我们看X(p-1)/2

115
00:09:58,704 --> 00:10:02,812
我们可以将其写成x（p-1）的平方根

116
00:10:07,138 --> 00:10:11,410
这就是x（p-1）的平方根。在费马定理中x(p-1)就是1。

117
00:10:11,410 --> 00:10:17,579
因此是x（p-1)/2也就是1的平方根，也就是1或者-1。

118
00:10:17,579 --> 00:10:21,688
以上证明了这里的求幂运算一定会输出1或者-1.

119
00:10:21,688 --> 00:10:26,654
我们看到了证明的过程。

120
00:10:26,654 --> 00:10:31,118
当x为二次剩余时，会输出1，当x不是二次剩余时输出-1。

121
00:10:31,118 --> 00:10:34,755
这不是一个很难的证明，在这里我们

122
00:10:34,755 --> 00:10:38,492
就不进行证明的演示了。证明会在这个模结束时的作为参考给出。

123
00:10:38,492 --> 00:10:43,643
为了讲解的完整性，我来讲讲这部分的计算。

124
00:10:43,643 --> 00:10:48,841
我们给x（p-1）/2取个名字，称为x对p的勒让德标志。

125
00:10:48,841 --> 00:10:54,517
正如前所说，在ZP中的元素标志为1或-1取决于

126
00:10:54,517 --> 00:10:59,924
x是否为二次剩余。现在，欧拉定理有个不好的地方在于

127
00:10:59,924 --> 00:11:03,726
它不是可构造的。尽管这是一个非常非常棒的定理。

128
00:11:03,726 --> 00:11:07,631
它告诉我们哪些数是二次剩余，哪些不是

129
00:11:07,631 --> 00:11:11,382
可是这个定理并不是可构造的。也就是说

130
00:11:11,382 --> 00:11:15,287
如果我们想计算一个二次剩余的平方根，定理不能

131
00:11:15,287 --> 00:11:19,295
确切地告诉我们该怎么做。还有，即使你想看证明，

132
00:11:19,295 --> 00:11:23,508
证明也是要基于确定存在的参数的。因此这个定理证明了平方根是存在的，

133
00:11:23,508 --> 00:11:28,541
但是并没告诉我们怎么计算平方根。

134
00:11:28,695 --> 00:11:33,149
所以下一个问题就是我们如何计算素数模的平方根。

135
00:11:33,149 --> 00:11:37,423
这不是个困难的问题，我们将其拆分成两块来看。

136
00:11:37,423 --> 00:11:41,327
第一，当p等于3mod4，这时很容易计算平方根。

137
00:11:41,327 --> 00:11:45,707
这是一个简单的函数。

138
00:11:45,707 --> 00:11:49,876
c的平方根就是c的（p+1）/4次幂。

139
00:11:49,876 --> 00:11:54,143
你们会注意到因为p等于3mod4，

140
00:11:54,143 --> 00:11:59,094
p+1等于0mod4，也就是说p+1可以被4除尽

141
00:11:59,094 --> 00:12:04,236
因此(p+1)/4是整数。这也是我们可以计算这个求幂运算

142
00:12:04,236 --> 00:12:09,188
的根本原因。并且，这也告诉了我们c的平方根是什么。

143
00:12:09,188 --> 00:12:14,203
通过很简单的函数，直接地可以求出c的平方根。

144
00:12:14,203 --> 00:12:17,099
现在我们来证明它的真实性。

145
00:12:17,099 --> 00:12:22,441
我们计算c的(p+1)/4词幂并求它的平方，

146
00:12:22,441 --> 00:12:29,663
如果c的（P+1)/4次方是c的平方根，那么我上面做平方时应该会得到c。

147
00:12:29,663 --> 00:12:36,358
我们来看看会得到什么。首先，根据求幂运算的法则，可以得到等于c的（P+1)/2次幂。


148
00:12:36,358 --> 00:12:43,232
我可以写下来c的f(p-1)/2次方乘以c

149
00:12:43,232 --> 00:12:47,804
接下来，去除二分之一

150
00:12:47,804 --> 00:12:53,221
那么现在c的 (p-1)/2次幂怎么样了呢 ?

151
00:12:53,221 --> 00:12:58,441
因为c是二次剩余，我们知道c的 (p-1)/2次幂是 1.

152
00:12:58,441 --> 00:13:03,472
因此，上式也就等于1乘以c，也就是在ZP中我们

153
00:13:03,472 --> 00:13:08,390
希望得到的c。因此我们证明了c的(P+1)/4次幂是c的平方根，

154
00:13:08,390 --> 00:13:13,374
至少当p等于3模4时成立

155
00:13:13,374 --> 00:13:18,175
现在可能有疑问，在什么情况下p等于1模4时？

156
00:13:18,175 --> 00:13:22,672
在这种情况下，这个公式甚至没什么意义

157
00:13:22,672 --> 00:13:27,534
因为指数(p+1)/4不知道是否为一个有理分式

158
00:13:27,534 --> 00:13:32,858
我也不知道如何提高，c才能使其成为有理分式

159
00:13:32,858 --> 00:13:37,151
然而它却说明了即使当p等于1模4时，我们可以高效地找到

160
00:13:37,151 --> 00:13:41,341
平方根，即使很难办到。特别是，我们并没有一个

161
00:13:41,341 --> 00:13:45,480
处理它使用的确定性算法。我们得用随机化算法来得到

162
00:13:46,180 --> 00:13:51,132
但是这种随机化算法实际上能高效地找到x模p的平方根

163
00:13:51,132 --> 00:13:56,795
我猜我应该提过，如果有人可以证明

164
00:13:56,795 --> 00:14:01,559
广义黎曼假设，这是一个很深奥的解析数论的假说

165
00:14:01,559 --> 00:14:05,651
如果有人能够证明这个假说是真的，事实上就得到了

166
00:14:05,651 --> 00:14:10,079
甚至当p等于1模4时的一个计算平方根的确定性算法

167
00:14:10,079 --> 00:14:14,507
我之所以提起这个是因为

168
00:14:14,507 --> 00:14:18,879
当你将计算透镜用在一些问题上时你就会发现了，比如

169
00:14:18,879 --> 00:14:23,255
要计算数x模p的平方根。就需要找到一个算法

170
00:14:23,255 --> 00:14:28,253
在数学上极其深入

171
00:14:28,253 --> 00:14:33,835
有些甚至在今天都不知道是否是真的。照目前来看，我们不仅仅需要一个

172
00:14:33,835 --> 00:14:38,428
确定性算法来计算p为1模4的平方根

173
00:14:38,428 --> 00:14:42,791
但是我们有不错的随机化算法，这种问题就会变得容易

174
00:14:42,791 --> 00:14:47,326
本质上这可以归结为一些乘幂运算。结果就像我们看到的

175
00:14:47,326 --> 00:14:52,033
计算平方根的时间本质上为p的比特数的立方

176
00:14:52,033 --> 00:14:57,154
非常完美。现在我们知道如何计算模p的平方根了

177
00:14:57,154 --> 00:15:01,100
现在我们可以说说二次方程模p了

178
00:15:01,100 --> 00:15:04,924
假设我给一个二次方程让你用ZP找到解这个方程的方法

179
00:15:04,924 --> 00:15:08,951
其实我想说你已经知道如何解决了

180
00:15:08,951 --> 00:15:12,927
解它的方法基本上会使用你在高中解决二次方程的公式

181
00:15:12,927 --> 00:15:16,955
所以解法是-b加减根号b平方减4ac

182
00:15:16,955 --> 00:15:20,982
我说你知道如何解

183
00:15:20,982 --> 00:15:25,213
这个公式里的所有元素。所以你就知道如何计算2a的倒数了

184
00:15:25,213 --> 00:15:29,189
你可以用2a来划分。那么问题就利用扩展欧几里得算法得以解决

185
00:15:29,189 --> 00:15:33,420
你也知道如何完成根号下b平方减4ac的计算，运用

186
00:15:33,420 --> 00:15:37,761
前面提到的平方根算法。当然这个公式

187
00:15:37,761 --> 00:15:43,495
仅仅当平方根在ZP上实际存在时才可用

188
00:15:43,495 --> 00:15:49,592
现在你们知道如何在ZP上解二次方根。那么下个问题是，

189
00:15:49,592 --> 00:15:54,760
如何计算这些根的模合数二次剩余，而不是计算模素数的。

190
00:15:54,760 --> 00:16:00,036
我们可以问一个先前提过的相同问题

191
00:16:00,036 --> 00:16:05,012
什么时候c^(1/e) in ZN存在?如果我们知道N存在

192
00:16:05,012 --> 00:16:10,120
我们可不可以更高效地计算出来?然而这个问题却非常困难

193
00:16:10,120 --> 00:16:14,692
事实上，计算ec^(1/e) in ZN的复合模数

194
00:16:14,692 --> 00:16:19,751
和对复合进行因式分解一样困难。对于一般情况下的e

195
00:16:19,751 --> 00:16:24,811
我们现在能计算e的根模N的最好算法，虽然不知道是不是真的

196
00:16:24,811 --> 00:16:29,505
需要我们把模数计入因子。一旦我们计入

197
00:16:29,505 --> 00:16:34,078
那么就更容易计算e的原根中的每个素因子

198
00:16:34,078 --> 00:16:39,137
我们可以结合所有e第i根来得到e的模复合N

199
00:16:39,137 --> 00:16:44,378
非常有趣的是，在计算e第i根

200
00:16:44,378 --> 00:16:48,919
模素数就很容易了。事实上，对于很多e而言都是容易的

201
00:16:48,919 --> 00:16:53,403
但是计算e的根模复合数是非常难的

202
00:16:53,403 --> 00:16:59,265
需要对N进行因式分解。这就是我想说的关于e第i根的问题

203
00:16:59,265 --> 00:17:03,489
下节课，我们会说到模化算法

204
00:17:03,489 --> 00:17:08,562
将会讲到加法、乘法、乘方算法，模素数和复合。【END】

