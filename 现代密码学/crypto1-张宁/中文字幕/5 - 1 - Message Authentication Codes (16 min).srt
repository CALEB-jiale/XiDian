1
00:00:00,000 --> 00:00:02,432
这一部分我们将不再讨论加密

2
00:00:02,432 --> 00:00:04,415
而讨论消息完整性

3
00:00:04,415 --> 00:00:08,987
然后 我们会再回到加密 展示一下怎么同时提供保密性和完整性

4
00:00:08,987 --> 00:00:13,222
如我所言 这里我们的目标是提供不带保密性的完整性

5
00:00:13,222 --> 00:00:16,561
实际中 有很多场景是需要这样的体制

6
00:00:16,561 --> 00:00:19,583
例如 你可能想对你硬盘上的系统文件进行操作

7
00:00:19,583 --> 00:00:24,608
如果你用的是Windows 所有Windows操作系统文件在硬盘上都是没有加密的

8
00:00:24,608 --> 00:00:26,116
它们对整个世界可知

9
00:00:26,116 --> 00:00:30,883
但是 很重要的一点是要确保它们没有被病毒或者什么恶意软件修改

10
00:00:30,883 --> 00:00:33,760
那就是一个你需要提供完整性但不

11
00:00:33,760 --> 00:00:38,127
关心保密性的例子 另一个例子是网页上的标题广告

12
00:00:38,127 --> 00:00:41,467
广告供应商不用在意谁拷贝

13
00:00:41,467 --> 00:00:45,128
并给其它人看 所以完全不存在保密的问题

14
00:00:45,128 --> 00:00:47,458
但是他们确实在意对这些广告的修改

15
00:00:47,458 --> 00:00:52,046
比如 他们不希望人们把这些广告改成其它的广告

16
00:00:52,046 --> 00:00:57,814
所以这是另一个例子 完整性重要但是保密性压根不重要

17
00:00:57,814 --> 00:00:59,940
那么我们怎么提供完整性呢？

18
00:00:59,940 --> 00:01:04,980
一个基本的方法是所谓的消息认证码MAC

19
00:01:04,980 --> 00:01:08,842
我们操作方法如下 我们的两个朋友 Alice和Bob来了

20
00:01:08,842 --> 00:01:13,783
他们有一个共享密钥k 攻击者不知道 但他两知道

21
00:01:13,783 --> 00:01:16,868
有个公开的消息M Alice想把M发给Bob

22
00:01:16,868 --> 00:01:21,743
但是信道上的攻击者不能修改这个消息

23
00:01:21,743 --> 00:01:27,935
Alice采取的方法是 使用所谓MAC签字算法 我们用S来表示

24
00:01:27,935 --> 00:01:32,558
MAC签字算法以密钥和这个消息作为输入

25
00:01:32,558 --> 00:01:37,243
生成一个很短的标签 标签可能是90比特或100比特 或者其它

26
00:01:37,243 --> 00:01:41,905
尽管消息可能是Gb量级的 标签实际上非常非常短

27
00:01:41,905 --> 00:01:46,640
那么 她给这个消息价格标签 把这两个合起来发送给Bob

28
00:01:46,640 --> 00:01:48,790
Bob接受到消息和标签

29
00:01:46,640 --> 00:01:48,790
Bob receives the message and the tag,

30
00:01:48,790 --> 00:01:53,311
他接着对这个标签运行所谓MAC验证算法

31
00:01:53,311 --> 00:01:56,564
MAC验证算法把这个标签、消息和密钥作为输入

32
00:01:56,564 --> 00:02:01,359
给出是或否 取决于消息是否有效

33
00:02:01,359 --> 00:02:05,585
或者是否被篡改过 好 更准确的 什么是MAC？

34
00:02:05,585 --> 00:02:08,401
我们说MAC基本上由两个算法构成

35
00:02:08,401 --> 00:02:10,766
一个签字算法 一个验证算法

36
00:02:10,766 --> 00:02:16,214
和往常一样 他们是定义在一个密钥空间 一个消息空间和一个标签空间上

37
00:02:16,214 --> 00:02:18,641
就像我们前面说的 这是一对算法

38
00:02:18,641 --> 00:02:22,637
签字算法会在标签空间输出一个标签 验证算法

39
00:02:22,637 --> 00:02:27,536
在已知密钥、消息和标签的情况下 输出是或否

40
00:02:27,536 --> 00:02:31,770
像往常一样 我要求大家注意一致性要求 就是

41
00:02:31,770 --> 00:02:36,755
对密钥空间的所有k 和消息空间的所有消息

42
00:02:36,755 --> 00:02:41,067
如果我对消息用一个特定的密钥签字

43
00:02:41,067 --> 00:02:47,364
那么我用同样的密钥对标签进行验证 我应该得到“是”这个结果

44
00:02:47,364 --> 00:02:50,915
这是标准的一致性要求

45
00:02:50,915 --> 00:02:54,736
和我们在加密中看到的一样 现在 我想指出的一点是

46
00:02:54,736 --> 00:02:58,477
完整性必须要求Alice和Bob共享密钥

47
00:02:58,477 --> 00:03:02,121
实际上 人们经常犯同一个错误 他们试图

48
00:03:02,121 --> 00:03:05,795
在没有共享密钥的情况下保证完整性 给个例子

49
00:03:05,795 --> 00:03:10,554
考虑一下CRC CRC代表循环冗余校验

50
00:03:10,554 --> 00:03:14,544
这已是个典型的校验和算法 用来检测消息中的随机错误

51
00:03:14,544 --> 00:03:19,636
想象一下 不用密钥来生成标签 Alice用无密钥

52
00:03:19,636 --> 00:03:24,162
的CRC算法来 不用任何密钥 生成标签

53
00:03:24,162 --> 00:03:27,594
然后她把标签贴在消息上 发给Bob

54
00:03:27,594 --> 00:03:31,984
Bob还用CRC来验证它是不是正确 换句话说

55
00:03:31,984 --> 00:03:37,108
Bob仍然验证这个标签等于CRC(m) 就是说

56
00:03:37,108 --> 00:03:40,454
如果相等 验证算法就给出是 不等就给出否

57
00:03:40,454 --> 00:03:44,027
这个的问题是 对于攻击者而言非常容易击破

58
00:03:44,027 --> 00:03:48,173
换句话说 攻击者可以非常容易地更改消息 并路由篡改过的消息

59
00:03:48,173 --> 00:03:51,645
并让Bob以为这个新消息是有效的

60
00:03:51,645 --> 00:03:55,205
攻击者这样做 他把消息中的标签先删掉

61
00:03:55,205 --> 00:03:58,352
就是屏蔽掉 然后自己生成一个消息 m一撇

62
00:03:58,352 --> 00:04:03,042
计算这个消息m一撇的CRC值

63
00:04:03,042 --> 00:04:06,622
然后串接这两个发给Bob

64
00:04:06,622 --> 00:04:10,948
Bob就会返回一个验证算法 验证正确

65
00:04:10,948 --> 00:04:15,856
因为实际上右边的是左边的一个有效的CRC

66
00:04:15,856 --> 00:04:19,898
结果是 Bob会认为这个消息来自Alice但是实际上

67
00:04:19,898 --> 00:04:24,980
消息已经完全被攻击者篡改了 和Alice发的原始消息没有一点关系

68
00:04:24,980 --> 00:04:29,440
好 那么问题是 因为CRC没有密钥 Alice

69
00:04:29,440 --> 00:04:34,609
和攻击者没有区别 结果是 Bob不知道消息是从谁发来的

70
00:04:34,609 --> 00:04:39,579
一旦我们引入密钥 Alice就能做一些攻击者不能做的事

71
00:04:39,579 --> 00:04:44,194
结果是 她能计算出一些攻击者不能篡改的标签

72
00:04:44,194 --> 00:04:50,166
所以 要牢记的是 CRC是设计来检测随机错误的 而不是恶意的错误

73
00:04:50,166 --> 00:04:55,490
现在我们的目标是确保恶意的攻击者不能在信道中篡改消息

74
00:04:55,490 --> 00:04:59,390
下面我们想对MAC系统的安全性给出定义

75
00:04:59,390 --> 00:05:04,635
和平时一样 我们从攻击者能力的角度来定义安全性 攻击者能干什么？

76
00:05:04,635 --> 00:05:08,842
攻击者的目标 他想干什么 在MAC的情况中

77·
00:05:08,842 --> 00:05:13,699
攻击者的能力被称为选择消息攻击 换句话说

78
00:05:13,699 --> 00:05:19,039
攻击者可一个给Alice任何消息 根据他的选择 m1 mq等等

79
00:05:19,039 --> 00:05:24,921
Alice会给他计算这些消息的标签 给他这些标签

80
00:05:24,921 --> 00:05:28,070
再一次 你可能会问 为什么Alice会这么做？

81
00:05:28,070 --> 00:05:31,796
为什么Alice要计算攻击者给她的消息的标签？

82
00:05:31,796 --> 00:05:35,935
看一下选择消息攻击的场景 其实在现实中很常见

83
00:05:35,935 --> 00:05:40,276
攻击者可以给Alice一个消息 Alice会计算这个消息的标签

84
00:05:40,276 --> 00:05:45,803
接着攻击者获得标签 例如 攻击者给Alice发个Email

85
00:05:45,803 --> 00:05:50,262
Alice可能想把这个email存在硬盘上 为了防止其他人

86
00:05:50,262 --> 00:05:53,441
篡改这个硬盘 她会计算这个消息的标签

87
00:05:53,441 --> 00:05:58,798
并把这个消息和标签都存在这个硬盘上 后来 攻击者偷了Alice的硬盘

88
00:05:58,798 --> 00:06:03,385
那么他现在就有了他发给Alice消息的标签

89
00:06:03,385 --> 00:06:07,670
这是真实世界选择消息攻击的例子 这里攻击者

90
00:06:07,670 --> 00:06:11,497
确实拥有一个他发给Alice的消息的标签

91
00:06:11,497 --> 00:06:15,796
好 攻击者能干什么 基本上 这种选择消息攻击

92
00:06:15,796 --> 00:06:20,441
那么他的目标是什么？他的目标是是做一种所谓的“存在伪造”

93
00:06:20,441 --> 00:06:26,312
他想做的是生成一些 一些新的有效的消息标签

94
00:06:26,312 --> 00:06:30,984
好 一些消息标签对 和之前

95
00:06:30,984 --> 00:06:34,327
他有的那些消息标签对不同

96
00:06:34,327 --> 00:06:38,788
如果他能这么做 那么我们就说这个系统是不安全的 如果他不能

97
00:06:38,788 --> 00:06:42,704
我们就说这个系统是安全的 所以 这里我想强调存在

98
00:06:42,704 --> 00:06:47,591
伪造意味着攻击者不能生成一对新的消息标签对

99
00:06:47,591 --> 00:06:52,575
即便这个消息是完全无意义的 你可能又要问了 好

100
00:06:52,575 --> 00:06:55,737
为什么我们会关心攻击者会不会对无意义的消息做标签

101
00:06:55,737 --> 00:06:57,697
这对攻击者来说没有任何价值

102
00:06:57,697 --> 00:07:02,220
但是我们想在任何应用场景下构建安全的MAC

103
00:07:02,220 --> 00:07:06,741
然后有 实际状况下 比如你可能想计算一个随机秘钥

104
00:07:06,741 --> 00:07:12,517
下的完整标签 在这种情况下 甚至攻击者也能够计算这个完全随机的消息

105
00:07:12,517 --> 00:07:18,365
的标签 他可能能够诱使用户使用错误的秘钥

106
00:07:18,365 --> 00:07:22,422
因此我们想要确认MAC是否是安全的 攻击者不能

107
00:07:22,422 --> 00:07:26,848
对任何消息创建合法的标签 不论消息是无用的还是无意义的

108
00:07:26,848 --> 00:07:31,725
另一个隐含的安全定义的性质是如果攻击者获得了一些

109
00:07:31,725 --> 00:07:37,691
消息标签对 他不能为同一消息写出新的标签

110
00:07:37,691 --> 00:07:42,456
换句话说即使消息m可能有另一个标签t'

111
00:07:42,456 --> 00:07:48,099
攻击者得到m和t后不应该有能力找到这个新的t'

112
00:07:48,099 --> 00:07:52,177
这时你可能奇怪为何我们要在乎攻击者已经拥有了消息m的一个标签

113
00:07:52,177 --> 00:07:55,774
为什么他能写出另一个消息m的标签这件事很重要 他已经

114
00:07:55,774 --> 00:08:00,672
有一个标签了 但是正如我们所看到的 很重要的一点是

115
00:08:00,672 --> 00:08:05,689
攻击者不能对已经签名的信息产生新的标签

116
00:08:05,689 --> 00:08:09,360
特别是 它将在我们融合了加密与完整性之后发生

117
00:08:09,360 --> 00:08:13,145
所以我们会要求给出消息的一个标签不可能

118
00:08:13,145 --> 00:08:17,226
找到这个消息的另一个标签 好的 所以现在我们清楚了

119
00:08:17,226 --> 00:08:21,703
我们正在努力获得的客观事实 让我们照旧用一个更严谨的游戏来定义它

120
00:08:21,703 --> 00:08:26,180
这里我们有两个算法S和V 而且我们有个对手A

121
00:08:26,180 --> 00:08:29,589
然后游戏进行如下 挑战者照例只为MAC

122
00:08:29,589 --> 00:08:34,833
选择一个随机秘钥 然后对手基本上根据他选择的消息攻击

123
00:08:34,833 --> 00:08:39,697
所以他提交了一个m1给挑战者随后收到一个m1的标签

124
00:08:39,697 --> 00:08:43,897
然后他提交了一个m2给挑战者随后收到一个m2的标签

125
00:08:43,897 --> 00:08:48,816
然后如此进行下去 直到 他给对手提交了q条消息然后

126
00:08:48,816 --> 00:08:53,628
收到了所有消息的q个标签 所以这就是选定消息攻击的部分

127
00:08:53,628 --> 00:08:57,216
然后对手继续试着去做一个存在伪造

128
00:08:57,216 --> 00:09:02,321
也就是说 他输出一个消息标签对 一个新的消息标签对

129
00:09:02,321 --> 00:09:07,704
我们说这样的话他赢得了这场游戏 换句话说b等于1的意思就是他赢了这个游戏

130
00:09:07,704 --> 00:09:12,196
如果 首先 他输出的这个消息秘钥对是有效的

131
00:09:12,196 --> 00:09:17,593
所以验证算法通过了 其次 它是一个新的消息标签对

132
00:09:17,593 --> 00:09:21,168
换句话说 它不是我们之前给过他的消息标签对

133
00:09:21,168 --> 00:09:25,339
换个角度 我们说攻击者输掉了这场游戏 也就是b等于0

134
00:09:25,339 --> 00:09:30,855
然后照例我们说 我们定义了一个对手的优势是

135
00:09:30,855 --> 00:09:35,267
在这场游戏中挑战者输出1的可能性 我们说MAC系统是安全的

136
00:09:35,267 --> 00:09:39,564
如果对于所有有能力的对手这个优势都是微不足道的 好的 换句话说

137
00:09:39,564 --> 00:09:43,853
在没有有能力的对手能够以不可忽视的概率赢得这场游戏

138
00:09:43,853 --> 00:09:48,799
好的 这就是我们对于MAC安全性的定义 然后我们的目标是建立像这样的安全的MAC


139
00:09:48,799 --> 00:09:53,529
在我们做这件事之前 我要问你两个问题 第一个问题是 假设我们有一个MAC

140
00:09:53,529 --> 00:09:59,154
而且碰巧攻击者能够找到两条消息 m0和m1

141
00:09:59,154 --> 00:10:02,904
它们碰巧对于一半的秘钥有相同的标签

142
00:10:02,904 --> 00:10:07,505
换句话说 如果你按照各半的概率随机选择一个秘钥 m0的

143
00:10:07,505 --> 00:10:12,339
标签将会和m1的标签一样 然后我给你的问题是

144
00:10:12,339 --> 00:10:16,072
这是一个安全的MAC吗？所以我想强调的是攻击者并不知道

145
00:10:16,072 --> 00:10:21,832
m0和m1的标签是什么 他只知道两条消息碰巧有

146
00:10:21,832 --> 00:10:27,559
相同的标签的几率是二分之一 于是问题来了 这是不是一个安全的MAC

147
00:10:27,559 --> 00:10:31,162
答案是否定的 这不是一个安全的MAC 原因是

148
00:10:31,162 --> 00:10:36,192
选定消息攻击 本质上攻击者可以请求一个m0的

149
00:10:36,192 --> 00:10:42,665
标签 然后他会从挑战者那里收到m0,T 事实上T是一个

150
00:10:42,665 --> 00:10:49,590
m0的有效的标签 然后他要作为存在伪造输出的是m1,T

151
00:10:49,590 --> 00:10:55,330
然后你发现这个m1,T和m0 T是不同的 所以这是一个有效的存在伪造

152
00:10:55,330 --> 00:10:59,748
而作为结果 攻击者在只有一半优势的情况下赢得了这场游戏

153
00:10:59,748 --> 00:11:03,968
所以我们断定这个MAC是不安全的 我想问的第二个问题是

154
00:11:03,968 --> 00:11:07,378
假设我们有一个MAC碰巧总是输出5比特的标签

155
00:11:07,378 --> 00:11:11,823
换句话说 这个MAC的标签空间碰巧是{0,1}^5

156
00:11:11,823 --> 00:11:17,680
所以对于每条消息的每个秘钥来说 签名算法只输出5比特的标签

157
00:11:17,680 --> 00:11:21,949
然后问题是 这个MAC安全吗？

158
00:11:21,949 --> 00:11:26,204
很显然答案是否定的 因为攻击者可以简单的猜测这个标签

159
00:11:26,204 --> 00:11:28,810
所以他需要做的就是 并不需要选定消息攻击

160
00:11:28,810 --> 00:11:32,324
他只需要做的 只是输出一个如下的存在伪造

161
00:11:32,324 --> 00:11:39,661
他只需要选择一个随机的标签 在{0,1}^5的空间中选择一个随机标签

162
00:11:39,661 --> 00:11:45,492
然后他只需要按刚才提到的那样输出他的存在伪造 消息0和标签t

163
00:11:45,492 --> 00:11:52,720
然后现在有1/2^5的概率 这个标签是对消息0有效的

164
00:11:52,720 --> 00:11:56,974
所以对手的优势是1/32 这是不可忽略的

165
00:11:56,974 --> 00:12:00,573
所以它基本上告诉我们 标签不能过短

166
00:12:00,573 --> 00:12:05,759
他们需要有一定的长度 而且事实上 典型标签的长度会有

167
00:12:05,759 --> 00:12:14,704
例如64比特 或者96比特 或128比特 这里我们以使用96比特的标签为例

168
00:12:14,704 --> 00:12:19,338
如果你试图去猜测一个96比特的标签的消息 你猜对

169
00:12:19,338 --> 00:12:23,726
的概率是1/2^96 所以对手的优势

170
00:12:23,726 --> 00:12:28,114
仅仅是1/2^96 这是微不足道的 所以既然我们已经理解了什么是MAC

171
00:12:28,114 --> 00:12:29,935
我将给你展示一个简单的应用

172
00:12:29,935 --> 00:12:34,193
特别地说 我们来看一下MAC是如何被用来保护硬盘上的文件的

173
00:12:34,193 --> 00:12:37,831
想象一下你安装了一个操作系统 假如 当你在你的机器上

174
00:12:37,831 --> 00:12:42,179
安装了Windows 其中一件事 Windows也这么做 是它要求用户提供

175
00:12:42,179 --> 00:12:47,444
一个密码 然后从这个密码导出一个秘钥K 然后对于它写到硬盘

176
00:12:47,444 --> 00:12:52,790
上的每个文件 在这种情况下 文件可以是F1、F2直到Fn

177
00:12:52,790 --> 00:12:56,123
操作系统做的就是它会为那个文件计算一个标签

178
00:12:56,123 --> 00:13:01,908
然后把标签和文件一起保存 所以这里它连接了每个标签和它对应的文件

179
00:13:01,908 --> 00:13:06,326
然后它删除了秘钥K 所以秘钥K不再被储存在硬盘里

180
00:13:06,326 --> 00:13:10,884
或者内存里 或者其他地方 好的 所以想象一下今后机器

181
00:13:10,884 --> 00:13:15,532
感染上一个病毒 这个病毒试图修改一些系统文件

182
00:13:15,532 --> 00:13:19,154
问题就是用户是否能够察觉哪些文件被修改了

183
00:13:19,154 --> 00:13:24,270
所以这里有一个方法 使用一些未被感染的操作系统重新启动机器

184
00:13:24,270 --> 00:13:28,868
比如你从U盘或者哪里启动 然后 一旦机器从这个未被感染的操作系统

185
00:13:28,868 --> 00:13:34,052
启动 用户可以提供他的密码给这个正在运行的未被感染的操作系统

186
00:13:34,052 --> 00:13:37,974
然后这个正在运行的未被感染的操作系统将继续执行并检查每个

187
00:13:37,974 --> 00:13:43,279
系统文件的MAC 现在 事实是MAC是安全的 这就意味着

188
00:13:43,279 --> 00:13:49,819
这个可怜的病毒并不能确实地创建一个拥有有效的标签的新文件 我们叫它F'

189
00:13:49,819 --> 00:13:53,928
所以它实际上不能创建一个f^A', t^A' 因为 如果它可以

190
00:13:53,928 --> 00:13:58,757
它就是在这个MAC中的一个存在伪造 然后因为

191
00:13:58,757 --> 00:14:02,973
这个MAC是存在不可伪造的 这个病毒不能创建任何F' 不论

192
00:14:02,973 --> 00:14:07,092
F'是什么 因此 由于MAC的安全性

193
00:14:07,092 --> 00:14:10,829
用户将会发现所有被病毒修改的文件

194
00:14:10,829 --> 00:14:16,104
现在 这里有一个警告 有一件病毒可以做的事 那就是交换

195
00:14:16,104 --> 00:14:22,190
两个文件 所以 例如 他可以交换这个文件 文件F1 和这里的文件F2

196
00:14:22,190 --> 00:14:26,364
仅仅是照字面意思交换它们 所以当系统 或者用户 尝试打开

197
00:14:26,364 --> 00:14:31,126
文件F1 作为替代它们会打开文件F2 所以自然这会造成

198
00:14:31,126 --> 00:14:35,475
各种各样的损害 所以防范它的方法本质上就是把

199
00:14:35,475 --> 00:14:40,345
文件名放到MAC空间里 所以事实上我们在做一个完整性检查

200
00:14:40,345 --> 00:14:44,658
就像我们对文件内容所做的一样 结果是 如果病毒

201
00:14:44,658 --> 00:14:48,602
试图替换两个文件 系统将会说 嗨 这个位于

202
00:14:48,602 --> 00:14:52,757
F1位置的文件没有正确的文件名 然后因此它会发现这个病毒

203
00:14:52,757 --> 00:14:56,859
做了文件替换 虽然MAC确实验证通过了 所以重要的是

204
00:14:56,859 --> 00:15:01,094
记住MAC可以帮你防范文件被篡改 或者数据被篡改

205
00:15:01,094 --> 00:15:06,403
但是它们并不能帮助你防范已验证数据的替换

206
00:15:06,403 --> 00:15:09,725
所以这需要通过其他手段实现 好的 这就是我们

207
00:15:09,725 --> 00:15:13,037
对MAC入门的总结 在下个部分 我们将继续介绍并构造

208
00:15:13,037 --> 00:15:15,173
我们第一个安全MAC的例子【END】