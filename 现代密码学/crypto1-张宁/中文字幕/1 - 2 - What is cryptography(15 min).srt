1
00:00:00,000 --> 00:00:02,951
在开始学习这门课程前，
我要给你们快速讲一下

2
00:00:02,951 --> 00:00:06,487
密码学的简要概述，
以及密码学的不同领域。

3
00:00:06,487 --> 00:00:10,487
密码学的核心当然
是安全通信，他本质上

4
00:00:10,487 --> 00:00:14,539
由两部分组成。第一部分是
安全秘钥的建立，然后是

5
00:00:14,539 --> 00:00:18,697
利用共享秘钥进行
安全通信。我们说过

6
00:00:18,697 --> 00:00:22,854
安全秘钥的建立是指Alice和Bob互相通信

7
00:00:22,854 --> 00:00:26,906
这样在协议的最后，双方达成共享秘钥k

8
00:00:26,906 --> 00:00:30,906
除了共享秘钥，事实上

9
00:00:30,906 --> 00:00:35,274
Alice应该知道她在和Bob通信
同样Bob应该知道他在和Alice通信

10
00:00:35,274 --> 00:00:39,964
而弱的攻击者监听该对话却无法得知

11
00:00:39,964 --> 00:00:44,011
共享秘钥，本节稍后
我们来看怎样操作。现在

12
00:00:44,011 --> 00:00:47,657
他们一旦达成共享秘钥，
他们希望使用该秘钥安全地交换信息

13
00:00:47,657 --> 00:00:51,698
我们将会讨论满足他们的加密机制，这样就使得

14
00:00:51,698 --> 00:00:55,491
攻击者无法知道什么消息在被传来传去。

15
00:00:55,491 --> 00:00:59,630
进一步说，攻击者甚至无法篡改通信内容，
一旦篡改，立刻被检测到

16
00:00:59,630 --> 00:01:03,227
换句话说，加密机制提供了机密性和

17
00:01:03,227 --> 00:01:06,774
完整性。不过密码学的功能远不止这两点。

18
00:01:06,774 --> 00:01:10,519
我来举一些例子。第一个例子

19
00:01:10,519 --> 00:01:14,468
叫做数字签名。数字签名

20
00:01:14,468 --> 00:01:18,892
基本上与实际手写签名类似，在实际中

21
00:01:18,892 --> 00:01:23,372
当你签署一份文件时，
你在文件上写下你签名

22
00:01:23,372 --> 00:01:27,740
你的签名总是一样的。
你总是在所有的文件上

23
00:01:27,740 --> 00:01:32,164
签同样的字，在数字世界中，

24
00:01:32,164 --> 00:01:36,812
签名不能这样.因为一旦攻击者
获得我的一个文件签名

25
00:01:36,812 --> 00:01:41,180
他可以复制粘贴到别的我不想

26
00:01:41,180 --> 00:01:45,247
签字的文件上。所以在数字世界中，

27
00:01:45,247 --> 00:01:49,590
我的签名对我想签的所有
不同文件不可能一样。本门课的

28
00:01:49,590 --> 00:01:53,830
后半部分我们将讨论如何构建数字签名

29
00:01:53,830 --> 00:01:58,123
这是一个很有趣的部件，
我们将确切地看到如何去做。

30
00:01:58,123 --> 00:02:02,098
提示你一下，数字签名基本上就是

31
00:02:02,098 --> 00:02:06,232
待签内容的一个函数值，
因此，一个攻击者

32
00:02:06,232 --> 00:02:10,313
想要复制我的签名到其他文件上将无法成功

34
00:02:10,313 --> 00:02:14,541
因为，数字签名，
新文件与旧文件的函数值不一致

35
00:02:14,541 --> 00:02:18,526
所以签名验证失败，就像我说过的

36
00:02:18,526 --> 00:02:22,608
稍后我们将确切地看到如何构建数字签名构造

37
00:02:22,608 --> 00:02:27,193
并且我们会证明这些构造是安全的。
我想说的密码学的

38
00:02:27,193 --> 00:02:31,096
另一个应用是匿名通信，想象一下

39
00:02:31,096 --> 00:02:35,828
用户Alice想和某个聊天服务器
Bob说话，也许她想谈论病情

40
00:02:35,828 --> 00:02:40,382
所以她想匿名，从而聊天服务器

41
00:02:40,382 --> 00:02:45,113
并不知道她是谁。有一个标准方法叫

42
00:02:45,113 --> 00:02:49,946
mixnet，可以允许Alice
通过公共互联网与Bob通信

43
00:02:49,946 --> 00:02:54,856
经过一系列代理，
最终让Bob无从得知对方身份

44
00:02:54,856 --> 00:02:59,537
mixnet的工作原理基本上是，
当Alice给Bob发出信息

45
00:02:59,537 --> 00:03:03,818
经过一系列代理时，
信息被适当地加密 解密

46
00:03:03,818 --> 00:03:08,271
以至于Bob不知道通信对方身份而且代理们

47
00:03:08,271 --> 00:03:12,724
也不知道Alice在和Bob通信，
或者压根不知道

48
00:03:12,724 --> 00:03:16,750
谁在和谁通信。
匿名通信的一个有趣事实是

49
00:03:16,750 --> 00:03:20,498
它是双向的，换句话说

50
00:03:20,498 --> 00:03:24,743
尽管Bob不知道他在跟谁说话，
他依然可以回应Alice

51
00:03:24,743 --> 00:03:29,153
Alice可以收到回复。
一旦我们有了匿名通信

52
00:03:29,153 --> 00:03:33,784
我们可以建立其他隐私机制。
我想为大家举个叫匿名

53
00:03:33,784 --> 00:03:37,643
数字现金的例子。
在现实中如果我有一美元

54
00:03:37,643 --> 00:03:42,108
我可以去书店买本书，
书店老板并不知道我是谁

55
00:03:42,108 --> 00:03:46,876
问题在于我们能不能做同样的事情在数字世界里

56
00:03:46,876 --> 00:03:50,963
在数字世界里，
Alice可以有一个数字美元

57
00:03:50,963 --> 00:03:55,984
一个数字美元硬币。
她可能想在网上购物花掉这一美元

58
00:03:55,984 --> 00:04:00,760
比如网上书店之类。
现在我们要让Alice

59
00:04:00,760 --> 00:04:05,539
在书店花掉这块硬币，
而书店不知道

60
00:04:05,539 --> 00:04:10,629
Alice是谁。这样我们提供了与现实一样的匿名

61
00:04:10,629 --> 00:04:15,470
问题是在数字世界里，Alice使用的硬币

62
00:04:15,470 --> 00:04:20,250
她可以在花掉之前复制该硬币

63
00:04:20,250 --> 00:04:24,086
突然间这不是一美元硬币了

64
00:04:24,093 --> 00:04:27,936
她突然间就有了三美元硬币，它们当然是一样的

65
00:04:27,936 --> 00:04:31,828
没什么能阻止她复制硬币并花掉它。

66
00:04:31,828 --> 00:04:35,819
那问题就是，我们该如何提供匿名数字现金

67
00:04:35,819 --> 00:04:39,849
同时还要防止Alice重复花费

68
00:04:39,849 --> 00:04:43,760
购买不同的商品。
在某些情况下这里有矛盾

69
00:04:43,760 --> 00:04:47,879
安全和匿名是相悖的，因为我们有匿名现金

70
00:04:47,879 --> 00:04:51,999
将没有什么能阻止Alice重复花费

71
00:04:51,999 --> 00:04:56,244
因为硬币是匿名的，
我们无法找到诈骗者。

72
00:04:56,244 --> 00:05:00,394
那我们如何解决该问题呢？
事实上，这一问题是完全可以解决的

73
00:05:00,394 --> 00:05:04,757
我们以后将会再次讨论到匿名数字现金。
给大家点提示

74
00:05:04,757 --> 00:05:09,173
我们的基本方法是确保
当Alice只花费一次时

75
00:05:09,173 --> 00:05:13,764
没人知道她是谁。
但如果她花费多于一次

76
00:05:13,764 --> 00:05:17,878
她的个人信息将会突然全部暴露

77
00:05:17,878 --> 00:05:22,096
她将面临各种法律问题。
那就是匿名现金

78
00:05:22,096 --> 00:05:26,158
从高层次来说如何工作的。
本课稍后将介绍如何实现它。

79
00:05:26,158 --> 00:05:30,219
密码学的另一应用是各种抽象的协议

80
00:05:30,219 --> 00:05:34,333
不过在我说一般结果之前，我想给大家看两个例子

81
00:05:34,333 --> 00:05:38,343
第一个例子与选举系统有关。
这有个选举的问题

82
00:05:38,343 --> 00:05:42,656
假设有两个党派，0和1，供选民投票

83
00:05:42,656 --> 00:05:47,101
比如说，这个选民投给了0，
那个投给了1，等等

84
00:05:47,101 --> 00:05:52,313
在本次选举中，0得三票，1得二票

85
00:05:52,313 --> 00:05:56,590
0当然是本次选举的获胜者

86
00:05:56,590 --> 00:06:01,579
一般的，胜者是获得多数票的一方

87
00:06:01,579 --> 00:06:06,453
现在，投票的问题如下，投票者

88
00:06:06,453 --> 00:06:11,720
可能会计算多数投票结果，
不过却不知道

89
00:06:11,720 --> 00:06:16,797
每个人的投票结果。
明白了吗？那么问题来了，要怎么实现它?

90
00:06:16,797 --> 00:06:21,493
为此我们引入了一个选举中心

91
00:06:21,493 --> 00:06:26,633
用来帮我们计算大多数票，
但投票结果保密

92
00:06:26,633 --> 00:06:32,027
各派将把他们的投票加密后送给选举中心

93
00:06:32,027 --> 00:06:36,949
投票结束时，
选举中心可以计算出胜者

94
00:06:36,949 --> 00:06:41,615
但除了选举胜者之外

95
00:06:41,615 --> 00:06:46,580
各个投票结果却无从知晓

96
00:06:46,580 --> 00:06:51,366
当然，个人投票结果也是完全私密的，
选举中心还要验证

97
00:06:51,366 --> 00:06:56,331
投票者是否能投票以及保证只能投一次

98
00:06:56,331 --> 00:07:00,818
除了这些信息，选举中心及其他人

99
00:07:00,818 --> 00:07:05,484
无从知晓各个投票人的选择。

100
00:07:05,484 --> 00:07:10,104
而只能知道最终选举结果。
所以这是一个涉及六方协议的例子

101
00:07:10,104 --> 00:07:14,430
在这个情况下，有五个投票者在一个选举中心

102
00:07:14,430 --> 00:07:19,417
参与者计算他们自己的投票结果，最后选举的结果可以得出

103
00:07:19,417 --> 00:07:24,404
不过个人投票决定是不被泄露的。

104
00:07:24,404 --> 00:07:29,156
对于私密的拍卖也有类似问题

105
00:07:29,156 --> 00:07:34,160
在私密拍卖中每个买家都有自己愿意出的标价

106
00:07:34,160 --> 00:07:39,356
假设拍卖机制使用的是Vickrey拍卖

107
00:07:39,356 --> 00:07:45,287
Vickrey拍卖的中标者为出价最高者

108
00:07:45,287 --> 00:07:50,099
但中标者付的钱为第二高的出价

109
00:07:50,099 --> 00:07:54,850
他付第二高的出价，
这就是Vickrey拍卖机制

110
00:07:54,850 --> 00:08:00,028
现在我们想做的是让参与者能计算

111
00:08:00,028 --> 00:08:04,779
算出最高出价者和该付的钱

112
00:08:04,779 --> 00:08:09,165
但除了这些，
所有其他关于个人投票的信息保密

113
00:08:09,165 --> 00:08:14,160
例如，最高出价者的数额保密

114
00:08:14,160 --> 00:08:19,225
为公众所知的只有第二高价的数额

115
00:08:19,225 --> 00:08:23,526
和出最高价者是谁。
又一次的，我们现在需要

116
00:08:23,526 --> 00:08:28,172
引入拍卖中心，类似于选举中心，

117
00:08:28,172 --> 00:08:32,588
每个人都会把其加密的投标送给拍卖中心

118
00:08:32,588 --> 00:08:37,119
拍卖中心会计算中标者是谁，以及第二高价

119
00:08:37,119 --> 00:08:41,822
不过除了这些，个人标价不会被泄露

120
00:08:41,822 --> 00:08:46,126
这其实是一个更广泛的问题

121
00:08:46,126 --> 00:08:50,264
叫做安全多方计算。
让我解释一下安全多方计算是什么。

122
00:08:50,264 --> 00:08:54,618
进行基本抽象，
参与者自己有一个秘密输入

123
00:08:54,618 --> 00:08:58,649
在选举中，输入将是投票

124
00:08:58,649 --> 00:09:02,787
在拍卖中，输入将是秘密投标

125
00:09:02,787 --> 00:09:06,959
然后他们想计算一个关于这些输入的函数

126
00:09:06,959 --> 00:09:10,840
再次的，在选举中，函数为最高票数。

127
00:09:10,840 --> 00:09:15,088
在拍卖中，函数为第二高价。
即X1到X4的最大值

128
00:09:15,088 --> 00:09:19,179
问题是，怎么办才能得知函数值

129
00:09:19,179 --> 00:09:23,375
而同时个人投票信息保密呢？

130
00:09:23,375 --> 00:09:27,675
我来展示一个愚蠢且不安全的方法。
我们引入一个可信赖方

131
00:09:27,675 --> 00:09:31,774
这个可信赖方收集个人输入

132
00:09:31,774 --> 00:09:36,223
它保证不泄露个人输入

133
00:09:36,223 --> 00:09:40,510
它自己是知道的。
然后，可信赖方公开发布函数结果

134
00:09:40,510 --> 00:09:44,742
这一目的是，仅公开函数值

135
00:09:44,742 --> 00:09:48,812
而不泄露个人信息

136
00:09:48,812 --> 00:09:52,990
当然，你是信任这个可信赖方的，
若出于某些原因，

137
00:09:52,990 --> 00:09:57,168
它不可信了，你就有麻烦了。
密码学有一个非常核心的定理

138
00:09:57,168 --> 00:10:01,001
揭示了一个非常惊人的事实。
定理说

139
00:10:01,001 --> 00:10:05,204
任何你想做的计算，任何函数F

140
00:10:05,204 --> 00:10:09,302
只要你能用可信任方计算，
一定也可以不借助可信任方来完成

141
00:10:09,302 --> 00:10:13,559
让我从较高的层次来解释下，
基本上，我们想做的

142
00:10:13,559 --> 00:10:17,816
就是去掉可信任方。
这样各方不会把他们的输入

143
00:10:17,816 --> 00:10:21,807
给可信任方。事实上系统中没有可信任方了

144
00:10:21,807 --> 00:10:26,011
取而代之的是，各参与者使用

145
00:10:26,011 --> 00:10:30,567
某些协议互相通信。在协议的最后

146
00:10:30,567 --> 00:10:34,890
大家将突然知道函数值是什么。

147
00:10:34,890 --> 00:10:39,390
除此之外无任何信息泄露，换句话说，

148
00:10:39,390 --> 00:10:43,639
个人投票依然保密。
没有可信任方

149
00:10:43,639 --> 00:10:47,867
各方相互交流就可以算出最终结果

150
00:10:47,867 --> 00:10:51,846
这是一个很普遍的结论。
其具有惊人的普适性

151
00:10:51,846 --> 00:10:56,024
事实上，在本课的最后，我们将看到

152
00:10:56,024 --> 00:11:00,577
这将如何实现。

153
00:11:00,577 --> 00:11:05,560
密码学还有些应用我无法分类，
只能说他们很神奇

154
00:11:05,560 --> 00:11:10,240
我给两个例子。
第一个叫私有外包计算

155
00:11:10,240 --> 00:11:15,224
为了说明这一点，
我举一个谷歌搜索的例子

156
00:11:15,224 --> 00:11:20,329
假设Alice有一个搜索请求

157
00:11:20,329 --> 00:11:25,434
事实上这有一个
很特殊的加密机制，可以

158
00:11:25,434 --> 00:11:30,368
把Alice的请求加密后交给谷歌。
由于加密机制的特性

159
00:11:30,368 --> 00:11:35,304
谷歌可以在加密后的值上直接运算，
而无需知道原文是什么

160
00:11:35,304 --> 00:11:40,368
所以谷歌可以在加密的请求上，
直接运行庞大的搜索算法

161
00:11:40,368 --> 00:11:44,903
来得到加密的结果。好，谷歌将加密后的结果

162
00:11:44,903 --> 00:11:49,242
返回给Alice。她解密后就会得到搜索结果了

163
00:11:49,242 --> 00:11:53,689
神奇之处在于谷歌
只能看到请求的加密形式，别无他物

164
00:11:53,689 --> 00:11:57,493
所以谷歌不知道Alice刚才搜索什么

165
00:11:57,493 --> 00:12:01,672
尽管Alice知道了她想要的东西

166
00:12:01,672 --> 00:12:05,812
好，这些是加密机制中很神奇的内容

167
00:12:05,812 --> 00:12:09,985
它们相对较新，只有两三年的发展历史

168
00:12:09,985 --> 00:12:14,436
这允许加密数据上的计算，
尽管我们不知道加密的内容

169
00:12:14,436 --> 00:12:18,667
在大家急着去想怎么实现这个之前

170
00:12:18,667 --> 00:12:22,470
我应当警告大家目前这只是理论结果

171
00:12:22,470 --> 00:12:26,422
也就是说基于加密数据的谷歌搜索

172
00:12:26,422 --> 00:12:30,521
很可能会花上亿年，
不过这个可行的事实已经很惊人了

173
00:12:30,521 --> 00:12:34,473
对于相对简单的计算也已经有应用了。

174
00:12:34,473 --> 00:12:38,671
事实上我们稍后会看到这个的一些应用。
另一个神奇的应用

175
00:12:38,671 --> 00:12:42,474
我将展示的叫做零知识。特别的，我将

176
00:12:42,474 --> 00:12:46,080
告诉大家有关知识的零知识的证明。

177
00:12:46,080 --> 00:12:50,177
这里，Alice知道一个特定的数N

178
00:12:50,177 --> 00:12:54,169
数N为两个大素数的积

179
00:12:54,169 --> 00:12:58,835
假设我们有两个素数P和Q，
每个你可以认为有1000位

180
00:12:58,835 --> 00:13:03,892
你可能知道乘两个1000位的数是容易的

181
00:13:03,892 --> 00:13:08,235
但如果给定乘积，求素数分解

182
00:13:08,235 --> 00:13:12,427
将会非常困难。
事实上，我们将利用这一事实

183
00:13:12,427 --> 00:13:16,566
用因子分解的困难性建立公钥密码系统，
这将在本课后半段介绍。

184
00:13:16,566 --> 00:13:20,968
好，那么Alice有大整数N，她知道N的因子分解

185
00:13:20,968 --> 00:13:24,898
Bob只知道数N，他不知道N的因子分解

186
00:13:24,898 --> 00:13:28,723
零知识证明的神奇之处在于

187
00:13:28,723 --> 00:13:33,144
Alice能向Bob证明她知道N的因子分解

188
00:13:33,144 --> 00:13:37,457
是的，你可以把这个证明给Bob，
Bob检查后确信Alice知道如何分解。

189
00:13:37,457 --> 00:13:42,386
但是，Bob不知道因子P和Q

190
00:13:42,386 --> 00:13:47,034
这是可证明的。
Bob完全不知道P和Q两个因子

191
00:13:47,034 --> 00:13:50,997
这个论断实际上很广泛

192
00:13:50,997 --> 00:13:55,275
它不仅仅是证明N的因子分解，
事实上有很多谜题

193
00:13:55,275 --> 00:13:59,606
你希望证明你知道答案，
你可以证明它是你的知识

194
00:13:59,606 --> 00:14:03,831
如果你解决了一个填字游戏，
哦可能填字游戏不是最好的例子

195
00:14:03,831 --> 00:14:07,845
如果你有一个数独谜题，例如

196
00:14:07,845 --> 00:14:12,282
你想证明你已经解决了，
你可以向Bob证明

197
00:14:12,282 --> 00:14:16,718
Bob不知道怎么解，
但Bob会相信

198
00:14:16,718 --> 00:14:20,930
你是知道数独的解的。
好的，这是一些很神奇的应用。

199
00:14:20,930 --> 00:14:25,000
最后我想说的是，现代密码学

200
00:14:25,000 --> 00:14:29,015
是很严格的科学。
事实上我们描述的每一个概念

201
00:14:29,015 --> 00:14:33,129
都依照非常严格的三个步骤，
我们将反复利用到这三步

202
00:14:33,129 --> 00:14:37,338
我想解释一下他们是什么。第一

203
00:14:37,338 --> 00:14:41,493
是当我们引入新的部件时，
例如数字签名

204
00:14:41,493 --> 00:14:45,540
我们要准确描述威胁模型是什么

205
00:14:45,540 --> 00:14:49,534
就是说攻击者如何攻击数字签名，
他伪造签名的目的何在？

206
00:14:49,534 --> 00:14:53,851
好了，我们将严格定义签名的含义

207
00:14:53,851 --> 00:14:57,760
例如，用于不可伪造。
不可伪造。好的

208
00:14:57,760 --> 00:15:01,998
我拿数字签名作为一个例子，
对每个我们描述的部件

209
00:15:01,998 --> 00:15:06,464
准确定义威胁模型，然后我们要提出构架

210
00:15:06,464 --> 00:15:10,931
证明任何攻击者对安全架构的攻击

211
00:15:10,931 --> 00:15:15,955
都在这一威胁模型中，
这个攻击者可以用一些方法

212
00:15:15,955 --> 00:15:20,150
来破解这一安全架构
如果这一安全架构真的很难被破解

213
00:15:20,150 --> 00:15:24,350
实际上就证明了攻击者无法在威胁模型下，
破解这个构架。

214
00:15:24,350 --> 00:15:27,843
所以这三步真的非常重要

215
00:15:27,843 --> 00:15:31,928
对于签名，我们会定义签名可伪造的含义

216
00:15:31,928 --> 00:15:35,914
然后我们给一个构架，
例如我们会说任何人若能破解我们

217
00:15:35,914 --> 00:15:39,801
的构架，他也可以用他破解的方法
来解决因子分解问题

218
00:15:39,801 --> 00:15:43,541
而后者是公认的难题。
好的，我们将通篇遵循这三步

219
00:15:43,541 --> 00:15:47,331
大家将看到这个实际上是如何发生的。
好，本节结束

220
00:15:47,331 --> 00:15:51,218
下一节我们要简要

221
00:15:51,218 --> 00:15:52,006
谈一下密码学的历史。【END】