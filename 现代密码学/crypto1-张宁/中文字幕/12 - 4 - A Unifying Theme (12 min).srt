1
00:00:00,000 --> 00:00:04,076
这周，我们看了两个公钥密码系统的体系。其中一个使用陷门函数构建，

2
00:00:04,076 --> 00:00:08,204
一般称为RSA，而另一个体系构建于

3
00:00:08,204 --> 00:00:12,078
Diffie-Hellman协议，在这最后一个章节，我希望向你展示

4
00:00:12,078 --> 00:00:16,065
这两个体系都遵循与一个更普遍的原则，这一统一的原则

5
00:00:16,065 --> 00:00:20,671
就是我们所谓的单向函数。那么什么是单向函数？

6
00:00:20,671 --> 00:00:24,995
我们在前面已经简要的研究过这一概念了，
基本上，一个函数，从一个到另一个，

7
00:00:24,995 --> 00:00:29,376
从 X 到 Y 就被称为单向，事实上，这儿有一个

8
00:00:29,376 --> 00:00:33,813
有效的算法让我们可以求出函数 F ，因此任何人可以

9
00:00:33,813 --> 00:00:38,306
对他选定的函数 F 求值，然而，转化的函数 F 需要是不同的。

10
00:00:38,306 --> 00:00:42,406
这使得函数是单向的，那么我想说的是什么？

11
00:00:42,406 --> 00:00:47,068
当然，你可以认为函数 F 是一个函数重新映射，

12
00:00:47,068 --> 00:00:52,165
使 X 到 Y 。但是现在每一个点 X 只能单向映射

13
00:00:52,165 --> 00:00:57,228
一个单独的点到Y。现在，他们说这个函数是很难被转化的。

14
00:00:57,228 --> 00:01:02,347
我想说的是，当我给你一些在 Y 中的点，然后我让你

15
00:01:02,347 --> 00:01:07,530
寻找这些点的原像，你很难找到这些的原像。

16
00:01:07,530 --> 00:01:12,838
换句话说，没有一个有效的算法可以找到所给点Y的原像。

17
00:01:12,838 --> 00:01:17,958
现在我们可以精确得说，我们说对所有

18
00:01:17,958 --> 00:01:23,203
有效的算法 A ，如果我随机选择一个集合 X ，现在我希望

19
00:01:23,203 --> 00:01:28,839
给一个 f(X)到算法 A ，然后，我想让算法 A 做的是，

20
00:01:28,839 --> 00:01:34,774
基本上能够产生一个 f(x) 的原像，那么，

21
00:01:34,774 --> 00:01:41,030
算法 A 产生一个 f(x) 的原像意味着什么？
这意味着如果我应用函数 f 来

22
00:01:41,030 --> 00:01:47,180
使 A 输出，我想要得到的是 f(x)的原像。让我们多思考一下。

23
00:01:47,180 --> 00:01:52,428
因此我随机选择一个点x，在集合X中，你知道的我给算法A了f(x)

24
00:01:52,428 --> 00:01:57,486
我将会给算法A一个点，现在 A 将要生成一些点。

25
00:01:57,486 --> 00:02:02,291
所以假装 A 产生的点在这里。现在，

26
00:02:02,291 --> 00:02:07,349
我想说的是，如果我应用函数 F 在这些 A 生成的点，

27
00:02:07,349 --> 00:02:12,471
我将可能得到一些相同的点，我初始的点可以被忽略，

28
00:02:12,471 --> 00:02:17,558
换句话说，算法 A 产生这些三个点的可能性，

29
00:02:17,558 --> 00:02:23,203
事实上，是可以被忽略的，所有它可以做的是生成一些其他的点，

30
00:02:23,203 --> 00:02:28,440
而不是映射到f(x)，对吗？所以，这些努力说明，

31
00:02:28,440 --> 00:02:33,814
给定 f(x) ，很难找都一些它的原像。

32
00:02:33,814 --> 00:02:38,119
所以这里有一些简单的函数，不是单向的。例如，

33
00:02:38,119 --> 00:02:42,955
一致性函数 f(x) 等于 x 就是一个普通的非单向函数。

34
00:02:42,955 --> 00:02:47,850
因为给定 f(x) 我可以简单得得到一个 f(x)的变形，叫做 x ，

35
00:02:47,850 --> 00:02:52,449
类似的，一个所有映射都是0的函数也是非单向的。所以，在我们的课程中

36
00:02:52,449 --> 00:02:57,167
让函数的所有映射都是0，简单得可以看作如下的函数，

37
00:02:57,167 --> 00:03:02,133
它获得所有这些点然后把他们映射到单个点上，所以这个函数是非单向的，

38
00:03:02,133 --> 00:03:07,324
因为如果我给你一个点，它非常容易找到它的原像。

39
00:03:07,324 --> 00:03:12,579
仅仅简单得选取集合 X 中的点，这将得到原像0。

40
00:03:12,579 --> 00:03:17,185
因此 f(x) = 0 是一个非单向函数。因此，我不在这里过多讨论了，

41
00:03:17,185 --> 00:03:21,337
如果我要正式的定义单向函数，这将

42
00:03:21,337 --> 00:03:25,707
证明单向函数是存在的。我们也将证明P不等于NP

43
00:03:25,707 --> 00:03:29,805
因为我们不能在现在证明P不等于NP，

44
00:03:29,805 --> 00:03:34,230
基本上我们也不能证明单向函数存在，我们只能猜测他们存在。

45
00:03:34,230 --> 00:03:38,305
所以让我们看一个单向函数的例子，一个预先假设的单向函数。

46
00:03:38,305 --> 00:03:42,329
我们将要从一个伪随机函数生成器(PRG)构建它。

47
00:03:42,329 --> 00:03:46,559
假设我有一个函数 F 是 X 到 Y 的，这有一个安全的PRG。

48
00:03:46,559 --> 00:03:50,531
所以f的输出远大于输入，记住，一个PRG

49
00:03:50,531 --> 00:03:54,691
从一个很小的种子扩展出一个很大的输出。

50
00:03:54,691 --> 00:03:58,590
例如，你可以，PRG可以用

51
00:03:58,590 --> 00:04:02,806
AES的确定计数器模式来构建。这可以简单得看出

52
00:04:02,806 --> 00:04:06,541
F 是一个安全的 PRG ，然后 F 事实上是一个单向函数。

53
00:04:06,547 --> 00:04:10,604
所以我们的第一个单向函数的例子实际上构建于一个PRG。

54
00:04:10,604 --> 00:04:14,820
这是一个不充分的证明，让我们从反面证明。

55
00:04:14,820 --> 00:04:19,088
假设我有一个有效的算法可以对 F 转化 。

56
00:04:19,088 --> 00:04:22,963
我将从反面证明，假设 F 不是单向的。

57
00:04:22,963 --> 00:04:27,457
那么 A 就是一个有效的对 F 求逆的算法。现在我需要构建算法 B 。

58
00:04:27,457 --> 00:04:32,301
这个算法将打破PRG，现在我从反面证明，现在，我怎么打破PRG呢？

59
00:04:32,301 --> 00:04:38,500
我们只需要如下做法，给算法 B 一些集合 Y 中的点 y ，

60
00:04:38,500 --> 00:04:43,406
我们将期望如下结果，

61
00:04:43,406 --> 00:04:47,608
尝试对算法 A 输入 y ，现在，如果 y 是PRG的输出。

62
00:04:47,608 --> 00:04:52,109
则算法 A 将输出种子，也就是

63
00:04:52,109 --> 00:04:56,861
集合 X 的元素，你知道的，不可忽略的可能性。

64
00:04:56,861 --> 00:05:02,112
所以，我们需要做的是再次对算法 A 应用 PRG

65
00:05:02,112 --> 00:05:06,989
正如我所说的，如果 y 是生成器的输出，则算法 A 将会输出

66
00:05:06,989 --> 00:05:12,240
PRG的种子，所以如果我们再次对 PRG 应用

67
00:05:12,240 --> 00:05:17,429
算法 A 的输出，我们得到的基本是我们初始使用的 y

68
00:05:17,429 --> 00:05:23,012
所以，如果这个情况得到了我们期望的，

69
00:05:23,012 --> 00:05:28,090
就说我们期望输出0，如果没有，我们则期望输出1

70
00:05:28,090 --> 00:05:32,955
这就是说，我们的能够区分出了PRG

71
00:05:32,955 --> 00:05:37,383
如果我们得到一个PRG的输出 y 来进行区分

72
00:05:37,383 --> 00:05:41,755
然后以一个不可忽略的概率，我们的区分算法 B 将输出0

73
00:05:41,755 --> 00:05:46,238
然而，如果我们的区分算法 B 得到了一个随机的输入串。

74
00:05:46,238 --> 00:05:50,832
一个随机的输出串不会有一个种子，这将使生成器输出这个串。

75
00:05:50,832 --> 00:05:56,410
那么，再次的，我们的区分器输出1，以一个很高的概率。

76
00:05:56,410 --> 00:06:01,291
再次的，我期望准确的，基本上，如果我们看

77
00:06:01,291 --> 00:06:06,129
所有集合的可能的输出，就是说集合Y，只有很小一部分的输出

78
00:06:06,129 --> 00:06:10,370
来自PRG，所以如果我们给

79
00:06:10,370 --> 00:06:15,088
一个随便的输出 y，而不是PRG的输出，

80
00:06:15,088 --> 00:06:19,687
然后我们返回算法 A ，这就不可能产生一个种子

81
00:06:19,687 --> 00:06:24,227
来输出这一点因为没有这样的种子，结果是，

82
00:06:24,227 --> 00:06:28,945
大部分的点都不在PRG的输出范围里，

83
00:06:28,945 --> 00:06:33,462
大部分的点都没有相应的种子，来映射到生成器，

84
00:06:33,462 --> 00:06:38,130
用我们给出的一个随机的Y的点。

85
00:06:38,130 --> 00:06:42,011
我们的区分算法 B 将会以一个高的概率输出1，然而

86
00:06:42,011 --> 00:06:46,679
如果我们给一个生成器的伪随机输出，然后算法 A 将会返回一个种子

87
00:06:46,679 --> 00:06:51,235
当我们对生成器应用这个种子之后，我们将会得到初始输出 y 

88
00:06:51,235 --> 00:06:55,356
因此我们将会以一个不可忽略的概率输出0

89
00:06:55,356 --> 00:06:59,546
好的，如果 A 来转化 F ,之后 B 将尝试破花生成器。

90
00:06:59,546 --> 00:07:04,024
要是生成器是安全的，算法 A 将不能转化 F ，特别的，

91
00:07:04,024 --> 00:07:08,559
没有有效的算法能转化 F ，因此，F 是一个单向函数，

92
00:07:08,559 --> 00:07:12,788
太好了，这是一个对于细小要点的很长的讨论，但是我想要向你展示，

93
00:07:12,788 --> 00:07:16,562
事实上，一个 PRG 直接给了我们一个单向函数。

94
00:07:16,562 --> 00:07:20,633
不幸的是，这个单向函数没有任何特殊性质，这意味着

95
00:07:20,633 --> 00:07:24,754
这很难用于密钥交换或是公钥加密。

96
00:07:24,754 --> 00:07:28,578
在某种意义上来说，我们可以用这个构造一个很好的密钥交换，

97
00:07:28,726 --> 00:07:32,868
正如我们所知的，就是 Merkle 谜题。接下来，让我们看第二个例子。

98
00:07:32,868 --> 00:07:37,200
我想说的第二个例子是离散对数单向函数。让我们建立一个组，

99
00:07:37,200 --> 00:07:41,971
一个序数N的循环组G，使G是一个生成器，

100
00:07:41,971 --> 00:07:46,987
让我再一次提醒你，如果我查看所有g的乘方

101
00:07:46,987 --> 00:07:51,335
我基本上测试了集合G的值，让我们定义

102
00:07:51,335 --> 00:07:56,068
接下来的函数，这个函数G从Z到N，

103
00:07:56,068 --> 00:08:00,802
这个定义基本上是对X的乘方求幂，好的，这个映射了一些[0, n-1]中的元素

104
00:08:00,802 --> 00:08:04,915
到集合G中的元素，通过简单得求g，小g是适当的乘方。

105
00:08:04,915 --> 00:08:09,197
显而易见的如果离散对数问题

106
00:08:09,197 --> 00:08:13,310
对于集合G是困难的，则事实上 f 是单向的。事实上，

107
00:08:13,310 --> 00:08:17,134
f 的单向是离散对数猜想，所以如果离散对数是困难的，

108
00:08:17,134 --> 00:08:21,324
f 就是单向的，现在，一个关于这个单向函数的有趣事实是

109
00:08:21,324 --> 00:08:25,800
它有一些有趣的性质。特别的，如果我给你 f(x) 和 f(y)

110
00:08:25,800 --> 00:08:31,119
我强调计算 f(x+y) 是很简单的，即使我们

111
00:08:31,119 --> 00:08:36,118
并不知道 x 和 y 是什么。我们得到的知识 f(x) 和 f(y)，然而，我们可以

112
00:08:36,118 --> 00:08:41,763
计算 f(x+y)，让我问你，你该怎么做？

113
00:08:41,763 --> 00:08:46,732
仅仅需要遵循求幂，基本上，f(x+y) 是简单的 f(x) 的 f(y) 次方，

114
00:08:46,732 --> 00:08:51,826
再次的，这些全部在集合 G 中，如果你不相信，只需要简单地

115
00:08:51,826 --> 00:08:57,046
调用 f(x+y) 是g，则在这里我们有g的x次方g的y次方。

116
00:08:57,046 --> 00:09:02,161
这个简单得性质，事实上，

117
00:09:02,161 --> 00:09:06,936
这个函数具有这以加法性质，如果你思考一下，事实上，

118
00:09:06,936 --> 00:09:11,722
这使得可以进行密钥交换和公钥加密，所以，这个

119
00:09:11,722 --> 00:09:16,602
单向函数的加法性质可用于任何公钥加密中。

120
00:09:16,602 --> 00:09:21,723
让我们看看我们的下一个例子，RSA单向函数，

121
00:09:21,723 --> 00:09:27,093
这里我们先选择两个质数p和q，我们设置N是p的q次方，然后我们选择e

122
00:09:27,093 --> 00:09:31,612
与质数相联系到phi(N)，之后我们定义函数，

123
00:09:31,612 --> 00:09:36,156
简单得相当于ZN到ZN，就像是f(x)等于x到e

124
00:09:36,156 --> 00:09:40,312
现在，提升x到e的乘方，再次的，我们看到这个函数是单向的，

125
00:09:40,312 --> 00:09:44,575
在RSA的猜想下。再次的，RSA猜想是假定

126
00:09:44,575 --> 00:09:48,519
函数是单向的，一个有趣的事实是，这个函数

127
00:09:48,519 --> 00:09:52,941
的性质与我们前面的很相似，

128
00:09:52,941 --> 00:09:57,258
给出 f(x) 和 f(y) ，现在我们可以计算 f(x y)，相反于f(x+y)

129
00:09:57,258 --> 00:10:01,627
所以我们看到这个函数具有一个乘法的性质，

130
00:10:01,627 --> 00:10:05,438
与我们前面的加法性质相反，但是重要的是这个

131
00:10:05,438 --> 00:10:09,213
性质对于这个函数来说不是那么有趣。事实上是

132
00:10:09,213 --> 00:10:12,708
这个函数具有一个陷门，换句话说这里有一个

133
00:10:12,708 --> 00:10:16,505
秘密的钥匙突然允许我们转化这个函数，

134
00:10:16,505 --> 00:10:20,679
要是没有这个秘密的钥匙，这个函数是一个单向的。

135
00:10:20,679 --> 00:10:24,337
正如我们所知的，这个性质，我们说具有一个陷门，允许任意公钥加密。

136
00:10:24,337 --> 00:10:28,632
我想说，这个陷门也使得RSA函数

137
00:10:28,632 --> 00:10:32,820
特别适合数字签名，在第七周，我们将会看到

138
00:10:32,820 --> 00:10:36,478
所有RSA函数和离散对数函数，让我们构建数字签名。

139
00:10:36,478 --> 00:10:40,614
但是RSA函数，因为具有陷门，使得它很适于

140
00:10:40,614 --> 00:10:44,484
构建数字签名，事实上，

141
00:10:44,484 --> 00:10:48,301
很多数字签名，依赖于RSA函数，

142
00:10:48,301 --> 00:10:52,459
仅仅因为它可以简单得构造数字签名，再次的，

143
00:10:52,459 --> 00:10:56,085
我们看到了单向函数的特殊性质，它具有乘法性质

144
00:10:56,085 --> 00:10:59,859
和一个陷门，必要的是，允许公钥加密。

145
00:10:59,859 --> 00:11:03,682
所以总结来说，我们构建公钥加密的原因，

146
00:11:03,682 --> 00:11:07,416
我们应用密钥交换和公钥加密的原因，

147
00:11:07,416 --> 00:11:11,485
是我们构建的单向函数具有十分特殊的性质

148
00:11:11,485 --> 00:11:15,555
特别的，它们所具有的这些性质，常被称为

149
00:11:15,555 --> 00:11:20,476
同型性质，所谓的给出 f(x) 和 f(y)，我们可以

150
00:11:20,476 --> 00:11:26,759
构造 f(x+y) 或是 f(x y)，一些函数，像是RSA，即使具有陷门，

151
00:11:26,759 --> 00:11:32,059
使得我们可以方便得构建数字签名，但是

152
00:11:32,059 --> 00:11:36,283
我想向你展示的主要的事情是，这个神奇的，通过

153
00:11:36,283 --> 00:11:40,250
特殊性质的单向函数构建公钥加密，

154
00:11:40,250 --> 00:11:44,268
所以，让我们结束这一个模块，在第七周，我们将开始数字签名。【END】
