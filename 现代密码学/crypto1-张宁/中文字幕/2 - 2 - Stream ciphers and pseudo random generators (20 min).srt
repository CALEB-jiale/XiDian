 1
00:00:00,000 --> 00:00:04,524
既然我们已经了解了一次一密，
现在来讨论如何利用流密码

2
00:00:04,524 --> 00:00:08,881
来使一次一密变得更加实用。开始之前

3
00:00:08,881 --> 00:00:13,573
让我们快速回顾一下我们进行到哪了。
提醒一下大家，

4
00:00:13,573 --> 00:00:18,209
密码系统是定义在一个三元组上的,
即密钥空间,明文空间和密文的空间

5
00:00:18,209 --> 00:00:22,398
密码算法由一对高效的算法E和D组成

6
00:00:22,398 --> 00:00:27,086
E代表加密算法，D代表解密算法。
这里唯一需要满足的特性就是

7
00:00:27,086 --> 00:00:32,294
应当满足解密算法是加密算法的逆运算。

8
00:00:32,294 --> 00:00:36,954
换句话说，如果我用特定的密钥给消息m加密，
解密就得用相同的密钥来解密

9
00:00:36,954 --> 00:00:41,272
这样就来得到最初的消息m。
上节课我们看到一对弱密码机制

10
00:00:41,272 --> 00:00:45,591
例如代换密码和vigonaire密码。
我们可以看出它们都很容易

11
00:00:45,591 --> 00:00:49,650
被破解以至于你永远不应该用这些密码

12
00:00:49,650 --> 00:00:53,604
这些都是历史经验证明,现在我们来看第一个例子,
一个更优越的密码体制

13
00:00:53,604 --> 00:00:57,819
被称作“一次一密”,
让我再提醒一下一次一密是如何定义的

14
00:00:57,819 --> 00:01:01,877
首先明文空间是一连串的比特码

15
00:01:01,877 --> 00:01:05,892
密文是一组比特流。同样的，

16
00:01:05,892 --> 00:01:10,310
密钥是N位比特流，
并且加密方法是通过简单异或来加密明文。

17
00:01:10,310 --> 00:01:14,467
我们只用密钥与明文做异或就得到密文。

18
00:01:14,467 --> 00:01:18,990
之后对密文解密，只需用再一次做异或

19
00:01:18,990 --> 00:01:23,240
这很容易看出整个算法过程,
这就体现了解密是加密的逆运算

20
00:01:23,240 --> 00:01:27,380
现在我们讲一下这个定理。
实际上，我们证明了

21
00:01:27,380 --> 00:01:31,794
一次一密具有很好的保密性,
指的是如果你是一个窃听者

22
00:01:31,794 --> 00:01:35,935
且只有一个简单的密文，你将不可能

23
00:01:35,935 --> 00:01:40,332
推断出任何有关已经加密的文本的信息。
很不幸，我们也说过

24
00:01:40,332 --> 00:01:44,648
香农证明了这个定理。
我们称它为坏消息定理，它实际在说

25
00:01:44,648 --> 00:01:48,751
任何一个密码，要想要完全保密必须要有很长的密钥。
换句话说

26
00:01:48,751 --> 00:01:53,067
密钥的长度至少和明文的长度一样

27
00:01:53,067 --> 00:01:57,490
也就意味着这种密码体制不是很实用。
因为如果双方

28
00:01:57,490 --> 00:02:01,753
同意密钥的长度和明文一样长，在某种程度上

29
00:02:01,753 --> 00:02:05,931
他们可能早已用这种机制传送消息本身了。
所以在这堂课上

30
00:02:05,931 --> 00:02:10,538
我们将再次使用一次一密的思想，
并改进它使其成为实用的密码

31
00:02:10,538 --> 00:02:15,031
所以，这就是所谓的流密码

32
00:02:15,031 --> 00:02:20,999
在流密码中，并不用随机密钥

33
00:02:20,999 --> 00:02:26,346
实际我们用的是伪随机序列。
为了解释它如何工作

34
00:02:26,346 --> 00:02:31,544
我需要定义什么是伪随机生成器(PRG)。PRG实际上就是

35
00:02:31,544 --> 00:02:37,337
一个种子生成函数,
我用g来表示种子生成器

36
00:02:37,337 --> 00:02:43,277
我们用{0,1}集合的s次方来表示长度为s的比特串

37
00:02:43,277 --> 00:02:48,729
这个我们称这个集合为种子空间,他将s比特的种子转化成一个更长的比特串，

38
00:02:48,729 --> 00:02:53,978
该串的长度用{0,1}的n次方来表示。
必须满足的性质是n比s大。

39
00:02:53,978 --> 00:02:59,161
换句话说我们输入种子密钥可能仅仅128比特

40
00:02:59,161 --> 00:03:04,345
之后我们把它扩展成更长，
可以达到千兆字节长度的输出串

41
00:03:04,345 --> 00:03:08,806
这就是伪随机生成器所做的。当然

42
00:03:08,806 --> 00:03:14,055
首要目标是发生器必须是高效可计算的

43
00:03:14,055 --> 00:03:19,248
所以对于函数g，应该是可以进行高效计算的。

44
00:03:19,248 --> 00:03:24,066
因此，必须用一个高效的算法来构建函数。

45
00:03:24,066 --> 00:03:29,250
函数g自身没有随机性,
理解这点是很重要的,它是确定性的。

46
00:03:29,250 --> 00:03:33,946
唯一具有随机性的是种子密钥

47
00:03:33,946 --> 00:03:38,703
它被作为函数g的输入。而函数的输出

48
00:03:38,703 --> 00:03:43,388
看起来是随机的。
问题是，看起来随机是什么意思。

49
00:03:43,388 --> 00:03:48,694
这我们将在后面的课程中给出定义，好，假设

50
00:03:48,694 --> 00:03:53,869
我们有一个发生器，那么我们怎样用它生成流密码

51
00:03:53,869 --> 00:03:59,503
我们的思路是用种子来作为密钥，
所以我们的短种子被作为秘密密钥，

52
00:03:59,503 --> 00:04:04,679
然后我们用生成器将种子密钥扩展

53
00:04:04,679 --> 00:04:09,723
成更长的类随机序列或者伪随机序列

54
00:04:09,723 --> 00:04:14,657
由已知,我们可以得到G(k),
之后用它进行异或就像

55
00:04:14,657 --> 00:04:19,185
在一次一密中那样。
我们用伪随机序列和明文做异或

56
00:04:19,185 --> 00:04:24,185
就得到了密文。如果我们想用数学语言来表达

57
00:04:24,185 --> 00:04:30,139
那么就用c代表信息经密钥k加密后的密文m，

58
00:04:30,139 --> 00:04:35,619
则c定义为m和G(k)的异或。
接下来我们要做解密,基本上就是

59
00:04:35,619 --> 00:04:41,234
在做同样的工作。用密文异或G(k),
就像在一次一密中那样，

60
00:04:41,234 --> 00:04:46,782
除了不是与K异或,而是我们用
生成器的输出与K进行异或运算

61
00:04:46,782 --> 00:04:52,148
所以第一个要问的问题是为什么这是安全的

62
00:04:52,148 --> 00:04:56,651
其实，到目前为止，
我们现在只有一个安全概念即完全保密

63
00:04:56,651 --> 00:05:01,552
所以让我们看看流密码是否具有完全保密性,

64
00:05:01,552 --> 00:05:06,132
记得，在流密码中,密钥长度远远比信息短,

65
00:05:06,132 --> 00:05:12,392
那么流密码是否具有完全保密性呢？
我希望每个人的回答是"不"

66
00:05:12,392 --> 00:05:17,198
密钥远远比明文的长度短。
而我们前面说过

67
00:05:17,198 --> 00:05:21,819
在完全保密体制中，
密钥必须和明文一样长。因此

68
00:05:21,819 --> 00:05:26,317
一个流密码要具有完全保密性是不可能的。

69
00:05:26,317 --> 00:05:30,774
所以问题是它为什么又是安全的呢？
首先我们需要对安全性给出一个不同的定义

70
00:05:30,774 --> 00:05:34,410
才能讨论流密码的安全性。 尤其是

71
00:05:34,410 --> 00:05:38,783
安全性取决于我们所使用的特定的生成器

72
00:05:38,783 --> 00:05:42,681
实际上，由流密码安全性所给出的私密性定义

73
00:05:42,681 --> 00:05:47,054
我们将在下一节课中给出。
现在让我给你们展示

74
00:05:47,054 --> 00:05:51,614
一个特殊的特性。那就是发生器
对于安全性的要求必须有一个最小限度

75
00:05:51,614 --> 00:05:56,510
这个特性被称为不可预测性,所以

76
00:05:56,510 --> 00:06:01,807
让我们暂时假设一个流密码是可预测的，

77
00:06:01,807 --> 00:06:07,172
那么这意味着什么？同样,
PRG也是可预测的,意思就是主要这里存在一个i值

78
00:06:07,172 --> 00:06:13,691
如果我给出输出的前i位，这个符号

79
00:06:13,691 --> 00:06:18,920
的意思是函数输出的前i个比特

80
00:06:18,920 --> 00:06:23,733
好的,我给你这个流密码的前i位。

81
00:06:23,733 --> 00:06:28,995
这里有一类可以计算剩余字串的有效算法

82
00:06:28,995 --> 00:06:34,193
所以我给你前i位,你可以计算出剩余的比特串

83
00:06:34,193 --> 00:06:39,392
如果是这种情况,流密码是不安全的。
让我们看看为什么

84
00:06:39,392 --> 00:06:44,205
假设一个攻击者拦截了一个特定的密文c

85
00:06:44,205 --> 00:06:49,511
如果是这样，那么我们有一个问题。

86
00:06:49,511 --> 00:06:55,514
因为假设根据之前获得的信息，
攻击者实际上知道的信息开头的部分

87
00:06:55,514 --> 00:07:01,298
刚好就是一些已知值,
例如，我们知道

88
00:07:01,298 --> 00:07:07,448
在一些邮件传输协议中，
比如smtp协议(标准邮件发送协议)

89
00:07:07,448 --> 00:07:12,860
每条信息都以冒号开始。
这是每一个敌手都知道的前缀

90
00:07:12,860 --> 00:07:18,169
对网站来说发送的信息必须以冒号开始

91
00:07:18,169 --> 00:07:23,677
网站能做就是它能够用冒号引出加密的密文

92
00:07:23,677 --> 00:07:29,053
用已知明文的一点前缀引出密文。

93
00:07:29,053 --> 00:07:33,951
它所能给的就是一个伪随机序列的前缀，
于是结果就是我将

94
00:07:33,951 --> 00:07:39,103
获得伪随机序列的前缀。但我们知道

95
00:07:39,103 --> 00:07:44,191
一旦知道伪随机序列前缀就可以推测出

96
00:07:44,191 --> 00:07:49,280
剩余的序列码并且进一步
可以推测出整个信息的剩余部分

97
00:07:49,280 --> 00:07:54,559
好的，例如如果伪随机序列生成器是

98
00:07:54,559 --> 00:07:59,132
可预测的并给他5个比特之后，
每一个用此流密码加密的邮件

99
00:07:59,132 --> 00:08:03,203
都将被解密，
因为攻击者通过推断密码文本的前缀

100
00:08:03,203 --> 00:08:07,556
来获取消息的前缀，这样他就能够

101
00:08:07,556 --> 00:08:12,023
计算出剩余的密码文本之后的部分，
从而进一步恢复

102
00:08:12,023 --> 00:08:16,433
整个未加密的文本。
好的这就是一个例子,说明了如果一个PRG

103
00:08:16,433 --> 00:08:21,485
是可预测的那么它就存在安全问题。
因为一个小的前缀

104
00:08:21,485 --> 00:08:27,288
将泄漏整个信息。结果就是,
如果我能预测出

105
00:08:27,288 --> 00:08:33,163
输出的一位，如果给我前i位，我能预测出

106
00:08:33,163 --> 00:08:38,764
下一位，再加上第一位。
这显然存在一个问题。再解释一遍就是说

107
00:08:38,764 --> 00:08:43,252
给出信息的前几个字母就

108
00:08:43,252 --> 00:08:48,163
可以预测和解密，并且恢复出
消息的下一位或者下一层，

109
00:08:48,163 --> 00:08:52,347
从而不断重复这个过程。
所以说这种可预测的特性告诉我们

110
00:08:52,347 --> 00:08:57,259
用于流密码的PRG最好是

111
00:08:57,259 --> 00:09:02,363
不可预测的。那么PRG是不可预测的意味着什么呢？
接下来让我们

112
00:09:02,363 --> 00:09:07,129
更准确的阐述PRG的不可预测性有什么意义。
我们先来阐述

113
00:09:07,129 --> 00:09:11,833
PRG的可预测性有什么意义。
我们先考虑g是可预测的

114
00:09:11,833 --> 00:09:18,111
如果存在一个有效的算法，称为A

115
00:09:18,111 --> 00:09:24,932
并且存在一个位置i存在于1到N-1之间。基于此，

116
00:09:24,932 --> 00:09:31,587
如果我们观察一个随机密钥的概率,
如果我生成一个随机密钥

117
00:09:31,587 --> 00:09:36,791
你们记得，这个记号表示从集合K中选择一个随机密钥

118
00:09:36,791 --> 00:09:42,212
所以，这个带r的箭头符号表示从集合K选择随机密钥。
基本上，如果我

119
00:09:42,212 --> 00:09:47,632
把输出的前缀给这个算法，如果把输出的前I字节给这个算法，

120
00:09:47,632 --> 00:09:53,190
则算法能推测出输出的下一个位的概率

121
00:09:53,190 --> 00:10:00,890
大于1/2+ε 因为一些不可忽略的ε

122
00:10:00,890 --> 00:10:07,389
例如

123
00:10:07,389 --> 00:10:11,322
e的值大于1/2^30，比如1/10^9就是不可忽略的

124
00:10:11,322 --> 00:10:15,415
我们认为是不可忽略的这些术语，

125
00:10:15,415 --> 00:10:19,508
可忽略和不可忽略的，
我们都将在这节课的最后回到这里并且给出更准确的定义

126
00:10:19,508 --> 00:10:24,260
不过现在让我们凭直觉思考一下不可忽略

127
00:10:24,260 --> 00:10:28,684
意味着什么。它是指对于一个算法，
一个发生器来说是可预测的

128
00:10:28,684 --> 00:10:33,332
实际，有一些算法可以预测I加第一个比特

129
00:10:33,332 --> 00:10:37,813
甚至共同的前缀，明白了吗？
我们说一个算法

130
00:10:37,813 --> 00:10:42,013
PRG是不可预测的。实际，如果它不满足

131
00:10:42,013 --> 00:10:46,269
我们之前定义的特性，那么它就是不可预测的

132
00:10:46,269 --> 00:10:50,861
但是这是什么意思呢，
对于不可预测更确切的意思是

133
00:10:50,861 --> 00:10:55,246
实际上，对于i的所有值，
不存在有效的对手和有效的算法A,

134
00:10:55,246 --> 00:10:59,881
在不可忽略的概率下能预测出i+1位

135
00:10:59,881 --> 00:11:04,642
好的，对于所有i这都是成立的，
无论我给你怎样的前缀

136
00:11:04,642 --> 00:11:08,920
你都不能推测出前缀的后一位

137
00:11:08,920 --> 00:11:13,267
好的，让我们看看一些例子，
一个十分简单的例子

138
00:11:13,267 --> 00:11:17,632
假设我给你一个生成器，
我的问题是它是否可预测的

139
00:11:17,632 --> 00:11:22,476
这个生成器恰巧具有这种特性,
这种特性就是如果我把所有输出位进行

140
00:11:22,476 --> 00:11:27,317
异或,我总是恰巧得到1。
所以,我对所有位进行异或。

141
00:11:27,317 --> 00:11:31,895
异或第一位，异或第二位,异或第三位。
如果我对所有位进行异或

142
00:11:31,895 --> 00:11:36,657
恰巧得到1 问题是这是一个可预测的生成器吗？

143
00:11:36,657 --> 00:11:41,113
再一次,我希望每个人回答"是", 
主要是给出输出字节的前n-1位

144
00:11:41,113 --> 00:11:45,997
就可以推测出第n位 因为仅仅需要比特值

145
00:11:45,997 --> 00:11:50,819
让它做异或运算使所有位为1。换句话说,我给你们

146
00:11:50,819 --> 00:11:55,825
除了生成器的比特值中的一个其他的所有值,
你就可以推测出生成器的最后一个字节

147
00:11:55,825 --> 00:12:00,230
既然我们已经看到了PRG必须是不可预测的。我想

148
00:12:00,230 --> 00:12:04,469
提及一下一对永远都不会用于加密的
弱伪随机序列生成器（PRGs)

149
00:12:04,469 --> 00:12:08,762
这是一个非常普遍的错误，我希望你们中没人

150
00:12:08,762 --> 00:12:12,895
犯这样的错误。一个很常见的PRG绝不会被用于加密,
这种PRG被称作

151
00:12:12,895 --> 00:12:17,347
线性同余生成器 我来解释一下什么是线性同余生成器

152
00:12:17,347 --> 00:12:22,773
首先它有一些参量,这里是三个参量,

153
00:12:22,773 --> 00:12:28,910
我将它们称作A, B,和P。
A和B是整数,P是一个素数。生成器定义如下：

154
00:12:28,910 --> 00:12:35,341
假设R0是生成器的种子密钥。然后

155
00:12:35,341 --> 00:12:42,883
生成随机序列的方法主要有以下

156
00:12:42,883 --> 00:12:49,971
这些步骤。计算r[i]=a*r[i-1](mod P)之后输出

157
00:12:49,971 --> 00:12:58,053
一些位的当前状态值，输出i的几位，然后增加i

158
00:12:58,053 --> 00:13:02,782
并且一遍又一遍的重复。
好的，现在你知道这种生成器是怎么进行了。

159
00:13:02,782 --> 00:13:07,341
它由一个特殊的种子开始，在每一步

160
00:13:07,341 --> 00:13:11,934
这种线性转换都作用于种子密钥，
之后输出

161
00:13:11,934 --> 00:13:16,258
当前状态的部分位，并且不断地重复这个过程。

162
00:13:16,258 --> 00:13:20,476
很不幸,即使这样,这个生成器在某种程度上

163
00:13:20,476 --> 00:13:24,960
也具有良好的统计特性。
例如，它输出的0的个数和输出中

164
00:13:24,960 --> 00:13:29,231
1的个数相似等等，对于这一点，
你应当确实了解所有这些统计特性

165
00:13:29,231 --> 00:13:33,662
然而它是一个非常容易预测的生成器

166
00:13:33,662 --> 00:13:37,925
实际是绝不会被应用的。实际上，

167
00:13:37,925 --> 00:13:42,592
给定一些输出样本很容易预测剩余序列

168
00:13:42,592 --> 00:13:47,143
因此，这种生成器绝不应当被应用。

169
00:13:47,143 --> 00:13:51,810
另一个例子是与线性同余生成器
关系十分密切的随机数生成器。

170
00:13:51,810 --> 00:13:56,244
这是一个运用于glibc的随机数生成器,
glibc是一个GNU发布的应用于linux的C运行库

171
00:13:56,244 --> 00:14:01,437
你看，我把定义写在这里。

172
00:14:01,437 --> 00:14:07,056
就可以看出,每次循环输出几个比特，并且每一步都

173
00:14:07,056 --> 00:14:12,470
做这样简单的线性变换。再次强调,
这是一个非常简单的可预测的生成器

174
00:14:12,470 --> 00:14:17,952
并且绝不应该应用于加密。所以第一节课我想强调

175
00:14:17,952 --> 00:14:23,179
永远不要使用内置的glibc库函数。对于加密来说

176
00:14:23,179 --> 00:14:27,718
从容易预测的意义来看，它并不会减少密码随机性

177
00:14:27,718 --> 00:14:32,749
实际上，Kerberos4系统就使用了随机数生成器

178
00:14:32,749 --> 00:14:37,717
并深受此害。请你们不要犯这样的错误。

179
00:14:37,717 --> 00:14:42,643
在下节课我们将会讨论如何实现安全的随机数生成器。

180
00:14:42,643 --> 00:14:47,765
在总结这节课之前我想给出一些关于

181
00:14:47,765 --> 00:14:52,513
有关可忽略和不可忽略的概念的细节。

182
00:14:52,513 --> 00:14:57,449
密码界不同的派别对这些概念有不同的定义

183
00:14:57,449 --> 00:15:02,879
对于实习者来说，
这些可忽略和不可忽略的术语

184
00:15:02,879 --> 00:15:06,991
仅是被用在定义中的特殊的词。
举个例子来说，

185
00:15:06,991 --> 00:15:11,623
一个实习者会说如果一个值大于1/10^9,

186
00:15:11,623 --> 00:15:16,082
或者大于1/2^30我们就认为这个值不能忽略

187
00:15:16,082 --> 00:15:20,831
原因就在于，因为如果你恰巧用一个密钥,

188
00:15:20,831 --> 00:15:25,522
例如来加密一个GB级别大小的数据。
GB级别大小的数据大概就在2^30

189
00:15:25,522 --> 00:15:30,198
到2^32字节之间。一个以1/2^30的概率发生的事件

190
00:15:30,198 --> 00:15:34,672
就可能出现在生成了GB大小的数据之后。

191
00:15:34,672 --> 00:15:39,090
那么既然GB级别大小的数据对于一个特定的密钥来说是可能的话，
那么这个事件就很有可能发生

192
00:15:39,090 --> 00:15:43,338
因此1/2^30就是不可忽略的。另一方面

193
00:15:43,338 --> 00:15:47,732
我们来考虑1/2^80，这是一个更小概率的事件

194
00:15:47,732 --> 00:15:51,794
这种事件发生的概率对于

195
00:15:51,794 --> 00:15:56,451
密钥的生命期来说基本是不会发生的。于是我们说

196
00:15:56,451 --> 00:16:00,559
这是可忽略的事件，如上所述，
这些有关忽略和不可忽略的实际的定义

197
00:16:00,559 --> 00:16:05,212
是相当有问题的。我们通过例子来看看为什么说它有问题？

198
00:16:05,212 --> 00:16:09,290
为什么说它有问题？
实际上在许多严密的密码学理论中，

199
00:16:09,290 --> 00:16:14,058
忽略性与不可忽略性的定义是有些不同的。

200
00:16:14,058 --> 00:16:18,251
实际上，我们在讨论一个事件的概率时，

201
00:16:18,251 --> 00:16:23,019
我们并不去讨论这些概率的数值，反而我们将概率

202
00:16:23,019 --> 00:16:27,270
作为函数安全参数来讨论。
让我来解释这是什么意思。这些函数

203
00:16:27,450 --> 00:16:32,447
本质上是映射输出的函数。
正实数值是可能作为概率值的非负实数

204
00:16:32,447 --> 00:16:37,384
但是它们是在非负整数集上工作的函数。

205
00:16:37,384 --> 00:16:41,960
那么对于一个函数来说，
不可忽略意味着什么？

206
00:16:41,960 --> 00:16:46,836
它是指函数通常比一些无限多项式大

207
00:16:46,836 --> 00:16:51,171
换句话说，对于无限的取值，

208
00:16:51,171 --> 00:16:55,867
函数值比1/多项式值，明白吗？

209
00:16:55,867 --> 00:17:01,130
我把准确的定义写在这里。
我们来看个例子，如果一个数较大

210
00:17:01,130 --> 00:17:06,100
它通常要大于1/多项式值，
那么我们就说这个值是不可忽略的

211
00:17:06,100 --> 00:17:11,070
但是，如果存在数值小于所有1/多项式值，

212
00:17:11,070 --> 00:17:15,908
那么我们认为他是可以忽略的。
就说到这，通常对任何次的多项式，

213
00:17:15,908 --> 00:17:20,838
对所有的d值，存在一些下限λd

214
00:17:20,838 --> 00:17:25,162
所有λ都大于λd，函数小于1/多项式的值

215
00:17:25,162 --> 00:17:29,716
这些都在说如果函数小于多项式的每一部分就认为他可以忽略

216
00:17:29,716 --> 00:17:33,924
换句话说就是存在足够大且小于1/λd的λ。

217
00:17:33,924 --> 00:17:38,135
让我们看一些例子之后就会发现

218
00:17:38,135 --> 00:17:43,085
这些这些忽略和不可忽略的概念的应用。

219
00:17:43,085 --> 00:17:47,689
但是我仅想使大家更清楚
怎样才能严密地发现这些概念。

220
00:17:47,689 --> 00:17:52,185
通常，不论小于1/多项式值或者大于1/多项式值

221
00:17:52,185 --> 00:17:56,410
都是可忽略的 否则就是不可忽略的。
让我们看一些例子

222
00:17:58,522 --> 00:18:00,635
例如，一个函数以λ的指数形式下降

223
00:18:00,635 --> 00:18:05,456
明显是可忽略的，
因为对任何一个常量d都存在一个有效的很大的λ

224
00:18:05,456 --> 00:18:09,952
例如1/2^λ小于1/λ^d

225
00:18:09,952 --> 00:18:15,405
好的明显这个值小于所有的多项式。
这个函数，比如

226
00:18:15,405 --> 00:18:20,894
1/λ^1000这个函数增长得非常慢，

227
00:18:20,894 --> 00:18:25,217
几乎不增长，然而这个函数

228
00:18:25,217 --> 00:18:30,432
是不可忽略的，
因为如果我设d等于10000

229
00:18:30,432 --> 00:18:36,127
明显这个函数大于1/λ^10000，
所以这个函数大于部分多项式，

230
00:18:36,127 --> 00:18:41,238
让我们看一个巧妙而费解的例子

231
00:18:41,238 --> 00:18:45,925
你怎么认为？我有一个函数，
当λ是奇数时，函数恰巧呈指数减小

232
00:18:45,925 --> 00:18:50,375
当λ是偶数时，函数恰好呈多式形式减小。
那么这是一个可忽略的还是

233
00:18:50,375 --> 00:18:55,350
不可忽略的函数呢？按照我们的定义这个函数是不可忽略的

234
00:18:55,350 --> 00:19:00,747
由直觉判断如果一个函数以多项式形式减小，

235
00:19:00,747 --> 00:19:05,815
那么通常意味着以这个概率发生的事件

236
00:19:05,815 --> 00:19:10,680
在实际的密码系统中已经是很大的事件了，

237
00:19:10,680 --> 00:19:15,420
所以，主要需要记住的点是这些术语

238
00:19:15,420 --> 00:19:19,559
分别对应着小于多项式或者大于多项式，

239
00:19:19,559 --> 00:19:23,862
并且贯穿这门课程，
我们大多数情况用忽略性表示小于一个指数。

240
00:19:23,862 --> 00:19:28,328
用不可忽略表示小于1/多项式值，
所以现在可以看到

241
00:19:28,328 --> 00:19:32,848
把一次一密转化为实用性密码的核心思想,
这里的实用性密码

242
00:19:32,848 --> 00:19:36,933
就是流密码。在下节课中我们将学习

243
00:19:36,933 --> 00:19:41,236
如何讨论一个流密码是否是真的安全的。

244
00:19:41,236 --> 00:19:45,757
这就需要对安全性进行全新的定义，
因为完全安全在这儿对密码来说还不够好

245
00:19:45,757 --> 00:19:47,500
这些定义我们将在下一节课中看到。【END】