1
00:00:00,000 --> 00:00:03,518
本节 我们将学习对一次一密的攻击

2
00:00:03,518 --> 00:00:06,542
和使用流密码时所需要注意的一些事情 
但在开始前

3
00:00:06,542 --> 00:00:10,012
我们对讲过的知识进行快速的回顾 
回想一下

4
00:00:10,012 --> 00:00:14,121
一次一密是通过将明文与密钥异或来加密的，

5
00:00:14,121 --> 00:00:18,653
这里密钥和明文一样长
类似的，解密同样是

6
00:00:18,653 --> 00:00:22,637
通过密文与相同密钥之间的异或来实现的 

7
00:00:22,637 --> 00:00:27,123
当密钥是均匀、随机的时
我们证明一次一密具有理论上的信息安全性

8
00:00:27,123 --> 00:00:31,292
也就是香农称作的完善保密
显然有个问题是密钥与明文一样长

9
00:00:31,292 --> 00:00:35,610
所以一次一密很难使用
之后我们讨论了

10
00:00:35,610 --> 00:00:40,109
通过使用伪随机数发生器使一次一密实用化

11
00:00:40,109 --> 00:00:44,438
伪随机数生成器可以将一个短的种子信息扩展成一条更长的信息。
流密码的工作方法

12
00:00:44,438 --> 00:00:49,109
本质上是使用伪随机数发生器  与一次一密的方法一样。

13
00:00:49,109 --> 00:00:53,666
基本上，流密码中我们不使用真随机序列

14
00:00:53,666 --> 00:00:58,337
而使用伪随机序列
这个序列是由发生器输入的短密钥扩展而成，并与明文一样长

15
00:00:58,337 --> 00:01:02,402
所以这里我们说它的安全性不再依赖于

16
00:01:02,402 --> 00:01:06,090
完善保密 因为（实用的）
流密码不可能是完善保密的

17
00:01:06,090 --> 00:01:09,978
而依赖于伪随机数发生器的性质

18
00:01:09,978 --> 00:01:14,014
我们说伪随机发生器必须是不可预测的 但事实上

19
00:01:14,014 --> 00:01:18,251
证明这个定义使用起来有点困难
这里我们将了解一个

20
00:01:18,251 --> 00:01:22,288
关于PRG（伪随机数生成器）的安全性的更好的定义
大概会花两节的内容。

21
00:01:22,288 --> 00:01:26,326
但本节我们将讨论对一次一密的攻击
第一个我想讨论的攻击

22
00:01:26,326 --> 00:01:30,623
是“二次密码本攻击” 。所以记住

23
00:01:30,623 --> 00:01:36,149
一次一密之所以叫“一次性”密码本，
是因为密码本只能用来加密

24
00:01:36,149 --> 00:01:41,058
单个信息 这里我想表示的是
如果同样的密码本为不止一个明文加密时

25
00:01:41,058 --> 00:01:45,678
安全性也就不复存在了
而且窃听者可以完全

26
00:01:45,678 --> 00:01:50,240
解密加密消息
那么我们来看一个例子

27
00:01:50,240 --> 00:01:54,513
这里有两个使用相同密码本
加密的明文消息，m1和m2

28
00:01:54,513 --> 00:01:58,729
密文c1和c2分别是m1和m2的加密

29
00:01:58,729 --> 00:02:03,238
但加密时使用的是相同密码本 

30
00:02:03,238 --> 00:02:09,507
现假设窃听者在截取c1和c2
并且截获成功了，那么他就有了c1和c2

31
00:02:09,507 --> 00:02:15,168
窃听者就会很自然的去计算出c1和c2的异或

32
00:02:15,168 --> 00:02:20,948
当他计算异或后他会得到什么呢？
我希望每个人都能想到

33
00:02:20,948 --> 00:02:25,178
基本上 当你将c1和c2异或 密钥就会被抵消

34
00:02:25,178 --> 00:02:29,747
本质上得到的就是两段明文的异或。

35
00:02:29,747 --> 00:02:34,372
英语实际上有着足够的冗余
因此如果我

36
00:02:34,372 --> 00:02:38,772
给你两个明文的异或，
你能完全还原出

37
00:02:38,772 --> 00:02:43,115
两个明文消息
而对我们来说更重要的是这些信息使用了

38
00:02:43,115 --> 00:02:47,515
ASCII编码 事实上，
ASCII本身就有足够的冗余。

39
00:02:47,515 --> 00:02:52,027
因此，给定两个ASCII码信息的异或，
你可以还原出原消息

40
00:02:52,027 --> 00:02:56,711
所以，本质上，给定这些异或，
可以还原出两条明文消息

41
00:02:56,711 --> 00:03:01,535
所以要记住的是
如果你使用同样的密钥序列去加密多条信息

42
00:03:01,535 --> 00:03:06,071
截取密文的攻击者最终可以

43
00:03:06,071 --> 00:03:10,818
毫不费力地还原出明文
所以，流密码的密钥或者

44
00:03:10,818 --> 00:03:16,167
一次一密的密钥永远不要使用超过一次

45
00:03:16,167 --> 00:03:20,904
我们看几个实际当中运用这个的例子
一个常见的错误

46
00:03:20,904 --> 00:03:25,360
是多次使用流密码密钥或一次一密密钥

47
00:03:25,360 --> 00:03:30,210
我给你们展示几个出现这种错误的例子，
从而让你避免在自己建造的系统中不犯这些错误

48
00:03:30,210 --> 00:03:35,060
第一个例子是史上著名例子
在20世纪40年代初期

49
00:03:35,060 --> 00:03:39,402
苏联人使用了一次一密加密了多个

50
00:03:39,402 --> 00:03:43,970
信息 很不幸
使用的密码序列是由人们掷骰子产生的

51
00:03:43,970 --> 00:03:48,394
所以，你应该知道
人们掷骰子并记录下结果

52
00:03:48,394 --> 00:03:52,884
然后收集到的结果就被用作加密的密码本

53
00:03:52,884 --> 00:03:57,053
而生成这种密码本需要大量的劳动力

54
00:03:57,053 --> 00:04:01,330
用它只加密一条信息就显得很浪费

55
00:04:01,330 --> 00:04:05,762
所以最后用这些密码本来加密多条信息
美国情报机关

56
00:04:05,762 --> 00:04:10,366
当时自然可以截获这些二次密码本
这些密文是由

57
00:04:10,366 --> 00:04:14,865
不同的明文，使用相同密码本生成的。
所以结果是

58
00:04:14,865 --> 00:04:19,177
经过几年，他们就能够解密约3000条明文

59
00:04:19,177 --> 00:04:23,273
仅凭截获密文 这个计划叫做Venona计划

60
00:04:23,273 --> 00:04:27,478
这是密码分析中很精彩的一幕，
仅仅因为二次

61
00:04:27,478 --> 00:04:31,985
密码本是不安全的
更重要的，我想讲一些近代的例子

62
00:04:31,985 --> 00:04:36,450
这些例子是在网络协议中发现的
来看一个来源于Windows NT的例子

63
00:04:36,450 --> 00:04:40,697
这个例子是在点到点传输协议中发现的

64
00:04:40,697 --> 00:04:44,726
这个协议是为想与服务器安全通信的客户设计的

65
00:04:44,726 --> 00:04:49,355
客户端和服务端共享同一个密钥，并相互通信

66
00:04:49,355 --> 00:04:53,438
这里，我们将客户端发送的明文信息称作m1

67
00:04:53,438 --> 00:04:57,903
客户端发送信息，服务器端应答，
客户端发送消息，服务器端应答

68
00:04:57,903 --> 00:05:02,710
客户端发送消息，服务端应答等等

69
00:05:02,710 --> 00:05:07,723
PPTP协议的工作原理是将双方进行整个互动

70
00:05:07,723 --> 00:05:12,996
从客户端到服务器端 当作一个流。换句话说

71
00:05:12,996 --> 00:05:17,944
这里的消息m1，m2，m3被视作一个长流

72
00:05:17,944 --> 00:05:22,501
这里双平行线表示串结。本质上

73
00:05:22,501 --> 00:05:27,840
我们将从客户端到服务器端的信息全部串结成一个长流

74
00:05:27,840 --> 00:05:34,649
整个长流使用密钥K来加密 整个过程

75
00:05:34,649 --> 00:05:38,463
非常好，并没有错误。这些消息被

76
00:05:38,463 --> 00:05:42,807
加密 并且被看做一个长流，
并且它们使用相同的密钥来加密

77
00:05:42,807 --> 00:05:46,727
问题在于，服务器端也正发生同样的事情

78
00:05:46,727 --> 00:05:50,647
换句话说，从服务端发出的消息也被看作成一个长流

79
00:05:50,647 --> 00:05:54,890
所以，它们都被串接起来

80
00:05:54,890 --> 00:06:01,010
很不幸，加密使用了相同的伪随机种子。
换句话说

81
00:06:01,010 --> 00:06:05,930
也就是使用了相同的流密钥。
所以你应该想到这里发生一个现象是

82
00:06:05,930 --> 00:06:10,265
二次密码本现象，
而这个现象是由一组从客户端来的消息

83
00:06:10,265 --> 00:06:14,656
与一组从服务端来的消息正在使用相同的密码本进行加密而产生的。

84
00:06:14,656 --> 00:06:19,158
这里的教训是永远不要使用相同的密钥加密两个方向的流量

85
00:06:19,158 --> 00:06:23,548
事实上，你需要的是一个密钥加密

86
00:06:23,548 --> 00:06:28,050
从客户端到服务端的通信，以及另一个密钥加密服务器到客户端的通信。

87
00:06:28,050 --> 00:06:32,651
我喜欢将这种密钥写成其实是一对密钥的共享密钥k。

88
00:06:32,651 --> 00:06:38,059
一个密钥加密从服务器到客户端的消息

89
00:06:38,059 --> 00:06:42,920
另一个加密客户端到服务端的消息，
所以有两个

90
00:06:42,920 --> 00:06:48,054
分开的密钥可供使用，
当然双方都知道这对密钥

91
00:06:48,054 --> 00:06:52,663
所以双方都有这对密钥，对吧？
双方都可以进行加密 所以一个用来

92
00:06:52,663 --> 00:06:57,107
加密一个方向，另一个用来加密另一个方向。

93
00:06:57,107 --> 00:07:01,230
另一个有二次密码本现象的例子是在WI-FI通信中

94
00:07:01,230 --> 00:07:05,728
特别是在802.11b的协议中 我相信你们都知道

95
00:07:05,728 --> 00:07:10,225
802.11包含了一层加密层，
最初的加密层叫做WEP

96
00:07:10,225 --> 00:07:14,723
WEP对我们来说实际上是一个设计很糟糕的协议，
所以我可以

97
00:07:14,723 --> 00:07:18,792
总是把它拿来当作反面教材╮(╯▽╰)╭

98
00:07:18,792 --> 00:07:23,236
WEP中有很多很多的错误，
这里我举产生一个二次密码本现象的例子

99
00:07:23,236 --> 00:07:27,362
先解释一下WEP的工作原理，
在WEP中，有一个客户端

100
00:07:27,362 --> 00:07:31,423
和一个接入点。这是客户端，这是接入点

101
00:07:31,423 --> 00:07:35,589
它们共享密钥K，
然后，当它们想相互通信时

102
00:07:35,589 --> 00:07:39,492
假设它们相互传递帧(一种数据报文)

103
00:07:39,492 --> 00:07:44,274
比如说客户端想发送一个
包含明文M的帧给接入点

104
00:07:44,274 --> 00:07:49,319
他首先要做的就是附加校验和在明文上

105
00:07:49,319 --> 00:07:54,301
这里这个校验和并不重要，
重要的是接下来这个新的连接(明文+校检)

106
00:07:54,301 --> 00:07:59,595
需要用流密码加密
这个流密码密钥是

107
00:07:59,595 --> 00:08:06,570
这个IV值和一个长期密钥k的串接
这个IV值为24比特字符串。

108
00:08:06,570 --> 00:08:11,742
好，这个IV是一个24比特字符串，
你可以想到它是以0开始

109
00:08:11,742 --> 00:08:16,468
它可能是一个以一个数据包加1
的方式计数增量的计数器。

110
00:08:16,468 --> 00:08:21,769
他们这样做的原因是
WEP的设计者们知道在流密码中

111
00:08:21,769 --> 00:08:27,006
一个密钥只能加密一个明文信息

112
00:08:27,006 --> 00:08:31,860
所以他们就每帧使用不同的密钥，
它们改变密钥的方法就是

113
00:08:31,860 --> 00:08:36,931
在密钥前面加上IV，
你或许会注意到这个IV的改变

114
00:08:36,931 --> 00:08:42,036
在每个数据包中，将每个数据包的IV加一
所以IV直接附加密文前面

115
00:08:42,036 --> 00:08:47,335
与密文一起被发送，
接收方也知道密钥k

116
00:08:47,335 --> 00:08:52,440
也知道IV。就能通过串接IV和K重新推出PRG

117
00:08:52,440 --> 00:08:57,541
然后就能解密密文，还原明文M了。
现在问题在于

118
00:08:57,541 --> 00:09:02,749
IV只有24比特的长度，也就是说2的24次方

119
00:09:02,749 --> 00:09:07,646
可能的IV，也就是说，
经过1600万帧的传输后

120
00:09:07,646 --> 00:09:12,291
IV又要重0开始循环了，
每经过1600万帧循环一次

121
00:09:12,291 --> 00:09:16,934
这就有了两次密码本，
同样的IV被用来加密两个不同的信息

122
00:09:16,934 --> 00:09:21,699
密钥k的长度不变，
它是一个长期的密钥 

123
00:09:21,699 --> 00:09:26,586
最终相同的密钥，
即IV串接K会被用来加密两个不同的帧

124
00:09:26,586 --> 00:09:31,349
然后攻击者可以解出两个帧的原文来

125
00:09:31,349 --> 00:09:36,297
这是一个问题，
更严重的问题是在很多802.11网卡上

126
00:09:36,297 --> 00:09:41,216
如果你重启网卡 IV会被重置为0 于是

127
00:09:41,216 --> 00:09:45,531
每次重新启动网卡，加密下次有效负载，

128
00:09:45,531 --> 00:09:49,847
用的都是0和密钥K的串接，
所以每次重启网卡后，你都要使用0串接k

129
00:09:49,847 --> 00:09:54,279
来加密许多许多相同数据包

130
00:09:54,279 --> 00:09:59,178
所以在WEP中，只要IV被重置，
同样的密码本就会用来加密许多不同的信息

131
00:09:59,178 --> 00:10:03,668
我们无法防止重启后IV被重置的现象

132
00:10:03,668 --> 00:10:08,220
或者1600万帧后归零，
1600万帧在忙碌的网络中并不算多

133
00:10:08,220 --> 00:10:12,946
所以当我们在讨论WEP时，我会提到WEP的

134
00:10:12,946 --> 00:10:17,540
另一个错误 这个确实是一个很严重的错误

135
00:10:17,540 --> 00:10:22,366
我们来看如何更好的设计它。
大家都注意到WEP的设计者

136
00:10:22,366 --> 00:10:27,017
本质上想为每个数据包使用不同的密钥

137
00:10:27,017 --> 00:10:31,145
所以每个帧使用不同的密钥加密，
即不同的IV和k串接

138
00:10:31,145 --> 00:10:35,325
很遗憾，它们没有随机选取密钥

139
00:10:35,325 --> 00:10:38,849
如果单看第一帧的密钥，它一定是

140
00:10:38,849 --> 00:10:43,004
1与k的串接。当然，
这个IV不能填满24比特

141
00:10:43,004 --> 00:10:47,369
第二帧的密钥是2和k的串接，第三帧的密钥是

142
00:10:47,369 --> 00:10:51,629
3与k的串接 所以这些密钥之间非常接近

143
00:10:51,629 --> 00:10:55,889
我还应该提到这些密钥本身可以是104比特

144
00:10:55,889 --> 00:11:00,362
因此PRG生成密钥实际上是104+24=128比特

145
00:11:00,362 --> 00:11:05,097
很遗憾这些密钥之间太过相近 它们并不是

146
00:11:05,097 --> 00:11:10,268
随机密钥 大家注意到
它们都有相同的104字节的后缀

147
00:11:10,268 --> 00:11:15,377
事实上WEP里的伪随机密钥并没有设计的那么安全

148
00:11:15,377 --> 00:11:20,548
因为你使用了相近的密钥。
换句话说 大部分密钥

149
00:11:20,548 --> 00:11:25,477
之间是一样的。事实上，
对于WEP中使用的PRG叫做RC4

150
00:11:25,477 --> 00:11:30,860
我们将在下一节中了解更多

151
00:11:30,860 --> 00:11:36,243
在2001年由Fluhrer，Mantin，Shamir三人发现了一个攻击

152
00:11:36,243 --> 00:11:41,763
证实经过10的6次方，约100万帧后

153
00:11:41,763 --> 00:11:47,105
你就可以还原密钥了 所以这是一个很严重的

154
00:11:47,105 --> 00:11:52,497
攻击，要想破译只需监听一百万帧就可以了

155
00:11:52,497 --> 00:11:57,707
刚才说过，这些帧全部由一个共同种子生成

156
00:11:57,707 --> 00:12:02,813
也就是说104位的种子序列全部一样

157
00:12:02,813 --> 00:12:07,794
这足以还原出密钥了

158
00:12:07,794 --> 00:12:12,527
实际上经过2001年的攻击，
更好的攻击方案开始出现

159
00:12:12,527 --> 00:12:17,010
证明了这种密钥关联是灾难性的 

160
00:12:17,010 --> 00:12:21,298
事实上最近又发现4万帧就足以破解 

161
00:12:21,298 --> 00:12:25,334
因此在几分钟内你就可以
还原任何WEP网络中使用的密钥了

162
00:12:25,334 --> 00:12:29,535
所以WEP基于下面两个原因无法提供任何的安全性。

163
00:12:29,535 --> 00:12:33,792
第一它像二次密码本一样脆弱，
但是更重要的是

164
00:12:33,792 --> 00:12:38,271
因为这些密钥之间的紧密关联，
仅窃听少量密文就可以还原密钥

165
00:12:38,271 --> 00:12:42,532
顺便说下，当我们对加密机制里的步骤
进行安全分析时，我们能更好地了解这个性质

166
00:12:42,532 --> 00:12:46,987
在下几节里，我们会开始讨论如何分析

167
00:12:46,987 --> 00:12:51,174
加密机制里的步骤，
我们会发现当我们使用这样紧密关联的密钥时

168
00:12:51,174 --> 00:12:55,361
事实上 会导致我们安全分析的失败，
我们无法得到

169
00:12:55,361 --> 00:12:59,870
可以被通过的证据。
所以WEP的设计者们应当怎么办？

170
00:12:59,870 --> 00:13:03,949
一个方法是对帧进行处理，M1，

171
00:13:03,949 --> 00:13:08,350
M2，M3等 每一帧都是由客户端分开发向服务端

172
00:13:08,350 --> 00:13:13,620
也可以把它们当作长流处理，
然后进行异或操作

173
00:13:13,620 --> 00:13:18,075
使用伪随机数发生器产生长流

174
00:13:18,075 --> 00:13:21,651
密码本的第一节用来加密M1

175
00:13:21,651 --> 00:13:25,548
密码本的第二节用来加密M2

176
00:13:25,548 --> 00:13:29,400
密码本的第三节用来加密M3.等等

177
00:13:29,400 --> 00:13:33,323
所以设计者们不必对每一帧都改变密钥

178
00:13:33,323 --> 00:13:38,106
因为整个会话应被视作长流，
但是他们为每一帧选出不同的密钥

179
00:13:38,106 --> 00:13:42,881
所以如果你想这么做，
有更好的方法

180
00:13:42,881 --> 00:13:47,718
不是轻微改变IV，
即轻微改变PRG的密钥前缀

181
00:13:47,718 --> 00:13:52,742
更好的办法是再次使用PRG。
所以本质上

182
00:13:52,742 --> 00:13:57,517
你能做的是获得一个长期密钥。
然后把长期密钥输入到

183
00:13:57,517 --> 00:14:02,726
PRG里 这样我们就得到了一个长流，
而且它看起来是随机的

184
00:14:02,726 --> 00:14:07,563
然后可以使用最初密码本的部分，
第一段可以当作密钥

185
00:14:07,563 --> 00:14:14,577
来加密第一帧。第二段当作密钥

186
00:14:14,577 --> 00:14:20,173
来加密第二帧等等

187
00:14:20,173 --> 00:14:25,138
第三段加密第三帧等等。
所以这样做的好处是，本质上，

188
00:14:25,138 --> 00:14:30,361
每一帧都有一个伪随机密钥了

189
00:14:30,361 --> 00:14:35,390
这些密钥之间没有关系了，
它们看起来像是随机密钥

190
00:14:35,390 --> 00:14:40,613
所以，如果PRG对于任意种子序列是安全的，
那它对这个输入也是安全的

191
00:14:40,613 --> 00:14:44,871
因为密钥看起来相互之间是独立的

192
00:14:44,871 --> 00:14:49,379
当我们讨论完这些加密机制后，
再来做正式的分析

193
00:14:49,379 --> 00:14:53,621
既然二次密码本的攻击在实践中很容易碰到，

194
00:14:53,621 --> 00:14:58,076
毕竟这也是一个常见错误，
我想通过举出另一个的例子让大家避免犯错

195
00:14:58,076 --> 00:15:02,000
最后一个例子是在磁盘加密的环境下讨论的

196
00:15:02,000 --> 00:15:06,243
想象我们有一个文件 也许这个文件开头是

197
00:15:06,243 --> 00:15:10,447
“给Bob的话”，后面跟着文件内容

198
00:15:10,447 --> 00:15:14,920
当把文件存在磁盘上时，
假设这个是磁盘

199
00:15:14,920 --> 00:15:19,404
文件被分块放置，对于每一块，

200
00:15:19,404 --> 00:15:23,726
当我们把分块存放在硬盘上时 就会对其加密

201
00:15:23,726 --> 00:15:28,446
那么“给Bob的话”就会放到第一块，余下的内容将

202
00:15:28,446 --> 00:15:33,109
放在剩下的分块里，当然这全部被加密了

203
00:15:33,109 --> 00:15:37,829
我用这些红线来表示被它们被加密了

204
00:15:37,829 --> 00:15:42,605
一个攻击者可以看到看硬盘
却不知道文件内容是什么。那么现在假设

205
00:15:42,605 --> 00:15:46,700
假设经过一段时间后，
用户做出修改，启动了编辑器

206
00:15:46,700 --> 00:15:51,745
它修改了文件 现在不是“给Bob” 而是“给Eve”

207
00:15:51,745 --> 00:15:56,853
文件其余内容不改变，仅改变这个地方

208
00:15:56,853 --> 00:16:01,520
当用户将修改保存到硬盘，它将再次加密一遍

209
00:16:01,780 --> 00:16:06,345
所以相同的事情又发生了一遍，
这个文件又被分成了几块

210
00:16:06,345 --> 00:16:10,416
现在这个文件是发给Eve，所有内容均被加密

211
00:16:10,416 --> 00:16:15,037
所以我又要用这些线表示加密，
现在有攻击者正在浏览磁盘

212
00:16:15,202 --> 00:16:19,713
并得到了文件编辑前的快照，
之后又继续观察编辑后的磁盘

213
00:16:19,713 --> 00:16:24,334
他会发现改变的地方仅仅是

214
00:16:24,334 --> 00:16:29,311
这一小段不一样，其他地方都一模一样

215
00:16:29,311 --> 00:16:34,134
即使攻击者不知道文件是如何修改的

216
00:16:34,134 --> 00:16:38,900
他却知道修改的确切位置

217
00:16:38,900 --> 00:16:43,840
事实上，一次一密或密码流一次加密一比特

218
00:16:43,840 --> 00:16:48,839
意味着如果一处发生改变，
很容易立刻发现变化的位置

219
00:16:48,839 --> 00:16:53,430
这就泄露了攻击者不应该知道的信息

220
00:16:53,430 --> 00:16:58,080
理想情况下，即使文件有一点改动

221
00:16:58,080 --> 00:17:02,818
整个文件就应该被改变，
或者至少这些分块的内容会有所改变

222
00:17:02,818 --> 00:17:07,557
而这里攻击者甚至知道改变发生在哪一分块

223
00:17:07,557 --> 00:17:12,125
事实上正因如此，通常

224
00:17:12,125 --> 00:17:16,522
磁盘加密使用流密码不是一个好方法，

225
00:17:16,522 --> 00:17:21,146
本质上这是二次密码本攻击的又一个例子，
因为相同的密码本被用来加密

226
00:17:21,146 --> 00:17:26,057
两条不同的信息 上面与下面的信息
虽然非常相似，但它们是两条

227
00:17:26,057 --> 00:17:30,582
不同的信息，攻击者可以知道什么改变了

228
00:17:30,582 --> 00:17:35,339
最终他还可能知道改变的内容是什么

229
00:17:35,339 --> 00:17:39,192
所以这里的教训是，我们需要做些不同的东西来

230
00:17:39,192 --> 00:17:43,249
执行磁盘加密。
在后面的章节中我们再来讨论磁盘加密

231
00:17:43,249 --> 00:17:46,965
但是一般来说，
一次一密不是用来加密磁盘块的好方法

232
00:17:46,965 --> 00:17:50,631
那么再总结一下二次密码本攻击

233
00:17:50,631 --> 00:17:54,493
我希望我已说服你

234
00:17:54,493 --> 00:17:58,551
千万不要重复使用流密码密钥超过一次 

235
00:17:58,551 --> 00:18:02,560
即使有这种情况可能会发生的自然环境，
你也需要小心并确保

236
00:18:02,560 --> 00:18:06,440
不会重复使用同样的密钥超过1次，
因此对网络流量来说

237
00:18:06,440 --> 00:18:10,566
你需要做的是，每次会话都有对应的密钥

238
00:18:10,566 --> 00:18:14,742
会话内从客户端到服务端
的信息可以视作一个完整流

239
00:18:14,742 --> 00:18:18,765
并使用一个密钥加密该信息，
从服务器端到客户端的消息也

240
00:18:18,765 --> 00:18:22,636
可视作一个流 并用不同的密钥加密该流

241
00:18:22,636 --> 00:18:26,761
然后对于磁盘加密，
一般不使用流密码。

242
00:18:26,761 --> 00:18:31,509
因为每当对文件的修改，
流密码算法会泄露文件内容

243
00:18:31,509 --> 00:18:36,136
好，我们总结完了二次密码本的讨论内容

244
00:18:36,136 --> 00:18:41,092
下面我们来谈一个攻击，
事实上，一次一密和流密码

245
00:18:41,092 --> 00:18:45,578
并不提供完整性保护，
他们所做的仅仅是在只使用

246
00:18:45,578 --> 00:18:50,610
密钥一次的情况下提供机密性。
他们根本不提供完整性

247
00:18:50,610 --> 00:18:55,581
更糟糕的是 这两种加密实际上很容易修改密文

248
00:18:55,581 --> 00:19:00,310
并且对通信原文造成显著影响，
让我来解释一下

249
00:19:00,486 --> 00:19:05,025
顺便说下，这个性质叫柔韧性(即易受外界影响)
待会会看到

250
00:19:05,025 --> 00:19:09,682
设想有明文Ｍ被加密

251
00:19:09,682 --> 00:19:14,279
使用流密码加密，密文当然应该是

252
00:19:14,279 --> 00:19:18,690
由Ｍ异或密钥ｋ得来，
现在一攻击者截取密文

253
00:19:18,690 --> 00:19:23,175
只有密文他当然不知道原明文是怎么样的，
不过除了窃听以外

254
00:19:23,175 --> 00:19:27,660
攻击者还可以积极篡改密文

255
00:19:27,660 --> 00:19:31,742
当我说篡改密文时，我们假设他

256
00:19:31,742 --> 00:19:36,955
将密文和一特定值ｐ异或，
ｐ称作子置换密钥

257
00:19:37,160 --> 00:19:42,020
这样密文就成了ｍ⊕ｋ⊕ｐ

258
00:19:42,020 --> 00:19:48,207
我问你们，当我们解密时，我们能够解密得到什么

259
00:19:48,207 --> 00:19:53,613
大家应该都了解异或操作，解密后为ｍ⊕ｐ

260
00:19:53,613 --> 00:19:58,952
注意到异或密码本ｐ后，攻击者就会

261
00:19:58,952 --> 00:20:03,700
对明文造成特定的影响。所以一句话说就是

262
00:20:03,700 --> 00:20:08,135
你可以修改密文，
而且这些修改将不会被检测出来

263
00:20:08,135 --> 00:20:12,289
更糟糕的是，它们对还原的明文有特定影响

264
00:20:12,289 --> 00:20:16,893
也就是说，不管你拿什么跟密文异或

265
00:20:16,893 --> 00:20:21,384
都会对明文产生影响，
为了看出什么地方是危险的

266
00:20:21,384 --> 00:20:25,987
我们来看一个特别的例子，
假设用户发送了一分Email

267
00:20:25,987 --> 00:20:30,661
邮件以“来自Bob”开头，
攻击者截获通信密文

268
00:20:30,661 --> 00:20:35,236
他不知道密文是什么，
但为说明方便我们假设

269
00:20:35,236 --> 00:20:39,851
他知道这信来自Bob

270
00:20:39,851 --> 00:20:44,240
他想修改密文，
让明文变得看起来像来自于另外一个人

271
00:20:44,240 --> 00:20:48,686
比如说，他想让这封信看起来

272
00:20:48,686 --> 00:20:53,131
好像是从Eve发来的，
攻击者只有密文，但他能做的是

273
00:20:53,131 --> 00:20:57,521
他可以异或特定的三个字母，
我们等会会看到

274
00:20:57,521 --> 00:21:01,799
三个字母是哪三个字母，
因此

275
00:21:01,799 --> 00:21:06,411
密文就变成从Eve发来的，
所以

276
00:21:06,411 --> 00:21:10,490
等用户解密时，
突然他会认为，这封信来自Eve

277
00:21:10,490 --> 00:21:14,564
虽然是错的，但他认为信来自Eve而不是Bob，
并且这可能会导致接下来

278
00:21:14,564 --> 00:21:18,677
不好事情的发生，所以攻击者即使

279
00:21:18,677 --> 00:21:23,405
不能自己创造密文声称信件来自Eve

280
00:21:23,405 --> 00:21:28,192
通过修改已有的密文，瞬间他也可以创造密文，
当然一般情况下，

281
00:21:28,192 --> 00:21:32,802
除非截取窃听密文，
否则他也不能达到目的，所以

282
00:21:32,802 --> 00:21:37,529
通过截获一段密文，修改一下，
就可以使其看起来是来自Eve

283
00:21:37,529 --> 00:21:42,316
而不是Bob，特别地，
我们来看这三个字母是什么

284
00:21:42,316 --> 00:21:47,756
我们看单词Bob，
我用ASCII表示

285
00:21:47,756 --> 00:21:54,285
Bob相当于ASCII码的16进制42，6F和62

286
00:21:54,285 --> 00:22:00,815
b被编码成62，o被编码成6F，
单词Eve被编码成45、76

287
00:22:00,815 --> 00:22:07,262
65，当我异或这两个词时，
我以字符串的形式异或

288
00:22:07,262 --> 00:22:13,791
Bob异或Eve，不难看出得到的是

289
00:22:13,791 --> 00:22:19,798
三个字符07，19，07，
所以这三个字符应该是什么呢

290
00:22:19,798 --> 00:22:25,536
就是简单的字符07，19，07

291
00:22:25,536 --> 00:22:31,340
能过在密文正确的位置异或这三个字母

292
00:22:31,340 --> 00:22:37,003
攻击者可以将密文改成来自Eve而不是Bob

293
00:22:37,003 --> 00:22:41,892
这就是一个对密文造成可预测影响的例子

294
00:22:41,892 --> 00:22:46,410
这个影响确实能造成一些问题，
而这个属性就

295
00:22:46,410 --> 00:22:50,817
叫做柔韧性，
我们说一次一密是具柔韧性的，

296
00:22:50,817 --> 00:22:54,833
是因为密文很容易推算，
并将特定改变应用到明文上

297
00:22:54,833 --> 00:22:59,184
为了防止这点，

298
00:22:59,184 --> 00:23:03,479
我将花两三讲的时间，
来为大家展示如何为加密机制增加完整性

299
00:23:03,479 --> 00:23:07,689
我希望大家可以记住

300
00:23:07,689 --> 00:23:11,551
一次一密本身是没有完整性保护的

301
00:23:11,551 --> 00:23:14,024
并且针对可修改密文的攻击者
来说是完全不安全的【END】