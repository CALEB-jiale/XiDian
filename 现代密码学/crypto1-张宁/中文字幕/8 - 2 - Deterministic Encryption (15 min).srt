1
00:00:00,000 --> 00:00:04,045
在这一节里，我们来看一下在实际中经常出现的确定性加密的概念

2
00:00:04,045 --> 00:00:08,040
当我说到确定性加密系统时，

3
00:00:08,040 --> 00:00:12,001
我的意思是一个加密系统,总是会给消息映射到相同的密文

4
00:00:12,001 --> 00:00:15,981
所以如果我们加密相同的消息三次，每次都会得到确切地相同的密文

5
00:00:15,981 --> 00:00:19,885
这里没有用到随机数

6
00:00:19,885 --> 00:00:24,143
从字面上这只是一个一致性加密方案，对于给定的一个特定的消息

7
00:00:24,143 --> 00:00:28,100
它总是输出相同的密文。那么我们来看看，在实际中，

8
00:00:28,100 --> 00:00:32,416
特别是在查询到一个加密的数据库中时。

9
00:00:32,416 --> 00:00:36,524
想象我们有一个服务器，信息存储在一个加密的数据库。

10
00:00:36,524 --> 00:00:40,736
所以它将存储记录,

11
00:00:40,736 --> 00:00:44,886
每个记录都有一个索引和一些数据

12
00:00:44,886 --> 00:00:49,479
服务器要做的第一件事就是要加密这个记录。

13
00:00:49,479 --> 00:00:53,851
这有一个被加密的记录，你会注意到索引用K1加密，

14
00:00:53,851 --> 00:00:58,333
数据用K2加密，这个加密的记录被发送到数据库。

15
00:00:58,333 --> 00:01:02,704
许多记录也会被同样处理所以整个数据库会

16
00:01:02,704 --> 00:01:07,131
保存很多很多被加密的记录。再一次，你能想象到

17
00:01:07,131 --> 00:01:11,015
索引用密钥K1加密，数据用密钥K2加密。

18
00:01:11,015 --> 00:01:15,096
现在，如果加密是确定性的，好处是

19
00:01:15,096 --> 00:01:19,338
在以后，当服务器想从数据库中检索一个记录时，

20
00:01:19,338 --> 00:01:23,741
他需要做的就是将一个服务器感兴趣的加密索引发送到数据库中。

21
00:01:23,741 --> 00:01:28,091
所以，它将发送一个加密的索引，Alice。

22
00:01:28,091 --> 00:01:32,172
再次被加密，得到的密文

23
00:01:32,172 --> 00:01:36,145
和当记录第一次被写进数据库时生成的密文是一样的。

24
00:01:36,145 --> 00:01:40,462
数据库可以发现有加密索引的记录

25
00:01:40,462 --> 00:01:44,633
然后向服务器发送返回结果。它的好处是

26
00:01:44,633 --> 00:01:48,959
现在数据库完全在黑暗中至于在库中被存储的数据

27
00:01:48,959 --> 00:01:53,128
它甚至不知道被服务器返回的记录是什么

28
00:01:53,128 --> 00:01:57,018
因为它所看到的基本上是被加密的吸引的请求。

29
00:01:57,018 --> 00:02:00,858
所以这是确定性加密机制。我们来做一个快速查找

30
00:02:00,858 --> 00:02:05,209
在被给定的加密的索引的数据库中，因为确定性加密的性质

31
00:02:05,209 --> 00:02:09,622
索引将会以完全相同的方式加密,

32
00:02:09,622 --> 00:02:13,936
就如当记录被创建时的一样。这应该会令你们中的许多人感到不安

33
00:02:13,936 --> 00:02:18,250
因为我们之前所说的，确定性加密不能被选择明文安全。

34
00:02:18,250 --> 00:02:22,729
问题是攻击者可以看到不同的密文

35
00:02:22,729 --> 00:02:27,316
如果他看到相同的密文两次，他就知道

36
00:02:27,316 --> 00:02:31,904
接下来被加密的消息一定也是相同的。所以换句话说，

37
00:02:31,904 --> 00:02:36,382
通过看密文，他能学到关于通信明文的一些信息因为

38
00:02:36,382 --> 00:02:40,603
每次他看两次相同的密文，他会知道接下来的消息也是相同的

39
00:02:40,603 --> 00:02:45,240
实际上，这会导致很严重的攻击，特别是当消息空间很小的时候。

40
00:02:45,240 --> 00:02:50,107
例如，如果我们在网络上传输单一字节,

41
00:02:50,107 --> 00:02:54,573
如按键正在传播一个按键。

42
00:02:54,573 --> 00:02:58,924
事实上，攻击者可以简单地建立一个所有可能的密码文本的字典。

43
00:02:58,924 --> 00:03:03,561
如果它只是简单的字节，就将只有256个可能的密文

44
00:03:03,561 --> 00:03:07,970
然后，通过简单地学习这些密码的解密文本是什么,

45
00:03:08,142 --> 00:03:12,811
他可以找出所有未来的密码文本，通过简单地浏览这些

46
00:03:12,811 --> 00:03:17,256
在这字典里。因此,在许多情况下,消息这么小,

47
00:03:17,256 --> 00:03:21,357
这个,确定性加密,仅仅是不安全的。具体来说，

48
00:03:21,357 --> 00:03:25,510
至于一个加密的数据库，攻击者看到的是如果这有两个记录

49
00:03:25,510 --> 00:03:29,821
恰好有相同的密文在索引位置中，现在

50
00:03:29,821 --> 00:03:33,921
他知道那两个记录对应于相同的索引。

51
00:03:33,921 --> 00:03:38,400
即使他不知道这个索引是什么，但他能知道些关于通信的纯文本的一些信息。

52
00:03:38,400 --> 00:03:42,459
我想简要地提醒你，我们所说的确定性加密

53
00:03:42,459 --> 00:03:46,570
不是CPA安全的，通过描述一个敌手,赢得了CPA游戏

54
00:03:46,570 --> 00:03:50,682
被选的纯文本攻击游戏，让我来快速地给你介绍下它是如何进行的

55
00:03:50,682 --> 00:03:54,740
这个游戏通过敌手发送两条消息开始，M0和M0.

56
00:03:54,740 --> 00:03:58,852
记住这个，在这个游戏里，敌手总是被给左边消息的加密

57
00:03:58,852 --> 00:04:02,963
或者右边的加密。

58
00:04:02,963 --> 00:04:06,763
在这种情况下，因为他在两个案例中用了相同的消息，

59
00:04:06,763 --> 00:04:10,979
他只能得到一个消息M0的加密密文。

60
00:04:10,979 --> 00:04:14,874
下一步，他会发送消息M0和M1.现在他或者得到M0的加密

61
00:04:14,874 --> 00:04:18,823
或者得到M1的。他的目标就是辨别他得到的是哪个

62
00:04:18,823 --> 00:04:22,985
但是因为这个加密是确定性的，这对他来说是非常容易做到的。

63
00:04:22,985 --> 00:04:27,467
他需要做的就是辨别是否C等于C0.

64
00:04:27,467 --> 00:04:31,843
如果C等于C0，他会知道他得到的是M0的加密。

65
00:04:31,843 --> 00:04:36,422
如果C不等于C0，他会知道他得到的是M1的加密。所以他可以输出0.

66
00:04:36,422 --> 00:04:41,127
如果C等于C0，并输出了0，如果C不等于C0，

67
00:04:41,127 --> 00:04:45,719
在这个特殊的游戏中他会有个优势。

68
00:04:45,719 --> 00:04:50,306
所以,这将是一个高,尽可能高的优势,这意味着他攻击者完全击败了被选择的纯文本的安全。

69
00:04:50,306 --> 00:04:54,631
好了，这只是一个正式的方式说,

70
00:04:54,631 --> 00:04:59,579
攻击者基本上得到了比他应该知道的更多的纯文本信息。

71
00:04:59,579 --> 00:05:04,803
问题是，我们该怎么做呢？解决方案基本上是

72
00:05:04,803 --> 00:05:09,839
限制消息的类型，这消息可以被单密钥加密的。

73
00:05:09,839 --> 00:05:14,814
这个想法是说假如加密器从不用单密钥加密相同的消息

74
00:05:14,814 --> 00:05:19,415
换句话说消息密钥对总是不同的，从不重复

75
00:05:19,415 --> 00:05:24,328
所以对于每一个单独加密，要么消息改变，

76
00:05:24,328 --> 00:05:29,001
要么密钥改变，或两个都变。但是我们不能用一个密钥加密相同的消息两次。

77
00:05:29,001 --> 00:05:33,152
所以这怎么会发生的?

78
00:05:33,152 --> 00:05:37,194
这是在非常自然的情况下发生的。比如，

79
00:05:37,194 --> 00:05:41,509
如果消息是随机发生，加密机加密密钥和那些密钥,

80
00:05:41,509 --> 00:05:45,933
你知道的，说是128密钥，它们不会有非常高的概率，

81
00:05:45,933 --> 00:05:50,358
它们也从不会重复。在这种情况下当我们加密密钥是，事实上，

82
00:05:50,358 --> 00:05:54,617
极有可能所有用一个主密钥加密的消息总是不同的，

83
00:05:54,617 --> 00:05:59,021
因为，这些密钥极不可能出现重复。

84
00:05:59,021 --> 00:06:03,371
为什么消息从不重复的另一个原因简单说就是因为在消息空间里的一些结构。

85
00:06:03,371 --> 00:06:07,612
比如，如果我们加密的所有都是唯一的用户IDs。

86
00:06:07,612 --> 00:06:11,690
所以想象一下,在数据库示例中,该索引对应一个唯一的用户ID。

87
00:06:11,690 --> 00:06:16,040
如果恰好在数据库中有一个为每一位用户的记录，也就是说，

88
00:06:16,040 --> 00:06:20,666
每个被加密的记录基本上包含了一个被加密的索引，

89
00:06:20,666 --> 00:06:25,460
这个索引对于所有在数据库中的记录都是不同的。所以这就是为什么消息可能从不重复的两个原因。

90
00:06:25,627 --> 00:06:29,919
这是一个在实际中经常发生的相当合理的事情。

91
00:06:29,919 --> 00:06:34,897
所以现在如果消息从不重复，

92
00:06:34,897 --> 00:06:39,646
现在也许我们可以定义安全性,在实际中给出结构来满足我们的定义。

93
00:06:39,646 --> 00:06:44,511
所以引出了确定性选择明文攻击

94
00:06:44,511 --> 00:06:49,029
我来解释一下。通常我们有一个用加密算法定义的加密机

95
00:06:49,029 --> 00:06:53,662
我们有一个密钥空间、明文空间和密文空间

96
00:06:53,662 --> 00:06:58,098
我们用两个实验定义安全

97
00:06:58,098 --> 00:07:02,233
实验1和实验2。这个游戏看起来很熟悉

98
00:07:02,233 --> 00:07:06,630
和标准的选择明文攻击游戏几乎相同

99
00:07:06,630 --> 00:07:10,609
攻击者发出询问

100
00:07:10,609 --> 00:07:14,849
询问由M0和M1这对消息组成，通常长度相等

101
00:07:14,849 --> 00:07:18,984
对于每次询问，攻击者得到M0或M1的加密

102
00:07:18,984 --> 00:07:23,172
攻击者可以重复询问，重复Q次

103
00:07:23,172 --> 00:07:27,613
游戏最后，他要求说出他得到的是左边消息的加密

104
00:07:27,613 --> 00:07:32,318
还是右边消息的加密

105
00:07:32,318 --> 00:07:37,141
这就是标准的选择明文攻击游戏。这里提醒一下

106
00:07:37,141 --> 00:07:42,022
如果这个比特等于0，B等于0

107
00:07:42,022 --> 00:07:46,669
就是说，攻击者总是看到左边消息的加密，左边消息必须都互不相同

108
00:07:46,669 --> 00:07:51,433
也就是说，他永远不会看到两个相同消息的加密

109
00:07:51,433 --> 00:07:56,298
因为左边消息总是互不相同的

110
00:07:56,298 --> 00:08:00,496
因此如果B等于0，那么他永远不会看到相同消息用相同密钥加密

111
00:08:00,496 --> 00:08:05,353
因为这些消息0，从M1,0到MQ，0，都互不相同

112
00:08:05,353 --> 00:08:09,851
同样的，我们要求所有的消息1都互不相同

113
00:08:09,851 --> 00:08:14,586
那么如果B恰巧等于1，攻击者永远不会看到两个消息用相同密钥加密

114
00:08:14,586 --> 00:08:18,854
那么这些要求

115
00:08:18,854 --> 00:08:24,285
所有这些消息都互不相同，同样，所有这些Q个消息都不同

116
00:08:24,285 --> 00:08:29,005
捕获了这样的用例

117
00:08:29,005 --> 00:08:33,983
加密机永不使用一个特定密钥多次加密相同消息

118
00:08:33,983 --> 00:08:38,573
因此，攻击者不能多次请求相同消息的相同密钥的加密

119
00:08:38,573 --> 00:08:43,033
那么回到我们原始的攻击

120
00:08:43,033 --> 00:08:47,436
这里我们回到确定性加密的CPA攻击

121
00:08:47,436 --> 00:08:52,011
注意，这不是一个确定性CPA游戏

122
00:08:52,011 --> 00:08:56,471
因为攻击者不能两次请求相同消息的加密

123
00:08:56,471 --> 00:09:01,160
事实上，这个攻击在确定性CPA下是不合法的

124
00:09:01,160 --> 00:09:05,682
通过排除这个攻击

125
00:09:05,682 --> 00:09:09,939
我们使得对确定性CPA安全下结论更为可信了

126
00:09:09,939 --> 00:09:13,819
通常我们说如果当敌手得到左边消息或右边消息的加密时

127
00:09:13,819 --> 00:09:18,128
不能区分是实验0还是实验1

128
00:09:18,128 --> 00:09:22,202
那么这个机制是语义安全的

129
00:09:22,202 --> 00:09:26,114
在确定性CPA攻击下

130
00:09:26,114 --> 00:09:30,241
敌手在实验0中输出1的概率是多少？

131
00:09:30,241 --> 00:09:34,475
实验1中输出1的概率是多少？如果概率接近的话

132
00:09:34,475 --> 00:09:38,710
那么他攻击这个机制的概率是可以忽略的

133
00:09:38,710 --> 00:09:43,199
如果对所有有效敌手都如此，那么这个机制是确定性CPA攻击下的语义安全

134
00:09:43,199 --> 00:09:47,722
那么首先是我想展示的是

135
00:09:47,722 --> 00:09:52,188
使用固定IV的分组密码不是确定性CPA安全的

136
00:09:52,188 --> 00:09:56,597
这是实际中常见的错误

137
00:09:56,597 --> 00:10:01,177
许多产品都应该使用确定性CPA安全的密码

138
00:10:01,177 --> 00:10:05,968
然而他们只是使用固定IV的CBC，认为这是一个安全的机制，而事实上不是

139
00:10:06,150 --> 00:10:11,259
我来说明原因。假设我们有一个作用于N比特分组的PRP

140
00:10:11,259 --> 00:10:16,306
我们使用这个PRP的CBC模式

141
00:10:16,306 --> 00:10:20,519
如果消息有5个分组，那么PRP E会调用5次来加密每个分组

142
00:10:20,519 --> 00:10:24,767
接下来的是攻击的方法

143
00:10:24,767 --> 00:10:28,802
首先敌手会请求消息0^N 1^N的加密

144
00:10:28,802 --> 00:10:32,997
就是说，第一个分组全为0，第二个分组全为1。

145
00:10:32,997 --> 00:10:37,458
所以这里左边消息等于右边消息

146
00:10:37,458 --> 00:10:41,784
说明他只想要0^N 1^N这个消息的加密

147
00:10:41,784 --> 00:10:46,077
我们来看密文是怎样的。为了完整

148
00:10:46,077 --> 00:10:50,048
我把这个固定IV作为密文的第一个元素

149
00:10:50,048 --> 00:10:54,609
想想CBC的工作方式

150
00:10:54,609 --> 00:10:58,955
第二个密文元素将会是IV与消息第一分组的异或后加密

151
00:10:58,955 --> 00:11:03,087
在我们这个例子，消息第一个分组全为0，因此加密的就是固定的IV

152
00:11:03,087 --> 00:11:07,112
因此密文第二个分组就是固定IV的加密

153
00:11:07,112 --> 00:11:10,845
接下来敌手要做的是

154
00:11:10,845 --> 00:11:14,982
输出两个都只有一个分组的消息

155
00:11:14,982 --> 00:11:18,918
那么第一个消息，左边的消息将会是全0分组

156
00:11:18,918 --> 00:11:22,752
右边的消息是全1分组。观察这个有效的询问

157
00:11:22,752 --> 00:11:26,788
因为左边的消息都不同，右边的消息也不同

158
00:11:26,788 --> 00:11:30,471
因此这些是有效的确定性CPA询问

159
00:11:30,471 --> 00:11:34,240
那么攻击者将会得到什么回应呢？他会得到如下回应

160
00:11:34,240 --> 00:11:38,783
如果他得到左边消息的加密

161
00:11:38,783 --> 00:11:43,327
即一个分组0n的加密

162
00:11:43,327 --> 00:11:48,107
正如之前看到的，也就是固定IV的加密

163
00:11:48,107 --> 00:11:52,671
然而如果他得到右边消息的加密，即1异或固定IV的加密

164
00:11:52,671 --> 00:11:56,884
这是CBC加密的定义

165
00:11:56,884 --> 00:12:01,370
你可以看到攻击是如何进行的。注意，我在这里用不同的颜色

166
00:12:01,370 --> 00:12:05,802
注意如果这两个分组恰巧是相同的

167
00:12:05,802 --> 00:12:10,356
那我们知道他得到的是左边消息的加密，也就是说B等于0

168
00:12:10,356 --> 00:12:14,885
如果不相同，那么他知道B等于1

169
00:12:14,885 --> 00:12:19,127
因此他输出0，当C[1]，也就是这个分组，

170
00:12:19,127 --> 00:12:23,599
等于C[2]，也就是这个分组。其他时候输出1

171
00:12:23,599 --> 00:12:28,070
所以这证明使用固定IV的CBC是完全不安全的

172
00:12:28,070 --> 00:12:32,542
第一个分组很容易被攻击

173
00:12:32,542 --> 00:12:37,185
事实上，如果消息很短，你可以创建字典

174
00:12:37,185 --> 00:12:41,996
然后完全攻陷使用固定IV的CBC的系统

175
00:12:41,996 --> 00:12:46,520
所以不要这么做。下一节我们会看到安全的确定性CPA构造

176
00:12:46,520 --> 00:12:50,872
所以我再说一遍，如果你需要用一致的方式加密数据库索引

177
00:12:50,872 --> 00:12:55,316
不要使用固定IV的CBC

178
00:12:55,316 --> 00:12:59,939
要使用我下节要讲的机制

179
00:12:59,939 --> 00:13:04,225
那么对于固定IV的计数器模式，我要问相同的问题

180
00:13:04,225 --> 00:13:08,848
这是不是确定性CPA安全的系统？我来提醒你什么是固定IV的计数器模式

181
00:13:08,848 --> 00:13:13,021
我们连接固定IV，固定IV加1，固定IV加L

182
00:13:13,021 --> 00:13:17,645
我们加密所有计数器，连接所有结果，我们加密所有消息得到密文

183
00:13:17,645 --> 00:13:22,919
那么你认为这是确定性CPA安全的吗？

184
00:13:22,922 --> 00:13:27,504
我希望每个人都回答不是

185
00:13:27,504 --> 00:13:32,152
这是一次性密码本，如果我们用一次性密码本加密不同消息

186
00:13:32,152 --> 00:13:36,638
那么我们得到两次密码本。为了看得更清楚，我把确定性CPA游戏写在这里

187
00:13:36,638 --> 00:13:41,066
那么注意，攻击者将会这么做

188
00:13:41,066 --> 00:13:45,955
他首先请求消息m的加密

189
00:13:45,955 --> 00:13:50,555
那么他会得到消息m异或固定IV的加密

190
00:13:50,555 --> 00:13:55,099
然后他请求与消息m不同的消息m0和m1

191
00:13:55,099 --> 00:13:59,527
那么m,m0,m1是三个不同的消息

192
00:13:59,527 --> 00:14:05,222
然后他得到mb的加密。现在他可以简单的进行两次密码本攻击

193
00:14:05,222 --> 00:14:10,658
如果c异或c'等于m异或m0

194
00:14:10,658 --> 00:14:15,348
他就知道c'是m0的加密，否则是m1的加密

195
00:14:15,348 --> 00:14:19,975
因此他赢得游戏的优势为1

196
00:14:19,975 --> 00:14:24,411
好的，使用固定IV的确定性CPA

197
00:14:24,411 --> 00:14:29,482
作为确定性CPA密码是完全不安全的

198
00:14:29,482 --> 00:14:29,482
所以，不要使用这些机制，而要用我下节描述的机制。【END】

