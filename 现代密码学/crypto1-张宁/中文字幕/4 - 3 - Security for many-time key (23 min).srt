1
00:00:00,000 --> 00:00:04,669
在这一节，我们来看一下
分组密码是如何用同一个密钥加密

2
00:00:04,669 --> 00:00:08,959
多条消息的。例如，在实际应用中，文件系统

3
00:00:08,959 --> 00:00:13,412
用同一个密钥来加密多个文件。
在网络协议中，同一个密钥

4
00:00:13,412 --> 00:00:17,647
被用来加密多个包。
我们来看一下如何实现这些。

5
00:00:17,647 --> 00:00:21,883
首先我们需要做的是定义
对于一个用同一个密钥加密多条信息的密码来说，

6
00:00:21,883 --> 00:00:26,185
什么才是安全的。当我们对一个密钥

7
00:00:26,185 --> 00:00:31,041
使用超过一次的结果就是
敌手得到用同一密钥加密出的许多密文。

8
00:00:31,041 --> 00:00:35,627
于是，当我们加密时，我们将

9
00:00:35,627 --> 00:00:40,512
使我们的敌手能够采取选择明文攻击。

10
00:00:40,512 --> 00:00:45,522
换句话说，敌手将获得他所选择的任意信息的密文。

11
00:00:45,522 --> 00:00:49,710
例如，如果敌手要和Alice通信，那么他可以

12
00:00:49,710 --> 00:00:53,924
让Alice加密任何一条他所选择的消息。

13
00:00:53,924 --> 00:00:58,138
那么Alice会继续并且加密那些信息，然后

14
00:00:58,138 --> 00:01:02,929
把得到的密文给他。
你可能会想Alice为什么要这么做呢?

15
00:01:02,929 --> 00:01:07,431
这在真实生活中怎么可能发生呢？
但结果这恰恰在现实生活中经常发生。

16
00:01:07,431 --> 00:01:11,760
而且实际上，这个模式还是一种在现实生活中

17
00:01:11,760 --> 00:01:16,320
较保守的模式。举个例子，
敌手可能会给Alice发一封电子邮件。

18
00:01:16,320 --> 00:01:21,168
当Alice接收到邮件后，把它写入到她的加密盘中，这样就用她的

19
00:01:21,168 --> 00:01:26,140
密钥加密了对方的邮件。
如果之后敌手盗取了这个盘，

20
00:01:26,140 --> 00:01:31,280
那么他就获得了用Alice的密钥加密的邮件的密文。

21
00:01:31,280 --> 00:01:36,298
这就是一个选择明文攻击的例子，
就是敌手给Alice提供一条信息，

22
00:01:36,298 --> 00:01:41,075
Alice用自己的密钥加密了这条信息。

23
00:01:41,075 --> 00:01:45,429
之后攻击者设法得到了密文。
这就是敌手所具有的能力。

24
00:01:45,429 --> 00:01:49,661
然后敌手的目标基本就是破坏语义安全性。

25
00:01:49,661 --> 00:01:54,368
让我们来更准确地定义一下。
同往常一样，我们要

26
00:01:54,368 --> 00:01:59,447
用两个实验，实验0和实验1来定义
在选择明文攻击下的语义安全性。

27
00:01:59,447 --> 00:02:04,717
这两个实验被设置成一场在一个挑战者

28
00:02:04,717 --> 00:02:09,669
和对手之间的游戏。当游戏开始时，
挑战者将会选择一个随机密钥K。

29
00:02:09,669 --> 00:02:14,006
现在对手开始查询挑战者，

30
00:02:14,006 --> 00:02:18,198
他给挑战者提交一个语义安全的询问。

31
00:02:18,198 --> 00:02:22,804
就是提交两条信息，M0和M1。
我在M下面加了另一个下标，

32
00:02:22,804 --> 00:02:27,351
但让我们先暂时忽略这个下标。
所以对手提交了两条信息，M0和M1。

33
00:02:27,351 --> 00:02:31,780
两条信息都恰好有相同的长度。然后攻击者收到

34
00:02:31,780 --> 00:02:36,031
两条中其中一条经过加密的信息，不管是M0还是M1.

35
00:02:36,031 --> 00:02:40,224
在实验零中，他收到M0经过加密的密文。

36
00:02:40,224 --> 00:02:44,952
在实验一中，它收到M1经过加密的密文。
目前为止，这看上去很熟悉，完全就像一个标准的

37
00:02:44,952 --> 00:02:49,477
语义安全一样。然而，在选择明文攻击下，

38
00:02:49,477 --> 00:02:54,007
敌手可以再次重复这一查询过程。所以现在你能发送一个含有

39
00:02:54,007 --> 00:02:58,485
另外两个明文的查询，长度还是相同的。你将会再一次收到两条信息

40
00:02:58,485 --> 00:03:03,189
中一条的密文。在实验0中你会得到M0的密文。

41
00:03:03,189 --> 00:03:07,837
在实验1中，你会得到M1的密文。攻击者可以

42
00:03:07,837 --> 00:03:12,542
继续发送像这样的查询。实际上他可以发送

43
00:03:12,542 --> 00:03:17,020
Q次这样的查询。记住，每次他都会发送一对消息。

44
00:03:17,020 --> 00:03:21,416
这对信息恰好有相同的长度并且每次他都会得到左侧

45
00:03:21,416 --> 00:03:25,867
或者右侧信息的密文，在实验0中他会得到左侧信息的密文。

46
00:03:25,867 --> 00:03:29,727
在实验1中他会得到右侧消息的密文。

47
00:03:29,727 --> 00:03:33,970
之后，敌手的目的就是搞清楚他是在

48
00:03:33,970 --> 00:03:38,289
实验0还是实验1当中。换句话说，他是一直

49
00:03:38,289 --> 00:03:42,713
收到左侧信息的密文还是一直收到右侧信息的密文。

50
00:03:42,713 --> 00:03:47,032
所以，从某种程度上来说，
这就是一个标准的语义安全游戏，

51
00:03:47,032 --> 00:03:51,193
仅仅就是重复许多次查询直到攻击者
能够适应地发送一条接一条的信息。

52
00:03:51,193 --> 00:03:56,014
所以选择明文攻击受限于这个事实，如果攻击者

53
00:03:56,014 --> 00:04:00,646
想要得到一条特定消息m的密文，他能做的就是，

54
00:04:00,646 --> 00:04:05,234
比如，使用查询J。在查询J中，他会将M0和M1设置

55
00:04:05,234 --> 00:04:09,593
成同一个M。换句话说，

56
00:04:09,593 --> 00:04:14,008
左侧和右侧的信息都是相同的，

57
00:04:14,008 --> 00:04:18,653
都被设置成M。在这个情况下，
因为两条信息都是一样的，在他所得到的密文中，

58
00:04:18,653 --> 00:04:23,126
他很清楚他将得到他感兴趣的信息M的密文。

59
00:04:23,126 --> 00:04:27,600
这就是我们所说的选择明文攻击。

60
00:04:27,600 --> 00:04:32,598
在这种攻击方式下，敌手能够提交信息m并且得到

61
00:04:32,598 --> 00:04:37,429
他所选择的特定信息m的密文。
所以他的某些查询会是这种

62
00:04:37,429 --> 00:04:42,157
左侧信息和右侧信息相同的选定明文的风格。

63
00:04:42,157 --> 00:04:46,775
但是有一些查询可能是标准语义安全查询，

64
00:04:46,775 --> 00:04:51,281
这个查询给出的两条信息有区别
并能给他足够的信息使他区分出

65
00:04:51,281 --> 00:04:55,453
自己在实验0还是在适应1。
到目前为止，你应该能够习惯这个

66
00:04:55,453 --> 00:05:00,182
在选择明文攻击下一个系统语义安全性的定义。

67
00:05:00,182 --> 00:05:04,141
如果对于所有有能力的敌手，他们不能够区分

68
00:05:04,141 --> 00:05:08,703
实验0和实验1的话，那么换句话说，到最后，

69
00:05:08,703 --> 00:05:13,091
我们将输出用Exp(b)来表示。那么

70
00:05:13,091 --> 00:05:17,769
这个输出不管在实验0还是在实验1中都是一样的。

71
00:05:17,769 --> 00:05:22,310
所以攻击者不能分辨是一直收到

72
00:05:22,310 --> 00:05:26,900
左侧的信息的密文还是一直收到右侧信息的密文。

73
00:05:26,900 --> 00:05:31,267
所以对于你们来说，我希望你们将敌手看成能够

74
00:05:31,267 --> 00:05:35,745
使用选择明文攻击，得到任意
他所选择的信息的密文的攻击者。

75
00:05:35,745 --> 00:05:40,168
而且他的目标就是破坏
其他一些有挑战性的密文的

76
00:05:40,168 --> 00:05:44,330
语义安全性。正如我所说的，在这个真实情况下，

77
00:05:44,330 --> 00:05:48,721
攻击者能够欺骗Alice让其加密他所选择的消息，

78
00:05:48,721 --> 00:05:53,287
之后攻击者的目标是用某种方式破解密文。

79
00:05:53,287 --> 00:05:58,173
所以我说到目前为止我们所见过的密码中，
例如，确定性计数器模式或者是一次一密

80
00:05:58,173 --> 00:06:02,541
对于选择明文攻击来说都是不安全的。更广泛地来说，

81
00:06:02,541 --> 00:06:07,312
假设我们的加密系统总是对一个特定的信息M

82
00:06:07,312 --> 00:06:11,968
输出相同的密文，换句话说，
如果我用一种加密方式加密信息M一次，

83
00:06:11,968 --> 00:06:16,188
然后我又让这种加密方式再加密一次信息m

84
00:06:16,188 --> 00:06:21,183
如果在两种情形下，
加密方式输出的密文都是相同的话，

85
00:06:21,183 --> 00:06:26,550
那么这种系统在面对选择明文攻击时
是完全不可能安全的。

86
00:06:26,550 --> 00:06:31,281
确定性计数器模式和一次一密都是这种风格的密码，

87
00:06:31,281 --> 00:06:35,923
它们总是对同样的信息输出相同的密文。
所以让我们来看看

88
00:06:35,923 --> 00:06:41,143
为什么它们不能是选择明文安全的。
这种攻击方式十分简单，攻击者所做的

89
00:06:41,143 --> 00:06:46,300
就是他将同一个信息输出两次。这就是说，

90
00:06:46,300 --> 00:06:51,233
他真正想要得到的是信息M0的密文。
所以在这攻击者得到了信息M0的密文也就是C0

91
00:06:51,233 --> 00:06:55,872
所以这就是他的选择明文查询，在这样的查询中

92
00:06:55,872 --> 00:07:00,805
他得到的就是他所选择的的信息M0加密后的密文。
现在他就可以破坏语义安全性。

93
00:07:00,805 --> 00:07:05,445
所以他所做的就是输出两条信息，
具有相同长度的M0和M1

94
00:07:05,445 --> 00:07:10,084
然后他将得到信息MB加密后的密文。但是往下接着看，

95
00:07:10,084 --> 00:07:15,850
我们所说的加密系统在加密信息M0时总是输出相同的密文

96
00:07:15,850 --> 00:07:21,539
所以，如果B=0的话，我们就知道密文C

97
00:07:21,539 --> 00:07:27,310
会等于C0，因为它是M0经过加密后的密文。

98
00:07:27,310 --> 00:07:32,409
然而，如果B=1的话，那么我们知道这个密文是M1经过

99
00:07:32,409 --> 00:07:38,048
加密得到的，而这个密文并不等于C0，
所以攻击者所要做的只是

100
00:07:38,048 --> 00:07:43,441
检查C是否等于C0，等于0的话就输出0否则输出就是1。

101
00:07:43,441 --> 00:07:47,722
在这个情况下，攻击者能够完美地猜测出B，

102
00:07:47,722 --> 00:07:52,412
于是他完全知道他得到的是什么。
是M0的密文，或者是M1的密文。于是结果就是

103
00:07:52,412 --> 00:07:57,103
他赢得游戏的只依赖于一个优势。
这就意味着这个系统不可能。

104
00:07:57,103 --> 00:08:01,491
对选择明文攻击来说是安全的。
1并不是一个可以被忽略的数。这就意味着

105
00:08:01,491 --> 00:08:05,582
确定性的加密方式不可能对于选择明文攻击
来说是安全的，但是你也可能会想

106
00:08:05,582 --> 00:08:09,345
这在实际中又意味着什么呢？在实际中，这意味着

107
00:08:09,345 --> 00:08:13,111
每一条信息总是被加密成相同的密文。这就是说

108
00:08:13,111 --> 00:08:17,234
如果你加密光盘上的文件，你恰好加密两个

109
00:08:17,234 --> 00:08:21,407
完全相同的文件，那么你就会得到相同的密文

110
00:08:21,407 --> 00:08:25,327
然后攻击者看到被加密的光盘后就可以得知这两个文件

111
00:08:25,327 --> 00:08:29,297
实际上包含着相同的内容。
攻击者可能不知道内容是什么

112
00:08:29,297 --> 00:08:33,419
但是这样攻击者就知道这两个被加密的文件
是同一个内容经过加密得到的，

113
00:08:33,419 --> 00:08:37,524
而这是攻击者不应该知道的。
相似地，如果你在网络上发送两个

114
00:08:37,524 --> 00:08:41,287
恰好相同的加密包，攻击者并不会知道这些

115
00:08:41,287 --> 00:08:45,146
包的内容，但是他会知道这两个包实际上

116
00:08:45,146 --> 00:08:49,301
包含着相同的信息。举个加密语音通话的

117
00:08:49,301 --> 00:08:53,769
例子，每当通话线上没有声音时，系统就会发送0的

118
00:08:53,769 --> 00:08:58,072
加密。但是由于0的加密总是对应着相同的密文

119
00:08:58,072 --> 00:09:02,334
一个注意到这一网络的攻击者将能够辨别出

120
00:09:02,334 --> 00:09:06,489
通话中没有声音的时间点，因为他每次总能够观察到

121
00:09:06,489 --> 00:09:11,113
那些完全相同的密文。这就是一些说明确定性加密系统

122
00:09:11,113 --> 00:09:15,492
不安全的例子。正如我之前所说，确定性加密系统

123
00:09:15,492 --> 00:09:19,800
在面对选择明文攻击时语义上是不安全的，

124
00:09:19,800 --> 00:09:24,743
那么我们应该怎么做呢？
经验就是如果一个密钥

125
00:09:24,743 --> 00:09:29,674
要被用做加密多条信息，
那么最好，就是如果对同一条明文要

126
00:09:29,674 --> 00:09:33,572
加密两次，加密算法一定要能够产生

127
00:09:33,572 --> 00:09:38,147
不同的密文。这里一共有两种方式来实现这一点。

128
00:09:38,147 --> 00:09:42,836
第一种方法被称为随机化加密。这种加密方式

129
00:09:42,836 --> 00:09:47,296
在加密过程中将会选择一些随机的字符串，而且

130
00:09:47,296 --> 00:09:51,642
它将会用随机字符串来加密信息M。
所以这就意味着，对于

131
00:09:51,642 --> 00:09:56,389
一个特定的信息M0来说，
它将不会被直接加密成一条密文，

132
00:09:56,389 --> 00:10:00,894
而是被对应到整个密文构成的集合中。
在每一次的加密过程中，

133
00:10:00,894 --> 00:10:06,692
基本上，我们输出集合中的一个点。
所以每一次的加密，

134
00:10:06,692 --> 00:10:11,292
加密算法都会选择一个随机的字符串，
并且每一个字符串都对应着集合中的一个点。

135
00:10:11,292 --> 00:10:15,832
当然，在解密算法中，当选取集合中的任意一点时，

136
00:10:15,832 --> 00:10:20,610
它将把结果对应到M0。相似地，密文M1

137
00:10:20,610 --> 00:10:25,449
也将会被对应到集合当中，于是每一次加密M1，

138
00:10:25,449 --> 00:10:29,690
我们基本上输出集合中一个点。
并且这些集合都是不相交的。

139
00:10:29,690 --> 00:10:34,469
所以对于加密算法，
当它包含集合中的对应与M1的一个点时，

140
00:10:34,469 --> 00:10:38,964
总会输出M1。这样，由于加密算法运用了随机性，

141
00:10:38,964 --> 00:10:43,266
如果我们对同一条信息加密两次，将会有很大的概率

142
00:10:43,266 --> 00:10:47,144
得到不同的密文。不幸的是，这就意味着密文

143
00:10:47,144 --> 00:10:51,393
将必须比明文要长。因为从某种意思上来说

144
00:10:51,393 --> 00:10:55,855
我们利用来生成密文的随机字符串
是被编码在密文中的。

145
00:10:55,855 --> 00:11:00,158
所以密文将会占用更多的空间。
大致来说，密文的体积将会

146
00:11:00,158 --> 00:11:04,620
比明文的体积大被用于加密的随机比特串的长度。

147
00:11:04,620 --> 00:11:08,748
所以如果明文十分的大的话，

148
00:11:08,748 --> 00:11:13,203
比如明文有几个G比特那么长的话，
那么随机数比特将会是128的阶。

149
00:11:13,203 --> 00:11:17,494
也许这多出来的空间并没有什么影响，

150
00:11:17,494 --> 00:11:21,786
但是如果明文十分短的话，比如只有128比特那么长，
那么给每一条密文都加上多余的128比特

151
00:11:21,786 --> 00:11:26,240
将会使密文的长度变为原来的两倍。
这样的代价将会是十分高昂的。

152
00:11:26,240 --> 00:11:31,117
正如我所说的，随机数加密是一个不错的解决方案，

153
00:11:31,117 --> 00:11:35,862
但是在一些情况下它也会带来一定的成本。
让我们来看一个简单的例子，

154
00:11:35,862 --> 00:11:41,107
假设我们有一个伪随机函数，这个函数将输入放入到

155
00:11:41,107 --> 00:11:46,223
一个特定的r空间中，我们将这个空间称为临时空间，
而输出会被放到一个信息空间中。

156
00:11:46,223 --> 00:11:50,636
现在让我们来定义下面这个随机加密方式，

157
00:11:50,636 --> 00:11:55,880
在这种加密方式中我们想要用加密算法来加密信息M。

158
00:11:55,880 --> 00:12:01,149
而算法首先要做的就是在临时空间R中生成一个随机的r。

159
00:12:01,149 --> 00:12:06,232
然后,他会输出一个由两部分组成的密文，

160
00:12:06,232 --> 00:12:10,943
第一个部分就是这个这个r的值，第二个部分就是

161
00:12:10,943 --> 00:12:16,180
伪随机函数在R点处的值于信息R的异或。然后问题来了，

162
00:12:16,180 --> 00:12:21,397
这个加密系统在面对选择明文攻击时是语义安全的吗？

163
00:12:21,397 --> 00:12:26,290
正确的答案是安全的。但是只有当临时空间R

164
00:12:26,290 --> 00:12:31,249
大到让小小的r不会以一个很高的概率出现才是安全的。

165
00:12:31,249 --> 00:12:36,332
让我们来很快地讨论下为什么这是安全的。
首先，因为F是一个安全的伪随机函数，

166
00:12:36,332 --> 00:12:41,352
当然我们也可以用以个真正的随机函数来替代它，换句话说，

167
00:12:41,352 --> 00:12:46,373
当我们用真随机函数f在R点处的值异或上M，

168
00:12:46,373 --> 00:12:51,252
和用伪随机函数做同样的操作时，二者是无法被区分的。

169
00:12:51,252 --> 00:12:57,320
但是由于r从来不会重复。每一个密文都会用不同的r，

170
00:12:57,320 --> 00:13:03,095
这就意味着F(r)的值每次都是统一独立的字符串。

171
00:13:03,095 --> 00:13:08,818
所以我们每加密一条信息，本质上都是在用一个

172
00:13:08,818 --> 00:13:14,369
新的独立的一次性的密码本。
由于将一个独立的字符串与任意一个字符串异或

173
00:13:14,369 --> 00:13:19,666
都会生成一个新的独立的字符串，得到的密文被分成了

174
00:13:19,666 --> 00:13:24,767
两个独立随机的字符串。我将它们称做r和r'。

175
00:13:24,767 --> 00:13:30,325
所以在实验0和实验1中，
所有的攻击者都将会看到独立随机的字符串r和r'，

176
00:13:30,325 --> 00:13:35,622
又因为在两个实验中攻击者看到的是同一个部分，

177
00:13:35,622 --> 00:13:40,666
他不能够区分出两个部分来。而且

178
00:13:40,666 --> 00:13:45,695
当我们使用真正的随机函数时安全性可也得到完全保证，
当我们使用伪随机函数时安全性也可以得到保证。

179
00:13:45,695 --> 00:13:50,559
好的，这是一个好的例子。

180
00:13:50,559 --> 00:13:55,435
用随机函数和伪随机函数的相同特点
来讨论特定加密方案的例子。

181
00:13:55,435 --> 00:13:59,829
好的，我们已经看了一个很巧妙的随机加密的例子。

182
00:13:59,829 --> 00:14:04,465
另一个构造选择明文安全的加密方案的方法

183
00:14:04,465 --> 00:14:09,344
被称为基于临时的加密方案。

184
00:14:09,344 --> 00:14:14,012
在一个基于临时的加密系统中，加密算法采用三个输入

185
00:14:14,012 --> 00:14:19,044
而不是两个。照例，它将信息和密钥作为输入。

186
00:14:19,044 --> 00:14:23,773
但是它又有另一个输入，叫做临时值。
相似的，解密算法也将

187
00:14:23,773 --> 00:14:28,683
临时值作为输入，并且产生经解密后的明文。

188
00:14:28,683 --> 00:14:33,529
而这个临时值n又是什么呢？
它是一个公开的值，它不需要对对手隐藏，

189
00:14:33,529 --> 00:14:38,402
但是唯一的要求是：

190
00:14:38,402 --> 00:14:43,213
有序数对(k,n)只被用来加密一条信息。
换句话说，这个有序数对(k,n)

191
00:14:43,213 --> 00:14:48,148
必须不断的根据不同的信息作出改变。
这里有两种方法来改变数对的值。

192
00:14:48,148 --> 00:14:53,144
一种方法是对每一条信息都用一个新的随机密钥，

193
00:14:53,144 --> 00:14:58,276
而另一种方法是一直使用同样的密钥，
但是我们必须对每一条信息选一个新的临时值。

194
00:14:58,276 --> 00:15:02,721
正如我所说的,我想再次强调一下，这个临时值不需要

195
00:15:02,721 --> 00:15:06,823
是秘密的也并不需要是随机的。
唯一的要求是这个临时值是唯一的。

196
00:15:06,823 --> 00:15:11,029
而事实上，我们在整个课程过程都将使用这个术语。

197
00:15:11,029 --> 00:15:15,247
临时值对于我们来说意味着一个
永不重复的唯一的值，它不必是随机的。

198
00:15:15,247 --> 00:15:19,891
让我们来看一些选择临时值的例子，最简单的选择就是

199
00:15:19,891 --> 00:15:24,255
把临时值当做一个计数器，例如在网络协议中

200
00:15:24,255 --> 00:15:28,898
你可以将临时值想象成一个计数器。这个计数器

201
00:15:28,898 --> 00:15:33,598
收到一个由发送者发出的包或发出一个包时就会自增。

202
00:15:33,598 --> 00:15:37,962
这就意味着加密器必须维护一条又一条信息的状态，

203
00:15:37,962 --> 00:15:42,270
它主要是让计数器保持运转并且
在每一条信息被传送后都自增一次。

204
00:15:42,270 --> 00:15:47,487
有趣的是，如果解密器有着同样的状态，

205
00:15:47,487 --> 00:15:52,705
那么就没有在密文中包含临时值的必要，
因为临时值是隐含的。让我们来看一个例子

206
00:15:52,705 --> 00:15:57,987
https协议在一个可靠的传送机制上面运行，在这个机制中，

207
00:15:57,987 --> 00:16:03,075
被发送出去的包总是假设以同样的顺序被接收者接收的

208
00:16:03,075 --> 00:16:07,645
所以如果发送者先发了第五个包再发送第六个包，那么接受者将

209
00:16:07,645 --> 00:16:12,068
会以同样的顺序收到第五个包和第六个包。

210
00:16:12,068 --> 00:16:16,215
这就意味着如果发送者维护一个包计数器，接收者也能维护一个

211
00:16:16,215 --> 00:16:20,860
包计数器而且两个计数器基本上同时自增。在这种情况下

212
00:16:20,860 --> 00:16:24,896
就没有在包中包含临时值的必要，因为

213
00:16:24,896 --> 00:16:29,476
临时值是隐含在两边的。然而，在其他协议中，例如

214
00:16:29,476 --> 00:16:34,600
IPsec协议。IPsec有一种为加密IP层而设计的协议。

215
00:16:34,600 --> 00:16:39,330
IP协议并不保证顺序收发包裹。发送者可能先发

216
00:16:39,330 --> 00:16:44,520
第五个包再发第六个包，但是这些包会以相反的顺序被接受者收到。

217
00:16:44,520 --> 00:16:49,164
在这种情况下也可以以包计数器来作为临时值

218
00:16:49,164 --> 00:16:53,748
但是现在临时值必须被包含在包中这样接收者才能知道

219
00:16:53,748 --> 00:16:58,102
用哪个临时值来解密收到的包。
正如我所说，基于临时值的

220
00:16:58,102 --> 00:17:02,686
加密方案是一种实现CPA安全的有效方式。

221
00:17:02,686 --> 00:17:07,098
尤其是当临时值是隐含的时候，
它甚至不会增加密文的长度。当然

222
00:17:07,098 --> 00:17:11,796
另一种生成唯一临时值的方法就是随机选一个临时值，

223
00:17:11,796 --> 00:17:16,495
假设临时值空间足够大来保证有很大的概率

224
00:17:16,495 --> 00:17:21,579
临时值在一个密钥的生命周期中永远不会重复。
在现在这个情况下，基于临时值的加密方案

225
00:17:21,579 --> 00:17:26,098
被弱化为随机加密方案。然而，

226
00:17:26,098 --> 00:17:31,600
这样的好处在于发送者不需要
在一条又一条的信息中维护任何状态

227
00:17:31,600 --> 00:17:36,382
所以当加密方案恰好被用在多个设备上，

228
00:17:36,382 --> 00:17:41,425
这就显得十分有用。举个例子，
我可能同时有一台笔记本和智能手机，

229
00:17:41,425 --> 00:17:46,096
它们可能使用着同样的密钥。
但是在这种情况下如果我需要状态安全加密，

230
00:17:46,097 --> 00:17:49,961
那么，我的笔记本电脑和智能手机将相互协调来保证

231
00:17:49,961 --> 00:17:54,302
它们不会使用相同的临时值。
然而如果两个设备都仅仅用

232
00:17:54,302 --> 00:17:58,114
随机的临时值，那么它们不需要协调因为有很大的概率

233
00:17:58,114 --> 00:18:02,243
它们不会选到同样的临时值，这也是在假设

234
00:18:02,243 --> 00:18:06,478
临时值空间很大的情况下。
所以在某些情况下，无状态的加密方案是很重要的，

235
00:18:06,478 --> 00:18:10,562
特别是当同一个密钥被用在不同的机器上时。

236
00:18:10,562 --> 00:18:14,492
所以我想更准确的知道，
安全对基于临时值的加密方案来说意味着什么。

237
00:18:14,492 --> 00:18:18,694
特别地，我想强调一下系统在对手选择

238
00:18:18,694 --> 00:18:23,122
临时值时必须保持安全状态。

239
00:18:23,122 --> 00:18:27,027
允许敌手来选择临时值的很重要的原因是因为对方可以

240
00:18:27,027 --> 00:18:31,090
选择要攻击的密文。所以假设临时值碰巧是一个

241
00:18:31,090 --> 00:18:35,364
计数器而且更碰巧的是计数器的值就是15，

242
00:18:35,364 --> 00:18:39,428
也许这样的话，对方就能很容易的破坏语义安全。

243
00:18:39,428 --> 00:18:43,702
所以敌手会等到15个包都被发送后，
也只有在这个时候他才能够

244
00:18:43,702 --> 00:18:48,076
破坏语义安全性。
所以当我们谈论基于临时值的加密方案时，

245
00:18:48,076 --> 00:18:52,806
我们总是允许对手来选择临值而且系统应当在

246
00:18:52,806 --> 00:18:57,772
这样的设定下仍然保持安全状态。
所以让我们在这样的情况下定义一个CPA游戏，

247
00:18:57,772 --> 00:19:02,442
它和之前的游戏很相似，基本上攻击者提交

248
00:19:02,442 --> 00:19:06,935
一对信息MI0和MI1。显然，它们必须有相同的长度

249
00:19:06,935 --> 00:19:11,576
然后他开始提供临时值。作为回应，敌手会

250
00:19:11,576 --> 00:19:16,304
收到MI0或者MI1经过加密后的密文，
但是使用的是敌手所选择的临时值。

251
00:19:16,304 --> 00:19:20,740
当然同样，敌手的目标是分别出他得到的密文是

252
00:19:20,740 --> 00:19:25,096
左侧明文的加密还是右侧明文的加密。

253
00:19:25,096 --> 00:19:29,464
和之前一样，敌手会重复这些查询
并且他可以发出任何数量的的查询，

254
00:19:29,464 --> 00:19:33,610
我们通常用q来表示对方发送查询的次数

255
00:19:33,610 --> 00:19:37,956
这里唯一的限制，也是很关键的一点，

256
00:19:37,956 --> 00:19:42,329
就是即使对方选择了临时值，
他也是被限制选择不同的临时值。

257
00:19:42,329 --> 00:19:46,758
我们强迫他选择不同的临时值的原因是因为

258
00:19:46,758 --> 00:19:50,959
这是在实践中的要求。即便敌手欺骗Alice，

259
00:19:50,959 --> 00:19:55,161
让其为他加密多条信息，
Alice也不会再一次使用相同的临时值。

260
00:19:55,161 --> 00:19:59,477
结果就是，敌手将永远不能看到
用同一个临时值加密的的信息，

261
00:19:59,477 --> 00:20:03,678
所以在这样的游戏中，
我们要求所有的临时值必须是不同的。

262
00:20:03,678 --> 00:20:08,305
和通常一样，我们称这个系统
是一个基于临时值加密的系统。

263
00:20:08,305 --> 00:20:13,412
也就是一个在面对选择明文攻击时语义安全的系统，

264
00:20:13,421 --> 00:20:17,890
当敌手不能分辨出在实验0中得到的左侧信息的加密

265
00:20:17,890 --> 00:20:22,593
和实验1中得到的右侧信息的加密时。

266
00:20:22,593 --> 00:20:27,121
让我们来看一个基于临时值加密系统的例子。

267
00:20:27,121 --> 00:20:32,119
同之前一样，我们有一个安全的伪随机函数，
这个函数把输入放到临时值空间R中，

268
00:20:32,119 --> 00:20:36,823
并且把输出字符串放到信息空间M中。
当选择一个新的密钥时，我们将我们的计数器R重置为0。

269
00:20:36,823 --> 00:20:41,006
现在我们来加密一个特定的信息M，我们要做的就是

270
00:20:41,006 --> 00:20:45,103
让计数器R自增，然后用伪随机函数在R处的值来

271
00:20:45,103 --> 00:20:49,481
加密信息M。和之前一样，密文

272
00:20:49,481 --> 00:20:53,859
有两个部分组成，计数器的当前值和

273
00:20:53,859 --> 00:20:58,518
经过一次一密加密的信息M。
所以我的问题是这个临时值空间

274
00:20:58,518 --> 00:21:03,312
的加密系统是不是安全的。之前我们的回答是安全的，

275
00:21:03,312 --> 00:21:08,485
但是仅当临时值空间足够大的时候才成立，
所以当我们增加计数器R时，它永远不会

276
00:21:08,485 --> 00:21:13,284
循环到0，也就是说临时值永远都是唯一的。

277
00:21:13,284 --> 00:21:18,020
我们像之前那样来讨论安全性，因为
伪随机函数是安全的，我们知道这个加密系统

278
00:21:18,020 --> 00:21:22,819
是无法区分是不是用了真正的随机函数。

279
00:21:22,819 --> 00:21:27,493
换句话说，如果我们对计数器
使用一个真正的随机函数，并且把结果和

280
00:21:27,493 --> 00:21:32,602
明文M做异或，但是因为每一次输出时临时值R永远不会重复，

281
00:21:32,602 --> 00:21:37,447
每次我们计算F和R的值时，
我们会得到一个真正随机且独立的字符串，

282
00:21:37,447 --> 00:21:42,843
所以我们实际上是在用一次一密来加密每一条信息。

283
00:21:42,843 --> 00:21:48,306
结果就是，敌手在两个实验中都会看到一对

284
00:21:48,306 --> 00:21:52,751
随机的字符串。所以在实验0和实验1中

285
00:21:52,751 --> 00:21:57,408
敌手都将看到完全相同的部分，也就是说，对于所有

286
00:21:57,408 --> 00:22:02,064
选择明文查询的回应都只是一对独立分配的字符串，

287
00:22:02,064 --> 00:22:06,950
而且字符串在实验0和实验1中都是相同的。

288
00:22:06,950 --> 00:22:11,664
所以攻击者将不能分辨出两个实验来，
既然他不能用一个真随机函数

289
00:22:11,664 --> 00:22:16,206
赢得语义安全的游戏，那么他也不能用一个伪随机函数

290
00:22:16,206 --> 00:22:20,517
赢得语义安全的游戏。于是这种方案是安全的。

291
00:22:20,517 --> 00:22:25,222
现在我们明白了当用密钥来加密多条信息时安全意味着什么。

292
00:22:25,222 --> 00:22:30,091
要求就是在选择明文攻击下保持安全性。

293
00:22:30,091 --> 00:22:34,777
而且我们说过基本上，在选择明文攻击下保持安全

294
00:22:34,777 --> 00:22:39,289
的唯一方式就是选择随机加密或者使用

295
00:22:39,289 --> 00:22:43,462
临时值永不重复的临时空间加密方案。在接下来的两节中，

296
00:22:43,462 --> 00:22:48,143
我们将建立两个经典的

297
00:22:48,143 --> 00:22:50,174
当密钥被多次使用时仍安全的加密系统。【END】

